
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a2  00800100  000035cc  00003680  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000035cc  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004d  008001a2  008001a2  00003722  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  00003722  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000011f4  00000000  00000000  0000372c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000005eb  00000000  00000000  00004920  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  00004f10  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002131  00000000  00000000  00005030  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000039b  00000000  00000000  00007161  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001047  00000000  00000000  000074fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000088c  00000000  00000000  00008544  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b28  00000000  00000000  00008dd0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001232  00000000  00000000  000098f8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 7d 12 	jmp	0x24fa	; 0x24fa <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 29 12 	jmp	0x2452	; 0x2452 <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 c2 12 	jmp	0x2584	; 0x2584 <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 e9 13 	jmp	0x27d2	; 0x27d2 <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 19 14 	jmp	0x2832	; 0x2832 <__vector_28>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	d7 19       	sub	r29, r7

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d0 e1       	ldi	r29, 0x10	; 16
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	ec ec       	ldi	r30, 0xCC	; 204
      92:	f5 e3       	ldi	r31, 0x35	; 53
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	a2 3a       	cpi	r26, 0xA2	; 162
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a2 ea       	ldi	r26, 0xA2	; 162
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	af 3e       	cpi	r26, 0xEF	; 239
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 19 1a 	call	0x3432	; 0x3432 <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 49 14 	call	0x2892	; 0x2892 <main>
      ca:	0c 94 e4 1a 	jmp	0x35c8	; 0x35c8 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate17checkValidityDateEv>:

BOOL myDate::checkValidityDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	00 d0       	rcall	.+0      	; 0x60a <_ZN6myDate17checkValidityDateEv+0x6>
     60a:	0f 92       	push	r0
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	9b 83       	std	Y+3, r25	; 0x03
     612:	8a 83       	std	Y+2, r24	; 0x02
	BOOL checkYear=fFalse;
     614:	19 82       	std	Y+1, r1	; 0x01
	if (month/13==0){
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	9b 81       	ldd	r25, Y+3	; 0x03
     61a:	fc 01       	movw	r30, r24
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	0c 96       	adiw	r24, 0x0c	; 12
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	89 31       	cpi	r24, 0x19	; 25
     626:	91 05       	cpc	r25, r1
     628:	08 f0       	brcs	.+2      	; 0x62c <_ZN6myDate17checkValidityDateEv+0x28>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	22 23       	and	r18, r18
     62e:	09 f4       	brne	.+2      	; 0x632 <_ZN6myDate17checkValidityDateEv+0x2e>
     630:	66 c0       	rjmp	.+204    	; 0x6fe <_ZN6myDate17checkValidityDateEv+0xfa>
			if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	89 30       	cpi	r24, 0x09	; 9
     63e:	91 05       	cpc	r25, r1
     640:	81 f0       	breq	.+32     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     642:	8a 81       	ldd	r24, Y+2	; 0x02
     644:	9b 81       	ldd	r25, Y+3	; 0x03
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
     64a:	91 81       	ldd	r25, Z+1	; 0x01
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	91 05       	cpc	r25, r1
     650:	41 f0       	breq	.+16     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	9b 81       	ldd	r25, Y+3	; 0x03
     656:	fc 01       	movw	r30, r24
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	86 30       	cpi	r24, 0x06	; 6
     65e:	91 05       	cpc	r25, r1
     660:	59 f4       	brne	.+22     	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	4e 96       	adiw	r24, 0x1e	; 30
     66e:	8d 33       	cpi	r24, 0x3D	; 61
     670:	91 05       	cpc	r25, r1
     672:	10 f4       	brcc	.+4      	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	01 c0       	rjmp	.+2      	; 0x67a <_ZN6myDate17checkValidityDateEv+0x76>
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	88 23       	and	r24, r24
     67c:	19 f0       	breq	.+6      	; 0x684 <_ZN6myDate17checkValidityDateEv+0x80>
				checkYear=fTrue;
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	89 83       	std	Y+1, r24	; 0x01
     682:	28 c0       	rjmp	.+80     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else if (month == 2 && day/29 == 0){
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	fc 01       	movw	r30, r24
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	91 05       	cpc	r25, r1
     692:	59 f4       	brne	.+22     	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     694:	8a 81       	ldd	r24, Y+2	; 0x02
     696:	9b 81       	ldd	r25, Y+3	; 0x03
     698:	fc 01       	movw	r30, r24
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	4c 96       	adiw	r24, 0x1c	; 28
     6a0:	89 33       	cpi	r24, 0x39	; 57
     6a2:	91 05       	cpc	r25, r1
     6a4:	10 f4       	brcc	.+4      	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_ZN6myDate17checkValidityDateEv+0xa8>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	88 23       	and	r24, r24
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_ZN6myDate17checkValidityDateEv+0xb2>
				checkYear=fTrue;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	89 83       	std	Y+1, r24	; 0x01
     6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else{
				if (day/32 == 0){
     6b6:	8a 81       	ldd	r24, Y+2	; 0x02
     6b8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ba:	fc 01       	movw	r30, r24
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	4f 96       	adiw	r24, 0x1f	; 31
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	8f 33       	cpi	r24, 0x3F	; 63
     6c6:	91 05       	cpc	r25, r1
     6c8:	08 f0       	brcs	.+2      	; 0x6cc <_ZN6myDate17checkValidityDateEv+0xc8>
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	22 23       	and	r18, r18
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
					checkYear=fTrue;
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
			
			//Check year
			if (checkYear && year>=2013){return fTrue;}
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	88 23       	and	r24, r24
     6d8:	59 f0       	breq	.+22     	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	84 81       	ldd	r24, Z+4	; 0x04
     6e2:	95 81       	ldd	r25, Z+5	; 0x05
     6e4:	f7 e0       	ldi	r31, 0x07	; 7
     6e6:	8d 3d       	cpi	r24, 0xDD	; 221
     6e8:	9f 07       	cpc	r25, r31
     6ea:	14 f0       	brlt	.+4      	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <_ZN6myDate17checkValidityDateEv+0xee>
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	88 23       	and	r24, r24
     6f4:	11 f0       	breq	.+4      	; 0x6fa <_ZN6myDate17checkValidityDateEv+0xf6>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	03 c0       	rjmp	.+6      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
			else {return fFalse;}
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
	} else {return fFalse;}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	cd b7       	in	r28, 0x3d	; 61
     712:	de b7       	in	r29, 0x3e	; 62
     714:	2d 97       	sbiw	r28, 0x0d	; 13
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	9d 87       	std	Y+13, r25	; 0x0d
     722:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     724:	8c 85       	ldd	r24, Y+12	; 0x0c
     726:	9d 85       	ldd	r25, Y+13	; 0x0d
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	91 81       	ldd	r25, Z+1	; 0x01
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <itoa>
	itoa(day,dayString,10);
     73e:	8c 85       	ldd	r24, Y+12	; 0x0c
     740:	9d 85       	ldd	r25, Y+13	; 0x0d
     742:	fc 01       	movw	r30, r24
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9e 01       	movw	r18, r28
     74a:	2c 5f       	subi	r18, 0xFC	; 252
     74c:	3f 4f       	sbci	r19, 0xFF	; 255
     74e:	b9 01       	movw	r22, r18
     750:	4a e0       	ldi	r20, 0x0A	; 10
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <itoa>
	itoa(year,yearString,10);
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	fc 01       	movw	r30, r24
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9e 01       	movw	r18, r28
     764:	29 5f       	subi	r18, 0xF9	; 249
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	4a e0       	ldi	r20, 0x0A	; 10
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <itoa>
	strcpy(dateString,monthString);
     772:	8c 85       	ldd	r24, Y+12	; 0x0c
     774:	9d 85       	ldd	r25, Y+13	; 0x0d
     776:	06 96       	adiw	r24, 0x06	; 6
     778:	9e 01       	movw	r18, r28
     77a:	2f 5f       	subi	r18, 0xFF	; 255
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	0e 94 4f 1a 	call	0x349e	; 0x349e <strcpy>
	strcat(dateString,",");
     784:	8c 85       	ldd	r24, Y+12	; 0x0c
     786:	9d 85       	ldd	r25, Y+13	; 0x0d
     788:	9c 01       	movw	r18, r24
     78a:	2a 5f       	subi	r18, 0xFA	; 250
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	c9 01       	movw	r24, r18
     790:	ac 01       	movw	r20, r24
     792:	fa 01       	movw	r30, r20
     794:	01 90       	ld	r0, Z+
     796:	00 20       	and	r0, r0
     798:	e9 f7       	brne	.-6      	; 0x794 <_ZN6myDate7getDateEv+0x88>
     79a:	cf 01       	movw	r24, r30
     79c:	01 97       	sbiw	r24, 0x01	; 1
     79e:	84 1b       	sub	r24, r20
     7a0:	95 0b       	sbc	r25, r21
     7a2:	82 0f       	add	r24, r18
     7a4:	93 1f       	adc	r25, r19
     7a6:	2c e2       	ldi	r18, 0x2C	; 44
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	fc 01       	movw	r30, r24
     7ac:	31 83       	std	Z+1, r19	; 0x01
     7ae:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     7b0:	8c 85       	ldd	r24, Y+12	; 0x0c
     7b2:	9d 85       	ldd	r25, Y+13	; 0x0d
     7b4:	06 96       	adiw	r24, 0x06	; 6
     7b6:	9e 01       	movw	r18, r28
     7b8:	2c 5f       	subi	r18, 0xFC	; 252
     7ba:	3f 4f       	sbci	r19, 0xFF	; 255
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 3b 1a 	call	0x3476	; 0x3476 <strcat>
	strcat(dateString,",");
     7c2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7c4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7c6:	9c 01       	movw	r18, r24
     7c8:	2a 5f       	subi	r18, 0xFA	; 250
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	c9 01       	movw	r24, r18
     7ce:	ac 01       	movw	r20, r24
     7d0:	fa 01       	movw	r30, r20
     7d2:	01 90       	ld	r0, Z+
     7d4:	00 20       	and	r0, r0
     7d6:	e9 f7       	brne	.-6      	; 0x7d2 <_ZN6myDate7getDateEv+0xc6>
     7d8:	cf 01       	movw	r24, r30
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	84 1b       	sub	r24, r20
     7de:	95 0b       	sbc	r25, r21
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	2c e2       	ldi	r18, 0x2C	; 44
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	fc 01       	movw	r30, r24
     7ea:	31 83       	std	Z+1, r19	; 0x01
     7ec:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     7ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     7f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f2:	06 96       	adiw	r24, 0x06	; 6
     7f4:	9e 01       	movw	r18, r28
     7f6:	29 5f       	subi	r18, 0xF9	; 249
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 3b 1a 	call	0x3476	; 0x3476 <strcat>
	dateString[15] = ' ';
     800:	8c 85       	ldd	r24, Y+12	; 0x0c
     802:	9d 85       	ldd	r25, Y+13	; 0x0d
     804:	20 e2       	ldi	r18, 0x20	; 32
     806:	fc 01       	movw	r30, r24
     808:	25 8b       	std	Z+21, r18	; 0x15
	dateString[16] = '\0';
     80a:	8c 85       	ldd	r24, Y+12	; 0x0c
     80c:	9d 85       	ldd	r25, Y+13	; 0x0d
     80e:	fc 01       	movw	r30, r24
     810:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     812:	8c 85       	ldd	r24, Y+12	; 0x0c
     814:	9d 85       	ldd	r25, Y+13	; 0x0d
     816:	06 96       	adiw	r24, 0x06	; 6
     818:	2d 96       	adiw	r28, 0x0d	; 13
     81a:	0f b6       	in	r0, 0x3f	; 63
     81c:	f8 94       	cli
     81e:	de bf       	out	0x3e, r29	; 62
     820:	0f be       	out	0x3f, r0	; 63
     822:	cd bf       	out	0x3d, r28	; 61
     824:	df 91       	pop	r29
     826:	cf 91       	pop	r28
     828:	08 95       	ret

0000082a <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	00 d0       	rcall	.+0      	; 0x830 <_ZN6myTimeC1Ev+0x6>
     830:	cd b7       	in	r28, 0x3d	; 61
     832:	de b7       	in	r29, 0x3e	; 62
     834:	9a 83       	std	Y+2, r25	; 0x02
     836:	89 83       	std	Y+1, r24	; 0x01
     838:	89 81       	ldd	r24, Y+1	; 0x01
     83a:	9a 81       	ldd	r25, Y+2	; 0x02
     83c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     840:	89 81       	ldd	r24, Y+1	; 0x01
     842:	9a 81       	ldd	r25, Y+2	; 0x02
     844:	60 e0       	ldi	r22, 0x00	; 0
     846:	70 e0       	ldi	r23, 0x00	; 0
     848:	40 e0       	ldi	r20, 0x00	; 0
     84a:	50 e0       	ldi	r21, 0x00	; 0
     84c:	20 e0       	ldi	r18, 0x00	; 0
     84e:	30 e0       	ldi	r19, 0x00	; 0
     850:	0e 94 59 05 	call	0xab2	; 0xab2 <_ZN6myTime7setTimeEiii>
}
     854:	0f 90       	pop	r0
     856:	0f 90       	pop	r0
     858:	df 91       	pop	r29
     85a:	cf 91       	pop	r28
     85c:	08 95       	ret

0000085e <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     85e:	cf 93       	push	r28
     860:	df 93       	push	r29
     862:	cd b7       	in	r28, 0x3d	; 61
     864:	de b7       	in	r29, 0x3e	; 62
     866:	28 97       	sbiw	r28, 0x08	; 8
     868:	0f b6       	in	r0, 0x3f	; 63
     86a:	f8 94       	cli
     86c:	de bf       	out	0x3e, r29	; 62
     86e:	0f be       	out	0x3f, r0	; 63
     870:	cd bf       	out	0x3d, r28	; 61
     872:	9a 83       	std	Y+2, r25	; 0x02
     874:	89 83       	std	Y+1, r24	; 0x01
     876:	7c 83       	std	Y+4, r23	; 0x04
     878:	6b 83       	std	Y+3, r22	; 0x03
     87a:	5e 83       	std	Y+6, r21	; 0x06
     87c:	4d 83       	std	Y+5, r20	; 0x05
     87e:	38 87       	std	Y+8, r19	; 0x08
     880:	2f 83       	std	Y+7, r18	; 0x07
     882:	89 81       	ldd	r24, Y+1	; 0x01
     884:	9a 81       	ldd	r25, Y+2	; 0x02
     886:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     88a:	89 81       	ldd	r24, Y+1	; 0x01
     88c:	9a 81       	ldd	r25, Y+2	; 0x02
     88e:	6b 81       	ldd	r22, Y+3	; 0x03
     890:	7c 81       	ldd	r23, Y+4	; 0x04
     892:	4d 81       	ldd	r20, Y+5	; 0x05
     894:	5e 81       	ldd	r21, Y+6	; 0x06
     896:	2f 81       	ldd	r18, Y+7	; 0x07
     898:	38 85       	ldd	r19, Y+8	; 0x08
     89a:	0e 94 59 05 	call	0xab2	; 0xab2 <_ZN6myTime7setTimeEiii>
}
     89e:	28 96       	adiw	r28, 0x08	; 8
     8a0:	0f b6       	in	r0, 0x3f	; 63
     8a2:	f8 94       	cli
     8a4:	de bf       	out	0x3e, r29	; 62
     8a6:	0f be       	out	0x3f, r0	; 63
     8a8:	cd bf       	out	0x3d, r28	; 61
     8aa:	df 91       	pop	r29
     8ac:	cf 91       	pop	r28
     8ae:	08 95       	ret

000008b0 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     8b0:	cf 92       	push	r12
     8b2:	df 92       	push	r13
     8b4:	ef 92       	push	r14
     8b6:	ff 92       	push	r15
     8b8:	0f 93       	push	r16
     8ba:	1f 93       	push	r17
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
     8c0:	cd b7       	in	r28, 0x3d	; 61
     8c2:	de b7       	in	r29, 0x3e	; 62
     8c4:	2e 97       	sbiw	r28, 0x0e	; 14
     8c6:	0f b6       	in	r0, 0x3f	; 63
     8c8:	f8 94       	cli
     8ca:	de bf       	out	0x3e, r29	; 62
     8cc:	0f be       	out	0x3f, r0	; 63
     8ce:	cd bf       	out	0x3d, r28	; 61
     8d0:	9a 83       	std	Y+2, r25	; 0x02
     8d2:	89 83       	std	Y+1, r24	; 0x01
     8d4:	7c 83       	std	Y+4, r23	; 0x04
     8d6:	6b 83       	std	Y+3, r22	; 0x03
     8d8:	5e 83       	std	Y+6, r21	; 0x06
     8da:	4d 83       	std	Y+5, r20	; 0x05
     8dc:	38 87       	std	Y+8, r19	; 0x08
     8de:	2f 83       	std	Y+7, r18	; 0x07
     8e0:	1a 87       	std	Y+10, r17	; 0x0a
     8e2:	09 87       	std	Y+9, r16	; 0x09
     8e4:	fc 86       	std	Y+12, r15	; 0x0c
     8e6:	eb 86       	std	Y+11, r14	; 0x0b
     8e8:	de 86       	std	Y+14, r13	; 0x0e
     8ea:	cd 86       	std	Y+13, r12	; 0x0d
     8ec:	89 81       	ldd	r24, Y+1	; 0x01
     8ee:	9a 81       	ldd	r25, Y+2	; 0x02
     8f0:	69 85       	ldd	r22, Y+9	; 0x09
     8f2:	7a 85       	ldd	r23, Y+10	; 0x0a
     8f4:	4b 85       	ldd	r20, Y+11	; 0x0b
     8f6:	5c 85       	ldd	r21, Y+12	; 0x0c
     8f8:	2d 85       	ldd	r18, Y+13	; 0x0d
     8fa:	3e 85       	ldd	r19, Y+14	; 0x0e
     8fc:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     900:	89 81       	ldd	r24, Y+1	; 0x01
     902:	9a 81       	ldd	r25, Y+2	; 0x02
     904:	6b 81       	ldd	r22, Y+3	; 0x03
     906:	7c 81       	ldd	r23, Y+4	; 0x04
     908:	4d 81       	ldd	r20, Y+5	; 0x05
     90a:	5e 81       	ldd	r21, Y+6	; 0x06
     90c:	2f 81       	ldd	r18, Y+7	; 0x07
     90e:	38 85       	ldd	r19, Y+8	; 0x08
     910:	0e 94 59 05 	call	0xab2	; 0xab2 <_ZN6myTime7setTimeEiii>
}
     914:	2e 96       	adiw	r28, 0x0e	; 14
     916:	0f b6       	in	r0, 0x3f	; 63
     918:	f8 94       	cli
     91a:	de bf       	out	0x3e, r29	; 62
     91c:	0f be       	out	0x3f, r0	; 63
     91e:	cd bf       	out	0x3d, r28	; 61
     920:	df 91       	pop	r29
     922:	cf 91       	pop	r28
     924:	1f 91       	pop	r17
     926:	0f 91       	pop	r16
     928:	ff 90       	pop	r15
     92a:	ef 90       	pop	r14
     92c:	df 90       	pop	r13
     92e:	cf 90       	pop	r12
     930:	08 95       	ret

00000932 <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     932:	cf 93       	push	r28
     934:	df 93       	push	r29
     936:	00 d0       	rcall	.+0      	; 0x938 <_ZN6myTime10getSecondsEv+0x6>
     938:	cd b7       	in	r28, 0x3d	; 61
     93a:	de b7       	in	r29, 0x3e	; 62
     93c:	9a 83       	std	Y+2, r25	; 0x02
     93e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     940:	89 81       	ldd	r24, Y+1	; 0x01
     942:	9a 81       	ldd	r25, Y+2	; 0x02
     944:	fc 01       	movw	r30, r24
     946:	83 8d       	ldd	r24, Z+27	; 0x1b
     948:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     94a:	0f 90       	pop	r0
     94c:	0f 90       	pop	r0
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	08 95       	ret

00000954 <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     954:	cf 93       	push	r28
     956:	df 93       	push	r29
     958:	00 d0       	rcall	.+0      	; 0x95a <_ZN6myTime10getMinutesEv+0x6>
     95a:	cd b7       	in	r28, 0x3d	; 61
     95c:	de b7       	in	r29, 0x3e	; 62
     95e:	9a 83       	std	Y+2, r25	; 0x02
     960:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     962:	89 81       	ldd	r24, Y+1	; 0x01
     964:	9a 81       	ldd	r25, Y+2	; 0x02
     966:	fc 01       	movw	r30, r24
     968:	81 8d       	ldd	r24, Z+25	; 0x19
     96a:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     96c:	0f 90       	pop	r0
     96e:	0f 90       	pop	r0
     970:	df 91       	pop	r29
     972:	cf 91       	pop	r28
     974:	08 95       	ret

00000976 <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     976:	cf 93       	push	r28
     978:	df 93       	push	r29
     97a:	00 d0       	rcall	.+0      	; 0x97c <_ZN6myTime8getHoursEv+0x6>
     97c:	cd b7       	in	r28, 0x3d	; 61
     97e:	de b7       	in	r29, 0x3e	; 62
     980:	9a 83       	std	Y+2, r25	; 0x02
     982:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     984:	89 81       	ldd	r24, Y+1	; 0x01
     986:	9a 81       	ldd	r25, Y+2	; 0x02
     988:	fc 01       	movw	r30, r24
     98a:	87 89       	ldd	r24, Z+23	; 0x17
     98c:	90 8d       	ldd	r25, Z+24	; 0x18
}
     98e:	0f 90       	pop	r0
     990:	0f 90       	pop	r0
     992:	df 91       	pop	r29
     994:	cf 91       	pop	r28
     996:	08 95       	ret

00000998 <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     998:	cf 93       	push	r28
     99a:	df 93       	push	r29
     99c:	cd b7       	in	r28, 0x3d	; 61
     99e:	de b7       	in	r29, 0x3e	; 62
     9a0:	a2 97       	sbiw	r28, 0x22	; 34
     9a2:	0f b6       	in	r0, 0x3f	; 63
     9a4:	f8 94       	cli
     9a6:	de bf       	out	0x3e, r29	; 62
     9a8:	0f be       	out	0x3f, r0	; 63
     9aa:	cd bf       	out	0x3d, r28	; 61
     9ac:	98 a3       	lds	r25, 0x58
     9ae:	8f 8f       	std	Y+31, r24	; 0x1f
     9b0:	7a a3       	lds	r23, 0x5a
     9b2:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     9b4:	ce 01       	movw	r24, r28
     9b6:	0b 96       	adiw	r24, 0x0b	; 11
     9b8:	29 a1       	lds	r18, 0x49
     9ba:	3a a1       	lds	r19, 0x4a
     9bc:	b9 01       	movw	r22, r18
     9be:	0e 94 4f 1a 	call	0x349e	; 0x349e <strcpy>
	for (int j=0; j<3; j++){
     9c2:	1a 82       	std	Y+2, r1	; 0x02
     9c4:	19 82       	std	Y+1, r1	; 0x01
     9c6:	43 c0       	rjmp	.+134    	; 0xa4e <_ZN6myTime7setTimeEPc+0xb6>
		for (int i=0; i<2; i++){
     9c8:	1c 82       	std	Y+4, r1	; 0x04
     9ca:	1b 82       	std	Y+3, r1	; 0x03
     9cc:	20 c0       	rjmp	.+64     	; 0xa0e <_ZN6myTime7setTimeEPc+0x76>
				tempString[i]=currentString[i+j*3];
     9ce:	29 81       	ldd	r18, Y+1	; 0x01
     9d0:	3a 81       	ldd	r19, Y+2	; 0x02
     9d2:	c9 01       	movw	r24, r18
     9d4:	88 0f       	add	r24, r24
     9d6:	99 1f       	adc	r25, r25
     9d8:	28 0f       	add	r18, r24
     9da:	39 1f       	adc	r19, r25
     9dc:	8b 81       	ldd	r24, Y+3	; 0x03
     9de:	9c 81       	ldd	r25, Y+4	; 0x04
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	9e 01       	movw	r18, r28
     9e6:	25 5f       	subi	r18, 0xF5	; 245
     9e8:	3f 4f       	sbci	r19, 0xFF	; 255
     9ea:	82 0f       	add	r24, r18
     9ec:	93 1f       	adc	r25, r19
     9ee:	fc 01       	movw	r30, r24
     9f0:	40 81       	ld	r20, Z
     9f2:	9e 01       	movw	r18, r28
     9f4:	2b 5e       	subi	r18, 0xEB	; 235
     9f6:	3f 4f       	sbci	r19, 0xFF	; 255
     9f8:	8b 81       	ldd	r24, Y+3	; 0x03
     9fa:	9c 81       	ldd	r25, Y+4	; 0x04
     9fc:	82 0f       	add	r24, r18
     9fe:	93 1f       	adc	r25, r19
     a00:	fc 01       	movw	r30, r24
     a02:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     a04:	8b 81       	ldd	r24, Y+3	; 0x03
     a06:	9c 81       	ldd	r25, Y+4	; 0x04
     a08:	01 96       	adiw	r24, 0x01	; 1
     a0a:	9c 83       	std	Y+4, r25	; 0x04
     a0c:	8b 83       	std	Y+3, r24	; 0x03
     a0e:	21 e0       	ldi	r18, 0x01	; 1
     a10:	8b 81       	ldd	r24, Y+3	; 0x03
     a12:	9c 81       	ldd	r25, Y+4	; 0x04
     a14:	82 30       	cpi	r24, 0x02	; 2
     a16:	91 05       	cpc	r25, r1
     a18:	0c f0       	brlt	.+2      	; 0xa1c <_ZN6myTime7setTimeEPc+0x84>
     a1a:	20 e0       	ldi	r18, 0x00	; 0
     a1c:	22 23       	and	r18, r18
     a1e:	b9 f6       	brne	.-82     	; 0x9ce <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     a20:	ce 01       	movw	r24, r28
     a22:	45 96       	adiw	r24, 0x15	; 21
     a24:	0e 94 1d 1a 	call	0x343a	; 0x343a <atoi>
     a28:	9c 01       	movw	r18, r24
     a2a:	89 81       	ldd	r24, Y+1	; 0x01
     a2c:	9a 81       	ldd	r25, Y+2	; 0x02
     a2e:	88 0f       	add	r24, r24
     a30:	99 1f       	adc	r25, r25
     a32:	ae 01       	movw	r20, r28
     a34:	4f 5f       	subi	r20, 0xFF	; 255
     a36:	5f 4f       	sbci	r21, 0xFF	; 255
     a38:	84 0f       	add	r24, r20
     a3a:	95 1f       	adc	r25, r21
     a3c:	04 96       	adiw	r24, 0x04	; 4
     a3e:	fc 01       	movw	r30, r24
     a40:	31 83       	std	Z+1, r19	; 0x01
     a42:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     a44:	89 81       	ldd	r24, Y+1	; 0x01
     a46:	9a 81       	ldd	r25, Y+2	; 0x02
     a48:	01 96       	adiw	r24, 0x01	; 1
     a4a:	9a 83       	std	Y+2, r25	; 0x02
     a4c:	89 83       	std	Y+1, r24	; 0x01
     a4e:	21 e0       	ldi	r18, 0x01	; 1
     a50:	89 81       	ldd	r24, Y+1	; 0x01
     a52:	9a 81       	ldd	r25, Y+2	; 0x02
     a54:	83 30       	cpi	r24, 0x03	; 3
     a56:	91 05       	cpc	r25, r1
     a58:	0c f0       	brlt	.+2      	; 0xa5c <_ZN6myTime7setTimeEPc+0xc4>
     a5a:	20 e0       	ldi	r18, 0x00	; 0
     a5c:	22 23       	and	r18, r18
     a5e:	09 f0       	breq	.+2      	; 0xa62 <_ZN6myTime7setTimeEPc+0xca>
     a60:	b3 cf       	rjmp	.-154    	; 0x9c8 <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     a62:	8d 81       	ldd	r24, Y+5	; 0x05
     a64:	9e 81       	ldd	r25, Y+6	; 0x06
     a66:	47 96       	adiw	r24, 0x17	; 23
     a68:	8f 32       	cpi	r24, 0x2F	; 47
     a6a:	91 05       	cpc	r25, r1
     a6c:	c0 f4       	brcc	.+48     	; 0xa9e <_ZN6myTime7setTimeEPc+0x106>
     a6e:	8f 81       	ldd	r24, Y+7	; 0x07
     a70:	98 85       	ldd	r25, Y+8	; 0x08
     a72:	cb 96       	adiw	r24, 0x3b	; 59
     a74:	87 37       	cpi	r24, 0x77	; 119
     a76:	91 05       	cpc	r25, r1
     a78:	90 f4       	brcc	.+36     	; 0xa9e <_ZN6myTime7setTimeEPc+0x106>
     a7a:	89 85       	ldd	r24, Y+9	; 0x09
     a7c:	9a 85       	ldd	r25, Y+10	; 0x0a
     a7e:	cb 96       	adiw	r24, 0x3b	; 59
     a80:	87 37       	cpi	r24, 0x77	; 119
     a82:	91 05       	cpc	r25, r1
     a84:	60 f4       	brcc	.+24     	; 0xa9e <_ZN6myTime7setTimeEPc+0x106>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     a86:	6d 81       	ldd	r22, Y+5	; 0x05
     a88:	7e 81       	ldd	r23, Y+6	; 0x06
     a8a:	4f 81       	ldd	r20, Y+7	; 0x07
     a8c:	58 85       	ldd	r21, Y+8	; 0x08
     a8e:	29 85       	ldd	r18, Y+9	; 0x09
     a90:	3a 85       	ldd	r19, Y+10	; 0x0a
     a92:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a94:	98 a1       	lds	r25, 0x48
     a96:	0e 94 59 05 	call	0xab2	; 0xab2 <_ZN6myTime7setTimeEiii>
		return fTrue;
     a9a:	81 e0       	ldi	r24, 0x01	; 1
     a9c:	01 c0       	rjmp	.+2      	; 0xaa0 <_ZN6myTime7setTimeEPc+0x108>
	} 
	return fFalse;
     a9e:	80 e0       	ldi	r24, 0x00	; 0
}
     aa0:	a2 96       	adiw	r28, 0x22	; 34
     aa2:	0f b6       	in	r0, 0x3f	; 63
     aa4:	f8 94       	cli
     aa6:	de bf       	out	0x3e, r29	; 62
     aa8:	0f be       	out	0x3f, r0	; 63
     aaa:	cd bf       	out	0x3d, r28	; 61
     aac:	df 91       	pop	r29
     aae:	cf 91       	pop	r28
     ab0:	08 95       	ret

00000ab2 <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     ab2:	cf 93       	push	r28
     ab4:	df 93       	push	r29
     ab6:	cd b7       	in	r28, 0x3d	; 61
     ab8:	de b7       	in	r29, 0x3e	; 62
     aba:	28 97       	sbiw	r28, 0x08	; 8
     abc:	0f b6       	in	r0, 0x3f	; 63
     abe:	f8 94       	cli
     ac0:	de bf       	out	0x3e, r29	; 62
     ac2:	0f be       	out	0x3f, r0	; 63
     ac4:	cd bf       	out	0x3d, r28	; 61
     ac6:	9a 83       	std	Y+2, r25	; 0x02
     ac8:	89 83       	std	Y+1, r24	; 0x01
     aca:	7c 83       	std	Y+4, r23	; 0x04
     acc:	6b 83       	std	Y+3, r22	; 0x03
     ace:	5e 83       	std	Y+6, r21	; 0x06
     ad0:	4d 83       	std	Y+5, r20	; 0x05
     ad2:	38 87       	std	Y+8, r19	; 0x08
     ad4:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     ad6:	89 81       	ldd	r24, Y+1	; 0x01
     ad8:	9a 81       	ldd	r25, Y+2	; 0x02
     ada:	2b 81       	ldd	r18, Y+3	; 0x03
     adc:	3c 81       	ldd	r19, Y+4	; 0x04
     ade:	b9 01       	movw	r22, r18
     ae0:	0e 94 89 05 	call	0xb12	; 0xb12 <_ZN6myTime7setHourEi>
	setMinute(minute);
     ae4:	89 81       	ldd	r24, Y+1	; 0x01
     ae6:	9a 81       	ldd	r25, Y+2	; 0x02
     ae8:	2d 81       	ldd	r18, Y+5	; 0x05
     aea:	3e 81       	ldd	r19, Y+6	; 0x06
     aec:	b9 01       	movw	r22, r18
     aee:	0e 94 a7 05 	call	0xb4e	; 0xb4e <_ZN6myTime9setMinuteEi>
	setSecond(second);
     af2:	89 81       	ldd	r24, Y+1	; 0x01
     af4:	9a 81       	ldd	r25, Y+2	; 0x02
     af6:	2f 81       	ldd	r18, Y+7	; 0x07
     af8:	38 85       	ldd	r19, Y+8	; 0x08
     afa:	b9 01       	movw	r22, r18
     afc:	0e 94 c5 05 	call	0xb8a	; 0xb8a <_ZN6myTime9setSecondEi>
}
     b00:	28 96       	adiw	r28, 0x08	; 8
     b02:	0f b6       	in	r0, 0x3f	; 63
     b04:	f8 94       	cli
     b06:	de bf       	out	0x3e, r29	; 62
     b08:	0f be       	out	0x3f, r0	; 63
     b0a:	cd bf       	out	0x3d, r28	; 61
     b0c:	df 91       	pop	r29
     b0e:	cf 91       	pop	r28
     b10:	08 95       	ret

00000b12 <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     b12:	cf 93       	push	r28
     b14:	df 93       	push	r29
     b16:	00 d0       	rcall	.+0      	; 0xb18 <_ZN6myTime7setHourEi+0x6>
     b18:	00 d0       	rcall	.+0      	; 0xb1a <_ZN6myTime7setHourEi+0x8>
     b1a:	cd b7       	in	r28, 0x3d	; 61
     b1c:	de b7       	in	r29, 0x3e	; 62
     b1e:	9a 83       	std	Y+2, r25	; 0x02
     b20:	89 83       	std	Y+1, r24	; 0x01
     b22:	7c 83       	std	Y+4, r23	; 0x04
     b24:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     b26:	8b 81       	ldd	r24, Y+3	; 0x03
     b28:	9c 81       	ldd	r25, Y+4	; 0x04
     b2a:	47 96       	adiw	r24, 0x17	; 23
     b2c:	8f 32       	cpi	r24, 0x2F	; 47
     b2e:	91 05       	cpc	r25, r1
     b30:	38 f4       	brcc	.+14     	; 0xb40 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     b32:	89 81       	ldd	r24, Y+1	; 0x01
     b34:	9a 81       	ldd	r25, Y+2	; 0x02
     b36:	2b 81       	ldd	r18, Y+3	; 0x03
     b38:	3c 81       	ldd	r19, Y+4	; 0x04
     b3a:	fc 01       	movw	r30, r24
     b3c:	30 8f       	std	Z+24, r19	; 0x18
     b3e:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     b40:	0f 90       	pop	r0
     b42:	0f 90       	pop	r0
     b44:	0f 90       	pop	r0
     b46:	0f 90       	pop	r0
     b48:	df 91       	pop	r29
     b4a:	cf 91       	pop	r28
     b4c:	08 95       	ret

00000b4e <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     b4e:	cf 93       	push	r28
     b50:	df 93       	push	r29
     b52:	00 d0       	rcall	.+0      	; 0xb54 <_ZN6myTime9setMinuteEi+0x6>
     b54:	00 d0       	rcall	.+0      	; 0xb56 <_ZN6myTime9setMinuteEi+0x8>
     b56:	cd b7       	in	r28, 0x3d	; 61
     b58:	de b7       	in	r29, 0x3e	; 62
     b5a:	9a 83       	std	Y+2, r25	; 0x02
     b5c:	89 83       	std	Y+1, r24	; 0x01
     b5e:	7c 83       	std	Y+4, r23	; 0x04
     b60:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     b62:	8b 81       	ldd	r24, Y+3	; 0x03
     b64:	9c 81       	ldd	r25, Y+4	; 0x04
     b66:	cb 96       	adiw	r24, 0x3b	; 59
     b68:	87 37       	cpi	r24, 0x77	; 119
     b6a:	91 05       	cpc	r25, r1
     b6c:	38 f4       	brcc	.+14     	; 0xb7c <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     b6e:	89 81       	ldd	r24, Y+1	; 0x01
     b70:	9a 81       	ldd	r25, Y+2	; 0x02
     b72:	2b 81       	ldd	r18, Y+3	; 0x03
     b74:	3c 81       	ldd	r19, Y+4	; 0x04
     b76:	fc 01       	movw	r30, r24
     b78:	32 8f       	std	Z+26, r19	; 0x1a
     b7a:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     b7c:	0f 90       	pop	r0
     b7e:	0f 90       	pop	r0
     b80:	0f 90       	pop	r0
     b82:	0f 90       	pop	r0
     b84:	df 91       	pop	r29
     b86:	cf 91       	pop	r28
     b88:	08 95       	ret

00000b8a <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     b8a:	cf 93       	push	r28
     b8c:	df 93       	push	r29
     b8e:	00 d0       	rcall	.+0      	; 0xb90 <_ZN6myTime9setSecondEi+0x6>
     b90:	00 d0       	rcall	.+0      	; 0xb92 <_ZN6myTime9setSecondEi+0x8>
     b92:	cd b7       	in	r28, 0x3d	; 61
     b94:	de b7       	in	r29, 0x3e	; 62
     b96:	9a 83       	std	Y+2, r25	; 0x02
     b98:	89 83       	std	Y+1, r24	; 0x01
     b9a:	7c 83       	std	Y+4, r23	; 0x04
     b9c:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     b9e:	8b 81       	ldd	r24, Y+3	; 0x03
     ba0:	9c 81       	ldd	r25, Y+4	; 0x04
     ba2:	cb 96       	adiw	r24, 0x3b	; 59
     ba4:	87 37       	cpi	r24, 0x77	; 119
     ba6:	91 05       	cpc	r25, r1
     ba8:	38 f4       	brcc	.+14     	; 0xbb8 <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     baa:	89 81       	ldd	r24, Y+1	; 0x01
     bac:	9a 81       	ldd	r25, Y+2	; 0x02
     bae:	2b 81       	ldd	r18, Y+3	; 0x03
     bb0:	3c 81       	ldd	r19, Y+4	; 0x04
     bb2:	fc 01       	movw	r30, r24
     bb4:	34 8f       	std	Z+28, r19	; 0x1c
     bb6:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     bb8:	0f 90       	pop	r0
     bba:	0f 90       	pop	r0
     bbc:	0f 90       	pop	r0
     bbe:	0f 90       	pop	r0
     bc0:	df 91       	pop	r29
     bc2:	cf 91       	pop	r28
     bc4:	08 95       	ret

00000bc6 <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     bc6:	cf 93       	push	r28
     bc8:	df 93       	push	r29
     bca:	cd b7       	in	r28, 0x3d	; 61
     bcc:	de b7       	in	r29, 0x3e	; 62
     bce:	28 97       	sbiw	r28, 0x08	; 8
     bd0:	0f b6       	in	r0, 0x3f	; 63
     bd2:	f8 94       	cli
     bd4:	de bf       	out	0x3e, r29	; 62
     bd6:	0f be       	out	0x3f, r0	; 63
     bd8:	cd bf       	out	0x3d, r28	; 61
     bda:	9e 83       	std	Y+6, r25	; 0x06
     bdc:	8d 83       	std	Y+5, r24	; 0x05
     bde:	78 87       	std	Y+8, r23	; 0x08
     be0:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     be2:	8d 81       	ldd	r24, Y+5	; 0x05
     be4:	9e 81       	ldd	r25, Y+6	; 0x06
     be6:	fc 01       	movw	r30, r24
     be8:	27 89       	ldd	r18, Z+23	; 0x17
     bea:	30 8d       	ldd	r19, Z+24	; 0x18
     bec:	8f 81       	ldd	r24, Y+7	; 0x07
     bee:	98 85       	ldd	r25, Y+8	; 0x08
     bf0:	82 0f       	add	r24, r18
     bf2:	93 1f       	adc	r25, r19
     bf4:	9a 83       	std	Y+2, r25	; 0x02
     bf6:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     bf8:	89 81       	ldd	r24, Y+1	; 0x01
     bfa:	9a 81       	ldd	r25, Y+2	; 0x02
     bfc:	28 e1       	ldi	r18, 0x18	; 24
     bfe:	30 e0       	ldi	r19, 0x00	; 0
     c00:	b9 01       	movw	r22, r18
     c02:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     c06:	9c 01       	movw	r18, r24
     c08:	8d 81       	ldd	r24, Y+5	; 0x05
     c0a:	9e 81       	ldd	r25, Y+6	; 0x06
     c0c:	fc 01       	movw	r30, r24
     c0e:	30 8f       	std	Z+24, r19	; 0x18
     c10:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     c12:	89 81       	ldd	r24, Y+1	; 0x01
     c14:	9a 81       	ldd	r25, Y+2	; 0x02
     c16:	21 e0       	ldi	r18, 0x01	; 1
     c18:	88 31       	cpi	r24, 0x18	; 24
     c1a:	91 05       	cpc	r25, r1
     c1c:	0c f4       	brge	.+2      	; 0xc20 <_ZN6myTime8addHoursEi+0x5a>
     c1e:	20 e0       	ldi	r18, 0x00	; 0
     c20:	22 23       	and	r18, r18
     c22:	91 f0       	breq	.+36     	; 0xc48 <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     c24:	89 81       	ldd	r24, Y+1	; 0x01
     c26:	9a 81       	ldd	r25, Y+2	; 0x02
     c28:	28 e1       	ldi	r18, 0x18	; 24
     c2a:	30 e0       	ldi	r19, 0x00	; 0
     c2c:	b9 01       	movw	r22, r18
     c2e:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     c32:	9b 01       	movw	r18, r22
     c34:	c9 01       	movw	r24, r18
     c36:	9c 83       	std	Y+4, r25	; 0x04
     c38:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     c3a:	8d 81       	ldd	r24, Y+5	; 0x05
     c3c:	9e 81       	ldd	r25, Y+6	; 0x06
     c3e:	2b 81       	ldd	r18, Y+3	; 0x03
     c40:	3c 81       	ldd	r19, Y+4	; 0x04
     c42:	b9 01       	movw	r22, r18
     c44:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     c48:	28 96       	adiw	r28, 0x08	; 8
     c4a:	0f b6       	in	r0, 0x3f	; 63
     c4c:	f8 94       	cli
     c4e:	de bf       	out	0x3e, r29	; 62
     c50:	0f be       	out	0x3f, r0	; 63
     c52:	cd bf       	out	0x3d, r28	; 61
     c54:	df 91       	pop	r29
     c56:	cf 91       	pop	r28
     c58:	08 95       	ret

00000c5a <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     c5a:	cf 93       	push	r28
     c5c:	df 93       	push	r29
     c5e:	cd b7       	in	r28, 0x3d	; 61
     c60:	de b7       	in	r29, 0x3e	; 62
     c62:	28 97       	sbiw	r28, 0x08	; 8
     c64:	0f b6       	in	r0, 0x3f	; 63
     c66:	f8 94       	cli
     c68:	de bf       	out	0x3e, r29	; 62
     c6a:	0f be       	out	0x3f, r0	; 63
     c6c:	cd bf       	out	0x3d, r28	; 61
     c6e:	9e 83       	std	Y+6, r25	; 0x06
     c70:	8d 83       	std	Y+5, r24	; 0x05
     c72:	78 87       	std	Y+8, r23	; 0x08
     c74:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     c76:	8d 81       	ldd	r24, Y+5	; 0x05
     c78:	9e 81       	ldd	r25, Y+6	; 0x06
     c7a:	fc 01       	movw	r30, r24
     c7c:	21 8d       	ldd	r18, Z+25	; 0x19
     c7e:	32 8d       	ldd	r19, Z+26	; 0x1a
     c80:	8f 81       	ldd	r24, Y+7	; 0x07
     c82:	98 85       	ldd	r25, Y+8	; 0x08
     c84:	82 0f       	add	r24, r18
     c86:	93 1f       	adc	r25, r19
     c88:	9a 83       	std	Y+2, r25	; 0x02
     c8a:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     c8c:	89 81       	ldd	r24, Y+1	; 0x01
     c8e:	9a 81       	ldd	r25, Y+2	; 0x02
     c90:	2c e3       	ldi	r18, 0x3C	; 60
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	b9 01       	movw	r22, r18
     c96:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     c9a:	9c 01       	movw	r18, r24
     c9c:	8d 81       	ldd	r24, Y+5	; 0x05
     c9e:	9e 81       	ldd	r25, Y+6	; 0x06
     ca0:	fc 01       	movw	r30, r24
     ca2:	32 8f       	std	Z+26, r19	; 0x1a
     ca4:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     ca6:	89 81       	ldd	r24, Y+1	; 0x01
     ca8:	9a 81       	ldd	r25, Y+2	; 0x02
     caa:	21 e0       	ldi	r18, 0x01	; 1
     cac:	8c 33       	cpi	r24, 0x3C	; 60
     cae:	91 05       	cpc	r25, r1
     cb0:	0c f4       	brge	.+2      	; 0xcb4 <_ZN6myTime10addMinutesEi+0x5a>
     cb2:	20 e0       	ldi	r18, 0x00	; 0
     cb4:	22 23       	and	r18, r18
     cb6:	91 f0       	breq	.+36     	; 0xcdc <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     cb8:	89 81       	ldd	r24, Y+1	; 0x01
     cba:	9a 81       	ldd	r25, Y+2	; 0x02
     cbc:	2c e3       	ldi	r18, 0x3C	; 60
     cbe:	30 e0       	ldi	r19, 0x00	; 0
     cc0:	b9 01       	movw	r22, r18
     cc2:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     cc6:	9b 01       	movw	r18, r22
     cc8:	c9 01       	movw	r24, r18
     cca:	9c 83       	std	Y+4, r25	; 0x04
     ccc:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     cce:	2b 81       	ldd	r18, Y+3	; 0x03
     cd0:	3c 81       	ldd	r19, Y+4	; 0x04
     cd2:	8d 81       	ldd	r24, Y+5	; 0x05
     cd4:	9e 81       	ldd	r25, Y+6	; 0x06
     cd6:	b9 01       	movw	r22, r18
     cd8:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <_ZN6myTime8addHoursEi>
	}
}
     cdc:	28 96       	adiw	r28, 0x08	; 8
     cde:	0f b6       	in	r0, 0x3f	; 63
     ce0:	f8 94       	cli
     ce2:	de bf       	out	0x3e, r29	; 62
     ce4:	0f be       	out	0x3f, r0	; 63
     ce6:	cd bf       	out	0x3d, r28	; 61
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	08 95       	ret

00000cee <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     cee:	cf 93       	push	r28
     cf0:	df 93       	push	r29
     cf2:	cd b7       	in	r28, 0x3d	; 61
     cf4:	de b7       	in	r29, 0x3e	; 62
     cf6:	28 97       	sbiw	r28, 0x08	; 8
     cf8:	0f b6       	in	r0, 0x3f	; 63
     cfa:	f8 94       	cli
     cfc:	de bf       	out	0x3e, r29	; 62
     cfe:	0f be       	out	0x3f, r0	; 63
     d00:	cd bf       	out	0x3d, r28	; 61
     d02:	9e 83       	std	Y+6, r25	; 0x06
     d04:	8d 83       	std	Y+5, r24	; 0x05
     d06:	78 87       	std	Y+8, r23	; 0x08
     d08:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     d0a:	8d 81       	ldd	r24, Y+5	; 0x05
     d0c:	9e 81       	ldd	r25, Y+6	; 0x06
     d0e:	fc 01       	movw	r30, r24
     d10:	23 8d       	ldd	r18, Z+27	; 0x1b
     d12:	34 8d       	ldd	r19, Z+28	; 0x1c
     d14:	8f 81       	ldd	r24, Y+7	; 0x07
     d16:	98 85       	ldd	r25, Y+8	; 0x08
     d18:	82 0f       	add	r24, r18
     d1a:	93 1f       	adc	r25, r19
     d1c:	9a 83       	std	Y+2, r25	; 0x02
     d1e:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     d20:	89 81       	ldd	r24, Y+1	; 0x01
     d22:	9a 81       	ldd	r25, Y+2	; 0x02
     d24:	2c e3       	ldi	r18, 0x3C	; 60
     d26:	30 e0       	ldi	r19, 0x00	; 0
     d28:	b9 01       	movw	r22, r18
     d2a:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     d2e:	9c 01       	movw	r18, r24
     d30:	8d 81       	ldd	r24, Y+5	; 0x05
     d32:	9e 81       	ldd	r25, Y+6	; 0x06
     d34:	fc 01       	movw	r30, r24
     d36:	34 8f       	std	Z+28, r19	; 0x1c
     d38:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     d3a:	89 81       	ldd	r24, Y+1	; 0x01
     d3c:	9a 81       	ldd	r25, Y+2	; 0x02
     d3e:	21 e0       	ldi	r18, 0x01	; 1
     d40:	8c 33       	cpi	r24, 0x3C	; 60
     d42:	91 05       	cpc	r25, r1
     d44:	0c f4       	brge	.+2      	; 0xd48 <_ZN6myTime10addSecondsEi+0x5a>
     d46:	20 e0       	ldi	r18, 0x00	; 0
     d48:	22 23       	and	r18, r18
     d4a:	91 f0       	breq	.+36     	; 0xd70 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     d4c:	89 81       	ldd	r24, Y+1	; 0x01
     d4e:	9a 81       	ldd	r25, Y+2	; 0x02
     d50:	2c e3       	ldi	r18, 0x3C	; 60
     d52:	30 e0       	ldi	r19, 0x00	; 0
     d54:	b9 01       	movw	r22, r18
     d56:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
     d5a:	9b 01       	movw	r18, r22
     d5c:	c9 01       	movw	r24, r18
     d5e:	9c 83       	std	Y+4, r25	; 0x04
     d60:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     d62:	2b 81       	ldd	r18, Y+3	; 0x03
     d64:	3c 81       	ldd	r19, Y+4	; 0x04
     d66:	8d 81       	ldd	r24, Y+5	; 0x05
     d68:	9e 81       	ldd	r25, Y+6	; 0x06
     d6a:	b9 01       	movw	r22, r18
     d6c:	0e 94 2d 06 	call	0xc5a	; 0xc5a <_ZN6myTime10addMinutesEi>
	}
}
     d70:	28 96       	adiw	r28, 0x08	; 8
     d72:	0f b6       	in	r0, 0x3f	; 63
     d74:	f8 94       	cli
     d76:	de bf       	out	0x3e, r29	; 62
     d78:	0f be       	out	0x3f, r0	; 63
     d7a:	cd bf       	out	0x3d, r28	; 61
     d7c:	df 91       	pop	r29
     d7e:	cf 91       	pop	r28
     d80:	08 95       	ret

00000d82 <_ZN6myTime13checkValidityEv>:

BOOL myTime::checkValidity(){
     d82:	cf 93       	push	r28
     d84:	df 93       	push	r29
     d86:	00 d0       	rcall	.+0      	; 0xd88 <_ZN6myTime13checkValidityEv+0x6>
     d88:	0f 92       	push	r0
     d8a:	cd b7       	in	r28, 0x3d	; 61
     d8c:	de b7       	in	r29, 0x3e	; 62
     d8e:	9b 83       	std	Y+3, r25	; 0x03
     d90:	8a 83       	std	Y+2, r24	; 0x02
	BOOL stillValid=fTrue;
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	89 83       	std	Y+1, r24	; 0x01
	if (second/60==0 && minute/60==0 && hour/24==0){
     d96:	8a 81       	ldd	r24, Y+2	; 0x02
     d98:	9b 81       	ldd	r25, Y+3	; 0x03
     d9a:	fc 01       	movw	r30, r24
     d9c:	83 8d       	ldd	r24, Z+27	; 0x1b
     d9e:	94 8d       	ldd	r25, Z+28	; 0x1c
     da0:	cb 96       	adiw	r24, 0x3b	; 59
     da2:	87 37       	cpi	r24, 0x77	; 119
     da4:	91 05       	cpc	r25, r1
     da6:	a0 f4       	brcc	.+40     	; 0xdd0 <_ZN6myTime13checkValidityEv+0x4e>
     da8:	8a 81       	ldd	r24, Y+2	; 0x02
     daa:	9b 81       	ldd	r25, Y+3	; 0x03
     dac:	fc 01       	movw	r30, r24
     dae:	81 8d       	ldd	r24, Z+25	; 0x19
     db0:	92 8d       	ldd	r25, Z+26	; 0x1a
     db2:	cb 96       	adiw	r24, 0x3b	; 59
     db4:	87 37       	cpi	r24, 0x77	; 119
     db6:	91 05       	cpc	r25, r1
     db8:	58 f4       	brcc	.+22     	; 0xdd0 <_ZN6myTime13checkValidityEv+0x4e>
     dba:	8a 81       	ldd	r24, Y+2	; 0x02
     dbc:	9b 81       	ldd	r25, Y+3	; 0x03
     dbe:	fc 01       	movw	r30, r24
     dc0:	87 89       	ldd	r24, Z+23	; 0x17
     dc2:	90 8d       	ldd	r25, Z+24	; 0x18
     dc4:	47 96       	adiw	r24, 0x17	; 23
     dc6:	8f 32       	cpi	r24, 0x2F	; 47
     dc8:	91 05       	cpc	r25, r1
     dca:	10 f4       	brcc	.+4      	; 0xdd0 <_ZN6myTime13checkValidityEv+0x4e>
     dcc:	81 e0       	ldi	r24, 0x01	; 1
     dce:	01 c0       	rjmp	.+2      	; 0xdd2 <_ZN6myTime13checkValidityEv+0x50>
     dd0:	80 e0       	ldi	r24, 0x00	; 0
     dd2:	88 23       	and	r24, r24
     dd4:	69 f0       	breq	.+26     	; 0xdf0 <_ZN6myTime13checkValidityEv+0x6e>
		if (checkValidityDate()){return fTrue;}
     dd6:	8a 81       	ldd	r24, Y+2	; 0x02
     dd8:	9b 81       	ldd	r25, Y+3	; 0x03
     dda:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate17checkValidityDateEv>
     dde:	98 2f       	mov	r25, r24
     de0:	81 e0       	ldi	r24, 0x01	; 1
     de2:	99 23       	and	r25, r25
     de4:	09 f4       	brne	.+2      	; 0xde8 <_ZN6myTime13checkValidityEv+0x66>
     de6:	80 e0       	ldi	r24, 0x00	; 0
     de8:	88 23       	and	r24, r24
     dea:	11 f0       	breq	.+4      	; 0xdf0 <_ZN6myTime13checkValidityEv+0x6e>
     dec:	81 e0       	ldi	r24, 0x01	; 1
     dee:	01 c0       	rjmp	.+2      	; 0xdf2 <_ZN6myTime13checkValidityEv+0x70>
	}
	return fFalse;
     df0:	80 e0       	ldi	r24, 0x00	; 0
}
     df2:	0f 90       	pop	r0
     df4:	0f 90       	pop	r0
     df6:	0f 90       	pop	r0
     df8:	df 91       	pop	r29
     dfa:	cf 91       	pop	r28
     dfc:	08 95       	ret

00000dfe <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     dfe:	cf 93       	push	r28
     e00:	df 93       	push	r29
     e02:	cd b7       	in	r28, 0x3d	; 61
     e04:	de b7       	in	r29, 0x3e	; 62
     e06:	2b 97       	sbiw	r28, 0x0b	; 11
     e08:	0f b6       	in	r0, 0x3f	; 63
     e0a:	f8 94       	cli
     e0c:	de bf       	out	0x3e, r29	; 62
     e0e:	0f be       	out	0x3f, r0	; 63
     e10:	cd bf       	out	0x3d, r28	; 61
     e12:	9b 87       	std	Y+11, r25	; 0x0b
     e14:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     e16:	8a 85       	ldd	r24, Y+10	; 0x0a
     e18:	9b 85       	ldd	r25, Y+11	; 0x0b
     e1a:	fc 01       	movw	r30, r24
     e1c:	87 89       	ldd	r24, Z+23	; 0x17
     e1e:	90 8d       	ldd	r25, Z+24	; 0x18
     e20:	9e 01       	movw	r18, r28
     e22:	2f 5f       	subi	r18, 0xFF	; 255
     e24:	3f 4f       	sbci	r19, 0xFF	; 255
     e26:	b9 01       	movw	r22, r18
     e28:	4a e0       	ldi	r20, 0x0A	; 10
     e2a:	50 e0       	ldi	r21, 0x00	; 0
     e2c:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <itoa>
	itoa(minute,minuteString,10);
     e30:	8a 85       	ldd	r24, Y+10	; 0x0a
     e32:	9b 85       	ldd	r25, Y+11	; 0x0b
     e34:	fc 01       	movw	r30, r24
     e36:	81 8d       	ldd	r24, Z+25	; 0x19
     e38:	92 8d       	ldd	r25, Z+26	; 0x1a
     e3a:	9e 01       	movw	r18, r28
     e3c:	2c 5f       	subi	r18, 0xFC	; 252
     e3e:	3f 4f       	sbci	r19, 0xFF	; 255
     e40:	b9 01       	movw	r22, r18
     e42:	4a e0       	ldi	r20, 0x0A	; 10
     e44:	50 e0       	ldi	r21, 0x00	; 0
     e46:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <itoa>
	itoa(second,secondString,10);
     e4a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e4c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e4e:	fc 01       	movw	r30, r24
     e50:	83 8d       	ldd	r24, Z+27	; 0x1b
     e52:	94 8d       	ldd	r25, Z+28	; 0x1c
     e54:	9e 01       	movw	r18, r28
     e56:	29 5f       	subi	r18, 0xF9	; 249
     e58:	3f 4f       	sbci	r19, 0xFF	; 255
     e5a:	b9 01       	movw	r22, r18
     e5c:	4a e0       	ldi	r20, 0x0A	; 10
     e5e:	50 e0       	ldi	r21, 0x00	; 0
     e60:	0e 94 64 1a 	call	0x34c8	; 0x34c8 <itoa>
	strcpy(timeString,hourString);
     e64:	8a 85       	ldd	r24, Y+10	; 0x0a
     e66:	9b 85       	ldd	r25, Y+11	; 0x0b
     e68:	4d 96       	adiw	r24, 0x1d	; 29
     e6a:	9e 01       	movw	r18, r28
     e6c:	2f 5f       	subi	r18, 0xFF	; 255
     e6e:	3f 4f       	sbci	r19, 0xFF	; 255
     e70:	b9 01       	movw	r22, r18
     e72:	0e 94 4f 1a 	call	0x349e	; 0x349e <strcpy>
	strcat(timeString,":");
     e76:	8a 85       	ldd	r24, Y+10	; 0x0a
     e78:	9b 85       	ldd	r25, Y+11	; 0x0b
     e7a:	9c 01       	movw	r18, r24
     e7c:	23 5e       	subi	r18, 0xE3	; 227
     e7e:	3f 4f       	sbci	r19, 0xFF	; 255
     e80:	c9 01       	movw	r24, r18
     e82:	ac 01       	movw	r20, r24
     e84:	fa 01       	movw	r30, r20
     e86:	01 90       	ld	r0, Z+
     e88:	00 20       	and	r0, r0
     e8a:	e9 f7       	brne	.-6      	; 0xe86 <_ZN6myTime7getTimeEv+0x88>
     e8c:	cf 01       	movw	r24, r30
     e8e:	01 97       	sbiw	r24, 0x01	; 1
     e90:	84 1b       	sub	r24, r20
     e92:	95 0b       	sbc	r25, r21
     e94:	82 0f       	add	r24, r18
     e96:	93 1f       	adc	r25, r19
     e98:	2a e3       	ldi	r18, 0x3A	; 58
     e9a:	30 e0       	ldi	r19, 0x00	; 0
     e9c:	fc 01       	movw	r30, r24
     e9e:	31 83       	std	Z+1, r19	; 0x01
     ea0:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     ea2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ea4:	9b 85       	ldd	r25, Y+11	; 0x0b
     ea6:	4d 96       	adiw	r24, 0x1d	; 29
     ea8:	9e 01       	movw	r18, r28
     eaa:	2c 5f       	subi	r18, 0xFC	; 252
     eac:	3f 4f       	sbci	r19, 0xFF	; 255
     eae:	b9 01       	movw	r22, r18
     eb0:	0e 94 3b 1a 	call	0x3476	; 0x3476 <strcat>
	strcat(timeString,":");
     eb4:	8a 85       	ldd	r24, Y+10	; 0x0a
     eb6:	9b 85       	ldd	r25, Y+11	; 0x0b
     eb8:	9c 01       	movw	r18, r24
     eba:	23 5e       	subi	r18, 0xE3	; 227
     ebc:	3f 4f       	sbci	r19, 0xFF	; 255
     ebe:	c9 01       	movw	r24, r18
     ec0:	ac 01       	movw	r20, r24
     ec2:	fa 01       	movw	r30, r20
     ec4:	01 90       	ld	r0, Z+
     ec6:	00 20       	and	r0, r0
     ec8:	e9 f7       	brne	.-6      	; 0xec4 <_ZN6myTime7getTimeEv+0xc6>
     eca:	cf 01       	movw	r24, r30
     ecc:	01 97       	sbiw	r24, 0x01	; 1
     ece:	84 1b       	sub	r24, r20
     ed0:	95 0b       	sbc	r25, r21
     ed2:	82 0f       	add	r24, r18
     ed4:	93 1f       	adc	r25, r19
     ed6:	2a e3       	ldi	r18, 0x3A	; 58
     ed8:	30 e0       	ldi	r19, 0x00	; 0
     eda:	fc 01       	movw	r30, r24
     edc:	31 83       	std	Z+1, r19	; 0x01
     ede:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     ee0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ee2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ee4:	4d 96       	adiw	r24, 0x1d	; 29
     ee6:	9e 01       	movw	r18, r28
     ee8:	29 5f       	subi	r18, 0xF9	; 249
     eea:	3f 4f       	sbci	r19, 0xFF	; 255
     eec:	b9 01       	movw	r22, r18
     eee:	0e 94 3b 1a 	call	0x3476	; 0x3476 <strcat>
	timeString[10] = ' ';
     ef2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ef4:	9b 85       	ldd	r25, Y+11	; 0x0b
     ef6:	20 e2       	ldi	r18, 0x20	; 32
     ef8:	fc 01       	movw	r30, r24
     efa:	27 a3       	lds	r18, 0x57
	timeString[11] = '\0';
     efc:	8a 85       	ldd	r24, Y+10	; 0x0a
     efe:	9b 85       	ldd	r25, Y+11	; 0x0b
     f00:	fc 01       	movw	r30, r24
     f02:	10 a6       	lds	r17, 0xb0
	return timeString;
     f04:	8a 85       	ldd	r24, Y+10	; 0x0a
     f06:	9b 85       	ldd	r25, Y+11	; 0x0b
     f08:	4d 96       	adiw	r24, 0x1d	; 29
     f0a:	2b 96       	adiw	r28, 0x0b	; 11
     f0c:	0f b6       	in	r0, 0x3f	; 63
     f0e:	f8 94       	cli
     f10:	de bf       	out	0x3e, r29	; 62
     f12:	0f be       	out	0x3f, r0	; 63
     f14:	cd bf       	out	0x3d, r28	; 61
     f16:	df 91       	pop	r29
     f18:	cf 91       	pop	r28
     f1a:	08 95       	ret

00000f1c <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 10;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     f1c:	cf 93       	push	r28
     f1e:	df 93       	push	r29
     f20:	cd b7       	in	r28, 0x3d	; 61
     f22:	de b7       	in	r29, 0x3e	; 62
     f24:	2f 97       	sbiw	r28, 0x0f	; 15
     f26:	0f b6       	in	r0, 0x3f	; 63
     f28:	f8 94       	cli
     f2a:	de bf       	out	0x3e, r29	; 62
     f2c:	0f be       	out	0x3f, r0	; 63
     f2e:	cd bf       	out	0x3d, r28	; 61
     f30:	8e 87       	std	Y+14, r24	; 0x0e
     f32:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     f34:	f8 94       	cli
	if (gTime){
     f36:	8e 85       	ldd	r24, Y+14	; 0x0e
     f38:	88 23       	and	r24, r24
     f3a:	09 f4       	brne	.+2      	; 0xf3e <_Z18getDateTime_eepromhh+0x22>
     f3c:	4b c0       	rjmp	.+150    	; 0xfd4 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     f3e:	1a 82       	std	Y+2, r1	; 0x02
     f40:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     f42:	81 e0       	ldi	r24, 0x01	; 1
     f44:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     f46:	2c c0       	rjmp	.+88     	; 0xfa0 <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     f48:	82 e0       	ldi	r24, 0x02	; 2
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__eerd_byte_m644pa>
     f50:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     f52:	81 e0       	ldi	r24, 0x01	; 1
     f54:	90 e0       	ldi	r25, 0x00	; 0
     f56:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__eerd_byte_m644pa>
     f5a:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     f5c:	80 e0       	ldi	r24, 0x00	; 0
     f5e:	90 e0       	ldi	r25, 0x00	; 0
     f60:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__eerd_byte_m644pa>
     f64:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     f66:	8f 81       	ldd	r24, Y+7	; 0x07
     f68:	8c 33       	cpi	r24, 0x3C	; 60
     f6a:	a8 f4       	brcc	.+42     	; 0xf96 <_Z18getDateTime_eepromhh+0x7a>
     f6c:	88 85       	ldd	r24, Y+8	; 0x08
     f6e:	8c 33       	cpi	r24, 0x3C	; 60
     f70:	90 f4       	brcc	.+36     	; 0xf96 <_Z18getDateTime_eepromhh+0x7a>
     f72:	89 85       	ldd	r24, Y+9	; 0x09
     f74:	88 31       	cpi	r24, 0x18	; 24
     f76:	78 f4       	brcc	.+30     	; 0xf96 <_Z18getDateTime_eepromhh+0x7a>
     f78:	89 85       	ldd	r24, Y+9	; 0x09
     f7a:	68 2f       	mov	r22, r24
     f7c:	70 e0       	ldi	r23, 0x00	; 0
     f7e:	88 85       	ldd	r24, Y+8	; 0x08
     f80:	48 2f       	mov	r20, r24
     f82:	50 e0       	ldi	r21, 0x00	; 0
     f84:	8f 81       	ldd	r24, Y+7	; 0x07
     f86:	28 2f       	mov	r18, r24
     f88:	30 e0       	ldi	r19, 0x00	; 0
     f8a:	86 ea       	ldi	r24, 0xA6	; 166
     f8c:	91 e0       	ldi	r25, 0x01	; 1
     f8e:	0e 94 59 05 	call	0xab2	; 0xab2 <_ZN6myTime7setTimeEiii>
     f92:	1b 82       	std	Y+3, r1	; 0x03
     f94:	05 c0       	rjmp	.+10     	; 0xfa0 <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     f96:	89 81       	ldd	r24, Y+1	; 0x01
     f98:	9a 81       	ldd	r25, Y+2	; 0x02
     f9a:	01 96       	adiw	r24, 0x01	; 1
     f9c:	9a 83       	std	Y+2, r25	; 0x02
     f9e:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     fa0:	8b 81       	ldd	r24, Y+3	; 0x03
     fa2:	88 23       	and	r24, r24
     fa4:	39 f0       	breq	.+14     	; 0xfb4 <_Z18getDateTime_eepromhh+0x98>
     fa6:	89 81       	ldd	r24, Y+1	; 0x01
     fa8:	9a 81       	ldd	r25, Y+2	; 0x02
     faa:	83 30       	cpi	r24, 0x03	; 3
     fac:	91 05       	cpc	r25, r1
     fae:	14 f4       	brge	.+4      	; 0xfb4 <_Z18getDateTime_eepromhh+0x98>
     fb0:	81 e0       	ldi	r24, 0x01	; 1
     fb2:	01 c0       	rjmp	.+2      	; 0xfb6 <_Z18getDateTime_eepromhh+0x9a>
     fb4:	80 e0       	ldi	r24, 0x00	; 0
     fb6:	88 23       	and	r24, r24
     fb8:	39 f6       	brne	.-114    	; 0xf48 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     fba:	8b 81       	ldd	r24, Y+3	; 0x03
     fbc:	88 23       	and	r24, r24
     fbe:	51 f0       	breq	.+20     	; 0xfd4 <_Z18getDateTime_eepromhh+0xb8>
     fc0:	86 ea       	ldi	r24, 0xA6	; 166
     fc2:	91 e0       	ldi	r25, 0x01	; 1
     fc4:	61 e0       	ldi	r22, 0x01	; 1
     fc6:	70 e0       	ldi	r23, 0x00	; 0
     fc8:	41 e0       	ldi	r20, 0x01	; 1
     fca:	50 e0       	ldi	r21, 0x00	; 0
     fcc:	21 e0       	ldi	r18, 0x01	; 1
     fce:	30 e0       	ldi	r19, 0x00	; 0
     fd0:	0e 94 59 05 	call	0xab2	; 0xab2 <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     fd4:	8f 85       	ldd	r24, Y+15	; 0x0f
     fd6:	88 23       	and	r24, r24
     fd8:	09 f4       	brne	.+2      	; 0xfdc <_Z18getDateTime_eepromhh+0xc0>
     fda:	4e c0       	rjmp	.+156    	; 0x1078 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     fdc:	1d 82       	std	Y+5, r1	; 0x05
     fde:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     fe0:	81 e0       	ldi	r24, 0x01	; 1
     fe2:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     fe4:	2f c0       	rjmp	.+94     	; 0x1044 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     fe6:	84 e0       	ldi	r24, 0x04	; 4
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__eerd_byte_m644pa>
     fee:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     ff0:	83 e0       	ldi	r24, 0x03	; 3
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__eerd_byte_m644pa>
     ff8:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     ffa:	85 e0       	ldi	r24, 0x05	; 5
     ffc:	90 e0       	ldi	r25, 0x00	; 0
     ffe:	0e 94 ab 1a 	call	0x3556	; 0x3556 <__eerd_word_m644pa>
    1002:	9d 87       	std	Y+13, r25	; 0x0d
    1004:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
    1006:	8a 85       	ldd	r24, Y+10	; 0x0a
    1008:	8f 31       	cpi	r24, 0x1F	; 31
    100a:	b8 f4       	brcc	.+46     	; 0x103a <_Z18getDateTime_eepromhh+0x11e>
    100c:	8b 85       	ldd	r24, Y+11	; 0x0b
    100e:	8d 30       	cpi	r24, 0x0D	; 13
    1010:	a0 f4       	brcc	.+40     	; 0x103a <_Z18getDateTime_eepromhh+0x11e>
    1012:	8c 85       	ldd	r24, Y+12	; 0x0c
    1014:	9d 85       	ldd	r25, Y+13	; 0x0d
    1016:	27 e2       	ldi	r18, 0x27	; 39
    1018:	80 31       	cpi	r24, 0x10	; 16
    101a:	92 07       	cpc	r25, r18
    101c:	70 f4       	brcc	.+28     	; 0x103a <_Z18getDateTime_eepromhh+0x11e>
    101e:	8b 85       	ldd	r24, Y+11	; 0x0b
    1020:	68 2f       	mov	r22, r24
    1022:	70 e0       	ldi	r23, 0x00	; 0
    1024:	8a 85       	ldd	r24, Y+10	; 0x0a
    1026:	48 2f       	mov	r20, r24
    1028:	50 e0       	ldi	r21, 0x00	; 0
    102a:	2c 85       	ldd	r18, Y+12	; 0x0c
    102c:	3d 85       	ldd	r19, Y+13	; 0x0d
    102e:	86 ea       	ldi	r24, 0xA6	; 166
    1030:	91 e0       	ldi	r25, 0x01	; 1
    1032:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
    1036:	1e 82       	std	Y+6, r1	; 0x06
    1038:	05 c0       	rjmp	.+10     	; 0x1044 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
    103a:	8c 81       	ldd	r24, Y+4	; 0x04
    103c:	9d 81       	ldd	r25, Y+5	; 0x05
    103e:	01 96       	adiw	r24, 0x01	; 1
    1040:	9d 83       	std	Y+5, r25	; 0x05
    1042:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
    1044:	8e 81       	ldd	r24, Y+6	; 0x06
    1046:	88 23       	and	r24, r24
    1048:	39 f0       	breq	.+14     	; 0x1058 <_Z18getDateTime_eepromhh+0x13c>
    104a:	8c 81       	ldd	r24, Y+4	; 0x04
    104c:	9d 81       	ldd	r25, Y+5	; 0x05
    104e:	83 30       	cpi	r24, 0x03	; 3
    1050:	91 05       	cpc	r25, r1
    1052:	14 f4       	brge	.+4      	; 0x1058 <_Z18getDateTime_eepromhh+0x13c>
    1054:	81 e0       	ldi	r24, 0x01	; 1
    1056:	01 c0       	rjmp	.+2      	; 0x105a <_Z18getDateTime_eepromhh+0x13e>
    1058:	80 e0       	ldi	r24, 0x00	; 0
    105a:	88 23       	and	r24, r24
    105c:	21 f6       	brne	.-120    	; 0xfe6 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
    105e:	8e 81       	ldd	r24, Y+6	; 0x06
    1060:	88 23       	and	r24, r24
    1062:	51 f0       	breq	.+20     	; 0x1078 <_Z18getDateTime_eepromhh+0x15c>
    1064:	86 ea       	ldi	r24, 0xA6	; 166
    1066:	91 e0       	ldi	r25, 0x01	; 1
    1068:	61 e0       	ldi	r22, 0x01	; 1
    106a:	70 e0       	ldi	r23, 0x00	; 0
    106c:	41 e0       	ldi	r20, 0x01	; 1
    106e:	50 e0       	ldi	r21, 0x00	; 0
    1070:	21 ed       	ldi	r18, 0xD1	; 209
    1072:	37 e0       	ldi	r19, 0x07	; 7
    1074:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
    1078:	78 94       	sei
}
    107a:	2f 96       	adiw	r28, 0x0f	; 15
    107c:	0f b6       	in	r0, 0x3f	; 63
    107e:	f8 94       	cli
    1080:	de bf       	out	0x3e, r29	; 62
    1082:	0f be       	out	0x3f, r0	; 63
    1084:	cd bf       	out	0x3d, r28	; 61
    1086:	df 91       	pop	r29
    1088:	cf 91       	pop	r28
    108a:	08 95       	ret

0000108c <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
    108c:	cf 93       	push	r28
    108e:	df 93       	push	r29
    1090:	cd b7       	in	r28, 0x3d	; 61
    1092:	de b7       	in	r29, 0x3e	; 62
    1094:	29 97       	sbiw	r28, 0x09	; 9
    1096:	0f b6       	in	r0, 0x3f	; 63
    1098:	f8 94       	cli
    109a:	de bf       	out	0x3e, r29	; 62
    109c:	0f be       	out	0x3f, r0	; 63
    109e:	cd bf       	out	0x3d, r28	; 61
    10a0:	88 87       	std	Y+8, r24	; 0x08
    10a2:	69 87       	std	Y+9, r22	; 0x09
	cli();
    10a4:	f8 94       	cli
	if (sTime){
    10a6:	88 85       	ldd	r24, Y+8	; 0x08
    10a8:	88 23       	and	r24, r24
    10aa:	f1 f0       	breq	.+60     	; 0x10e8 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
    10ac:	86 ea       	ldi	r24, 0xA6	; 166
    10ae:	91 e0       	ldi	r25, 0x01	; 1
    10b0:	0e 94 bb 04 	call	0x976	; 0x976 <_ZN6myTime8getHoursEv>
    10b4:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
    10b6:	86 ea       	ldi	r24, 0xA6	; 166
    10b8:	91 e0       	ldi	r25, 0x01	; 1
    10ba:	0e 94 aa 04 	call	0x954	; 0x954 <_ZN6myTime10getMinutesEv>
    10be:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
    10c0:	86 ea       	ldi	r24, 0xA6	; 166
    10c2:	91 e0       	ldi	r25, 0x01	; 1
    10c4:	0e 94 99 04 	call	0x932	; 0x932 <_ZN6myTime10getSecondsEv>
    10c8:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
    10ca:	82 e0       	ldi	r24, 0x02	; 2
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	6b 81       	ldd	r22, Y+3	; 0x03
    10d0:	0e 94 b1 1a 	call	0x3562	; 0x3562 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeMinute,tempMin);
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	90 e0       	ldi	r25, 0x00	; 0
    10d8:	6a 81       	ldd	r22, Y+2	; 0x02
    10da:	0e 94 b1 1a 	call	0x3562	; 0x3562 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeHour,tempHour);
    10de:	80 e0       	ldi	r24, 0x00	; 0
    10e0:	90 e0       	ldi	r25, 0x00	; 0
    10e2:	69 81       	ldd	r22, Y+1	; 0x01
    10e4:	0e 94 b1 1a 	call	0x3562	; 0x3562 <__eewr_byte_m644pa>
	}
	if (sDate){
    10e8:	89 85       	ldd	r24, Y+9	; 0x09
    10ea:	88 23       	and	r24, r24
    10ec:	09 f1       	breq	.+66     	; 0x1130 <__stack+0x31>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
    10ee:	86 ea       	ldi	r24, 0xA6	; 166
    10f0:	91 e0       	ldi	r25, 0x01	; 1
    10f2:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
    10f6:	9d 83       	std	Y+5, r25	; 0x05
    10f8:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
    10fa:	86 ea       	ldi	r24, 0xA6	; 166
    10fc:	91 e0       	ldi	r25, 0x01	; 1
    10fe:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
    1102:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
    1104:	86 ea       	ldi	r24, 0xA6	; 166
    1106:	91 e0       	ldi	r25, 0x01	; 1
    1108:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
    110c:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
    110e:	85 e0       	ldi	r24, 0x05	; 5
    1110:	90 e0       	ldi	r25, 0x00	; 0
    1112:	2c 81       	ldd	r18, Y+4	; 0x04
    1114:	3d 81       	ldd	r19, Y+5	; 0x05
    1116:	b9 01       	movw	r22, r18
    1118:	0e 94 bf 1a 	call	0x357e	; 0x357e <__eewr_word_m644pa>
		eeprom_write_byte(&eeMonth,tempMonth);
    111c:	83 e0       	ldi	r24, 0x03	; 3
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	6e 81       	ldd	r22, Y+6	; 0x06
    1122:	0e 94 b1 1a 	call	0x3562	; 0x3562 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeDay,tempDay);
    1126:	84 e0       	ldi	r24, 0x04	; 4
    1128:	90 e0       	ldi	r25, 0x00	; 0
    112a:	6f 81       	ldd	r22, Y+7	; 0x07
    112c:	0e 94 b1 1a 	call	0x3562	; 0x3562 <__eewr_byte_m644pa>
	}
	sei();
    1130:	78 94       	sei
}
    1132:	29 96       	adiw	r28, 0x09	; 9
    1134:	0f b6       	in	r0, 0x3f	; 63
    1136:	f8 94       	cli
    1138:	de bf       	out	0x3e, r29	; 62
    113a:	0f be       	out	0x3f, r0	; 63
    113c:	cd bf       	out	0x3d, r28	; 61
    113e:	df 91       	pop	r29
    1140:	cf 91       	pop	r28
    1142:	08 95       	ret

00001144 <_Z13PutUartChBonec>:
extern myTime currentTime;

#define updatingGAVR (flagUpdateGAVRDate || flagUpdateGAVRTime)

/**************************************************************************************************************/
void PutUartChBone(char ch){
    1144:	cf 93       	push	r28
    1146:	df 93       	push	r29
    1148:	0f 92       	push	r0
    114a:	cd b7       	in	r28, 0x3d	; 61
    114c:	de b7       	in	r29, 0x3e	; 62
    114e:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
    1150:	00 00       	nop
    1152:	80 ec       	ldi	r24, 0xC0	; 192
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	fc 01       	movw	r30, r24
    1158:	80 81       	ld	r24, Z
    115a:	88 2f       	mov	r24, r24
    115c:	90 e0       	ldi	r25, 0x00	; 0
    115e:	80 72       	andi	r24, 0x20	; 32
    1160:	90 70       	andi	r25, 0x00	; 0
    1162:	21 e0       	ldi	r18, 0x01	; 1
    1164:	00 97       	sbiw	r24, 0x00	; 0
    1166:	09 f0       	breq	.+2      	; 0x116a <_Z13PutUartChBonec+0x26>
    1168:	20 e0       	ldi	r18, 0x00	; 0
    116a:	22 23       	and	r18, r18
    116c:	91 f7       	brne	.-28     	; 0x1152 <_Z13PutUartChBonec+0xe>
	UDR0=ch;
    116e:	86 ec       	ldi	r24, 0xC6	; 198
    1170:	90 e0       	ldi	r25, 0x00	; 0
    1172:	29 81       	ldd	r18, Y+1	; 0x01
    1174:	fc 01       	movw	r30, r24
    1176:	20 83       	st	Z, r18
}
    1178:	0f 90       	pop	r0
    117a:	df 91       	pop	r29
    117c:	cf 91       	pop	r28
    117e:	08 95       	ret

00001180 <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
    1180:	cf 93       	push	r28
    1182:	df 93       	push	r29
    1184:	00 d0       	rcall	.+0      	; 0x1186 <_Z9PrintBonePc+0x6>
    1186:	0f 92       	push	r0
    1188:	cd b7       	in	r28, 0x3d	; 61
    118a:	de b7       	in	r29, 0x3e	; 62
    118c:	9b 83       	std	Y+3, r25	; 0x03
    118e:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    1190:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    1192:	0e c0       	rjmp	.+28     	; 0x11b0 <_Z9PrintBonePc+0x30>
		PutUartChBone(string[i++]);
    1194:	89 81       	ldd	r24, Y+1	; 0x01
    1196:	88 2f       	mov	r24, r24
    1198:	90 e0       	ldi	r25, 0x00	; 0
    119a:	2a 81       	ldd	r18, Y+2	; 0x02
    119c:	3b 81       	ldd	r19, Y+3	; 0x03
    119e:	82 0f       	add	r24, r18
    11a0:	93 1f       	adc	r25, r19
    11a2:	fc 01       	movw	r30, r24
    11a4:	80 81       	ld	r24, Z
    11a6:	99 81       	ldd	r25, Y+1	; 0x01
    11a8:	9f 5f       	subi	r25, 0xFF	; 255
    11aa:	99 83       	std	Y+1, r25	; 0x01
    11ac:	0e 94 a2 08 	call	0x1144	; 0x1144 <_Z13PutUartChBonec>
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    11b0:	89 81       	ldd	r24, Y+1	; 0x01
    11b2:	88 2f       	mov	r24, r24
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	2a 81       	ldd	r18, Y+2	; 0x02
    11b8:	3b 81       	ldd	r19, Y+3	; 0x03
    11ba:	82 0f       	add	r24, r18
    11bc:	93 1f       	adc	r25, r19
    11be:	fc 01       	movw	r30, r24
    11c0:	90 81       	ld	r25, Z
    11c2:	81 e0       	ldi	r24, 0x01	; 1
    11c4:	99 23       	and	r25, r25
    11c6:	09 f4       	brne	.+2      	; 0x11ca <_Z9PrintBonePc+0x4a>
    11c8:	80 e0       	ldi	r24, 0x00	; 0
    11ca:	88 23       	and	r24, r24
    11cc:	19 f7       	brne	.-58     	; 0x1194 <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i++]);
	}
}
    11ce:	0f 90       	pop	r0
    11d0:	0f 90       	pop	r0
    11d2:	0f 90       	pop	r0
    11d4:	df 91       	pop	r29
    11d6:	cf 91       	pop	r28
    11d8:	08 95       	ret

000011da <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    11da:	cf 93       	push	r28
    11dc:	df 93       	push	r29
    11de:	0f 92       	push	r0
    11e0:	cd b7       	in	r28, 0x3d	; 61
    11e2:	de b7       	in	r29, 0x3e	; 62
    11e4:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    11e6:	00 00       	nop
    11e8:	88 ec       	ldi	r24, 0xC8	; 200
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	fc 01       	movw	r30, r24
    11ee:	80 81       	ld	r24, Z
    11f0:	88 2f       	mov	r24, r24
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	80 72       	andi	r24, 0x20	; 32
    11f6:	90 70       	andi	r25, 0x00	; 0
    11f8:	21 e0       	ldi	r18, 0x01	; 1
    11fa:	00 97       	sbiw	r24, 0x00	; 0
    11fc:	09 f0       	breq	.+2      	; 0x1200 <_Z13PutUartChGAVRc+0x26>
    11fe:	20 e0       	ldi	r18, 0x00	; 0
    1200:	22 23       	and	r18, r18
    1202:	91 f7       	brne	.-28     	; 0x11e8 <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    1204:	8e ec       	ldi	r24, 0xCE	; 206
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	29 81       	ldd	r18, Y+1	; 0x01
    120a:	fc 01       	movw	r30, r24
    120c:	20 83       	st	Z, r18
}
    120e:	0f 90       	pop	r0
    1210:	df 91       	pop	r29
    1212:	cf 91       	pop	r28
    1214:	08 95       	ret

00001216 <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    1216:	cf 93       	push	r28
    1218:	df 93       	push	r29
    121a:	00 d0       	rcall	.+0      	; 0x121c <_Z9PrintGAVRPc+0x6>
    121c:	0f 92       	push	r0
    121e:	cd b7       	in	r28, 0x3d	; 61
    1220:	de b7       	in	r29, 0x3e	; 62
    1222:	9b 83       	std	Y+3, r25	; 0x03
    1224:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    1226:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    1228:	0e c0       	rjmp	.+28     	; 0x1246 <_Z9PrintGAVRPc+0x30>
		PutUartChGAVR(string[i++]);
    122a:	89 81       	ldd	r24, Y+1	; 0x01
    122c:	88 2f       	mov	r24, r24
    122e:	90 e0       	ldi	r25, 0x00	; 0
    1230:	2a 81       	ldd	r18, Y+2	; 0x02
    1232:	3b 81       	ldd	r19, Y+3	; 0x03
    1234:	82 0f       	add	r24, r18
    1236:	93 1f       	adc	r25, r19
    1238:	fc 01       	movw	r30, r24
    123a:	80 81       	ld	r24, Z
    123c:	99 81       	ldd	r25, Y+1	; 0x01
    123e:	9f 5f       	subi	r25, 0xFF	; 255
    1240:	99 83       	std	Y+1, r25	; 0x01
    1242:	0e 94 ed 08 	call	0x11da	; 0x11da <_Z13PutUartChGAVRc>
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    1246:	89 81       	ldd	r24, Y+1	; 0x01
    1248:	88 2f       	mov	r24, r24
    124a:	90 e0       	ldi	r25, 0x00	; 0
    124c:	2a 81       	ldd	r18, Y+2	; 0x02
    124e:	3b 81       	ldd	r19, Y+3	; 0x03
    1250:	82 0f       	add	r24, r18
    1252:	93 1f       	adc	r25, r19
    1254:	fc 01       	movw	r30, r24
    1256:	90 81       	ld	r25, Z
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	99 23       	and	r25, r25
    125c:	09 f4       	brne	.+2      	; 0x1260 <_Z9PrintGAVRPc+0x4a>
    125e:	80 e0       	ldi	r24, 0x00	; 0
    1260:	88 23       	and	r24, r24
    1262:	19 f7       	brne	.-58     	; 0x122a <_Z9PrintGAVRPc+0x14>
		PutUartChGAVR(string[i++]);
	}
}
    1264:	0f 90       	pop	r0
    1266:	0f 90       	pop	r0
    1268:	0f 90       	pop	r0
    126a:	df 91       	pop	r29
    126c:	cf 91       	pop	r28
    126e:	08 95       	ret

00001270 <_Z8sendGAVRv>:
/*************************************************************************************************************/
void sendGAVR(){
    1270:	cf 93       	push	r28
    1272:	df 93       	push	r29
    1274:	cd b7       	in	r28, 0x3d	; 61
    1276:	de b7       	in	r29, 0x3e	; 62
    1278:	ca 55       	subi	r28, 0x5A	; 90
    127a:	d0 40       	sbci	r29, 0x00	; 0
    127c:	0f b6       	in	r0, 0x3f	; 63
    127e:	f8 94       	cli
    1280:	de bf       	out	0x3e, r29	; 62
    1282:	0f be       	out	0x3f, r0	; 63
    1284:	cd bf       	out	0x3d, r28	; 61
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    1286:	81 e0       	ldi	r24, 0x01	; 1
    1288:	8a 87       	std	Y+10, r24	; 0x0a
	char recChar, recString[40], sentString[40];
	unsigned int strLoc=0;
    128a:	1a 82       	std	Y+2, r1	; 0x02
    128c:	19 82       	std	Y+1, r1	; 0x01
	
	//Used for shutdown connection logic if there was a timeout in sending or receiving
	BOOL flagTimeout=fFalse;
    128e:	1b 82       	std	Y+3, r1	; 0x03
	
	//Transmission protocol
	while (flagSendingGAVR && !flagTimeout){
    1290:	45 c2       	rjmp	.+1162   	; 0x171c <_Z8sendGAVRv+0x4ac>
		/* State 5: Successful transmission and reception. Kill sending flag, reset state, exit.					 */
		/* State 6: ACKBAD received, check to see if we have an invalid date/time in our clock or it was just noisy  */
		/*			and had error in transmission/reception. If valid, go to waiting state. Else exit and set flag.	 */
		/* State 7: Got the wrong ack for something, set a flag to let the WAVR do its thing then try again.		 */
		/*************************************************************************************************************/
		switch (state){
    1292:	80 91 ed 01 	lds	r24, 0x01ED
    1296:	90 91 ee 01 	lds	r25, 0x01EE
    129a:	83 30       	cpi	r24, 0x03	; 3
    129c:	91 05       	cpc	r25, r1
    129e:	09 f4       	brne	.+2      	; 0x12a2 <_Z8sendGAVRv+0x32>
    12a0:	3f c1       	rjmp	.+638    	; 0x1520 <_Z8sendGAVRv+0x2b0>
    12a2:	84 30       	cpi	r24, 0x04	; 4
    12a4:	91 05       	cpc	r25, r1
    12a6:	48 f4       	brcc	.+18     	; 0x12ba <_Z8sendGAVRv+0x4a>
    12a8:	81 30       	cpi	r24, 0x01	; 1
    12aa:	91 05       	cpc	r25, r1
    12ac:	09 f4       	brne	.+2      	; 0x12b0 <_Z8sendGAVRv+0x40>
    12ae:	97 c0       	rjmp	.+302    	; 0x13de <_Z8sendGAVRv+0x16e>
    12b0:	82 30       	cpi	r24, 0x02	; 2
    12b2:	91 05       	cpc	r25, r1
    12b4:	08 f0       	brcs	.+2      	; 0x12b8 <_Z8sendGAVRv+0x48>
    12b6:	a1 c0       	rjmp	.+322    	; 0x13fa <_Z8sendGAVRv+0x18a>
    12b8:	11 c0       	rjmp	.+34     	; 0x12dc <_Z8sendGAVRv+0x6c>
    12ba:	85 30       	cpi	r24, 0x05	; 5
    12bc:	91 05       	cpc	r25, r1
    12be:	09 f4       	brne	.+2      	; 0x12c2 <_Z8sendGAVRv+0x52>
    12c0:	f6 c1       	rjmp	.+1004   	; 0x16ae <_Z8sendGAVRv+0x43e>
    12c2:	85 30       	cpi	r24, 0x05	; 5
    12c4:	91 05       	cpc	r25, r1
    12c6:	08 f4       	brcc	.+2      	; 0x12ca <_Z8sendGAVRv+0x5a>
    12c8:	e7 c1       	rjmp	.+974    	; 0x1698 <_Z8sendGAVRv+0x428>
    12ca:	86 30       	cpi	r24, 0x06	; 6
    12cc:	91 05       	cpc	r25, r1
    12ce:	09 f4       	brne	.+2      	; 0x12d2 <_Z8sendGAVRv+0x62>
    12d0:	f8 c1       	rjmp	.+1008   	; 0x16c2 <_Z8sendGAVRv+0x452>
    12d2:	87 30       	cpi	r24, 0x07	; 7
    12d4:	91 05       	cpc	r25, r1
    12d6:	09 f4       	brne	.+2      	; 0x12da <_Z8sendGAVRv+0x6a>
    12d8:	0d c2       	rjmp	.+1050   	; 0x16f4 <_Z8sendGAVRv+0x484>
    12da:	17 c2       	rjmp	.+1070   	; 0x170a <_Z8sendGAVRv+0x49a>
			case 0: {
				//Raise interrupts to GAVR for three ish clock cycles.
				prtGAVRINT |= (1 << bnGAVRINT);
    12dc:	85 e2       	ldi	r24, 0x25	; 37
    12de:	90 e0       	ldi	r25, 0x00	; 0
    12e0:	25 e2       	ldi	r18, 0x25	; 37
    12e2:	30 e0       	ldi	r19, 0x00	; 0
    12e4:	f9 01       	movw	r30, r18
    12e6:	20 81       	ld	r18, Z
    12e8:	28 60       	ori	r18, 0x08	; 8
    12ea:	fc 01       	movw	r30, r24
    12ec:	20 83       	st	Z, r18
				for (int i=0; i<2; i++){asm volatile("nop");}
    12ee:	1d 82       	std	Y+5, r1	; 0x05
    12f0:	1c 82       	std	Y+4, r1	; 0x04
    12f2:	06 c0       	rjmp	.+12     	; 0x1300 <_Z8sendGAVRv+0x90>
    12f4:	00 00       	nop
    12f6:	8c 81       	ldd	r24, Y+4	; 0x04
    12f8:	9d 81       	ldd	r25, Y+5	; 0x05
    12fa:	01 96       	adiw	r24, 0x01	; 1
    12fc:	9d 83       	std	Y+5, r25	; 0x05
    12fe:	8c 83       	std	Y+4, r24	; 0x04
    1300:	21 e0       	ldi	r18, 0x01	; 1
    1302:	8c 81       	ldd	r24, Y+4	; 0x04
    1304:	9d 81       	ldd	r25, Y+5	; 0x05
    1306:	82 30       	cpi	r24, 0x02	; 2
    1308:	91 05       	cpc	r25, r1
    130a:	0c f0       	brlt	.+2      	; 0x130e <_Z8sendGAVRv+0x9e>
    130c:	20 e0       	ldi	r18, 0x00	; 0
    130e:	22 23       	and	r18, r18
    1310:	89 f7       	brne	.-30     	; 0x12f4 <_Z8sendGAVRv+0x84>
				prtGAVRINT &= ~(1 << bnGAVRINT);
    1312:	85 e2       	ldi	r24, 0x25	; 37
    1314:	90 e0       	ldi	r25, 0x00	; 0
    1316:	25 e2       	ldi	r18, 0x25	; 37
    1318:	30 e0       	ldi	r19, 0x00	; 0
    131a:	f9 01       	movw	r30, r18
    131c:	20 81       	ld	r18, Z
    131e:	27 7f       	andi	r18, 0xF7	; 247
    1320:	fc 01       	movw	r30, r24
    1322:	20 83       	st	Z, r18
				state=1;
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	90 93 ee 01 	sts	0x01EE, r25
    132c:	80 93 ed 01 	sts	0x01ED, r24
				break;
    1330:	f5 c1       	rjmp	.+1002   	; 0x171c <_Z8sendGAVRv+0x4ac>
			}//end case 0
			case 1: {
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);
    1332:	00 00       	nop
    1334:	88 ec       	ldi	r24, 0xC8	; 200
    1336:	90 e0       	ldi	r25, 0x00	; 0
    1338:	fc 01       	movw	r30, r24
    133a:	80 81       	ld	r24, Z
    133c:	88 23       	and	r24, r24
    133e:	34 f0       	brlt	.+12     	; 0x134c <_Z8sendGAVRv+0xdc>
    1340:	80 91 d5 01 	lds	r24, 0x01D5
    1344:	88 23       	and	r24, r24
    1346:	11 f0       	breq	.+4      	; 0x134c <_Z8sendGAVRv+0xdc>
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	01 c0       	rjmp	.+2      	; 0x134e <_Z8sendGAVRv+0xde>
    134c:	80 e0       	ldi	r24, 0x00	; 0
    134e:	88 23       	and	r24, r24
    1350:	89 f7       	brne	.-30     	; 0x1334 <_Z8sendGAVRv+0xc4>
					if (!flagSendingGAVR){state=0; flagTimeout=fTrue; break;}
    1352:	80 91 d5 01 	lds	r24, 0x01D5
    1356:	88 23       	and	r24, r24
    1358:	41 f4       	brne	.+16     	; 0x136a <_Z8sendGAVRv+0xfa>
    135a:	10 92 ee 01 	sts	0x01EE, r1
    135e:	10 92 ed 01 	sts	0x01ED, r1
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	8b 83       	std	Y+3, r24	; 0x03
    1366:	00 00       	nop
							//recString[strLoc++] = recChar;
							if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
						}//end if-else
					}//end if-else	
				}//end while
				break;
    1368:	d9 c1       	rjmp	.+946    	; 0x171c <_Z8sendGAVRv+0x4ac>
			case 1: {
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);
					if (!flagSendingGAVR){state=0; flagTimeout=fTrue; break;}
					else {
						recChar=UDR1;
    136a:	8e ec       	ldi	r24, 0xCE	; 206
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	fc 01       	movw	r30, r24
    1370:	80 81       	ld	r24, Z
    1372:	88 87       	std	Y+8, r24	; 0x08
						recString[strLoc++]=recChar;
    1374:	9e 01       	movw	r18, r28
    1376:	2d 5c       	subi	r18, 0xCD	; 205
    1378:	3f 4f       	sbci	r19, 0xFF	; 255
    137a:	89 81       	ldd	r24, Y+1	; 0x01
    137c:	9a 81       	ldd	r25, Y+2	; 0x02
    137e:	82 0f       	add	r24, r18
    1380:	93 1f       	adc	r25, r19
    1382:	28 85       	ldd	r18, Y+8	; 0x08
    1384:	fc 01       	movw	r30, r24
    1386:	20 83       	st	Z, r18
    1388:	89 81       	ldd	r24, Y+1	; 0x01
    138a:	9a 81       	ldd	r25, Y+2	; 0x02
    138c:	01 96       	adiw	r24, 0x01	; 1
    138e:	9a 83       	std	Y+2, r25	; 0x02
    1390:	89 83       	std	Y+1, r24	; 0x01
						if (recChar=='.'){recString[strLoc++]='\0'; state=2;}
    1392:	88 85       	ldd	r24, Y+8	; 0x08
    1394:	8e 32       	cpi	r24, 0x2E	; 46
    1396:	a9 f4       	brne	.+42     	; 0x13c2 <_Z8sendGAVRv+0x152>
    1398:	9e 01       	movw	r18, r28
    139a:	2d 5c       	subi	r18, 0xCD	; 205
    139c:	3f 4f       	sbci	r19, 0xFF	; 255
    139e:	89 81       	ldd	r24, Y+1	; 0x01
    13a0:	9a 81       	ldd	r25, Y+2	; 0x02
    13a2:	82 0f       	add	r24, r18
    13a4:	93 1f       	adc	r25, r19
    13a6:	fc 01       	movw	r30, r24
    13a8:	10 82       	st	Z, r1
    13aa:	89 81       	ldd	r24, Y+1	; 0x01
    13ac:	9a 81       	ldd	r25, Y+2	; 0x02
    13ae:	01 96       	adiw	r24, 0x01	; 1
    13b0:	9a 83       	std	Y+2, r25	; 0x02
    13b2:	89 83       	std	Y+1, r24	; 0x01
    13b4:	82 e0       	ldi	r24, 0x02	; 2
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	90 93 ee 01 	sts	0x01EE, r25
    13bc:	80 93 ed 01 	sts	0x01ED, r24
    13c0:	0e c0       	rjmp	.+28     	; 0x13de <_Z8sendGAVRv+0x16e>
						else {
							//recString[strLoc++] = recChar;
							if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
    13c2:	89 81       	ldd	r24, Y+1	; 0x01
    13c4:	9a 81       	ldd	r25, Y+2	; 0x02
    13c6:	87 32       	cpi	r24, 0x27	; 39
    13c8:	91 05       	cpc	r25, r1
    13ca:	48 f0       	brcs	.+18     	; 0x13de <_Z8sendGAVRv+0x16e>
    13cc:	1a 82       	std	Y+2, r1	; 0x02
    13ce:	19 82       	std	Y+1, r1	; 0x01
    13d0:	1a 86       	std	Y+10, r1	; 0x0a
    13d2:	87 e0       	ldi	r24, 0x07	; 7
    13d4:	90 e0       	ldi	r25, 0x00	; 0
    13d6:	90 93 ee 01 	sts	0x01EE, r25
    13da:	80 93 ed 01 	sts	0x01ED, r24
				prtGAVRINT &= ~(1 << bnGAVRINT);
				state=1;
				break;
			}//end case 0
			case 1: {
				while (noCarriage && flagSendingGAVR){
    13de:	8a 85       	ldd	r24, Y+10	; 0x0a
    13e0:	88 23       	and	r24, r24
    13e2:	31 f0       	breq	.+12     	; 0x13f0 <_Z8sendGAVRv+0x180>
    13e4:	80 91 d5 01 	lds	r24, 0x01D5
    13e8:	88 23       	and	r24, r24
    13ea:	11 f0       	breq	.+4      	; 0x13f0 <_Z8sendGAVRv+0x180>
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	01 c0       	rjmp	.+2      	; 0x13f2 <_Z8sendGAVRv+0x182>
    13f0:	80 e0       	ldi	r24, 0x00	; 0
    13f2:	88 23       	and	r24, r24
    13f4:	09 f0       	breq	.+2      	; 0x13f8 <_Z8sendGAVRv+0x188>
    13f6:	9d cf       	rjmp	.-198    	; 0x1332 <_Z8sendGAVRv+0xc2>
							//recString[strLoc++] = recChar;
							if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
						}//end if-else
					}//end if-else	
				}//end while
				break;
    13f8:	91 c1       	rjmp	.+802    	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 1
			case 2: {
				if (!strcmp(recString,"ACKW.")){state=3;}
    13fa:	ce 01       	movw	r24, r28
    13fc:	c3 96       	adiw	r24, 0x33	; 51
    13fe:	20 e0       	ldi	r18, 0x00	; 0
    1400:	31 e0       	ldi	r19, 0x01	; 1
    1402:	b9 01       	movw	r22, r18
    1404:	0e 94 46 1a 	call	0x348c	; 0x348c <strcmp>
    1408:	00 97       	sbiw	r24, 0x00	; 0
    140a:	39 f4       	brne	.+14     	; 0x141a <_Z8sendGAVRv+0x1aa>
    140c:	83 e0       	ldi	r24, 0x03	; 3
    140e:	90 e0       	ldi	r25, 0x00	; 0
    1410:	90 93 ee 01 	sts	0x01EE, r25
    1414:	80 93 ed 01 	sts	0x01ED, r24
				else if (!strcmp(recString,"ACKBAD.")){state=6;}
				//send string case.
				else if (updatingGAVR && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (updatingGAVR && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1418:	81 c1       	rjmp	.+770    	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (!strcmp(recString,"ACKW.")){state=3;}
				else if (!strcmp(recString,"ACKGD.")){state=4;}
    141a:	ce 01       	movw	r24, r28
    141c:	c3 96       	adiw	r24, 0x33	; 51
    141e:	26 e0       	ldi	r18, 0x06	; 6
    1420:	31 e0       	ldi	r19, 0x01	; 1
    1422:	b9 01       	movw	r22, r18
    1424:	0e 94 46 1a 	call	0x348c	; 0x348c <strcmp>
    1428:	00 97       	sbiw	r24, 0x00	; 0
    142a:	39 f4       	brne	.+14     	; 0x143a <_Z8sendGAVRv+0x1ca>
    142c:	84 e0       	ldi	r24, 0x04	; 4
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	90 93 ee 01 	sts	0x01EE, r25
    1434:	80 93 ed 01 	sts	0x01ED, r24
				else if (!strcmp(recString,"ACKBAD.")){state=6;}
				//send string case.
				else if (updatingGAVR && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (updatingGAVR && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1438:	71 c1       	rjmp	.+738    	; 0x171c <_Z8sendGAVRv+0x4ac>
				break;
				}//end case 1
			case 2: {
				if (!strcmp(recString,"ACKW.")){state=3;}
				else if (!strcmp(recString,"ACKGD.")){state=4;}
				else if (!strcmp(recString,"ACKGT.")){state=4;}
    143a:	ce 01       	movw	r24, r28
    143c:	c3 96       	adiw	r24, 0x33	; 51
    143e:	2d e0       	ldi	r18, 0x0D	; 13
    1440:	31 e0       	ldi	r19, 0x01	; 1
    1442:	b9 01       	movw	r22, r18
    1444:	0e 94 46 1a 	call	0x348c	; 0x348c <strcmp>
    1448:	00 97       	sbiw	r24, 0x00	; 0
    144a:	39 f4       	brne	.+14     	; 0x145a <_Z8sendGAVRv+0x1ea>
    144c:	84 e0       	ldi	r24, 0x04	; 4
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	90 93 ee 01 	sts	0x01EE, r25
    1454:	80 93 ed 01 	sts	0x01ED, r24
				else if (!strcmp(recString,"ACKBAD.")){state=6;}
				//send string case.
				else if (updatingGAVR && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (updatingGAVR && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1458:	61 c1       	rjmp	.+706    	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 1
			case 2: {
				if (!strcmp(recString,"ACKW.")){state=3;}
				else if (!strcmp(recString,"ACKGD.")){state=4;}
				else if (!strcmp(recString,"ACKGT.")){state=4;}
				else if (!strcmp(recString,"ACKGB.")){state=4;}
    145a:	ce 01       	movw	r24, r28
    145c:	c3 96       	adiw	r24, 0x33	; 51
    145e:	24 e1       	ldi	r18, 0x14	; 20
    1460:	31 e0       	ldi	r19, 0x01	; 1
    1462:	b9 01       	movw	r22, r18
    1464:	0e 94 46 1a 	call	0x348c	; 0x348c <strcmp>
    1468:	00 97       	sbiw	r24, 0x00	; 0
    146a:	39 f4       	brne	.+14     	; 0x147a <_Z8sendGAVRv+0x20a>
    146c:	84 e0       	ldi	r24, 0x04	; 4
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	90 93 ee 01 	sts	0x01EE, r25
    1474:	80 93 ed 01 	sts	0x01ED, r24
				else if (!strcmp(recString,"ACKBAD.")){state=6;}
				//send string case.
				else if (updatingGAVR && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (updatingGAVR && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1478:	51 c1       	rjmp	.+674    	; 0x171c <_Z8sendGAVRv+0x4ac>
			case 2: {
				if (!strcmp(recString,"ACKW.")){state=3;}
				else if (!strcmp(recString,"ACKGD.")){state=4;}
				else if (!strcmp(recString,"ACKGT.")){state=4;}
				else if (!strcmp(recString,"ACKGB.")){state=4;}
				else if (!strcmp(recString,"ACKBAD.")){state=6;}
    147a:	ce 01       	movw	r24, r28
    147c:	c3 96       	adiw	r24, 0x33	; 51
    147e:	2b e1       	ldi	r18, 0x1B	; 27
    1480:	31 e0       	ldi	r19, 0x01	; 1
    1482:	b9 01       	movw	r22, r18
    1484:	0e 94 46 1a 	call	0x348c	; 0x348c <strcmp>
    1488:	00 97       	sbiw	r24, 0x00	; 0
    148a:	39 f4       	brne	.+14     	; 0x149a <_Z8sendGAVRv+0x22a>
    148c:	86 e0       	ldi	r24, 0x06	; 6
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	90 93 ee 01 	sts	0x01EE, r25
    1494:	80 93 ed 01 	sts	0x01ED, r24
				//send string case.
				else if (updatingGAVR && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (updatingGAVR && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1498:	41 c1       	rjmp	.+642    	; 0x171c <_Z8sendGAVRv+0x4ac>
				else if (!strcmp(recString,"ACKGD.")){state=4;}
				else if (!strcmp(recString,"ACKGT.")){state=4;}
				else if (!strcmp(recString,"ACKGB.")){state=4;}
				else if (!strcmp(recString,"ACKBAD.")){state=6;}
				//send string case.
				else if (updatingGAVR && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
    149a:	80 91 d4 01 	lds	r24, 0x01D4
    149e:	88 23       	and	r24, r24
    14a0:	21 f4       	brne	.+8      	; 0x14aa <_Z8sendGAVRv+0x23a>
    14a2:	80 91 d3 01 	lds	r24, 0x01D3
    14a6:	88 23       	and	r24, r24
    14a8:	89 f0       	breq	.+34     	; 0x14cc <_Z8sendGAVRv+0x25c>
    14aa:	ce 01       	movw	r24, r28
    14ac:	c3 96       	adiw	r24, 0x33	; 51
    14ae:	9e 01       	movw	r18, r28
    14b0:	25 5f       	subi	r18, 0xF5	; 245
    14b2:	3f 4f       	sbci	r19, 0xFF	; 255
    14b4:	b9 01       	movw	r22, r18
    14b6:	0e 94 46 1a 	call	0x348c	; 0x348c <strcmp>
    14ba:	00 97       	sbiw	r24, 0x00	; 0
    14bc:	39 f4       	brne	.+14     	; 0x14cc <_Z8sendGAVRv+0x25c>
    14be:	85 e0       	ldi	r24, 0x05	; 5
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	90 93 ee 01 	sts	0x01EE, r25
    14c6:	80 93 ed 01 	sts	0x01ED, r24
    14ca:	29 c0       	rjmp	.+82     	; 0x151e <_Z8sendGAVRv+0x2ae>
				else if (updatingGAVR && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
    14cc:	80 91 d4 01 	lds	r24, 0x01D4
    14d0:	88 23       	and	r24, r24
    14d2:	21 f4       	brne	.+8      	; 0x14dc <_Z8sendGAVRv+0x26c>
    14d4:	80 91 d3 01 	lds	r24, 0x01D3
    14d8:	88 23       	and	r24, r24
    14da:	d1 f0       	breq	.+52     	; 0x1510 <_Z8sendGAVRv+0x2a0>
    14dc:	ce 01       	movw	r24, r28
    14de:	c3 96       	adiw	r24, 0x33	; 51
    14e0:	9e 01       	movw	r18, r28
    14e2:	25 5f       	subi	r18, 0xF5	; 245
    14e4:	3f 4f       	sbci	r19, 0xFF	; 255
    14e6:	b9 01       	movw	r22, r18
    14e8:	0e 94 46 1a 	call	0x348c	; 0x348c <strcmp>
    14ec:	00 97       	sbiw	r24, 0x00	; 0
    14ee:	81 f0       	breq	.+32     	; 0x1510 <_Z8sendGAVRv+0x2a0>
    14f0:	ce 01       	movw	r24, r28
    14f2:	c3 96       	adiw	r24, 0x33	; 51
    14f4:	2b e1       	ldi	r18, 0x1B	; 27
    14f6:	31 e0       	ldi	r19, 0x01	; 1
    14f8:	b9 01       	movw	r22, r18
    14fa:	0e 94 46 1a 	call	0x348c	; 0x348c <strcmp>
    14fe:	00 97       	sbiw	r24, 0x00	; 0
    1500:	39 f0       	breq	.+14     	; 0x1510 <_Z8sendGAVRv+0x2a0>
    1502:	87 e0       	ldi	r24, 0x07	; 7
    1504:	90 e0       	ldi	r25, 0x00	; 0
    1506:	90 93 ee 01 	sts	0x01EE, r25
    150a:	80 93 ed 01 	sts	0x01ED, r24
    150e:	07 c0       	rjmp	.+14     	; 0x151e <_Z8sendGAVRv+0x2ae>
				else{state=7;} //invalid ack. ACKERROR goes here.
    1510:	87 e0       	ldi	r24, 0x07	; 7
    1512:	90 e0       	ldi	r25, 0x00	; 0
    1514:	90 93 ee 01 	sts	0x01EE, r25
    1518:	80 93 ed 01 	sts	0x01ED, r24
				break;
    151c:	ff c0       	rjmp	.+510    	; 0x171c <_Z8sendGAVRv+0x4ac>
    151e:	fe c0       	rjmp	.+508    	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 2
			case 3:{
				if (flagUserDate&&!flagUserTime){
    1520:	80 91 d6 01 	lds	r24, 0x01D6
    1524:	88 23       	and	r24, r24
    1526:	61 f0       	breq	.+24     	; 0x1540 <_Z8sendGAVRv+0x2d0>
    1528:	80 91 d7 01 	lds	r24, 0x01D7
    152c:	88 23       	and	r24, r24
    152e:	41 f4       	brne	.+16     	; 0x1540 <_Z8sendGAVRv+0x2d0>
					PrintGAVR("SYNGD.");
    1530:	83 e2       	ldi	r24, 0x23	; 35
    1532:	91 e0       	ldi	r25, 0x01	; 1
    1534:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
					flagWaitingForReceiveGAVR=fTrue;
    1538:	81 e0       	ldi	r24, 0x01	; 1
    153a:	80 93 d2 01 	sts	0x01D2, r24
    153e:	1f c0       	rjmp	.+62     	; 0x157e <_Z8sendGAVRv+0x30e>
				} else if (!flagUserDate&&flagUserTime){
    1540:	80 91 d6 01 	lds	r24, 0x01D6
    1544:	88 23       	and	r24, r24
    1546:	61 f4       	brne	.+24     	; 0x1560 <_Z8sendGAVRv+0x2f0>
    1548:	80 91 d7 01 	lds	r24, 0x01D7
    154c:	88 23       	and	r24, r24
    154e:	41 f0       	breq	.+16     	; 0x1560 <_Z8sendGAVRv+0x2f0>
					PrintGAVR("SYNGT.");
    1550:	8a e2       	ldi	r24, 0x2A	; 42
    1552:	91 e0       	ldi	r25, 0x01	; 1
    1554:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
					flagWaitingForReceiveGAVR=fTrue;
    1558:	81 e0       	ldi	r24, 0x01	; 1
    155a:	80 93 d2 01 	sts	0x01D2, r24
    155e:	0f c0       	rjmp	.+30     	; 0x157e <_Z8sendGAVRv+0x30e>
				} else if (flagUserTime&&flagUserDate){
    1560:	80 91 d7 01 	lds	r24, 0x01D7
    1564:	88 23       	and	r24, r24
    1566:	59 f0       	breq	.+22     	; 0x157e <_Z8sendGAVRv+0x30e>
    1568:	80 91 d6 01 	lds	r24, 0x01D6
    156c:	88 23       	and	r24, r24
    156e:	39 f0       	breq	.+14     	; 0x157e <_Z8sendGAVRv+0x30e>
					PrintGAVR("SYNGB.");
    1570:	81 e3       	ldi	r24, 0x31	; 49
    1572:	91 e0       	ldi	r25, 0x01	; 1
    1574:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
					flagWaitingForReceiveGAVR=fTrue;
    1578:	81 e0       	ldi	r24, 0x01	; 1
    157a:	80 93 d2 01 	sts	0x01D2, r24
				} else;
				
				//If we are updating the gavr, send the time and date together regardless. preface with SYN
				if (updatingGAVR && !(flagUserDate || flagUserTime)){
    157e:	80 91 d4 01 	lds	r24, 0x01D4
    1582:	88 23       	and	r24, r24
    1584:	29 f4       	brne	.+10     	; 0x1590 <_Z8sendGAVRv+0x320>
    1586:	80 91 d3 01 	lds	r24, 0x01D3
    158a:	88 23       	and	r24, r24
    158c:	09 f4       	brne	.+2      	; 0x1590 <_Z8sendGAVRv+0x320>
    158e:	5d c0       	rjmp	.+186    	; 0x164a <_Z8sendGAVRv+0x3da>
    1590:	80 91 d6 01 	lds	r24, 0x01D6
    1594:	88 23       	and	r24, r24
    1596:	09 f0       	breq	.+2      	; 0x159a <_Z8sendGAVRv+0x32a>
    1598:	58 c0       	rjmp	.+176    	; 0x164a <_Z8sendGAVRv+0x3da>
    159a:	80 91 d7 01 	lds	r24, 0x01D7
    159e:	88 23       	and	r24, r24
    15a0:	09 f0       	breq	.+2      	; 0x15a4 <_Z8sendGAVRv+0x334>
    15a2:	53 c0       	rjmp	.+166    	; 0x164a <_Z8sendGAVRv+0x3da>
					strcpy(sentString,"SYN");			//this is a syn, not ack to save logic in GAVR code. Can change if we want.
    15a4:	9e 01       	movw	r18, r28
    15a6:	25 5f       	subi	r18, 0xF5	; 245
    15a8:	3f 4f       	sbci	r19, 0xFF	; 255
    15aa:	83 e5       	ldi	r24, 0x53	; 83
    15ac:	99 e5       	ldi	r25, 0x59	; 89
    15ae:	ae e4       	ldi	r26, 0x4E	; 78
    15b0:	b0 e0       	ldi	r27, 0x00	; 0
    15b2:	f9 01       	movw	r30, r18
    15b4:	80 83       	st	Z, r24
    15b6:	91 83       	std	Z+1, r25	; 0x01
    15b8:	a2 83       	std	Z+2, r26	; 0x02
    15ba:	b3 83       	std	Z+3, r27	; 0x03
					strcat(sentString,currentTime.getTime());
    15bc:	86 ea       	ldi	r24, 0xA6	; 166
    15be:	91 e0       	ldi	r25, 0x01	; 1
    15c0:	0e 94 ff 06 	call	0xdfe	; 0xdfe <_ZN6myTime7getTimeEv>
    15c4:	9c 01       	movw	r18, r24
    15c6:	ce 01       	movw	r24, r28
    15c8:	0b 96       	adiw	r24, 0x0b	; 11
    15ca:	b9 01       	movw	r22, r18
    15cc:	0e 94 3b 1a 	call	0x3476	; 0x3476 <strcat>
					strcat(sentString,"/");	//add delimiter.
    15d0:	ce 01       	movw	r24, r28
    15d2:	0b 96       	adiw	r24, 0x0b	; 11
    15d4:	9c 01       	movw	r18, r24
    15d6:	f9 01       	movw	r30, r18
    15d8:	01 90       	ld	r0, Z+
    15da:	00 20       	and	r0, r0
    15dc:	e9 f7       	brne	.-6      	; 0x15d8 <_Z8sendGAVRv+0x368>
    15de:	cf 01       	movw	r24, r30
    15e0:	01 97       	sbiw	r24, 0x01	; 1
    15e2:	82 1b       	sub	r24, r18
    15e4:	93 0b       	sbc	r25, r19
    15e6:	9e 01       	movw	r18, r28
    15e8:	25 5f       	subi	r18, 0xF5	; 245
    15ea:	3f 4f       	sbci	r19, 0xFF	; 255
    15ec:	82 0f       	add	r24, r18
    15ee:	93 1f       	adc	r25, r19
    15f0:	2f e2       	ldi	r18, 0x2F	; 47
    15f2:	30 e0       	ldi	r19, 0x00	; 0
    15f4:	fc 01       	movw	r30, r24
    15f6:	31 83       	std	Z+1, r19	; 0x01
    15f8:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getDate());
    15fa:	86 ea       	ldi	r24, 0xA6	; 166
    15fc:	91 e0       	ldi	r25, 0x01	; 1
    15fe:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    1602:	9c 01       	movw	r18, r24
    1604:	ce 01       	movw	r24, r28
    1606:	0b 96       	adiw	r24, 0x0b	; 11
    1608:	b9 01       	movw	r22, r18
    160a:	0e 94 3b 1a 	call	0x3476	; 0x3476 <strcat>
					strcat(sentString,".\0");
    160e:	ce 01       	movw	r24, r28
    1610:	0b 96       	adiw	r24, 0x0b	; 11
    1612:	9c 01       	movw	r18, r24
    1614:	f9 01       	movw	r30, r18
    1616:	01 90       	ld	r0, Z+
    1618:	00 20       	and	r0, r0
    161a:	e9 f7       	brne	.-6      	; 0x1616 <_Z8sendGAVRv+0x3a6>
    161c:	cf 01       	movw	r24, r30
    161e:	01 97       	sbiw	r24, 0x01	; 1
    1620:	82 1b       	sub	r24, r18
    1622:	93 0b       	sbc	r25, r19
    1624:	9e 01       	movw	r18, r28
    1626:	25 5f       	subi	r18, 0xF5	; 245
    1628:	3f 4f       	sbci	r19, 0xFF	; 255
    162a:	82 0f       	add	r24, r18
    162c:	93 1f       	adc	r25, r19
    162e:	2e e2       	ldi	r18, 0x2E	; 46
    1630:	30 e0       	ldi	r19, 0x00	; 0
    1632:	fc 01       	movw	r30, r24
    1634:	31 83       	std	Z+1, r19	; 0x01
    1636:	20 83       	st	Z, r18
					PrintGAVR("SYN");
    1638:	88 e3       	ldi	r24, 0x38	; 56
    163a:	91 e0       	ldi	r25, 0x01	; 1
    163c:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
    1640:	80 e0       	ldi	r24, 0x00	; 0
    1642:	61 e0       	ldi	r22, 0x01	; 1
    1644:	41 e0       	ldi	r20, 0x01	; 1
    1646:	0e 94 bf 11 	call	0x237e	; 0x237e <_Z13printTimeDatehhh>
				}			
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){
    164a:	1f 82       	std	Y+7, r1	; 0x07
    164c:	1e 82       	std	Y+6, r1	; 0x06
    164e:	0e c0       	rjmp	.+28     	; 0x166c <_Z8sendGAVRv+0x3fc>
					recString[i]=NULL;
    1650:	9e 01       	movw	r18, r28
    1652:	2d 5c       	subi	r18, 0xCD	; 205
    1654:	3f 4f       	sbci	r19, 0xFF	; 255
    1656:	8e 81       	ldd	r24, Y+6	; 0x06
    1658:	9f 81       	ldd	r25, Y+7	; 0x07
    165a:	82 0f       	add	r24, r18
    165c:	93 1f       	adc	r25, r19
    165e:	fc 01       	movw	r30, r24
    1660:	10 82       	st	Z, r1
					strcat(sentString,".\0");
					PrintGAVR("SYN");
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
				}			
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){
    1662:	8e 81       	ldd	r24, Y+6	; 0x06
    1664:	9f 81       	ldd	r25, Y+7	; 0x07
    1666:	01 96       	adiw	r24, 0x01	; 1
    1668:	9f 83       	std	Y+7, r25	; 0x07
    166a:	8e 83       	std	Y+6, r24	; 0x06
    166c:	2e 81       	ldd	r18, Y+6	; 0x06
    166e:	3f 81       	ldd	r19, Y+7	; 0x07
    1670:	41 e0       	ldi	r20, 0x01	; 1
    1672:	89 81       	ldd	r24, Y+1	; 0x01
    1674:	9a 81       	ldd	r25, Y+2	; 0x02
    1676:	28 17       	cp	r18, r24
    1678:	39 07       	cpc	r19, r25
    167a:	08 f0       	brcs	.+2      	; 0x167e <_Z8sendGAVRv+0x40e>
    167c:	40 e0       	ldi	r20, 0x00	; 0
    167e:	44 23       	and	r20, r20
    1680:	39 f7       	brne	.-50     	; 0x1650 <_Z8sendGAVRv+0x3e0>
					recString[i]=NULL;
				}
				//Reset the carriage feature, string location and go back to the receiving state.
				noCarriage=fTrue;
    1682:	81 e0       	ldi	r24, 0x01	; 1
    1684:	8a 87       	std	Y+10, r24	; 0x0a
				strLoc=0;
    1686:	1a 82       	std	Y+2, r1	; 0x02
    1688:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    168a:	81 e0       	ldi	r24, 0x01	; 1
    168c:	90 e0       	ldi	r25, 0x00	; 0
    168e:	90 93 ee 01 	sts	0x01EE, r25
    1692:	80 93 ed 01 	sts	0x01ED, r24
				break;
    1696:	42 c0       	rjmp	.+132    	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 3
			case 4:{
				//Successful communication with just flags
				PrintGAVR("SYNDONE.");	//end the communication
    1698:	8c e3       	ldi	r24, 0x3C	; 60
    169a:	91 e0       	ldi	r25, 0x01	; 1
    169c:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
				state=5;
    16a0:	85 e0       	ldi	r24, 0x05	; 5
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	90 93 ee 01 	sts	0x01EE, r25
    16a8:	80 93 ed 01 	sts	0x01ED, r24
				break;				
    16ac:	37 c0       	rjmp	.+110    	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 4	
			case 5:{
				//Successful communications overall
				flagSendingGAVR=fFalse;
    16ae:	10 92 d5 01 	sts	0x01D5, r1
				flagWaitingToSendGAVR=fFalse;
    16b2:	10 92 d9 01 	sts	0x01D9, r1
				flagTimeout=fFalse;
    16b6:	1b 82       	std	Y+3, r1	; 0x03
				state=0;
    16b8:	10 92 ee 01 	sts	0x01EE, r1
    16bc:	10 92 ed 01 	sts	0x01ED, r1
				break;
    16c0:	2d c0       	rjmp	.+90     	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
    16c2:	86 ea       	ldi	r24, 0xA6	; 166
    16c4:	91 e0       	ldi	r25, 0x01	; 1
    16c6:	0e 94 c1 06 	call	0xd82	; 0xd82 <_ZN6myTime13checkValidityEv>
    16ca:	89 87       	std	Y+9, r24	; 0x09
				if (dateOK){state=7;}
    16cc:	89 85       	ldd	r24, Y+9	; 0x09
    16ce:	88 23       	and	r24, r24
    16d0:	39 f0       	breq	.+14     	; 0x16e0 <_Z8sendGAVRv+0x470>
    16d2:	87 e0       	ldi	r24, 0x07	; 7
    16d4:	90 e0       	ldi	r25, 0x00	; 0
    16d6:	90 93 ee 01 	sts	0x01EE, r25
    16da:	80 93 ed 01 	sts	0x01ED, r24
				else {state=5; flagInvalidDateTime=fTrue;}
				break;
    16de:	1e c0       	rjmp	.+60     	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
				if (dateOK){state=7;}
				else {state=5; flagInvalidDateTime=fTrue;}
    16e0:	85 e0       	ldi	r24, 0x05	; 5
    16e2:	90 e0       	ldi	r25, 0x00	; 0
    16e4:	90 93 ee 01 	sts	0x01EE, r25
    16e8:	80 93 ed 01 	sts	0x01ED, r24
    16ec:	81 e0       	ldi	r24, 0x01	; 1
    16ee:	80 93 d8 01 	sts	0x01D8, r24
				break;
    16f2:	14 c0       	rjmp	.+40     	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 6
			case 7:{
				//Got the wrong ACK back, or invalid ACK. Wait for next cycle then resend. Keep all the flags the same
				flagWaitingToSendGAVR=fTrue;
    16f4:	81 e0       	ldi	r24, 0x01	; 1
    16f6:	80 93 d9 01 	sts	0x01D9, r24
				flagSendingGAVR=fFalse;
    16fa:	10 92 d5 01 	sts	0x01D5, r1
				flagTimeout=fFalse;
    16fe:	1b 82       	std	Y+3, r1	; 0x03
				state=0;
    1700:	10 92 ee 01 	sts	0x01EE, r1
    1704:	10 92 ed 01 	sts	0x01ED, r1
				break;
    1708:	09 c0       	rjmp	.+18     	; 0x171c <_Z8sendGAVRv+0x4ac>
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; flagTimeout=fFalse;break;}
    170a:	10 92 ee 01 	sts	0x01EE, r1
    170e:	10 92 ed 01 	sts	0x01ED, r1
    1712:	10 92 d5 01 	sts	0x01D5, r1
    1716:	1a 86       	std	Y+10, r1	; 0x0a
    1718:	1b 82       	std	Y+3, r1	; 0x03
    171a:	00 00       	nop
	
	//Used for shutdown connection logic if there was a timeout in sending or receiving
	BOOL flagTimeout=fFalse;
	
	//Transmission protocol
	while (flagSendingGAVR && !flagTimeout){
    171c:	80 91 d5 01 	lds	r24, 0x01D5
    1720:	88 23       	and	r24, r24
    1722:	29 f0       	breq	.+10     	; 0x172e <_Z8sendGAVRv+0x4be>
    1724:	8b 81       	ldd	r24, Y+3	; 0x03
    1726:	88 23       	and	r24, r24
    1728:	11 f4       	brne	.+4      	; 0x172e <_Z8sendGAVRv+0x4be>
    172a:	81 e0       	ldi	r24, 0x01	; 1
    172c:	01 c0       	rjmp	.+2      	; 0x1730 <_Z8sendGAVRv+0x4c0>
    172e:	80 e0       	ldi	r24, 0x00	; 0
    1730:	88 23       	and	r24, r24
    1732:	09 f0       	breq	.+2      	; 0x1736 <_Z8sendGAVRv+0x4c6>
    1734:	ae cd       	rjmp	.-1188   	; 0x1292 <_Z8sendGAVRv+0x22>
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; flagTimeout=fFalse;break;}
		}//end switch
	}//end while
	
	//If there was a timeout and the wiating flag has not been set yet, make sure waiting flag.
	if (noCarriage || flagTimeout){
    1736:	8a 85       	ldd	r24, Y+10	; 0x0a
    1738:	88 23       	and	r24, r24
    173a:	19 f4       	brne	.+6      	; 0x1742 <_Z8sendGAVRv+0x4d2>
    173c:	8b 81       	ldd	r24, Y+3	; 0x03
    173e:	88 23       	and	r24, r24
    1740:	11 f0       	breq	.+4      	; 0x1746 <_Z8sendGAVRv+0x4d6>
    1742:	81 e0       	ldi	r24, 0x01	; 1
    1744:	01 c0       	rjmp	.+2      	; 0x1748 <_Z8sendGAVRv+0x4d8>
    1746:	80 e0       	ldi	r24, 0x00	; 0
    1748:	88 23       	and	r24, r24
    174a:	19 f0       	breq	.+6      	; 0x1752 <_Z8sendGAVRv+0x4e2>
		flagWaitingToSendGAVR=fTrue;
    174c:	81 e0       	ldi	r24, 0x01	; 1
    174e:	80 93 d9 01 	sts	0x01D9, r24
	}
	
	//If we aren't waiting for the next round, don't reset the flags. If we are waiting, just reset the waiting flag. Like a stack popping
	if (!flagWaitingToSendGAVR){
    1752:	80 91 d9 01 	lds	r24, 0x01D9
    1756:	88 23       	and	r24, r24
    1758:	49 f4       	brne	.+18     	; 0x176c <_Z8sendGAVRv+0x4fc>
		flagUserDate=fFalse;
    175a:	10 92 d6 01 	sts	0x01D6, r1
		flagUserTime=fFalse;
    175e:	10 92 d7 01 	sts	0x01D7, r1
		flagUpdateGAVRDate=fFalse;
    1762:	10 92 d4 01 	sts	0x01D4, r1
		flagUpdateGAVRTime=fFalse;		
    1766:	10 92 d3 01 	sts	0x01D3, r1
    176a:	02 c0       	rjmp	.+4      	; 0x1770 <_Z8sendGAVRv+0x500>
	} else {flagWaitingToSendGAVR=fFalse;}
    176c:	10 92 d9 01 	sts	0x01D9, r1
}//end function 	
    1770:	c6 5a       	subi	r28, 0xA6	; 166
    1772:	df 4f       	sbci	r29, 0xFF	; 255
    1774:	0f b6       	in	r0, 0x3f	; 63
    1776:	f8 94       	cli
    1778:	de bf       	out	0x3e, r29	; 62
    177a:	0f be       	out	0x3f, r0	; 63
    177c:	cd bf       	out	0x3d, r28	; 61
    177e:	df 91       	pop	r29
    1780:	cf 91       	pop	r28
    1782:	08 95       	ret

00001784 <_Z11ReceiveBonev>:
	
/*************************************************************************************************************/
void ReceiveBone(){
    1784:	cf 93       	push	r28
    1786:	df 93       	push	r29
    1788:	cd b7       	in	r28, 0x3d	; 61
    178a:	de b7       	in	r29, 0x3e	; 62
    178c:	a7 97       	sbiw	r28, 0x27	; 39
    178e:	0f b6       	in	r0, 0x3f	; 63
    1790:	f8 94       	cli
    1792:	de bf       	out	0x3e, r29	; 62
    1794:	0f be       	out	0x3f, r0	; 63
    1796:	cd bf       	out	0x3d, r28	; 61
	volatile static unsigned int state=0;
	char recChar, recString[20];
	volatile unsigned int strLoc=0;
    1798:	19 8e       	std	Y+25, r1	; 0x19
    179a:	18 8e       	std	Y+24, r1	; 0x18
	BOOL noCarriage=fTrue;
    179c:	81 e0       	ldi	r24, 0x01	; 1
    179e:	89 83       	std	Y+1, r24	; 0x01
	
	while (flagReceivingBone){
    17a0:	1b c2       	rjmp	.+1078   	; 0x1bd8 <_Z11ReceiveBonev+0x454>
			/* State 4: ACKBAD, string it sent was not valid. Reply and exit loop.															*/
			/* State 5: ACKERROR, invalid string or overflow. Say error then exit.															*/
			/* State 6: Graceful exit. Exit from a command like adc or temp.																*/
			/********************************************************************************************************************************/
			
			switch(state){
    17a2:	80 91 eb 01 	lds	r24, 0x01EB
    17a6:	90 91 ec 01 	lds	r25, 0x01EC
    17aa:	83 30       	cpi	r24, 0x03	; 3
    17ac:	91 05       	cpc	r25, r1
    17ae:	09 f4       	brne	.+2      	; 0x17b2 <_Z11ReceiveBonev+0x2e>
    17b0:	df c1       	rjmp	.+958    	; 0x1b70 <_Z11ReceiveBonev+0x3ec>
    17b2:	84 30       	cpi	r24, 0x04	; 4
    17b4:	91 05       	cpc	r25, r1
    17b6:	48 f4       	brcc	.+18     	; 0x17ca <_Z11ReceiveBonev+0x46>
    17b8:	81 30       	cpi	r24, 0x01	; 1
    17ba:	91 05       	cpc	r25, r1
    17bc:	09 f4       	brne	.+2      	; 0x17c0 <_Z11ReceiveBonev+0x3c>
    17be:	87 c0       	rjmp	.+270    	; 0x18ce <_Z11ReceiveBonev+0x14a>
    17c0:	82 30       	cpi	r24, 0x02	; 2
    17c2:	91 05       	cpc	r25, r1
    17c4:	08 f0       	brcs	.+2      	; 0x17c8 <_Z11ReceiveBonev+0x44>
    17c6:	91 c0       	rjmp	.+290    	; 0x18ea <_Z11ReceiveBonev+0x166>
    17c8:	0d c0       	rjmp	.+26     	; 0x17e4 <_Z11ReceiveBonev+0x60>
    17ca:	85 30       	cpi	r24, 0x05	; 5
    17cc:	91 05       	cpc	r25, r1
    17ce:	09 f4       	brne	.+2      	; 0x17d2 <_Z11ReceiveBonev+0x4e>
    17d0:	e9 c1       	rjmp	.+978    	; 0x1ba4 <_Z11ReceiveBonev+0x420>
    17d2:	85 30       	cpi	r24, 0x05	; 5
    17d4:	91 05       	cpc	r25, r1
    17d6:	08 f4       	brcc	.+2      	; 0x17da <_Z11ReceiveBonev+0x56>
    17d8:	da c1       	rjmp	.+948    	; 0x1b8e <_Z11ReceiveBonev+0x40a>
    17da:	86 30       	cpi	r24, 0x06	; 6
    17dc:	91 05       	cpc	r25, r1
    17de:	09 f4       	brne	.+2      	; 0x17e2 <_Z11ReceiveBonev+0x5e>
    17e0:	ec c1       	rjmp	.+984    	; 0x1bba <_Z11ReceiveBonev+0x436>
    17e2:	f2 c1       	rjmp	.+996    	; 0x1bc8 <_Z11ReceiveBonev+0x444>
				case 0:{
					strLoc=0;
    17e4:	19 8e       	std	Y+25, r1	; 0x19
    17e6:	18 8e       	std	Y+24, r1	; 0x18
					recChar = UDR0;
    17e8:	86 ec       	ldi	r24, 0xC6	; 198
    17ea:	90 e0       	ldi	r25, 0x00	; 0
    17ec:	fc 01       	movw	r30, r24
    17ee:	80 81       	ld	r24, Z
    17f0:	8a 83       	std	Y+2, r24	; 0x02
					if (recChar=='.'){
    17f2:	8a 81       	ldd	r24, Y+2	; 0x02
    17f4:	8e 32       	cpi	r24, 0x2E	; 46
    17f6:	39 f4       	brne	.+14     	; 0x1806 <_Z11ReceiveBonev+0x82>
						state=5;
    17f8:	85 e0       	ldi	r24, 0x05	; 5
    17fa:	90 e0       	ldi	r25, 0x00	; 0
    17fc:	90 93 ec 01 	sts	0x01EC, r25
    1800:	80 93 eb 01 	sts	0x01EB, r24
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
    1804:	e9 c1       	rjmp	.+978    	; 0x1bd8 <_Z11ReceiveBonev+0x454>
				case 0:{
					strLoc=0;
					recChar = UDR0;
					if (recChar=='.'){
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
    1806:	88 8d       	ldd	r24, Y+24	; 0x18
    1808:	99 8d       	ldd	r25, Y+25	; 0x19
    180a:	9e 01       	movw	r18, r28
    180c:	2c 5f       	subi	r18, 0xFC	; 252
    180e:	3f 4f       	sbci	r19, 0xFF	; 255
    1810:	28 0f       	add	r18, r24
    1812:	39 1f       	adc	r19, r25
    1814:	4a 81       	ldd	r20, Y+2	; 0x02
    1816:	f9 01       	movw	r30, r18
    1818:	40 83       	st	Z, r20
    181a:	01 96       	adiw	r24, 0x01	; 1
    181c:	99 8f       	std	Y+25, r25	; 0x19
    181e:	88 8f       	std	Y+24, r24	; 0x18
    1820:	81 e0       	ldi	r24, 0x01	; 1
    1822:	90 e0       	ldi	r25, 0x00	; 0
    1824:	90 93 ec 01 	sts	0x01EC, r25
    1828:	80 93 eb 01 	sts	0x01EB, r24
					break;				
    182c:	d5 c1       	rjmp	.+938    	; 0x1bd8 <_Z11ReceiveBonev+0x454>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while (!(UCSR0A & (1 << RXC0)) && flagReceivingBone);		//get the next character
    182e:	00 00       	nop
    1830:	80 ec       	ldi	r24, 0xC0	; 192
    1832:	90 e0       	ldi	r25, 0x00	; 0
    1834:	fc 01       	movw	r30, r24
    1836:	80 81       	ld	r24, Z
    1838:	88 23       	and	r24, r24
    183a:	34 f0       	brlt	.+12     	; 0x1848 <_Z11ReceiveBonev+0xc4>
    183c:	80 91 cf 01 	lds	r24, 0x01CF
    1840:	88 23       	and	r24, r24
    1842:	11 f0       	breq	.+4      	; 0x1848 <_Z11ReceiveBonev+0xc4>
    1844:	81 e0       	ldi	r24, 0x01	; 1
    1846:	01 c0       	rjmp	.+2      	; 0x184a <_Z11ReceiveBonev+0xc6>
    1848:	80 e0       	ldi	r24, 0x00	; 0
    184a:	88 23       	and	r24, r24
    184c:	89 f7       	brne	.-30     	; 0x1830 <_Z11ReceiveBonev+0xac>
						if (!flagReceivingBone){state=0; break;}					//if there was a timeout, break out and reset state
    184e:	80 91 cf 01 	lds	r24, 0x01CF
    1852:	88 23       	and	r24, r24
    1854:	31 f4       	brne	.+12     	; 0x1862 <_Z11ReceiveBonev+0xde>
    1856:	10 92 ec 01 	sts	0x01EC, r1
    185a:	10 92 eb 01 	sts	0x01EB, r1
    185e:	00 00       	nop
						else{
							//recString[strLoc++]=recChar;
							if (strLoc >= 19){state=5;noCarriage=fFalse;}
						}//end if-else
					}//end while
					break;
    1860:	bb c1       	rjmp	.+886    	; 0x1bd8 <_Z11ReceiveBonev+0x454>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while (!(UCSR0A & (1 << RXC0)) && flagReceivingBone);		//get the next character
						if (!flagReceivingBone){state=0; break;}					//if there was a timeout, break out and reset state
						recChar=UDR0;
    1862:	86 ec       	ldi	r24, 0xC6	; 198
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	fc 01       	movw	r30, r24
    1868:	80 81       	ld	r24, Z
    186a:	8a 83       	std	Y+2, r24	; 0x02
						recString[strLoc++]=recChar;
    186c:	88 8d       	ldd	r24, Y+24	; 0x18
    186e:	99 8d       	ldd	r25, Y+25	; 0x19
    1870:	9e 01       	movw	r18, r28
    1872:	2c 5f       	subi	r18, 0xFC	; 252
    1874:	3f 4f       	sbci	r19, 0xFF	; 255
    1876:	28 0f       	add	r18, r24
    1878:	39 1f       	adc	r19, r25
    187a:	4a 81       	ldd	r20, Y+2	; 0x02
    187c:	f9 01       	movw	r30, r18
    187e:	40 83       	st	Z, r20
    1880:	01 96       	adiw	r24, 0x01	; 1
    1882:	99 8f       	std	Y+25, r25	; 0x19
    1884:	88 8f       	std	Y+24, r24	; 0x18
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1886:	8a 81       	ldd	r24, Y+2	; 0x02
    1888:	8e 32       	cpi	r24, 0x2E	; 46
    188a:	89 f4       	brne	.+34     	; 0x18ae <_Z11ReceiveBonev+0x12a>
    188c:	88 8d       	ldd	r24, Y+24	; 0x18
    188e:	99 8d       	ldd	r25, Y+25	; 0x19
    1890:	9e 01       	movw	r18, r28
    1892:	2c 5f       	subi	r18, 0xFC	; 252
    1894:	3f 4f       	sbci	r19, 0xFF	; 255
    1896:	82 0f       	add	r24, r18
    1898:	93 1f       	adc	r25, r19
    189a:	fc 01       	movw	r30, r24
    189c:	10 82       	st	Z, r1
    189e:	19 82       	std	Y+1, r1	; 0x01
    18a0:	82 e0       	ldi	r24, 0x02	; 2
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	90 93 ec 01 	sts	0x01EC, r25
    18a8:	80 93 eb 01 	sts	0x01EB, r24
    18ac:	10 c0       	rjmp	.+32     	; 0x18ce <_Z11ReceiveBonev+0x14a>
						else{
							//recString[strLoc++]=recChar;
							if (strLoc >= 19){state=5;noCarriage=fFalse;}
    18ae:	88 8d       	ldd	r24, Y+24	; 0x18
    18b0:	99 8d       	ldd	r25, Y+25	; 0x19
    18b2:	21 e0       	ldi	r18, 0x01	; 1
    18b4:	83 31       	cpi	r24, 0x13	; 19
    18b6:	91 05       	cpc	r25, r1
    18b8:	08 f4       	brcc	.+2      	; 0x18bc <_Z11ReceiveBonev+0x138>
    18ba:	20 e0       	ldi	r18, 0x00	; 0
    18bc:	22 23       	and	r18, r18
    18be:	39 f0       	breq	.+14     	; 0x18ce <_Z11ReceiveBonev+0x14a>
    18c0:	85 e0       	ldi	r24, 0x05	; 5
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	90 93 ec 01 	sts	0x01EC, r25
    18c8:	80 93 eb 01 	sts	0x01EB, r24
    18cc:	19 82       	std	Y+1, r1	; 0x01
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    18ce:	89 81       	ldd	r24, Y+1	; 0x01
    18d0:	88 23       	and	r24, r24
    18d2:	31 f0       	breq	.+12     	; 0x18e0 <_Z11ReceiveBonev+0x15c>
    18d4:	80 91 cf 01 	lds	r24, 0x01CF
    18d8:	88 23       	and	r24, r24
    18da:	11 f0       	breq	.+4      	; 0x18e0 <_Z11ReceiveBonev+0x15c>
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	01 c0       	rjmp	.+2      	; 0x18e2 <_Z11ReceiveBonev+0x15e>
    18e0:	80 e0       	ldi	r24, 0x00	; 0
    18e2:	88 23       	and	r24, r24
    18e4:	09 f0       	breq	.+2      	; 0x18e8 <_Z11ReceiveBonev+0x164>
    18e6:	a3 cf       	rjmp	.-186    	; 0x182e <_Z11ReceiveBonev+0xaa>
						else{
							//recString[strLoc++]=recChar;
							if (strLoc >= 19){state=5;noCarriage=fFalse;}
						}//end if-else
					}//end while
					break;
    18e8:	77 c1       	rjmp	.+750    	; 0x1bd8 <_Z11ReceiveBonev+0x454>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
    18ea:	ce 01       	movw	r24, r28
    18ec:	04 96       	adiw	r24, 0x04	; 4
    18ee:	25 e4       	ldi	r18, 0x45	; 69
    18f0:	31 e0       	ldi	r19, 0x01	; 1
    18f2:	b9 01       	movw	r22, r18
    18f4:	45 e0       	ldi	r20, 0x05	; 5
    18f6:	50 e0       	ldi	r21, 0x00	; 0
    18f8:	0e 94 56 1a 	call	0x34ac	; 0x34ac <strncmp>
    18fc:	00 97       	sbiw	r24, 0x00	; 0
    18fe:	61 f4       	brne	.+24     	; 0x1918 <_Z11ReceiveBonev+0x194>
    1900:	81 e0       	ldi	r24, 0x01	; 1
    1902:	60 e0       	ldi	r22, 0x00	; 0
    1904:	41 e0       	ldi	r20, 0x01	; 1
    1906:	0e 94 bf 11 	call	0x237e	; 0x237e <_Z13printTimeDatehhh>
    190a:	86 e0       	ldi	r24, 0x06	; 6
    190c:	90 e0       	ldi	r25, 0x00	; 0
    190e:	90 93 ec 01 	sts	0x01EC, r25
    1912:	80 93 eb 01 	sts	0x01EB, r24
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
					break;
    1916:	5f c1       	rjmp	.+702    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
					}//end while
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
    1918:	ce 01       	movw	r24, r28
    191a:	04 96       	adiw	r24, 0x04	; 4
    191c:	2b e4       	ldi	r18, 0x4B	; 75
    191e:	31 e0       	ldi	r19, 0x01	; 1
    1920:	b9 01       	movw	r22, r18
    1922:	45 e0       	ldi	r20, 0x05	; 5
    1924:	50 e0       	ldi	r21, 0x00	; 0
    1926:	0e 94 56 1a 	call	0x34ac	; 0x34ac <strncmp>
    192a:	00 97       	sbiw	r24, 0x00	; 0
    192c:	61 f4       	brne	.+24     	; 0x1946 <_Z11ReceiveBonev+0x1c2>
    192e:	81 e0       	ldi	r24, 0x01	; 1
    1930:	61 e0       	ldi	r22, 0x01	; 1
    1932:	40 e0       	ldi	r20, 0x00	; 0
    1934:	0e 94 bf 11 	call	0x237e	; 0x237e <_Z13printTimeDatehhh>
    1938:	86 e0       	ldi	r24, 0x06	; 6
    193a:	90 e0       	ldi	r25, 0x00	; 0
    193c:	90 93 ec 01 	sts	0x01EC, r25
    1940:	80 93 eb 01 	sts	0x01EB, r24
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
					break;
    1944:	48 c1       	rjmp	.+656    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
    1946:	ce 01       	movw	r24, r28
    1948:	04 96       	adiw	r24, 0x04	; 4
    194a:	21 e5       	ldi	r18, 0x51	; 81
    194c:	31 e0       	ldi	r19, 0x01	; 1
    194e:	b9 01       	movw	r22, r18
    1950:	45 e0       	ldi	r20, 0x05	; 5
    1952:	50 e0       	ldi	r21, 0x00	; 0
    1954:	0e 94 56 1a 	call	0x34ac	; 0x34ac <strncmp>
    1958:	00 97       	sbiw	r24, 0x00	; 0
    195a:	61 f4       	brne	.+24     	; 0x1974 <_Z11ReceiveBonev+0x1f0>
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	61 e0       	ldi	r22, 0x01	; 1
    1960:	41 e0       	ldi	r20, 0x01	; 1
    1962:	0e 94 bf 11 	call	0x237e	; 0x237e <_Z13printTimeDatehhh>
    1966:	86 e0       	ldi	r24, 0x06	; 6
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	90 93 ec 01 	sts	0x01EC, r25
    196e:	80 93 eb 01 	sts	0x01EB, r24
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
					break;
    1972:	31 c1       	rjmp	.+610    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
    1974:	ce 01       	movw	r24, r28
    1976:	04 96       	adiw	r24, 0x04	; 4
    1978:	27 e5       	ldi	r18, 0x57	; 87
    197a:	31 e0       	ldi	r19, 0x01	; 1
    197c:	b9 01       	movw	r22, r18
    197e:	45 e0       	ldi	r20, 0x05	; 5
    1980:	50 e0       	ldi	r21, 0x00	; 0
    1982:	0e 94 56 1a 	call	0x34ac	; 0x34ac <strncmp>
    1986:	00 97       	sbiw	r24, 0x00	; 0
    1988:	79 f4       	brne	.+30     	; 0x19a8 <_Z11ReceiveBonev+0x224>
    198a:	81 e0       	ldi	r24, 0x01	; 1
    198c:	60 e0       	ldi	r22, 0x00	; 0
    198e:	0e 94 46 08 	call	0x108c	; 0x108c <_Z19saveDateTime_eepromhh>
    1992:	ce 01       	movw	r24, r28
    1994:	04 96       	adiw	r24, 0x04	; 4
    1996:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
    199a:	86 e0       	ldi	r24, 0x06	; 6
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	90 93 ec 01 	sts	0x01EC, r25
    19a2:	80 93 eb 01 	sts	0x01EB, r24
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
					break;
    19a6:	17 c1       	rjmp	.+558    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    19a8:	ce 01       	movw	r24, r28
    19aa:	04 96       	adiw	r24, 0x04	; 4
    19ac:	2d e5       	ldi	r18, 0x5D	; 93
    19ae:	31 e0       	ldi	r19, 0x01	; 1
    19b0:	b9 01       	movw	r22, r18
    19b2:	44 e0       	ldi	r20, 0x04	; 4
    19b4:	50 e0       	ldi	r21, 0x00	; 0
    19b6:	0e 94 56 1a 	call	0x34ac	; 0x34ac <strncmp>
    19ba:	00 97       	sbiw	r24, 0x00	; 0
    19bc:	c1 f4       	brne	.+48     	; 0x19ee <_Z11ReceiveBonev+0x26a>
    19be:	80 91 a2 01 	lds	r24, 0x01A2
    19c2:	90 91 a3 01 	lds	r25, 0x01A3
    19c6:	9e 01       	movw	r18, r28
    19c8:	26 5e       	subi	r18, 0xE6	; 230
    19ca:	3f 4f       	sbci	r19, 0xFF	; 255
    19cc:	b9 01       	movw	r22, r18
    19ce:	4a e0       	ldi	r20, 0x0A	; 10
    19d0:	50 e0       	ldi	r21, 0x00	; 0
    19d2:	0e 94 8d 1a 	call	0x351a	; 0x351a <utoa>
    19d6:	18 a2       	lds	r17, 0x98
    19d8:	ce 01       	movw	r24, r28
    19da:	4a 96       	adiw	r24, 0x1a	; 26
    19dc:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
    19e0:	86 e0       	ldi	r24, 0x06	; 6
    19e2:	90 e0       	ldi	r25, 0x00	; 0
    19e4:	90 93 ec 01 	sts	0x01EC, r25
    19e8:	80 93 eb 01 	sts	0x01EB, r24
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
					break;
    19ec:	f4 c0       	rjmp	.+488    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    19ee:	ce 01       	movw	r24, r28
    19f0:	04 96       	adiw	r24, 0x04	; 4
    19f2:	22 e6       	ldi	r18, 0x62	; 98
    19f4:	31 e0       	ldi	r19, 0x01	; 1
    19f6:	b9 01       	movw	r22, r18
    19f8:	45 e0       	ldi	r20, 0x05	; 5
    19fa:	50 e0       	ldi	r21, 0x00	; 0
    19fc:	0e 94 56 1a 	call	0x34ac	; 0x34ac <strncmp>
    1a00:	00 97       	sbiw	r24, 0x00	; 0
    1a02:	c1 f4       	brne	.+48     	; 0x1a34 <_Z11ReceiveBonev+0x2b0>
    1a04:	80 91 a4 01 	lds	r24, 0x01A4
    1a08:	90 91 a5 01 	lds	r25, 0x01A5
    1a0c:	9e 01       	movw	r18, r28
    1a0e:	2f 5d       	subi	r18, 0xDF	; 223
    1a10:	3f 4f       	sbci	r19, 0xFF	; 255
    1a12:	b9 01       	movw	r22, r18
    1a14:	4a e0       	ldi	r20, 0x0A	; 10
    1a16:	50 e0       	ldi	r21, 0x00	; 0
    1a18:	0e 94 8d 1a 	call	0x351a	; 0x351a <utoa>
    1a1c:	1f a2       	lds	r17, 0x9f
    1a1e:	ce 01       	movw	r24, r28
    1a20:	81 96       	adiw	r24, 0x21	; 33
    1a22:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
    1a26:	86 e0       	ldi	r24, 0x06	; 6
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	90 93 ec 01 	sts	0x01EC, r25
    1a2e:	80 93 eb 01 	sts	0x01EB, r24
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
					break;
    1a32:	d1 c0       	rjmp	.+418    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (recString[2] == ':'){//valid string. Update the time anyways. Comes in every 20 minutes or so...
    1a34:	8e 81       	ldd	r24, Y+6	; 0x06
    1a36:	8a 33       	cpi	r24, 0x3A	; 58
    1a38:	09 f0       	breq	.+2      	; 0x1a3c <_Z11ReceiveBonev+0x2b8>
    1a3a:	81 c0       	rjmp	.+258    	; 0x1b3e <_Z11ReceiveBonev+0x3ba>
						BOOL success=currentTime.setTime(recString);
    1a3c:	86 ea       	ldi	r24, 0xA6	; 166
    1a3e:	91 e0       	ldi	r25, 0x01	; 1
    1a40:	9e 01       	movw	r18, r28
    1a42:	2c 5f       	subi	r18, 0xFC	; 252
    1a44:	3f 4f       	sbci	r19, 0xFF	; 255
    1a46:	b9 01       	movw	r22, r18
    1a48:	0e 94 cc 04 	call	0x998	; 0x998 <_ZN6myTime7setTimeEPc>
    1a4c:	8b 83       	std	Y+3, r24	; 0x03
						if (success){state=3;}
    1a4e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a50:	88 23       	and	r24, r24
    1a52:	39 f0       	breq	.+14     	; 0x1a62 <_Z11ReceiveBonev+0x2de>
    1a54:	83 e0       	ldi	r24, 0x03	; 3
    1a56:	90 e0       	ldi	r25, 0x00	; 0
    1a58:	90 93 ec 01 	sts	0x01EC, r25
    1a5c:	80 93 eb 01 	sts	0x01EB, r24
    1a60:	06 c0       	rjmp	.+12     	; 0x1a6e <_Z11ReceiveBonev+0x2ea>
						else {state=4;}
    1a62:	84 e0       	ldi	r24, 0x04	; 4
    1a64:	90 e0       	ldi	r25, 0x00	; 0
    1a66:	90 93 ec 01 	sts	0x01EC, r25
    1a6a:	80 93 eb 01 	sts	0x01EB, r24
						
						//Decide what I need to save and which flags need to go up.	
						if (success && !restart && !flagFreshStart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRTime=fTrue;}
    1a6e:	8b 81       	ldd	r24, Y+3	; 0x03
    1a70:	88 23       	and	r24, r24
    1a72:	81 f0       	breq	.+32     	; 0x1a94 <_Z11ReceiveBonev+0x310>
    1a74:	80 91 df 01 	lds	r24, 0x01DF
    1a78:	88 23       	and	r24, r24
    1a7a:	61 f4       	brne	.+24     	; 0x1a94 <_Z11ReceiveBonev+0x310>
    1a7c:	80 91 e0 01 	lds	r24, 0x01E0
    1a80:	88 23       	and	r24, r24
    1a82:	41 f4       	brne	.+16     	; 0x1a94 <_Z11ReceiveBonev+0x310>
    1a84:	81 e0       	ldi	r24, 0x01	; 1
    1a86:	60 e0       	ldi	r22, 0x00	; 0
    1a88:	0e 94 46 08 	call	0x108c	; 0x108c <_Z19saveDateTime_eepromhh>
    1a8c:	81 e0       	ldi	r24, 0x01	; 1
    1a8e:	80 93 d3 01 	sts	0x01D3, r24
    1a92:	47 c0       	rjmp	.+142    	; 0x1b22 <_Z11ReceiveBonev+0x39e>
						else if (success && !restart && flagFreshStart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRTime=fTrue; flagUserDate=fTrue;}
    1a94:	8b 81       	ldd	r24, Y+3	; 0x03
    1a96:	88 23       	and	r24, r24
    1a98:	99 f0       	breq	.+38     	; 0x1ac0 <_Z11ReceiveBonev+0x33c>
    1a9a:	80 91 df 01 	lds	r24, 0x01DF
    1a9e:	88 23       	and	r24, r24
    1aa0:	79 f4       	brne	.+30     	; 0x1ac0 <_Z11ReceiveBonev+0x33c>
    1aa2:	80 91 e0 01 	lds	r24, 0x01E0
    1aa6:	88 23       	and	r24, r24
    1aa8:	59 f0       	breq	.+22     	; 0x1ac0 <_Z11ReceiveBonev+0x33c>
    1aaa:	81 e0       	ldi	r24, 0x01	; 1
    1aac:	60 e0       	ldi	r22, 0x00	; 0
    1aae:	0e 94 46 08 	call	0x108c	; 0x108c <_Z19saveDateTime_eepromhh>
    1ab2:	81 e0       	ldi	r24, 0x01	; 1
    1ab4:	80 93 d3 01 	sts	0x01D3, r24
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	80 93 d6 01 	sts	0x01D6, r24
    1abe:	31 c0       	rjmp	.+98     	; 0x1b22 <_Z11ReceiveBonev+0x39e>
						else if (success && restart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRDate=fTrue; flagUpdateGAVRTime=fTrue;;}
    1ac0:	8b 81       	ldd	r24, Y+3	; 0x03
    1ac2:	88 23       	and	r24, r24
    1ac4:	79 f0       	breq	.+30     	; 0x1ae4 <_Z11ReceiveBonev+0x360>
    1ac6:	80 91 df 01 	lds	r24, 0x01DF
    1aca:	88 23       	and	r24, r24
    1acc:	59 f0       	breq	.+22     	; 0x1ae4 <_Z11ReceiveBonev+0x360>
    1ace:	81 e0       	ldi	r24, 0x01	; 1
    1ad0:	60 e0       	ldi	r22, 0x00	; 0
    1ad2:	0e 94 46 08 	call	0x108c	; 0x108c <_Z19saveDateTime_eepromhh>
    1ad6:	81 e0       	ldi	r24, 0x01	; 1
    1ad8:	80 93 d4 01 	sts	0x01D4, r24
    1adc:	81 e0       	ldi	r24, 0x01	; 1
    1ade:	80 93 d3 01 	sts	0x01D3, r24
    1ae2:	1f c0       	rjmp	.+62     	; 0x1b22 <_Z11ReceiveBonev+0x39e>
						else if (!success && restart){flagUpdateGAVRTime=fTrue; flagUpdateGAVRDate=fTrue;}	//sends eeprom time and date
    1ae4:	8b 81       	ldd	r24, Y+3	; 0x03
    1ae6:	88 23       	and	r24, r24
    1ae8:	59 f4       	brne	.+22     	; 0x1b00 <_Z11ReceiveBonev+0x37c>
    1aea:	80 91 df 01 	lds	r24, 0x01DF
    1aee:	88 23       	and	r24, r24
    1af0:	39 f0       	breq	.+14     	; 0x1b00 <_Z11ReceiveBonev+0x37c>
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	80 93 d3 01 	sts	0x01D3, r24
    1af8:	81 e0       	ldi	r24, 0x01	; 1
    1afa:	80 93 d4 01 	sts	0x01D4, r24
    1afe:	11 c0       	rjmp	.+34     	; 0x1b22 <_Z11ReceiveBonev+0x39e>
						else if (!success && flagFreshStart && !restart){flagUserTime=fTrue; flagUserDate=fTrue;} //need to get user time and date
    1b00:	8b 81       	ldd	r24, Y+3	; 0x03
    1b02:	88 23       	and	r24, r24
    1b04:	71 f4       	brne	.+28     	; 0x1b22 <_Z11ReceiveBonev+0x39e>
    1b06:	80 91 e0 01 	lds	r24, 0x01E0
    1b0a:	88 23       	and	r24, r24
    1b0c:	51 f0       	breq	.+20     	; 0x1b22 <_Z11ReceiveBonev+0x39e>
    1b0e:	80 91 df 01 	lds	r24, 0x01DF
    1b12:	88 23       	and	r24, r24
    1b14:	31 f4       	brne	.+12     	; 0x1b22 <_Z11ReceiveBonev+0x39e>
    1b16:	81 e0       	ldi	r24, 0x01	; 1
    1b18:	80 93 d7 01 	sts	0x01D7, r24
    1b1c:	81 e0       	ldi	r24, 0x01	; 1
    1b1e:	80 93 d6 01 	sts	0x01D6, r24
						else;
						//Reset flags for startup
						if (restart){restart=fFalse;}
    1b22:	80 91 df 01 	lds	r24, 0x01DF
    1b26:	88 23       	and	r24, r24
    1b28:	11 f0       	breq	.+4      	; 0x1b2e <_Z11ReceiveBonev+0x3aa>
    1b2a:	10 92 df 01 	sts	0x01DF, r1
						if (flagFreshStart){flagFreshStart=fFalse;}	
    1b2e:	80 91 e0 01 	lds	r24, 0x01E0
    1b32:	88 23       	and	r24, r24
    1b34:	09 f4       	brne	.+2      	; 0x1b38 <_Z11ReceiveBonev+0x3b4>
    1b36:	4f c0       	rjmp	.+158    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
    1b38:	10 92 e0 01 	sts	0x01E0, r1
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
					break;
    1b3c:	4c c0       	rjmp	.+152    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
						else if (!success && flagFreshStart && !restart){flagUserTime=fTrue; flagUserDate=fTrue;} //need to get user time and date
						else;
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
    1b3e:	ce 01       	movw	r24, r28
    1b40:	04 96       	adiw	r24, 0x04	; 4
    1b42:	28 e6       	ldi	r18, 0x68	; 104
    1b44:	31 e0       	ldi	r19, 0x01	; 1
    1b46:	b9 01       	movw	r22, r18
    1b48:	48 e0       	ldi	r20, 0x08	; 8
    1b4a:	50 e0       	ldi	r21, 0x00	; 0
    1b4c:	0e 94 56 1a 	call	0x34ac	; 0x34ac <strncmp>
    1b50:	00 97       	sbiw	r24, 0x00	; 0
    1b52:	39 f4       	brne	.+14     	; 0x1b62 <_Z11ReceiveBonev+0x3de>
    1b54:	83 e0       	ldi	r24, 0x03	; 3
    1b56:	90 e0       	ldi	r25, 0x00	; 0
    1b58:	90 93 ec 01 	sts	0x01EC, r25
    1b5c:	80 93 eb 01 	sts	0x01EB, r24
					else {state=5;}						
					break;
    1b60:	3a c0       	rjmp	.+116    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
						else;
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
    1b62:	85 e0       	ldi	r24, 0x05	; 5
    1b64:	90 e0       	ldi	r25, 0x00	; 0
    1b66:	90 93 ec 01 	sts	0x01EC, r25
    1b6a:	80 93 eb 01 	sts	0x01EB, r24
					break;
    1b6e:	33 c0       	rjmp	.+102    	; 0x1bd6 <_Z11ReceiveBonev+0x452>
					}//end case 2
				case 3:{
					//Successful receive state
					PrintBone("ACK");
    1b70:	81 e7       	ldi	r24, 0x71	; 113
    1b72:	91 e0       	ldi	r25, 0x01	; 1
    1b74:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
					PrintBone(recString);
    1b78:	ce 01       	movw	r24, r28
    1b7a:	04 96       	adiw	r24, 0x04	; 4
    1b7c:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
					state=0;
    1b80:	10 92 ec 01 	sts	0x01EC, r1
    1b84:	10 92 eb 01 	sts	0x01EB, r1
					flagReceivingBone=fFalse;
    1b88:	10 92 cf 01 	sts	0x01CF, r1
					break;
    1b8c:	25 c0       	rjmp	.+74     	; 0x1bd8 <_Z11ReceiveBonev+0x454>
					}//end case 3
				case 4:{
					PrintBone("ACKBAD.");
    1b8e:	8b e1       	ldi	r24, 0x1B	; 27
    1b90:	91 e0       	ldi	r25, 0x01	; 1
    1b92:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1b96:	10 92 cf 01 	sts	0x01CF, r1
					state=0;
    1b9a:	10 92 ec 01 	sts	0x01EC, r1
    1b9e:	10 92 eb 01 	sts	0x01EB, r1
					break;
    1ba2:	1a c0       	rjmp	.+52     	; 0x1bd8 <_Z11ReceiveBonev+0x454>
					}//end case 4
				case 5:{
					PrintBone("ACKERROR.");
    1ba4:	85 e7       	ldi	r24, 0x75	; 117
    1ba6:	91 e0       	ldi	r25, 0x01	; 1
    1ba8:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1bac:	10 92 cf 01 	sts	0x01CF, r1
					state=0;
    1bb0:	10 92 ec 01 	sts	0x01EC, r1
    1bb4:	10 92 eb 01 	sts	0x01EB, r1
					break;
    1bb8:	0f c0       	rjmp	.+30     	; 0x1bd8 <_Z11ReceiveBonev+0x454>
					}//end case 5
				case 6:{
					flagReceivingBone=fFalse;
    1bba:	10 92 cf 01 	sts	0x01CF, r1
					state=0;
    1bbe:	10 92 ec 01 	sts	0x01EC, r1
    1bc2:	10 92 eb 01 	sts	0x01EB, r1
					break;
    1bc6:	08 c0       	rjmp	.+16     	; 0x1bd8 <_Z11ReceiveBonev+0x454>
					}//end case 6
				default:{flagReceivingBone=fFalse; state=0;break;}
    1bc8:	10 92 cf 01 	sts	0x01CF, r1
    1bcc:	10 92 ec 01 	sts	0x01EC, r1
    1bd0:	10 92 eb 01 	sts	0x01EB, r1
    1bd4:	01 c0       	rjmp	.+2      	; 0x1bd8 <_Z11ReceiveBonev+0x454>
						//Reset flags for startup
						if (restart){restart=fFalse;}
						if (flagFreshStart){flagFreshStart=fFalse;}	
					} else if (!strncmp(recString,"SYNNONE.",8)){state=3;}	
					else {state=5;}						
					break;
    1bd6:	00 00       	nop
	volatile static unsigned int state=0;
	char recChar, recString[20];
	volatile unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	while (flagReceivingBone){
    1bd8:	90 91 cf 01 	lds	r25, 0x01CF
    1bdc:	81 e0       	ldi	r24, 0x01	; 1
    1bde:	99 23       	and	r25, r25
    1be0:	09 f4       	brne	.+2      	; 0x1be4 <_Z11ReceiveBonev+0x460>
    1be2:	80 e0       	ldi	r24, 0x00	; 0
    1be4:	88 23       	and	r24, r24
    1be6:	09 f0       	breq	.+2      	; 0x1bea <_Z11ReceiveBonev+0x466>
    1be8:	dc cd       	rjmp	.-1096   	; 0x17a2 <_Z11ReceiveBonev+0x1e>
					break;
					}//end case 6
				default:{flagReceivingBone=fFalse; state=0;break;}
			}//end switch
	}//end while(flagUARTbone)	
}//end ReceiveBone()
    1bea:	a7 96       	adiw	r28, 0x27	; 39
    1bec:	0f b6       	in	r0, 0x3f	; 63
    1bee:	f8 94       	cli
    1bf0:	de bf       	out	0x3e, r29	; 62
    1bf2:	0f be       	out	0x3f, r0	; 63
    1bf4:	cd bf       	out	0x3d, r28	; 61
    1bf6:	df 91       	pop	r29
    1bf8:	cf 91       	pop	r28
    1bfa:	08 95       	ret

00001bfc <_Z11ReceiveGAVRv>:

/*************************************************************************************************************/
void ReceiveGAVR(){
    1bfc:	cf 93       	push	r28
    1bfe:	df 93       	push	r29
    1c00:	cd b7       	in	r28, 0x3d	; 61
    1c02:	de b7       	in	r29, 0x3e	; 62
    1c04:	e9 97       	sbiw	r28, 0x39	; 57
    1c06:	0f b6       	in	r0, 0x3f	; 63
    1c08:	f8 94       	cli
    1c0a:	de bf       	out	0x3e, r29	; 62
    1c0c:	0f be       	out	0x3f, r0	; 63
    1c0e:	cd bf       	out	0x3d, r28	; 61
	volatile static unsigned int state=0;
	char recChar, recString[20];
	volatile unsigned int strLoc=0;
    1c10:	18 a6       	lds	r17, 0xb8
    1c12:	1f a2       	lds	r17, 0x9f
	BOOL noCarriage=fTrue;
    1c14:	81 e0       	ldi	r24, 0x01	; 1
    1c16:	89 83       	std	Y+1, r24	; 0x01
	
	//While Loop
	while (flagReceivingGAVR){
    1c18:	a0 c3       	rjmp	.+1856   	; 0x235a <_Z11ReceiveGAVRv+0x75e>
			/** State 5: Exit case. Lower "flagReceivingGAVR" which causes and exit.													   **/
			/** State 6: ACKERROR state. Send "ACKERROR", then exit through state 5.													   **/
			/** State 7: Successful acquire of time/date.
			/** Default: Set state to 0, doesn't really matter though. Exit signalling timeout to sender.								   **/
			/********************************************************************************************************************************/			
			switch(state){
    1c1a:	80 91 e9 01 	lds	r24, 0x01E9
    1c1e:	90 91 ea 01 	lds	r25, 0x01EA
    1c22:	83 30       	cpi	r24, 0x03	; 3
    1c24:	91 05       	cpc	r25, r1
    1c26:	09 f4       	brne	.+2      	; 0x1c2a <_Z11ReceiveGAVRv+0x2e>
    1c28:	cd c0       	rjmp	.+410    	; 0x1dc4 <_Z11ReceiveGAVRv+0x1c8>
    1c2a:	84 30       	cpi	r24, 0x04	; 4
    1c2c:	91 05       	cpc	r25, r1
    1c2e:	48 f4       	brcc	.+18     	; 0x1c42 <_Z11ReceiveGAVRv+0x46>
    1c30:	81 30       	cpi	r24, 0x01	; 1
    1c32:	91 05       	cpc	r25, r1
    1c34:	09 f4       	brne	.+2      	; 0x1c38 <_Z11ReceiveGAVRv+0x3c>
    1c36:	8b c0       	rjmp	.+278    	; 0x1d4e <_Z11ReceiveGAVRv+0x152>
    1c38:	82 30       	cpi	r24, 0x02	; 2
    1c3a:	91 05       	cpc	r25, r1
    1c3c:	08 f0       	brcs	.+2      	; 0x1c40 <_Z11ReceiveGAVRv+0x44>
    1c3e:	95 c0       	rjmp	.+298    	; 0x1d6a <_Z11ReceiveGAVRv+0x16e>
    1c40:	11 c0       	rjmp	.+34     	; 0x1c64 <_Z11ReceiveGAVRv+0x68>
    1c42:	85 30       	cpi	r24, 0x05	; 5
    1c44:	91 05       	cpc	r25, r1
    1c46:	09 f4       	brne	.+2      	; 0x1c4a <_Z11ReceiveGAVRv+0x4e>
    1c48:	5c c3       	rjmp	.+1720   	; 0x2302 <_Z11ReceiveGAVRv+0x706>
    1c4a:	85 30       	cpi	r24, 0x05	; 5
    1c4c:	91 05       	cpc	r25, r1
    1c4e:	08 f4       	brcc	.+2      	; 0x1c52 <_Z11ReceiveGAVRv+0x56>
    1c50:	3a c3       	rjmp	.+1652   	; 0x22c6 <_Z11ReceiveGAVRv+0x6ca>
    1c52:	86 30       	cpi	r24, 0x06	; 6
    1c54:	91 05       	cpc	r25, r1
    1c56:	09 f4       	brne	.+2      	; 0x1c5a <_Z11ReceiveGAVRv+0x5e>
    1c58:	5b c3       	rjmp	.+1718   	; 0x2310 <_Z11ReceiveGAVRv+0x714>
    1c5a:	87 30       	cpi	r24, 0x07	; 7
    1c5c:	91 05       	cpc	r25, r1
    1c5e:	09 f4       	brne	.+2      	; 0x1c62 <_Z11ReceiveGAVRv+0x66>
    1c60:	62 c3       	rjmp	.+1732   	; 0x2326 <_Z11ReceiveGAVRv+0x72a>
    1c62:	72 c3       	rjmp	.+1764   	; 0x2348 <_Z11ReceiveGAVRv+0x74c>
				case 0:{
					//Beginning case
					strLoc=0;
    1c64:	18 a6       	lds	r17, 0xb8
    1c66:	1f a2       	lds	r17, 0x9f
					recChar = UDR1;
    1c68:	8e ec       	ldi	r24, 0xCE	; 206
    1c6a:	90 e0       	ldi	r25, 0x00	; 0
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	80 81       	ld	r24, Z
    1c70:	8a 8b       	std	Y+18, r24	; 0x12
					if (recChar=='.'){
    1c72:	8a 89       	ldd	r24, Y+18	; 0x12
    1c74:	8e 32       	cpi	r24, 0x2E	; 46
    1c76:	39 f4       	brne	.+14     	; 0x1c86 <_Z11ReceiveGAVRv+0x8a>
						state=6;															//Go to error state.
    1c78:	86 e0       	ldi	r24, 0x06	; 6
    1c7a:	90 e0       	ldi	r25, 0x00	; 0
    1c7c:	90 93 ea 01 	sts	0x01EA, r25
    1c80:	80 93 e9 01 	sts	0x01E9, r24
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
    1c84:	6a c3       	rjmp	.+1748   	; 0x235a <_Z11ReceiveGAVRv+0x75e>
					//Beginning case
					strLoc=0;
					recChar = UDR1;
					if (recChar=='.'){
						state=6;															//Go to error state.
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
    1c86:	8f a1       	lds	r24, 0x4f
    1c88:	98 a5       	lds	r25, 0x68
    1c8a:	9e 01       	movw	r18, r28
    1c8c:	2d 5e       	subi	r18, 0xED	; 237
    1c8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1c90:	28 0f       	add	r18, r24
    1c92:	39 1f       	adc	r19, r25
    1c94:	4a 89       	ldd	r20, Y+18	; 0x12
    1c96:	f9 01       	movw	r30, r18
    1c98:	40 83       	st	Z, r20
    1c9a:	01 96       	adiw	r24, 0x01	; 1
    1c9c:	98 a7       	lds	r25, 0x78
    1c9e:	8f a3       	lds	r24, 0x5f
    1ca0:	81 e0       	ldi	r24, 0x01	; 1
    1ca2:	90 e0       	ldi	r25, 0x00	; 0
    1ca4:	90 93 ea 01 	sts	0x01EA, r25
    1ca8:	80 93 e9 01 	sts	0x01E9, r24
					break;
    1cac:	56 c3       	rjmp	.+1708   	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingBone);				//get the next character
    1cae:	00 00       	nop
    1cb0:	88 ec       	ldi	r24, 0xC8	; 200
    1cb2:	90 e0       	ldi	r25, 0x00	; 0
    1cb4:	fc 01       	movw	r30, r24
    1cb6:	80 81       	ld	r24, Z
    1cb8:	88 23       	and	r24, r24
    1cba:	34 f0       	brlt	.+12     	; 0x1cc8 <_Z11ReceiveGAVRv+0xcc>
    1cbc:	80 91 cf 01 	lds	r24, 0x01CF
    1cc0:	88 23       	and	r24, r24
    1cc2:	11 f0       	breq	.+4      	; 0x1cc8 <_Z11ReceiveGAVRv+0xcc>
    1cc4:	81 e0       	ldi	r24, 0x01	; 1
    1cc6:	01 c0       	rjmp	.+2      	; 0x1cca <_Z11ReceiveGAVRv+0xce>
    1cc8:	80 e0       	ldi	r24, 0x00	; 0
    1cca:	88 23       	and	r24, r24
    1ccc:	89 f7       	brne	.-30     	; 0x1cb0 <_Z11ReceiveGAVRv+0xb4>
						if (!flagReceivingBone){state=0; break;}							//if there was a timeout, break out and reset state
    1cce:	80 91 cf 01 	lds	r24, 0x01CF
    1cd2:	88 23       	and	r24, r24
    1cd4:	31 f4       	brne	.+12     	; 0x1ce2 <_Z11ReceiveGAVRv+0xe6>
    1cd6:	10 92 ea 01 	sts	0x01EA, r1
    1cda:	10 92 e9 01 	sts	0x01E9, r1
    1cde:	00 00       	nop
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 19){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    1ce0:	3c c3       	rjmp	.+1656   	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingBone);				//get the next character
						if (!flagReceivingBone){state=0; break;}							//if there was a timeout, break out and reset state
						recChar=UDR1;
    1ce2:	8e ec       	ldi	r24, 0xCE	; 206
    1ce4:	90 e0       	ldi	r25, 0x00	; 0
    1ce6:	fc 01       	movw	r30, r24
    1ce8:	80 81       	ld	r24, Z
    1cea:	8a 8b       	std	Y+18, r24	; 0x12
						recString[strLoc++]=recChar;										//'.' always included into recString
    1cec:	8f a1       	lds	r24, 0x4f
    1cee:	98 a5       	lds	r25, 0x68
    1cf0:	9e 01       	movw	r18, r28
    1cf2:	2d 5e       	subi	r18, 0xED	; 237
    1cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    1cf6:	28 0f       	add	r18, r24
    1cf8:	39 1f       	adc	r19, r25
    1cfa:	4a 89       	ldd	r20, Y+18	; 0x12
    1cfc:	f9 01       	movw	r30, r18
    1cfe:	40 83       	st	Z, r20
    1d00:	01 96       	adiw	r24, 0x01	; 1
    1d02:	98 a7       	lds	r25, 0x78
    1d04:	8f a3       	lds	r24, 0x5f
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1d06:	8a 89       	ldd	r24, Y+18	; 0x12
    1d08:	8e 32       	cpi	r24, 0x2E	; 46
    1d0a:	89 f4       	brne	.+34     	; 0x1d2e <_Z11ReceiveGAVRv+0x132>
    1d0c:	8f a1       	lds	r24, 0x4f
    1d0e:	98 a5       	lds	r25, 0x68
    1d10:	9e 01       	movw	r18, r28
    1d12:	2d 5e       	subi	r18, 0xED	; 237
    1d14:	3f 4f       	sbci	r19, 0xFF	; 255
    1d16:	82 0f       	add	r24, r18
    1d18:	93 1f       	adc	r25, r19
    1d1a:	fc 01       	movw	r30, r24
    1d1c:	10 82       	st	Z, r1
    1d1e:	19 82       	std	Y+1, r1	; 0x01
    1d20:	82 e0       	ldi	r24, 0x02	; 2
    1d22:	90 e0       	ldi	r25, 0x00	; 0
    1d24:	90 93 ea 01 	sts	0x01EA, r25
    1d28:	80 93 e9 01 	sts	0x01E9, r24
    1d2c:	10 c0       	rjmp	.+32     	; 0x1d4e <_Z11ReceiveGAVRv+0x152>
						else if(strLoc >= 19){state=6;noCarriage=fFalse;}
    1d2e:	8f a1       	lds	r24, 0x4f
    1d30:	98 a5       	lds	r25, 0x68
    1d32:	21 e0       	ldi	r18, 0x01	; 1
    1d34:	83 31       	cpi	r24, 0x13	; 19
    1d36:	91 05       	cpc	r25, r1
    1d38:	08 f4       	brcc	.+2      	; 0x1d3c <_Z11ReceiveGAVRv+0x140>
    1d3a:	20 e0       	ldi	r18, 0x00	; 0
    1d3c:	22 23       	and	r18, r18
    1d3e:	39 f0       	breq	.+14     	; 0x1d4e <_Z11ReceiveGAVRv+0x152>
    1d40:	86 e0       	ldi	r24, 0x06	; 6
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	90 93 ea 01 	sts	0x01EA, r25
    1d48:	80 93 e9 01 	sts	0x01E9, r24
    1d4c:	19 82       	std	Y+1, r1	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    1d4e:	89 81       	ldd	r24, Y+1	; 0x01
    1d50:	88 23       	and	r24, r24
    1d52:	31 f0       	breq	.+12     	; 0x1d60 <_Z11ReceiveGAVRv+0x164>
    1d54:	80 91 cf 01 	lds	r24, 0x01CF
    1d58:	88 23       	and	r24, r24
    1d5a:	11 f0       	breq	.+4      	; 0x1d60 <_Z11ReceiveGAVRv+0x164>
    1d5c:	81 e0       	ldi	r24, 0x01	; 1
    1d5e:	01 c0       	rjmp	.+2      	; 0x1d62 <_Z11ReceiveGAVRv+0x166>
    1d60:	80 e0       	ldi	r24, 0x00	; 0
    1d62:	88 23       	and	r24, r24
    1d64:	09 f0       	breq	.+2      	; 0x1d68 <_Z11ReceiveGAVRv+0x16c>
    1d66:	a3 cf       	rjmp	.-186    	; 0x1cae <_Z11ReceiveGAVRv+0xb2>
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 19){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    1d68:	f8 c2       	rjmp	.+1520   	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
    1d6a:	ce 01       	movw	r24, r28
    1d6c:	43 96       	adiw	r24, 0x13	; 19
    1d6e:	2f e7       	ldi	r18, 0x7F	; 127
    1d70:	31 e0       	ldi	r19, 0x01	; 1
    1d72:	b9 01       	movw	r22, r18
    1d74:	48 e0       	ldi	r20, 0x08	; 8
    1d76:	50 e0       	ldi	r21, 0x00	; 0
    1d78:	0e 94 56 1a 	call	0x34ac	; 0x34ac <strncmp>
    1d7c:	00 97       	sbiw	r24, 0x00	; 0
    1d7e:	39 f4       	brne	.+14     	; 0x1d8e <_Z11ReceiveGAVRv+0x192>
    1d80:	84 e0       	ldi	r24, 0x04	; 4
    1d82:	90 e0       	ldi	r25, 0x00	; 0
    1d84:	90 93 ea 01 	sts	0x01EA, r25
    1d88:	80 93 e9 01 	sts	0x01E9, r24
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
					break;
    1d8c:	e6 c2       	rjmp	.+1484   	; 0x235a <_Z11ReceiveGAVRv+0x75e>
					break;
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
    1d8e:	8f 89       	ldd	r24, Y+23	; 0x17
    1d90:	91 e0       	ldi	r25, 0x01	; 1
    1d92:	8a 33       	cpi	r24, 0x3A	; 58
    1d94:	09 f0       	breq	.+2      	; 0x1d98 <_Z11ReceiveGAVRv+0x19c>
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	28 8d       	ldd	r18, Y+24	; 0x18
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	2a 33       	cpi	r18, 0x3A	; 58
    1d9e:	09 f0       	breq	.+2      	; 0x1da2 <_Z11ReceiveGAVRv+0x1a6>
    1da0:	80 e0       	ldi	r24, 0x00	; 0
    1da2:	89 27       	eor	r24, r25
    1da4:	88 23       	and	r24, r24
    1da6:	39 f0       	breq	.+14     	; 0x1db6 <_Z11ReceiveGAVRv+0x1ba>
    1da8:	83 e0       	ldi	r24, 0x03	; 3
    1daa:	90 e0       	ldi	r25, 0x00	; 0
    1dac:	90 93 ea 01 	sts	0x01EA, r25
    1db0:	80 93 e9 01 	sts	0x01E9, r24
					else {state=6;}
					break;
    1db4:	d2 c2       	rjmp	.+1444   	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
    1db6:	86 e0       	ldi	r24, 0x06	; 6
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	90 93 ea 01 	sts	0x01EA, r25
    1dbe:	80 93 e9 01 	sts	0x01E9, r24
					break;
    1dc2:	cb c2       	rjmp	.+1430   	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				}//end case 2
				case 3:{
					//Parse for date/time case
					if (flagUserDate || flagUserTime){
    1dc4:	80 91 d6 01 	lds	r24, 0x01D6
    1dc8:	88 23       	and	r24, r24
    1dca:	29 f4       	brne	.+10     	; 0x1dd6 <_Z11ReceiveGAVRv+0x1da>
    1dcc:	80 91 d7 01 	lds	r24, 0x01D7
    1dd0:	88 23       	and	r24, r24
    1dd2:	09 f4       	brne	.+2      	; 0x1dd6 <_Z11ReceiveGAVRv+0x1da>
    1dd4:	6c c2       	rjmp	.+1240   	; 0x22ae <_Z11ReceiveGAVRv+0x6b2>
						//Go through the string and parse for the time. Must go through the time to get the date.
						BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    1dd6:	1a 82       	std	Y+2, r1	; 0x02
    1dd8:	1b 82       	std	Y+3, r1	; 0x03
						int counter=0;
    1dda:	1d 82       	std	Y+5, r1	; 0x05
    1ddc:	1c 82       	std	Y+4, r1	; 0x04
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    1dde:	1a a6       	lds	r17, 0xba
    1de0:	19 a6       	lds	r17, 0xb9
    1de2:	1c a6       	lds	r17, 0xbc
    1de4:	1b a6       	lds	r17, 0xbb
    1de6:	1e a6       	lds	r17, 0xbe
    1de8:	1d a6       	lds	r17, 0xbd
    1dea:	18 aa       	sts	0x98, r17
    1dec:	1f a6       	lds	r17, 0xbf
    1dee:	1a aa       	sts	0x9a, r17
    1df0:	19 aa       	sts	0x99, r17
    1df2:	1c aa       	sts	0x9c, r17
    1df4:	1b aa       	sts	0x9b, r17
    1df6:	1f 82       	std	Y+7, r1	; 0x07
    1df8:	1e 82       	std	Y+6, r1	; 0x06
    1dfa:	19 86       	std	Y+9, r1	; 0x09
    1dfc:	18 86       	std	Y+8, r1	; 0x08
    1dfe:	1b 86       	std	Y+11, r1	; 0x0b
    1e00:	1a 86       	std	Y+10, r1	; 0x0a
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    1e02:	73 c0       	rjmp	.+230    	; 0x1eea <_Z11ReceiveGAVRv+0x2ee>
							//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
							if (recString[counter]!=':' && hms<3){
    1e04:	9e 01       	movw	r18, r28
    1e06:	2d 5e       	subi	r18, 0xED	; 237
    1e08:	3f 4f       	sbci	r19, 0xFF	; 255
    1e0a:	8c 81       	ldd	r24, Y+4	; 0x04
    1e0c:	9d 81       	ldd	r25, Y+5	; 0x05
    1e0e:	82 0f       	add	r24, r18
    1e10:	93 1f       	adc	r25, r19
    1e12:	fc 01       	movw	r30, r24
    1e14:	80 81       	ld	r24, Z
    1e16:	8a 33       	cpi	r24, 0x3A	; 58
    1e18:	e9 f0       	breq	.+58     	; 0x1e54 <_Z11ReceiveGAVRv+0x258>
    1e1a:	88 85       	ldd	r24, Y+8	; 0x08
    1e1c:	99 85       	ldd	r25, Y+9	; 0x09
    1e1e:	83 30       	cpi	r24, 0x03	; 3
    1e20:	91 05       	cpc	r25, r1
    1e22:	c4 f4       	brge	.+48     	; 0x1e54 <_Z11ReceiveGAVRv+0x258>
								tempStringNum[placement++]=recString[counter];
    1e24:	9e 01       	movw	r18, r28
    1e26:	2d 5e       	subi	r18, 0xED	; 237
    1e28:	3f 4f       	sbci	r19, 0xFF	; 255
    1e2a:	8c 81       	ldd	r24, Y+4	; 0x04
    1e2c:	9d 81       	ldd	r25, Y+5	; 0x05
    1e2e:	82 0f       	add	r24, r18
    1e30:	93 1f       	adc	r25, r19
    1e32:	fc 01       	movw	r30, r24
    1e34:	40 81       	ld	r20, Z
    1e36:	9e 01       	movw	r18, r28
    1e38:	2b 5c       	subi	r18, 0xCB	; 203
    1e3a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e3c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e3e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e40:	82 0f       	add	r24, r18
    1e42:	93 1f       	adc	r25, r19
    1e44:	fc 01       	movw	r30, r24
    1e46:	40 83       	st	Z, r20
    1e48:	8a 85       	ldd	r24, Y+10	; 0x0a
    1e4a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1e4c:	01 96       	adiw	r24, 0x01	; 1
    1e4e:	9b 87       	std	Y+11, r25	; 0x0b
    1e50:	8a 87       	std	Y+10, r24	; 0x0a
    1e52:	46 c0       	rjmp	.+140    	; 0x1ee0 <_Z11ReceiveGAVRv+0x2e4>
							//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
							} else if (hms<2 && recString[counter] == ':') {
    1e54:	88 85       	ldd	r24, Y+8	; 0x08
    1e56:	99 85       	ldd	r25, Y+9	; 0x09
    1e58:	82 30       	cpi	r24, 0x02	; 2
    1e5a:	91 05       	cpc	r25, r1
    1e5c:	0c f0       	brlt	.+2      	; 0x1e60 <_Z11ReceiveGAVRv+0x264>
    1e5e:	40 c0       	rjmp	.+128    	; 0x1ee0 <_Z11ReceiveGAVRv+0x2e4>
    1e60:	9e 01       	movw	r18, r28
    1e62:	2d 5e       	subi	r18, 0xED	; 237
    1e64:	3f 4f       	sbci	r19, 0xFF	; 255
    1e66:	8c 81       	ldd	r24, Y+4	; 0x04
    1e68:	9d 81       	ldd	r25, Y+5	; 0x05
    1e6a:	82 0f       	add	r24, r18
    1e6c:	93 1f       	adc	r25, r19
    1e6e:	fc 01       	movw	r30, r24
    1e70:	80 81       	ld	r24, Z
    1e72:	8a 33       	cpi	r24, 0x3A	; 58
    1e74:	a9 f5       	brne	.+106    	; 0x1ee0 <_Z11ReceiveGAVRv+0x2e4>
								tempNum[hms++] = atoi(tempStringNum);
    1e76:	ce 01       	movw	r24, r28
    1e78:	c5 96       	adiw	r24, 0x35	; 53
    1e7a:	0e 94 1d 1a 	call	0x343a	; 0x343a <atoi>
    1e7e:	9c 01       	movw	r18, r24
    1e80:	88 85       	ldd	r24, Y+8	; 0x08
    1e82:	99 85       	ldd	r25, Y+9	; 0x09
    1e84:	88 0f       	add	r24, r24
    1e86:	99 1f       	adc	r25, r25
    1e88:	ae 01       	movw	r20, r28
    1e8a:	4f 5f       	subi	r20, 0xFF	; 255
    1e8c:	5f 4f       	sbci	r21, 0xFF	; 255
    1e8e:	84 0f       	add	r24, r20
    1e90:	95 1f       	adc	r25, r21
    1e92:	88 96       	adiw	r24, 0x28	; 40
    1e94:	fc 01       	movw	r30, r24
    1e96:	31 83       	std	Z+1, r19	; 0x01
    1e98:	20 83       	st	Z, r18
    1e9a:	88 85       	ldd	r24, Y+8	; 0x08
    1e9c:	99 85       	ldd	r25, Y+9	; 0x09
    1e9e:	01 96       	adiw	r24, 0x01	; 1
    1ea0:	99 87       	std	Y+9, r25	; 0x09
    1ea2:	88 87       	std	Y+8, r24	; 0x08
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1ea4:	1d 86       	std	Y+13, r1	; 0x0d
    1ea6:	1c 86       	std	Y+12, r1	; 0x0c
    1ea8:	0e c0       	rjmp	.+28     	; 0x1ec6 <_Z11ReceiveGAVRv+0x2ca>
    1eaa:	9e 01       	movw	r18, r28
    1eac:	2b 5c       	subi	r18, 0xCB	; 203
    1eae:	3f 4f       	sbci	r19, 0xFF	; 255
    1eb0:	8c 85       	ldd	r24, Y+12	; 0x0c
    1eb2:	9d 85       	ldd	r25, Y+13	; 0x0d
    1eb4:	82 0f       	add	r24, r18
    1eb6:	93 1f       	adc	r25, r19
    1eb8:	fc 01       	movw	r30, r24
    1eba:	10 82       	st	Z, r1
    1ebc:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ebe:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ec0:	01 96       	adiw	r24, 0x01	; 1
    1ec2:	9d 87       	std	Y+13, r25	; 0x0d
    1ec4:	8c 87       	std	Y+12, r24	; 0x0c
    1ec6:	41 e0       	ldi	r20, 0x01	; 1
    1ec8:	2c 85       	ldd	r18, Y+12	; 0x0c
    1eca:	3d 85       	ldd	r19, Y+13	; 0x0d
    1ecc:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ece:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ed0:	82 17       	cp	r24, r18
    1ed2:	93 07       	cpc	r25, r19
    1ed4:	0c f4       	brge	.+2      	; 0x1ed8 <_Z11ReceiveGAVRv+0x2dc>
    1ed6:	40 e0       	ldi	r20, 0x00	; 0
    1ed8:	44 23       	and	r20, r20
    1eda:	39 f7       	brne	.-50     	; 0x1eaa <_Z11ReceiveGAVRv+0x2ae>
								placement=0;												//reset placement
    1edc:	1b 86       	std	Y+11, r1	; 0x0b
    1ede:	1a 86       	std	Y+10, r1	; 0x0a
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
    1ee0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ee2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ee4:	01 96       	adiw	r24, 0x01	; 1
    1ee6:	9d 83       	std	Y+5, r25	; 0x05
    1ee8:	8c 83       	std	Y+4, r24	; 0x04
						int counter=0;
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    1eea:	9e 01       	movw	r18, r28
    1eec:	2d 5e       	subi	r18, 0xED	; 237
    1eee:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef0:	8c 81       	ldd	r24, Y+4	; 0x04
    1ef2:	9d 81       	ldd	r25, Y+5	; 0x05
    1ef4:	82 0f       	add	r24, r18
    1ef6:	93 1f       	adc	r25, r19
    1ef8:	fc 01       	movw	r30, r24
    1efa:	80 81       	ld	r24, Z
    1efc:	8f 32       	cpi	r24, 0x2F	; 47
    1efe:	69 f0       	breq	.+26     	; 0x1f1a <_Z11ReceiveGAVRv+0x31e>
    1f00:	9e 01       	movw	r18, r28
    1f02:	2d 5e       	subi	r18, 0xED	; 237
    1f04:	3f 4f       	sbci	r19, 0xFF	; 255
    1f06:	8c 81       	ldd	r24, Y+4	; 0x04
    1f08:	9d 81       	ldd	r25, Y+5	; 0x05
    1f0a:	82 0f       	add	r24, r18
    1f0c:	93 1f       	adc	r25, r19
    1f0e:	fc 01       	movw	r30, r24
    1f10:	80 81       	ld	r24, Z
    1f12:	88 23       	and	r24, r24
    1f14:	11 f0       	breq	.+4      	; 0x1f1a <_Z11ReceiveGAVRv+0x31e>
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	01 c0       	rjmp	.+2      	; 0x1f1c <_Z11ReceiveGAVRv+0x320>
    1f1a:	80 e0       	ldi	r24, 0x00	; 0
    1f1c:	88 23       	and	r24, r24
    1f1e:	09 f0       	breq	.+2      	; 0x1f22 <_Z11ReceiveGAVRv+0x326>
    1f20:	71 cf       	rjmp	.-286    	; 0x1e04 <_Z11ReceiveGAVRv+0x208>
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
						}//end while
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
    1f22:	9e 01       	movw	r18, r28
    1f24:	2d 5e       	subi	r18, 0xED	; 237
    1f26:	3f 4f       	sbci	r19, 0xFF	; 255
    1f28:	8c 81       	ldd	r24, Y+4	; 0x04
    1f2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1f2c:	82 0f       	add	r24, r18
    1f2e:	93 1f       	adc	r25, r19
    1f30:	fc 01       	movw	r30, r24
    1f32:	80 81       	ld	r24, Z
    1f34:	8f 32       	cpi	r24, 0x2F	; 47
    1f36:	a9 f4       	brne	.+42     	; 0x1f62 <_Z11ReceiveGAVRv+0x366>
							tempNum[hms] = atoi(tempStringNum);
    1f38:	ce 01       	movw	r24, r28
    1f3a:	c5 96       	adiw	r24, 0x35	; 53
    1f3c:	0e 94 1d 1a 	call	0x343a	; 0x343a <atoi>
    1f40:	9c 01       	movw	r18, r24
    1f42:	88 85       	ldd	r24, Y+8	; 0x08
    1f44:	99 85       	ldd	r25, Y+9	; 0x09
    1f46:	88 0f       	add	r24, r24
    1f48:	99 1f       	adc	r25, r25
    1f4a:	ae 01       	movw	r20, r28
    1f4c:	4f 5f       	subi	r20, 0xFF	; 255
    1f4e:	5f 4f       	sbci	r21, 0xFF	; 255
    1f50:	84 0f       	add	r24, r20
    1f52:	95 1f       	adc	r25, r21
    1f54:	88 96       	adiw	r24, 0x28	; 40
    1f56:	fc 01       	movw	r30, r24
    1f58:	31 83       	std	Z+1, r19	; 0x01
    1f5a:	20 83       	st	Z, r18
							successTime=fTrue;
    1f5c:	81 e0       	ldi	r24, 0x01	; 1
    1f5e:	8a 83       	std	Y+2, r24	; 0x02
    1f60:	0a c0       	rjmp	.+20     	; 0x1f76 <_Z11ReceiveGAVRv+0x37a>
						} else {
							state=5;
    1f62:	85 e0       	ldi	r24, 0x05	; 5
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	90 93 ea 01 	sts	0x01EA, r25
    1f6a:	80 93 e9 01 	sts	0x01E9, r24
							PrintGAVR("ACKBAD.");
    1f6e:	8b e1       	ldi	r24, 0x1B	; 27
    1f70:	91 e0       	ldi	r25, 0x01	; 1
    1f72:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						if (flagUserDate){
    1f76:	80 91 d6 01 	lds	r24, 0x01D6
    1f7a:	88 23       	and	r24, r24
    1f7c:	09 f4       	brne	.+2      	; 0x1f80 <_Z11ReceiveGAVRv+0x384>
    1f7e:	e4 c0       	rjmp	.+456    	; 0x2148 <_Z11ReceiveGAVRv+0x54c>
							//Now get the date. have to null the tempStringNum
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1f80:	1f 86       	std	Y+15, r1	; 0x0f
    1f82:	1e 86       	std	Y+14, r1	; 0x0e
    1f84:	0e c0       	rjmp	.+28     	; 0x1fa2 <_Z11ReceiveGAVRv+0x3a6>
    1f86:	9e 01       	movw	r18, r28
    1f88:	2b 5c       	subi	r18, 0xCB	; 203
    1f8a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f8c:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f8e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f90:	82 0f       	add	r24, r18
    1f92:	93 1f       	adc	r25, r19
    1f94:	fc 01       	movw	r30, r24
    1f96:	10 82       	st	Z, r1
    1f98:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f9a:	9f 85       	ldd	r25, Y+15	; 0x0f
    1f9c:	01 96       	adiw	r24, 0x01	; 1
    1f9e:	9f 87       	std	Y+15, r25	; 0x0f
    1fa0:	8e 87       	std	Y+14, r24	; 0x0e
    1fa2:	41 e0       	ldi	r20, 0x01	; 1
    1fa4:	2e 85       	ldd	r18, Y+14	; 0x0e
    1fa6:	3f 85       	ldd	r19, Y+15	; 0x0f
    1fa8:	8a 85       	ldd	r24, Y+10	; 0x0a
    1faa:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fac:	82 17       	cp	r24, r18
    1fae:	93 07       	cpc	r25, r19
    1fb0:	0c f4       	brge	.+2      	; 0x1fb4 <_Z11ReceiveGAVRv+0x3b8>
    1fb2:	40 e0       	ldi	r20, 0x00	; 0
    1fb4:	44 23       	and	r20, r20
    1fb6:	39 f7       	brne	.-50     	; 0x1f86 <_Z11ReceiveGAVRv+0x38a>
							placement=0;
    1fb8:	1b 86       	std	Y+11, r1	; 0x0b
    1fba:	1a 86       	std	Y+10, r1	; 0x0a
							counter++;	//get past the '/'
    1fbc:	8c 81       	ldd	r24, Y+4	; 0x04
    1fbe:	9d 81       	ldd	r25, Y+5	; 0x05
    1fc0:	01 96       	adiw	r24, 0x01	; 1
    1fc2:	9d 83       	std	Y+5, r25	; 0x05
    1fc4:	8c 83       	std	Y+4, r24	; 0x04
							
							//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
							while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1fc6:	73 c0       	rjmp	.+230    	; 0x20ae <_Z11ReceiveGAVRv+0x4b2>
								//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
								if  (recString[counter] != ',' && dmy < 3){
    1fc8:	9e 01       	movw	r18, r28
    1fca:	2d 5e       	subi	r18, 0xED	; 237
    1fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fce:	8c 81       	ldd	r24, Y+4	; 0x04
    1fd0:	9d 81       	ldd	r25, Y+5	; 0x05
    1fd2:	82 0f       	add	r24, r18
    1fd4:	93 1f       	adc	r25, r19
    1fd6:	fc 01       	movw	r30, r24
    1fd8:	80 81       	ld	r24, Z
    1fda:	8c 32       	cpi	r24, 0x2C	; 44
    1fdc:	e9 f0       	breq	.+58     	; 0x2018 <_Z11ReceiveGAVRv+0x41c>
    1fde:	8e 81       	ldd	r24, Y+6	; 0x06
    1fe0:	9f 81       	ldd	r25, Y+7	; 0x07
    1fe2:	83 30       	cpi	r24, 0x03	; 3
    1fe4:	91 05       	cpc	r25, r1
    1fe6:	c4 f4       	brge	.+48     	; 0x2018 <_Z11ReceiveGAVRv+0x41c>
									tempStringNum[placement++]=recString[counter];
    1fe8:	9e 01       	movw	r18, r28
    1fea:	2d 5e       	subi	r18, 0xED	; 237
    1fec:	3f 4f       	sbci	r19, 0xFF	; 255
    1fee:	8c 81       	ldd	r24, Y+4	; 0x04
    1ff0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ff2:	82 0f       	add	r24, r18
    1ff4:	93 1f       	adc	r25, r19
    1ff6:	fc 01       	movw	r30, r24
    1ff8:	40 81       	ld	r20, Z
    1ffa:	9e 01       	movw	r18, r28
    1ffc:	2b 5c       	subi	r18, 0xCB	; 203
    1ffe:	3f 4f       	sbci	r19, 0xFF	; 255
    2000:	8a 85       	ldd	r24, Y+10	; 0x0a
    2002:	9b 85       	ldd	r25, Y+11	; 0x0b
    2004:	82 0f       	add	r24, r18
    2006:	93 1f       	adc	r25, r19
    2008:	fc 01       	movw	r30, r24
    200a:	40 83       	st	Z, r20
    200c:	8a 85       	ldd	r24, Y+10	; 0x0a
    200e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2010:	01 96       	adiw	r24, 0x01	; 1
    2012:	9b 87       	std	Y+11, r25	; 0x0b
    2014:	8a 87       	std	Y+10, r24	; 0x0a
    2016:	46 c0       	rjmp	.+140    	; 0x20a4 <_Z11ReceiveGAVRv+0x4a8>
								//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
								} else if (dmy<2 && recString[counter]==','){
    2018:	8e 81       	ldd	r24, Y+6	; 0x06
    201a:	9f 81       	ldd	r25, Y+7	; 0x07
    201c:	82 30       	cpi	r24, 0x02	; 2
    201e:	91 05       	cpc	r25, r1
    2020:	0c f0       	brlt	.+2      	; 0x2024 <_Z11ReceiveGAVRv+0x428>
    2022:	40 c0       	rjmp	.+128    	; 0x20a4 <_Z11ReceiveGAVRv+0x4a8>
    2024:	9e 01       	movw	r18, r28
    2026:	2d 5e       	subi	r18, 0xED	; 237
    2028:	3f 4f       	sbci	r19, 0xFF	; 255
    202a:	8c 81       	ldd	r24, Y+4	; 0x04
    202c:	9d 81       	ldd	r25, Y+5	; 0x05
    202e:	82 0f       	add	r24, r18
    2030:	93 1f       	adc	r25, r19
    2032:	fc 01       	movw	r30, r24
    2034:	80 81       	ld	r24, Z
    2036:	8c 32       	cpi	r24, 0x2C	; 44
    2038:	a9 f5       	brne	.+106    	; 0x20a4 <_Z11ReceiveGAVRv+0x4a8>
									tempNum1[dmy++] = atoi(tempStringNum);
    203a:	ce 01       	movw	r24, r28
    203c:	c5 96       	adiw	r24, 0x35	; 53
    203e:	0e 94 1d 1a 	call	0x343a	; 0x343a <atoi>
    2042:	9c 01       	movw	r18, r24
    2044:	8e 81       	ldd	r24, Y+6	; 0x06
    2046:	9f 81       	ldd	r25, Y+7	; 0x07
    2048:	88 0f       	add	r24, r24
    204a:	99 1f       	adc	r25, r25
    204c:	ae 01       	movw	r20, r28
    204e:	4f 5f       	subi	r20, 0xFF	; 255
    2050:	5f 4f       	sbci	r21, 0xFF	; 255
    2052:	84 0f       	add	r24, r20
    2054:	95 1f       	adc	r25, r21
    2056:	8e 96       	adiw	r24, 0x2e	; 46
    2058:	fc 01       	movw	r30, r24
    205a:	31 83       	std	Z+1, r19	; 0x01
    205c:	20 83       	st	Z, r18
    205e:	8e 81       	ldd	r24, Y+6	; 0x06
    2060:	9f 81       	ldd	r25, Y+7	; 0x07
    2062:	01 96       	adiw	r24, 0x01	; 1
    2064:	9f 83       	std	Y+7, r25	; 0x07
    2066:	8e 83       	std	Y+6, r24	; 0x06
									for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    2068:	19 8a       	std	Y+17, r1	; 0x11
    206a:	18 8a       	std	Y+16, r1	; 0x10
    206c:	0e c0       	rjmp	.+28     	; 0x208a <_Z11ReceiveGAVRv+0x48e>
    206e:	9e 01       	movw	r18, r28
    2070:	2b 5c       	subi	r18, 0xCB	; 203
    2072:	3f 4f       	sbci	r19, 0xFF	; 255
    2074:	88 89       	ldd	r24, Y+16	; 0x10
    2076:	99 89       	ldd	r25, Y+17	; 0x11
    2078:	82 0f       	add	r24, r18
    207a:	93 1f       	adc	r25, r19
    207c:	fc 01       	movw	r30, r24
    207e:	10 82       	st	Z, r1
    2080:	88 89       	ldd	r24, Y+16	; 0x10
    2082:	99 89       	ldd	r25, Y+17	; 0x11
    2084:	01 96       	adiw	r24, 0x01	; 1
    2086:	99 8b       	std	Y+17, r25	; 0x11
    2088:	88 8b       	std	Y+16, r24	; 0x10
    208a:	41 e0       	ldi	r20, 0x01	; 1
    208c:	28 89       	ldd	r18, Y+16	; 0x10
    208e:	39 89       	ldd	r19, Y+17	; 0x11
    2090:	8a 85       	ldd	r24, Y+10	; 0x0a
    2092:	9b 85       	ldd	r25, Y+11	; 0x0b
    2094:	82 17       	cp	r24, r18
    2096:	93 07       	cpc	r25, r19
    2098:	0c f4       	brge	.+2      	; 0x209c <_Z11ReceiveGAVRv+0x4a0>
    209a:	40 e0       	ldi	r20, 0x00	; 0
    209c:	44 23       	and	r20, r20
    209e:	39 f7       	brne	.-50     	; 0x206e <_Z11ReceiveGAVRv+0x472>
									placement=0;
    20a0:	1b 86       	std	Y+11, r1	; 0x0b
    20a2:	1a 86       	std	Y+10, r1	; 0x0a
								} else;
								counter++;							
    20a4:	8c 81       	ldd	r24, Y+4	; 0x04
    20a6:	9d 81       	ldd	r25, Y+5	; 0x05
    20a8:	01 96       	adiw	r24, 0x01	; 1
    20aa:	9d 83       	std	Y+5, r25	; 0x05
    20ac:	8c 83       	std	Y+4, r24	; 0x04
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
							placement=0;
							counter++;	//get past the '/'
							
							//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
							while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    20ae:	9e 01       	movw	r18, r28
    20b0:	2d 5e       	subi	r18, 0xED	; 237
    20b2:	3f 4f       	sbci	r19, 0xFF	; 255
    20b4:	8c 81       	ldd	r24, Y+4	; 0x04
    20b6:	9d 81       	ldd	r25, Y+5	; 0x05
    20b8:	82 0f       	add	r24, r18
    20ba:	93 1f       	adc	r25, r19
    20bc:	fc 01       	movw	r30, r24
    20be:	80 81       	ld	r24, Z
    20c0:	8e 32       	cpi	r24, 0x2E	; 46
    20c2:	a1 f0       	breq	.+40     	; 0x20ec <_Z11ReceiveGAVRv+0x4f0>
    20c4:	9e 01       	movw	r18, r28
    20c6:	2d 5e       	subi	r18, 0xED	; 237
    20c8:	3f 4f       	sbci	r19, 0xFF	; 255
    20ca:	8c 81       	ldd	r24, Y+4	; 0x04
    20cc:	9d 81       	ldd	r25, Y+5	; 0x05
    20ce:	82 0f       	add	r24, r18
    20d0:	93 1f       	adc	r25, r19
    20d2:	fc 01       	movw	r30, r24
    20d4:	80 81       	ld	r24, Z
    20d6:	88 23       	and	r24, r24
    20d8:	49 f0       	breq	.+18     	; 0x20ec <_Z11ReceiveGAVRv+0x4f0>
    20da:	2c 81       	ldd	r18, Y+4	; 0x04
    20dc:	3d 81       	ldd	r19, Y+5	; 0x05
    20de:	8f a1       	lds	r24, 0x4f
    20e0:	98 a5       	lds	r25, 0x68
    20e2:	28 17       	cp	r18, r24
    20e4:	39 07       	cpc	r19, r25
    20e6:	11 f0       	breq	.+4      	; 0x20ec <_Z11ReceiveGAVRv+0x4f0>
    20e8:	81 e0       	ldi	r24, 0x01	; 1
    20ea:	01 c0       	rjmp	.+2      	; 0x20ee <_Z11ReceiveGAVRv+0x4f2>
    20ec:	80 e0       	ldi	r24, 0x00	; 0
    20ee:	88 23       	and	r24, r24
    20f0:	09 f0       	breq	.+2      	; 0x20f4 <_Z11ReceiveGAVRv+0x4f8>
    20f2:	6a cf       	rjmp	.-300    	; 0x1fc8 <_Z11ReceiveGAVRv+0x3cc>
									placement=0;
								} else;
								counter++;							
							}//end while
							//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
							if (recString[counter] == '.'){
    20f4:	9e 01       	movw	r18, r28
    20f6:	2d 5e       	subi	r18, 0xED	; 237
    20f8:	3f 4f       	sbci	r19, 0xFF	; 255
    20fa:	8c 81       	ldd	r24, Y+4	; 0x04
    20fc:	9d 81       	ldd	r25, Y+5	; 0x05
    20fe:	82 0f       	add	r24, r18
    2100:	93 1f       	adc	r25, r19
    2102:	fc 01       	movw	r30, r24
    2104:	80 81       	ld	r24, Z
    2106:	8e 32       	cpi	r24, 0x2E	; 46
    2108:	a9 f4       	brne	.+42     	; 0x2134 <_Z11ReceiveGAVRv+0x538>
								tempNum1[dmy] = atoi(tempStringNum);
    210a:	ce 01       	movw	r24, r28
    210c:	c5 96       	adiw	r24, 0x35	; 53
    210e:	0e 94 1d 1a 	call	0x343a	; 0x343a <atoi>
    2112:	9c 01       	movw	r18, r24
    2114:	8e 81       	ldd	r24, Y+6	; 0x06
    2116:	9f 81       	ldd	r25, Y+7	; 0x07
    2118:	88 0f       	add	r24, r24
    211a:	99 1f       	adc	r25, r25
    211c:	ae 01       	movw	r20, r28
    211e:	4f 5f       	subi	r20, 0xFF	; 255
    2120:	5f 4f       	sbci	r21, 0xFF	; 255
    2122:	84 0f       	add	r24, r20
    2124:	95 1f       	adc	r25, r21
    2126:	8e 96       	adiw	r24, 0x2e	; 46
    2128:	fc 01       	movw	r30, r24
    212a:	31 83       	std	Z+1, r19	; 0x01
    212c:	20 83       	st	Z, r18
								successDate=fTrue;
    212e:	81 e0       	ldi	r24, 0x01	; 1
    2130:	8b 83       	std	Y+3, r24	; 0x03
    2132:	0a c0       	rjmp	.+20     	; 0x2148 <_Z11ReceiveGAVRv+0x54c>
							} else {//something in the string was wrong, ACKBAD and then exit
								PrintGAVR("ACKBAD.");
    2134:	8b e1       	ldi	r24, 0x1B	; 27
    2136:	91 e0       	ldi	r25, 0x01	; 1
    2138:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
								state=5;
    213c:	85 e0       	ldi	r24, 0x05	; 5
    213e:	90 e0       	ldi	r25, 0x00	; 0
    2140:	90 93 ea 01 	sts	0x01EA, r25
    2144:	80 93 e9 01 	sts	0x01E9, r24
							}
						}//end if flagUserDate						
	
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0 && flagUserTime && successTime){
    2148:	89 a5       	lds	r24, 0x69
    214a:	9a a5       	lds	r25, 0x6a
    214c:	47 96       	adiw	r24, 0x17	; 23
    214e:	8f 32       	cpi	r24, 0x2F	; 47
    2150:	91 05       	cpc	r25, r1
    2152:	08 f5       	brcc	.+66     	; 0x2196 <_Z11ReceiveGAVRv+0x59a>
    2154:	8b a5       	lds	r24, 0x6b
    2156:	9c a5       	lds	r25, 0x6c
    2158:	cb 96       	adiw	r24, 0x3b	; 59
    215a:	87 37       	cpi	r24, 0x77	; 119
    215c:	91 05       	cpc	r25, r1
    215e:	d8 f4       	brcc	.+54     	; 0x2196 <_Z11ReceiveGAVRv+0x59a>
    2160:	8d a5       	lds	r24, 0x6d
    2162:	9e a5       	lds	r25, 0x6e
    2164:	cb 96       	adiw	r24, 0x3b	; 59
    2166:	87 37       	cpi	r24, 0x77	; 119
    2168:	91 05       	cpc	r25, r1
    216a:	a8 f4       	brcc	.+42     	; 0x2196 <_Z11ReceiveGAVRv+0x59a>
    216c:	80 91 d7 01 	lds	r24, 0x01D7
    2170:	88 23       	and	r24, r24
    2172:	89 f0       	breq	.+34     	; 0x2196 <_Z11ReceiveGAVRv+0x59a>
    2174:	8a 81       	ldd	r24, Y+2	; 0x02
    2176:	88 23       	and	r24, r24
    2178:	71 f0       	breq	.+28     	; 0x2196 <_Z11ReceiveGAVRv+0x59a>
							currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    217a:	69 a5       	lds	r22, 0x69
    217c:	7a a5       	lds	r23, 0x6a
    217e:	4b a5       	lds	r20, 0x6b
    2180:	5c a5       	lds	r21, 0x6c
    2182:	2d a5       	lds	r18, 0x6d
    2184:	3e a5       	lds	r19, 0x6e
    2186:	86 ea       	ldi	r24, 0xA6	; 166
    2188:	91 e0       	ldi	r25, 0x01	; 1
    218a:	0e 94 59 05 	call	0xab2	; 0xab2 <_ZN6myTime7setTimeEiii>
							flagNoGPSTime=fTrue;
    218e:	81 e0       	ldi	r24, 0x01	; 1
    2190:	80 93 da 01 	sts	0x01DA, r24
    2194:	0a c0       	rjmp	.+20     	; 0x21aa <_Z11ReceiveGAVRv+0x5ae>
						} else {
							PrintGAVR("ACKBAD.");
    2196:	8b e1       	ldi	r24, 0x1B	; 27
    2198:	91 e0       	ldi	r25, 0x01	; 1
    219a:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
							state=5;
    219e:	85 e0       	ldi	r24, 0x05	; 5
    21a0:	90 e0       	ldi	r25, 0x00	; 0
    21a2:	90 93 ea 01 	sts	0x01EA, r25
    21a6:	80 93 e9 01 	sts	0x01E9, r24
						}//end if-else time
						
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && flagUserDate && successDate){
    21aa:	8f a5       	lds	r24, 0x6f
    21ac:	98 a9       	sts	0x48, r25
    21ae:	0c 96       	adiw	r24, 0x0c	; 12
    21b0:	89 31       	cpi	r24, 0x19	; 25
    21b2:	91 05       	cpc	r25, r1
    21b4:	10 f5       	brcc	.+68     	; 0x21fa <_Z11ReceiveGAVRv+0x5fe>
    21b6:	89 a9       	sts	0x49, r24
    21b8:	9a a9       	sts	0x4a, r25
    21ba:	4f 96       	adiw	r24, 0x1f	; 31
    21bc:	8f 33       	cpi	r24, 0x3F	; 63
    21be:	91 05       	cpc	r25, r1
    21c0:	e0 f4       	brcc	.+56     	; 0x21fa <_Z11ReceiveGAVRv+0x5fe>
    21c2:	8b a9       	sts	0x4b, r24
    21c4:	9c a9       	sts	0x4c, r25
    21c6:	f7 e0       	ldi	r31, 0x07	; 7
    21c8:	80 3d       	cpi	r24, 0xD0	; 208
    21ca:	9f 07       	cpc	r25, r31
    21cc:	b4 f0       	brlt	.+44     	; 0x21fa <_Z11ReceiveGAVRv+0x5fe>
    21ce:	80 91 d6 01 	lds	r24, 0x01D6
    21d2:	88 23       	and	r24, r24
    21d4:	91 f0       	breq	.+36     	; 0x21fa <_Z11ReceiveGAVRv+0x5fe>
    21d6:	8b 81       	ldd	r24, Y+3	; 0x03
    21d8:	88 23       	and	r24, r24
    21da:	79 f0       	breq	.+30     	; 0x21fa <_Z11ReceiveGAVRv+0x5fe>
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
    21dc:	6f a5       	lds	r22, 0x6f
    21de:	78 a9       	sts	0x48, r23
    21e0:	49 a9       	sts	0x49, r20
    21e2:	5a a9       	sts	0x4a, r21
    21e4:	2b a9       	sts	0x4b, r18
    21e6:	3c a9       	sts	0x4c, r19
    21e8:	86 ea       	ldi	r24, 0xA6	; 166
    21ea:	91 e0       	ldi	r25, 0x01	; 1
    21ec:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
							state=5;
							break;
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if ((flagUserDate && successDate) && (flagUserTime && successTime)){
    21f0:	80 91 d6 01 	lds	r24, 0x01D6
    21f4:	88 23       	and	r24, r24
    21f6:	61 f4       	brne	.+24     	; 0x2210 <_Z11ReceiveGAVRv+0x614>
    21f8:	22 c0       	rjmp	.+68     	; 0x223e <_Z11ReceiveGAVRv+0x642>
						
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && flagUserDate && successDate){
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
						} else {
							PrintGAVR("ACKBAD.");
    21fa:	8b e1       	ldi	r24, 0x1B	; 27
    21fc:	91 e0       	ldi	r25, 0x01	; 1
    21fe:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
							state=5;
    2202:	85 e0       	ldi	r24, 0x05	; 5
    2204:	90 e0       	ldi	r25, 0x00	; 0
    2206:	90 93 ea 01 	sts	0x01EA, r25
    220a:	80 93 e9 01 	sts	0x01E9, r24
							break;
    220e:	a5 c0       	rjmp	.+330    	; 0x235a <_Z11ReceiveGAVRv+0x75e>
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if ((flagUserDate && successDate) && (flagUserTime && successTime)){
    2210:	8b 81       	ldd	r24, Y+3	; 0x03
    2212:	88 23       	and	r24, r24
    2214:	a1 f0       	breq	.+40     	; 0x223e <_Z11ReceiveGAVRv+0x642>
    2216:	80 91 d7 01 	lds	r24, 0x01D7
    221a:	88 23       	and	r24, r24
    221c:	81 f0       	breq	.+32     	; 0x223e <_Z11ReceiveGAVRv+0x642>
    221e:	8a 81       	ldd	r24, Y+2	; 0x02
    2220:	88 23       	and	r24, r24
    2222:	69 f0       	breq	.+26     	; 0x223e <_Z11ReceiveGAVRv+0x642>
							flagUserDate=fFalse;
    2224:	10 92 d6 01 	sts	0x01D6, r1
							flagUserTime=fFalse;
    2228:	10 92 d7 01 	sts	0x01D7, r1
							flagWaitingForReceiveGAVR=fFalse;
    222c:	10 92 d2 01 	sts	0x01D2, r1
							state=7;
    2230:	87 e0       	ldi	r24, 0x07	; 7
    2232:	90 e0       	ldi	r25, 0x00	; 0
    2234:	90 93 ea 01 	sts	0x01EA, r25
    2238:	80 93 e9 01 	sts	0x01E9, r24
    223c:	37 c0       	rjmp	.+110    	; 0x22ac <_Z11ReceiveGAVRv+0x6b0>
						} else if (flagUserDate && successDate && !flagUserTime){
    223e:	80 91 d6 01 	lds	r24, 0x01D6
    2242:	88 23       	and	r24, r24
    2244:	91 f0       	breq	.+36     	; 0x226a <_Z11ReceiveGAVRv+0x66e>
    2246:	8b 81       	ldd	r24, Y+3	; 0x03
    2248:	88 23       	and	r24, r24
    224a:	79 f0       	breq	.+30     	; 0x226a <_Z11ReceiveGAVRv+0x66e>
    224c:	80 91 d7 01 	lds	r24, 0x01D7
    2250:	88 23       	and	r24, r24
    2252:	59 f4       	brne	.+22     	; 0x226a <_Z11ReceiveGAVRv+0x66e>
							flagUserDate=fFalse;
    2254:	10 92 d6 01 	sts	0x01D6, r1
							flagWaitingForReceiveGAVR=fFalse;
    2258:	10 92 d2 01 	sts	0x01D2, r1
							state=7;
    225c:	87 e0       	ldi	r24, 0x07	; 7
    225e:	90 e0       	ldi	r25, 0x00	; 0
    2260:	90 93 ea 01 	sts	0x01EA, r25
    2264:	80 93 e9 01 	sts	0x01E9, r24
    2268:	21 c0       	rjmp	.+66     	; 0x22ac <_Z11ReceiveGAVRv+0x6b0>
						} else if (flagUserTime && successTime && !flagUserDate){
    226a:	80 91 d7 01 	lds	r24, 0x01D7
    226e:	88 23       	and	r24, r24
    2270:	91 f0       	breq	.+36     	; 0x2296 <_Z11ReceiveGAVRv+0x69a>
    2272:	8a 81       	ldd	r24, Y+2	; 0x02
    2274:	88 23       	and	r24, r24
    2276:	79 f0       	breq	.+30     	; 0x2296 <_Z11ReceiveGAVRv+0x69a>
    2278:	80 91 d6 01 	lds	r24, 0x01D6
    227c:	88 23       	and	r24, r24
    227e:	59 f4       	brne	.+22     	; 0x2296 <_Z11ReceiveGAVRv+0x69a>
							flagUserTime=fFalse;
    2280:	10 92 d7 01 	sts	0x01D7, r1
							flagWaitingForReceiveGAVR=fFalse;
    2284:	10 92 d2 01 	sts	0x01D2, r1
							state=7;
    2288:	87 e0       	ldi	r24, 0x07	; 7
    228a:	90 e0       	ldi	r25, 0x00	; 0
    228c:	90 93 ea 01 	sts	0x01EA, r25
    2290:	80 93 e9 01 	sts	0x01E9, r24
    2294:	0b c0       	rjmp	.+22     	; 0x22ac <_Z11ReceiveGAVRv+0x6b0>
						} else {
							PrintGAVR("ACKBAD.");
    2296:	8b e1       	ldi	r24, 0x1B	; 27
    2298:	91 e0       	ldi	r25, 0x01	; 1
    229a:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
							state=5;
    229e:	85 e0       	ldi	r24, 0x05	; 5
    22a0:	90 e0       	ldi	r25, 0x00	; 0
    22a2:	90 93 ea 01 	sts	0x01EA, r25
    22a6:	80 93 e9 01 	sts	0x01E9, r24
						}																										
    22aa:	0c c0       	rjmp	.+24     	; 0x22c4 <_Z11ReceiveGAVRv+0x6c8>
    22ac:	0b c0       	rjmp	.+22     	; 0x22c4 <_Z11ReceiveGAVRv+0x6c8>
					} else {	//don't need the date, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("ACKNO.");
    22ae:	88 e8       	ldi	r24, 0x88	; 136
    22b0:	91 e0       	ldi	r25, 0x01	; 1
    22b2:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
						state=5;
    22b6:	85 e0       	ldi	r24, 0x05	; 5
    22b8:	90 e0       	ldi	r25, 0x00	; 0
    22ba:	90 93 ea 01 	sts	0x01EA, r25
    22be:	80 93 e9 01 	sts	0x01E9, r24
					}// end if-else (flagUserDate || flagUserTime)					
					//Exit
					break;
    22c2:	4b c0       	rjmp	.+150    	; 0x235a <_Z11ReceiveGAVRv+0x75e>
    22c4:	4a c0       	rjmp	.+148    	; 0x235a <_Z11ReceiveGAVRv+0x75e>
					}//end case 3				
				case 4:{
					//Successful SYNNEED case.
					if (!flagUserDate && !flagUserTime){	//If we don't need the date or time, update with what we have.
    22c6:	80 91 d6 01 	lds	r24, 0x01D6
    22ca:	88 23       	and	r24, r24
    22cc:	79 f4       	brne	.+30     	; 0x22ec <_Z11ReceiveGAVRv+0x6f0>
    22ce:	80 91 d7 01 	lds	r24, 0x01D7
    22d2:	88 23       	and	r24, r24
    22d4:	59 f4       	brne	.+22     	; 0x22ec <_Z11ReceiveGAVRv+0x6f0>
						flagUpdateGAVRDate=fTrue;
    22d6:	81 e0       	ldi	r24, 0x01	; 1
    22d8:	80 93 d4 01 	sts	0x01D4, r24
						flagUpdateGAVRTime=fTrue;
    22dc:	81 e0       	ldi	r24, 0x01	; 1
    22de:	80 93 d3 01 	sts	0x01D3, r24
						PrintGAVR("ACKNEED.");				//respond with correct ack
    22e2:	8f e8       	ldi	r24, 0x8F	; 143
    22e4:	91 e0       	ldi	r25, 0x01	; 1
    22e6:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
    22ea:	04 c0       	rjmp	.+8      	; 0x22f4 <_Z11ReceiveGAVRv+0x6f8>
					} else {
						PrintGAVR("ACKNO.");	//say we can't give you anything, ask the user.
    22ec:	88 e8       	ldi	r24, 0x88	; 136
    22ee:	91 e0       	ldi	r25, 0x01	; 1
    22f0:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
						//Should be expecting something from the GAVR with user date and time, this reminds the GAVR.
					} //end if-else
					state=5;
    22f4:	85 e0       	ldi	r24, 0x05	; 5
    22f6:	90 e0       	ldi	r25, 0x00	; 0
    22f8:	90 93 ea 01 	sts	0x01EA, r25
    22fc:	80 93 e9 01 	sts	0x01E9, r24
					break;					
    2300:	2c c0       	rjmp	.+88     	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				}//end case 4
				case 5:{
					//Exit case
					flagReceivingGAVR=fFalse;
    2302:	10 92 d1 01 	sts	0x01D1, r1
					state=0;		//just in case
    2306:	10 92 ea 01 	sts	0x01EA, r1
    230a:	10 92 e9 01 	sts	0x01E9, r1
					break;
    230e:	25 c0       	rjmp	.+74     	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				}//end case 5
				case 6:{
					//Error in ACK case
					PrintGAVR("ACKERROR.");
    2310:	85 e7       	ldi	r24, 0x75	; 117
    2312:	91 e0       	ldi	r25, 0x01	; 1
    2314:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
					state=5;
    2318:	85 e0       	ldi	r24, 0x05	; 5
    231a:	90 e0       	ldi	r25, 0x00	; 0
    231c:	90 93 ea 01 	sts	0x01EA, r25
    2320:	80 93 e9 01 	sts	0x01E9, r24
					break;
    2324:	1a c0       	rjmp	.+52     	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				}//end case 6
				case 7:{
					//Successful grab of date/time case
					recString[0]='A';
    2326:	81 e4       	ldi	r24, 0x41	; 65
    2328:	8b 8b       	std	Y+19, r24	; 0x13
					recString[1]='C';
    232a:	83 e4       	ldi	r24, 0x43	; 67
    232c:	8c 8b       	std	Y+20, r24	; 0x14
					recString[2]='K';
    232e:	8b e4       	ldi	r24, 0x4B	; 75
    2330:	8d 8b       	std	Y+21, r24	; 0x15
					PrintGAVR(recString);
    2332:	ce 01       	movw	r24, r28
    2334:	43 96       	adiw	r24, 0x13	; 19
    2336:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
					state=5;
    233a:	85 e0       	ldi	r24, 0x05	; 5
    233c:	90 e0       	ldi	r25, 0x00	; 0
    233e:	90 93 ea 01 	sts	0x01EA, r25
    2342:	80 93 e9 01 	sts	0x01E9, r24
					break;		
    2346:	09 c0       	rjmp	.+18     	; 0x235a <_Z11ReceiveGAVRv+0x75e>
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
    2348:	10 92 ea 01 	sts	0x01EA, r1
    234c:	10 92 e9 01 	sts	0x01E9, r1
    2350:	18 a6       	lds	r17, 0xb8
    2352:	1f a2       	lds	r17, 0x9f
    2354:	10 92 d1 01 	sts	0x01D1, r1
    2358:	00 00       	nop
	char recChar, recString[20];
	volatile unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	//While Loop
	while (flagReceivingGAVR){
    235a:	90 91 d1 01 	lds	r25, 0x01D1
    235e:	81 e0       	ldi	r24, 0x01	; 1
    2360:	99 23       	and	r25, r25
    2362:	09 f4       	brne	.+2      	; 0x2366 <_Z11ReceiveGAVRv+0x76a>
    2364:	80 e0       	ldi	r24, 0x00	; 0
    2366:	88 23       	and	r24, r24
    2368:	09 f0       	breq	.+2      	; 0x236c <_Z11ReceiveGAVRv+0x770>
    236a:	57 cc       	rjmp	.-1874   	; 0x1c1a <_Z11ReceiveGAVRv+0x1e>
					break;		
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
			}//end switch	
		}//end while flagReceivingGAVR	
}
    236c:	e9 96       	adiw	r28, 0x39	; 57
    236e:	0f b6       	in	r0, 0x3f	; 63
    2370:	f8 94       	cli
    2372:	de bf       	out	0x3e, r29	; 62
    2374:	0f be       	out	0x3f, r0	; 63
    2376:	cd bf       	out	0x3d, r28	; 61
    2378:	df 91       	pop	r29
    237a:	cf 91       	pop	r28
    237c:	08 95       	ret

0000237e <_Z13printTimeDatehhh>:
/*************************************************************************************************************/
//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    237e:	cf 93       	push	r28
    2380:	df 93       	push	r29
    2382:	cd b7       	in	r28, 0x3d	; 61
    2384:	de b7       	in	r29, 0x3e	; 62
    2386:	eb 97       	sbiw	r28, 0x3b	; 59
    2388:	0f b6       	in	r0, 0x3f	; 63
    238a:	f8 94       	cli
    238c:	de bf       	out	0x3e, r29	; 62
    238e:	0f be       	out	0x3f, r0	; 63
    2390:	cd bf       	out	0x3d, r28	; 61
    2392:	89 af       	sts	0x79, r24
    2394:	6a af       	sts	0x7a, r22
    2396:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    2398:	89 ad       	sts	0x69, r24
    239a:	88 23       	and	r24, r24
    239c:	49 f1       	breq	.+82     	; 0x23f0 <_Z13printTimeDatehhh+0x72>
		if (pTime){
    239e:	8a ad       	sts	0x6a, r24
    23a0:	88 23       	and	r24, r24
    23a2:	89 f0       	breq	.+34     	; 0x23c6 <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    23a4:	86 ea       	ldi	r24, 0xA6	; 166
    23a6:	91 e0       	ldi	r25, 0x01	; 1
    23a8:	0e 94 ff 06 	call	0xdfe	; 0xdfe <_ZN6myTime7getTimeEv>
    23ac:	9c 01       	movw	r18, r24
    23ae:	ce 01       	movw	r24, r28
    23b0:	01 96       	adiw	r24, 0x01	; 1
    23b2:	b9 01       	movw	r22, r18
    23b4:	0e 94 4f 1a 	call	0x349e	; 0x349e <strcpy>
			PrintBone(tempTime);
    23b8:	ce 01       	movw	r24, r28
    23ba:	01 96       	adiw	r24, 0x01	; 1
    23bc:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
			PutUartChBone('/');
    23c0:	8f e2       	ldi	r24, 0x2F	; 47
    23c2:	0e 94 a2 08 	call	0x1144	; 0x1144 <_Z13PutUartChBonec>
		}
		if (pDate){
    23c6:	8b ad       	sts	0x6b, r24
    23c8:	88 23       	and	r24, r24
    23ca:	d1 f1       	breq	.+116    	; 0x2440 <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    23cc:	86 ea       	ldi	r24, 0xA6	; 166
    23ce:	91 e0       	ldi	r25, 0x01	; 1
    23d0:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    23d4:	9c 01       	movw	r18, r24
    23d6:	ce 01       	movw	r24, r28
    23d8:	0c 96       	adiw	r24, 0x0c	; 12
    23da:	b9 01       	movw	r22, r18
    23dc:	0e 94 4f 1a 	call	0x349e	; 0x349e <strcpy>
			PrintBone(tempDate);
    23e0:	ce 01       	movw	r24, r28
    23e2:	0c 96       	adiw	r24, 0x0c	; 12
    23e4:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
			PutUartChGAVR('.');
    23e8:	8e e2       	ldi	r24, 0x2E	; 46
    23ea:	0e 94 ed 08 	call	0x11da	; 0x11da <_Z13PutUartChGAVRc>
    23ee:	28 c0       	rjmp	.+80     	; 0x2440 <_Z13printTimeDatehhh+0xc2>
		}
	} else { //Printing to GAVR
		if (pTime){
    23f0:	8a ad       	sts	0x6a, r24
    23f2:	88 23       	and	r24, r24
    23f4:	89 f0       	breq	.+34     	; 0x2418 <_Z13printTimeDatehhh+0x9a>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    23f6:	86 ea       	ldi	r24, 0xA6	; 166
    23f8:	91 e0       	ldi	r25, 0x01	; 1
    23fa:	0e 94 ff 06 	call	0xdfe	; 0xdfe <_ZN6myTime7getTimeEv>
    23fe:	9c 01       	movw	r18, r24
    2400:	ce 01       	movw	r24, r28
    2402:	4d 96       	adiw	r24, 0x1d	; 29
    2404:	b9 01       	movw	r22, r18
    2406:	0e 94 4f 1a 	call	0x349e	; 0x349e <strcpy>
			PrintGAVR(tempTime);
    240a:	ce 01       	movw	r24, r28
    240c:	4d 96       	adiw	r24, 0x1d	; 29
    240e:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    2412:	8f e2       	ldi	r24, 0x2F	; 47
    2414:	0e 94 ed 08 	call	0x11da	; 0x11da <_Z13PutUartChGAVRc>
		}
		if (pDate){
    2418:	8b ad       	sts	0x6b, r24
    241a:	88 23       	and	r24, r24
    241c:	89 f0       	breq	.+34     	; 0x2440 <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    241e:	86 ea       	ldi	r24, 0xA6	; 166
    2420:	91 e0       	ldi	r25, 0x01	; 1
    2422:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    2426:	9c 01       	movw	r18, r24
    2428:	ce 01       	movw	r24, r28
    242a:	88 96       	adiw	r24, 0x28	; 40
    242c:	b9 01       	movw	r22, r18
    242e:	0e 94 4f 1a 	call	0x349e	; 0x349e <strcpy>
			PrintGAVR(tempDate);
    2432:	ce 01       	movw	r24, r28
    2434:	88 96       	adiw	r24, 0x28	; 40
    2436:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
			PutUartChGAVR('.');
    243a:	8e e2       	ldi	r24, 0x2E	; 46
    243c:	0e 94 ed 08 	call	0x11da	; 0x11da <_Z13PutUartChGAVRc>
		}
	}
}
    2440:	eb 96       	adiw	r28, 0x3b	; 59
    2442:	0f b6       	in	r0, 0x3f	; 63
    2444:	f8 94       	cli
    2446:	de bf       	out	0x3e, r29	; 62
    2448:	0f be       	out	0x3f, r0	; 63
    244a:	cd bf       	out	0x3d, r28	; 61
    244c:	df 91       	pop	r29
    244e:	cf 91       	pop	r28
    2450:	08 95       	ret

00002452 <__vector_6>:
/****************************************************************************************************************/


/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
//PCINT_17: Getting information from the GAVR
ISR(PCINT2_vect){
    2452:	1f 92       	push	r1
    2454:	0f 92       	push	r0
    2456:	0f b6       	in	r0, 0x3f	; 63
    2458:	0f 92       	push	r0
    245a:	11 24       	eor	r1, r1
    245c:	2f 93       	push	r18
    245e:	3f 93       	push	r19
    2460:	4f 93       	push	r20
    2462:	5f 93       	push	r21
    2464:	6f 93       	push	r22
    2466:	7f 93       	push	r23
    2468:	8f 93       	push	r24
    246a:	9f 93       	push	r25
    246c:	af 93       	push	r26
    246e:	bf 93       	push	r27
    2470:	ef 93       	push	r30
    2472:	ff 93       	push	r31
    2474:	cf 93       	push	r28
    2476:	df 93       	push	r29
    2478:	cd b7       	in	r28, 0x3d	; 61
    247a:	de b7       	in	r29, 0x3e	; 62
	if ((PINC & (1 << PCINT17)) && !flagShutdown){
    247c:	86 e2       	ldi	r24, 0x26	; 38
    247e:	90 e0       	ldi	r25, 0x00	; 0
    2480:	fc 01       	movw	r30, r24
    2482:	80 81       	ld	r24, Z
    2484:	88 2f       	mov	r24, r24
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	82 70       	andi	r24, 0x02	; 2
    248a:	90 70       	andi	r25, 0x00	; 0
    248c:	00 97       	sbiw	r24, 0x00	; 0
    248e:	31 f0       	breq	.+12     	; 0x249c <__vector_6+0x4a>
    2490:	80 91 dc 01 	lds	r24, 0x01DC
    2494:	88 23       	and	r24, r24
    2496:	11 f4       	brne	.+4      	; 0x249c <__vector_6+0x4a>
    2498:	81 e0       	ldi	r24, 0x01	; 1
    249a:	01 c0       	rjmp	.+2      	; 0x249e <__vector_6+0x4c>
    249c:	80 e0       	ldi	r24, 0x00	; 0
    249e:	88 23       	and	r24, r24
    24a0:	c9 f0       	breq	.+50     	; 0x24d4 <__vector_6+0x82>
		//Do work, correct interrupt
		UCSR1B |= (1 << RXCIE1);
    24a2:	89 ec       	ldi	r24, 0xC9	; 201
    24a4:	90 e0       	ldi	r25, 0x00	; 0
    24a6:	29 ec       	ldi	r18, 0xC9	; 201
    24a8:	30 e0       	ldi	r19, 0x00	; 0
    24aa:	f9 01       	movw	r30, r18
    24ac:	20 81       	ld	r18, Z
    24ae:	20 68       	ori	r18, 0x80	; 128
    24b0:	fc 01       	movw	r30, r24
    24b2:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;
    24b4:	10 92 ce 01 	sts	0x01CE, r1
		flagNormalMode=fFalse;
    24b8:	10 92 d0 01 	sts	0x01D0, r1
		__killCommINT();
    24bc:	8d e3       	ldi	r24, 0x3D	; 61
    24be:	90 e0       	ldi	r25, 0x00	; 0
    24c0:	fc 01       	movw	r30, r24
    24c2:	10 82       	st	Z, r1
    24c4:	8d e6       	ldi	r24, 0x6D	; 109
    24c6:	90 e0       	ldi	r25, 0x00	; 0
    24c8:	fc 01       	movw	r30, r24
    24ca:	10 82       	st	Z, r1
		//Acknowledge
		PrintGAVR("ACKG");
    24cc:	88 e9       	ldi	r24, 0x98	; 152
    24ce:	91 e0       	ldi	r25, 0x01	; 1
    24d0:	0e 94 0b 09 	call	0x1216	; 0x1216 <_Z9PrintGAVRPc>
	}
}	
    24d4:	df 91       	pop	r29
    24d6:	cf 91       	pop	r28
    24d8:	ff 91       	pop	r31
    24da:	ef 91       	pop	r30
    24dc:	bf 91       	pop	r27
    24de:	af 91       	pop	r26
    24e0:	9f 91       	pop	r25
    24e2:	8f 91       	pop	r24
    24e4:	7f 91       	pop	r23
    24e6:	6f 91       	pop	r22
    24e8:	5f 91       	pop	r21
    24ea:	4f 91       	pop	r20
    24ec:	3f 91       	pop	r19
    24ee:	2f 91       	pop	r18
    24f0:	0f 90       	pop	r0
    24f2:	0f be       	out	0x3f, r0	; 63
    24f4:	0f 90       	pop	r0
    24f6:	1f 90       	pop	r1
    24f8:	18 95       	reti

000024fa <__vector_3>:

//INT2: Getting information from BeagleBone
ISR(INT2_vect){	//about to get time, get things ready
    24fa:	1f 92       	push	r1
    24fc:	0f 92       	push	r0
    24fe:	0f b6       	in	r0, 0x3f	; 63
    2500:	0f 92       	push	r0
    2502:	11 24       	eor	r1, r1
    2504:	2f 93       	push	r18
    2506:	3f 93       	push	r19
    2508:	4f 93       	push	r20
    250a:	5f 93       	push	r21
    250c:	6f 93       	push	r22
    250e:	7f 93       	push	r23
    2510:	8f 93       	push	r24
    2512:	9f 93       	push	r25
    2514:	af 93       	push	r26
    2516:	bf 93       	push	r27
    2518:	ef 93       	push	r30
    251a:	ff 93       	push	r31
    251c:	cf 93       	push	r28
    251e:	df 93       	push	r29
    2520:	cd b7       	in	r28, 0x3d	; 61
    2522:	de b7       	in	r29, 0x3e	; 62
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    2524:	80 91 dc 01 	lds	r24, 0x01DC
    2528:	88 23       	and	r24, r24
    252a:	c9 f4       	brne	.+50     	; 0x255e <__vector_3+0x64>
		UCSR0B |= (1 << RXCIE0);
    252c:	81 ec       	ldi	r24, 0xC1	; 193
    252e:	90 e0       	ldi	r25, 0x00	; 0
    2530:	21 ec       	ldi	r18, 0xC1	; 193
    2532:	30 e0       	ldi	r19, 0x00	; 0
    2534:	f9 01       	movw	r30, r18
    2536:	20 81       	ld	r18, Z
    2538:	20 68       	ori	r18, 0x80	; 128
    253a:	fc 01       	movw	r30, r24
    253c:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    253e:	10 92 ce 01 	sts	0x01CE, r1
		flagNormalMode=fFalse;
    2542:	10 92 d0 01 	sts	0x01D0, r1
		__killCommINT();
    2546:	8d e3       	ldi	r24, 0x3D	; 61
    2548:	90 e0       	ldi	r25, 0x00	; 0
    254a:	fc 01       	movw	r30, r24
    254c:	10 82       	st	Z, r1
    254e:	8d e6       	ldi	r24, 0x6D	; 109
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	fc 01       	movw	r30, r24
    2554:	10 82       	st	Z, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("ACKT");
    2556:	8d e9       	ldi	r24, 0x9D	; 157
    2558:	91 e0       	ldi	r25, 0x01	; 1
    255a:	0e 94 c0 08 	call	0x1180	; 0x1180 <_Z9PrintBonePc>
	}	
}
    255e:	df 91       	pop	r29
    2560:	cf 91       	pop	r28
    2562:	ff 91       	pop	r31
    2564:	ef 91       	pop	r30
    2566:	bf 91       	pop	r27
    2568:	af 91       	pop	r26
    256a:	9f 91       	pop	r25
    256c:	8f 91       	pop	r24
    256e:	7f 91       	pop	r23
    2570:	6f 91       	pop	r22
    2572:	5f 91       	pop	r21
    2574:	4f 91       	pop	r20
    2576:	3f 91       	pop	r19
    2578:	2f 91       	pop	r18
    257a:	0f 90       	pop	r0
    257c:	0f be       	out	0x3f, r0	; 63
    257e:	0f 90       	pop	r0
    2580:	1f 90       	pop	r1
    2582:	18 95       	reti

00002584 <__vector_11>:

//RTC Timer.
ISR(TIMER2_OVF_vect){
    2584:	1f 92       	push	r1
    2586:	0f 92       	push	r0
    2588:	0f b6       	in	r0, 0x3f	; 63
    258a:	0f 92       	push	r0
    258c:	11 24       	eor	r1, r1
    258e:	2f 93       	push	r18
    2590:	3f 93       	push	r19
    2592:	4f 93       	push	r20
    2594:	5f 93       	push	r21
    2596:	6f 93       	push	r22
    2598:	7f 93       	push	r23
    259a:	8f 93       	push	r24
    259c:	9f 93       	push	r25
    259e:	af 93       	push	r26
    25a0:	bf 93       	push	r27
    25a2:	ef 93       	push	r30
    25a4:	ff 93       	push	r31
    25a6:	cf 93       	push	r28
    25a8:	df 93       	push	r29
    25aa:	cd b7       	in	r28, 0x3d	; 61
    25ac:	de b7       	in	r29, 0x3e	; 62
	volatile static int timeOut = 0;
	volatile static int gavrSendTimeout=0, boneReceiveTimeout=0, gavrReceiveTimeout=0;
	
	currentTime.addSeconds(1);
    25ae:	86 ea       	ldi	r24, 0xA6	; 166
    25b0:	91 e0       	ldi	r25, 0x01	; 1
    25b2:	61 e0       	ldi	r22, 0x01	; 1
    25b4:	70 e0       	ldi	r23, 0x00	; 0
    25b6:	0e 94 77 06 	call	0xcee	; 0xcee <_ZN6myTime10addSecondsEi>
	
	//GAVR Transmission Timeout
	if (flagSendingGAVR && gavrSendTimeout <=COMM_TIMEOUT_SEC){gavrSendTimeout++;}
    25ba:	80 91 d5 01 	lds	r24, 0x01D5
    25be:	88 23       	and	r24, r24
    25c0:	49 f0       	breq	.+18     	; 0x25d4 <__vector_11+0x50>
    25c2:	80 91 e1 01 	lds	r24, 0x01E1
    25c6:	90 91 e2 01 	lds	r25, 0x01E2
    25ca:	84 30       	cpi	r24, 0x04	; 4
    25cc:	91 05       	cpc	r25, r1
    25ce:	14 f4       	brge	.+4      	; 0x25d4 <__vector_11+0x50>
    25d0:	81 e0       	ldi	r24, 0x01	; 1
    25d2:	01 c0       	rjmp	.+2      	; 0x25d6 <__vector_11+0x52>
    25d4:	80 e0       	ldi	r24, 0x00	; 0
    25d6:	88 23       	and	r24, r24
    25d8:	51 f0       	breq	.+20     	; 0x25ee <__vector_11+0x6a>
    25da:	80 91 e1 01 	lds	r24, 0x01E1
    25de:	90 91 e2 01 	lds	r25, 0x01E2
    25e2:	01 96       	adiw	r24, 0x01	; 1
    25e4:	90 93 e2 01 	sts	0x01E2, r25
    25e8:	80 93 e1 01 	sts	0x01E1, r24
    25ec:	39 c0       	rjmp	.+114    	; 0x2660 <__vector_11+0xdc>
	else if (flagSendingGAVR && gavrSendTimeout > COMM_TIMEOUT_SEC){flagSendingGAVR=fFalse; gavrSendTimeout=0; __enableCommINT();}
    25ee:	80 91 d5 01 	lds	r24, 0x01D5
    25f2:	88 23       	and	r24, r24
    25f4:	49 f0       	breq	.+18     	; 0x2608 <__vector_11+0x84>
    25f6:	80 91 e1 01 	lds	r24, 0x01E1
    25fa:	90 91 e2 01 	lds	r25, 0x01E2
    25fe:	84 30       	cpi	r24, 0x04	; 4
    2600:	91 05       	cpc	r25, r1
    2602:	14 f0       	brlt	.+4      	; 0x2608 <__vector_11+0x84>
    2604:	81 e0       	ldi	r24, 0x01	; 1
    2606:	01 c0       	rjmp	.+2      	; 0x260a <__vector_11+0x86>
    2608:	80 e0       	ldi	r24, 0x00	; 0
    260a:	88 23       	and	r24, r24
    260c:	a9 f0       	breq	.+42     	; 0x2638 <__vector_11+0xb4>
    260e:	10 92 d5 01 	sts	0x01D5, r1
    2612:	10 92 e2 01 	sts	0x01E2, r1
    2616:	10 92 e1 01 	sts	0x01E1, r1
    261a:	8d e3       	ldi	r24, 0x3D	; 61
    261c:	90 e0       	ldi	r25, 0x00	; 0
    261e:	2d e3       	ldi	r18, 0x3D	; 61
    2620:	30 e0       	ldi	r19, 0x00	; 0
    2622:	f9 01       	movw	r30, r18
    2624:	20 81       	ld	r18, Z
    2626:	24 60       	ori	r18, 0x04	; 4
    2628:	fc 01       	movw	r30, r24
    262a:	20 83       	st	Z, r18
    262c:	8d e6       	ldi	r24, 0x6D	; 109
    262e:	90 e0       	ldi	r25, 0x00	; 0
    2630:	22 e0       	ldi	r18, 0x02	; 2
    2632:	fc 01       	movw	r30, r24
    2634:	20 83       	st	Z, r18
    2636:	14 c0       	rjmp	.+40     	; 0x2660 <__vector_11+0xdc>
	else if (!flagSendingGAVR && gavrSendTimeout > 0){gavrSendTimeout=0;}
    2638:	80 91 d5 01 	lds	r24, 0x01D5
    263c:	88 23       	and	r24, r24
    263e:	49 f4       	brne	.+18     	; 0x2652 <__vector_11+0xce>
    2640:	80 91 e1 01 	lds	r24, 0x01E1
    2644:	90 91 e2 01 	lds	r25, 0x01E2
    2648:	18 16       	cp	r1, r24
    264a:	19 06       	cpc	r1, r25
    264c:	14 f4       	brge	.+4      	; 0x2652 <__vector_11+0xce>
    264e:	81 e0       	ldi	r24, 0x01	; 1
    2650:	01 c0       	rjmp	.+2      	; 0x2654 <__vector_11+0xd0>
    2652:	80 e0       	ldi	r24, 0x00	; 0
    2654:	88 23       	and	r24, r24
    2656:	21 f0       	breq	.+8      	; 0x2660 <__vector_11+0xdc>
    2658:	10 92 e2 01 	sts	0x01E2, r1
    265c:	10 92 e1 01 	sts	0x01E1, r1
	else;
	
	//BeagleBone Reception Timeout
	if (flagReceivingBone && boneReceiveTimeout <=COMM_TIMEOUT_SEC){boneReceiveTimeout++;}
    2660:	80 91 cf 01 	lds	r24, 0x01CF
    2664:	88 23       	and	r24, r24
    2666:	49 f0       	breq	.+18     	; 0x267a <__vector_11+0xf6>
    2668:	80 91 e3 01 	lds	r24, 0x01E3
    266c:	90 91 e4 01 	lds	r25, 0x01E4
    2670:	84 30       	cpi	r24, 0x04	; 4
    2672:	91 05       	cpc	r25, r1
    2674:	14 f4       	brge	.+4      	; 0x267a <__vector_11+0xf6>
    2676:	81 e0       	ldi	r24, 0x01	; 1
    2678:	01 c0       	rjmp	.+2      	; 0x267c <__vector_11+0xf8>
    267a:	80 e0       	ldi	r24, 0x00	; 0
    267c:	88 23       	and	r24, r24
    267e:	51 f0       	breq	.+20     	; 0x2694 <__vector_11+0x110>
    2680:	80 91 e3 01 	lds	r24, 0x01E3
    2684:	90 91 e4 01 	lds	r25, 0x01E4
    2688:	01 96       	adiw	r24, 0x01	; 1
    268a:	90 93 e4 01 	sts	0x01E4, r25
    268e:	80 93 e3 01 	sts	0x01E3, r24
    2692:	39 c0       	rjmp	.+114    	; 0x2706 <__vector_11+0x182>
	else if (flagReceivingBone && boneReceiveTimeout > COMM_TIMEOUT_SEC){flagReceivingBone=fFalse; boneReceiveTimeout=0; __enableCommINT();}
    2694:	80 91 cf 01 	lds	r24, 0x01CF
    2698:	88 23       	and	r24, r24
    269a:	49 f0       	breq	.+18     	; 0x26ae <__vector_11+0x12a>
    269c:	80 91 e3 01 	lds	r24, 0x01E3
    26a0:	90 91 e4 01 	lds	r25, 0x01E4
    26a4:	84 30       	cpi	r24, 0x04	; 4
    26a6:	91 05       	cpc	r25, r1
    26a8:	14 f0       	brlt	.+4      	; 0x26ae <__vector_11+0x12a>
    26aa:	81 e0       	ldi	r24, 0x01	; 1
    26ac:	01 c0       	rjmp	.+2      	; 0x26b0 <__vector_11+0x12c>
    26ae:	80 e0       	ldi	r24, 0x00	; 0
    26b0:	88 23       	and	r24, r24
    26b2:	a9 f0       	breq	.+42     	; 0x26de <__vector_11+0x15a>
    26b4:	10 92 cf 01 	sts	0x01CF, r1
    26b8:	10 92 e4 01 	sts	0x01E4, r1
    26bc:	10 92 e3 01 	sts	0x01E3, r1
    26c0:	8d e3       	ldi	r24, 0x3D	; 61
    26c2:	90 e0       	ldi	r25, 0x00	; 0
    26c4:	2d e3       	ldi	r18, 0x3D	; 61
    26c6:	30 e0       	ldi	r19, 0x00	; 0
    26c8:	f9 01       	movw	r30, r18
    26ca:	20 81       	ld	r18, Z
    26cc:	24 60       	ori	r18, 0x04	; 4
    26ce:	fc 01       	movw	r30, r24
    26d0:	20 83       	st	Z, r18
    26d2:	8d e6       	ldi	r24, 0x6D	; 109
    26d4:	90 e0       	ldi	r25, 0x00	; 0
    26d6:	22 e0       	ldi	r18, 0x02	; 2
    26d8:	fc 01       	movw	r30, r24
    26da:	20 83       	st	Z, r18
    26dc:	14 c0       	rjmp	.+40     	; 0x2706 <__vector_11+0x182>
	else if (!flagReceivingBone && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    26de:	80 91 cf 01 	lds	r24, 0x01CF
    26e2:	88 23       	and	r24, r24
    26e4:	49 f4       	brne	.+18     	; 0x26f8 <__vector_11+0x174>
    26e6:	80 91 e3 01 	lds	r24, 0x01E3
    26ea:	90 91 e4 01 	lds	r25, 0x01E4
    26ee:	18 16       	cp	r1, r24
    26f0:	19 06       	cpc	r1, r25
    26f2:	14 f4       	brge	.+4      	; 0x26f8 <__vector_11+0x174>
    26f4:	81 e0       	ldi	r24, 0x01	; 1
    26f6:	01 c0       	rjmp	.+2      	; 0x26fa <__vector_11+0x176>
    26f8:	80 e0       	ldi	r24, 0x00	; 0
    26fa:	88 23       	and	r24, r24
    26fc:	21 f0       	breq	.+8      	; 0x2706 <__vector_11+0x182>
    26fe:	10 92 e4 01 	sts	0x01E4, r1
    2702:	10 92 e3 01 	sts	0x01E3, r1
	else;
	
	//GAVR Reception Timeout
	if (flagReceivingGAVR && gavrReceiveTimeout <= COMM_TIMEOUT_SEC){gavrReceiveTimeout++;}
    2706:	80 91 d1 01 	lds	r24, 0x01D1
    270a:	88 23       	and	r24, r24
    270c:	49 f0       	breq	.+18     	; 0x2720 <__vector_11+0x19c>
    270e:	80 91 e5 01 	lds	r24, 0x01E5
    2712:	90 91 e6 01 	lds	r25, 0x01E6
    2716:	84 30       	cpi	r24, 0x04	; 4
    2718:	91 05       	cpc	r25, r1
    271a:	14 f4       	brge	.+4      	; 0x2720 <__vector_11+0x19c>
    271c:	81 e0       	ldi	r24, 0x01	; 1
    271e:	01 c0       	rjmp	.+2      	; 0x2722 <__vector_11+0x19e>
    2720:	80 e0       	ldi	r24, 0x00	; 0
    2722:	88 23       	and	r24, r24
    2724:	51 f0       	breq	.+20     	; 0x273a <__vector_11+0x1b6>
    2726:	80 91 e5 01 	lds	r24, 0x01E5
    272a:	90 91 e6 01 	lds	r25, 0x01E6
    272e:	01 96       	adiw	r24, 0x01	; 1
    2730:	90 93 e6 01 	sts	0x01E6, r25
    2734:	80 93 e5 01 	sts	0x01E5, r24
    2738:	39 c0       	rjmp	.+114    	; 0x27ac <__vector_11+0x228>
	else if (flagReceivingGAVR && gavrReceiveTimeout > COMM_TIMEOUT_SEC){flagReceivingGAVR=fFalse; boneReceiveTimeout=0; __enableCommINT();}
    273a:	80 91 d1 01 	lds	r24, 0x01D1
    273e:	88 23       	and	r24, r24
    2740:	49 f0       	breq	.+18     	; 0x2754 <__vector_11+0x1d0>
    2742:	80 91 e5 01 	lds	r24, 0x01E5
    2746:	90 91 e6 01 	lds	r25, 0x01E6
    274a:	84 30       	cpi	r24, 0x04	; 4
    274c:	91 05       	cpc	r25, r1
    274e:	14 f0       	brlt	.+4      	; 0x2754 <__vector_11+0x1d0>
    2750:	81 e0       	ldi	r24, 0x01	; 1
    2752:	01 c0       	rjmp	.+2      	; 0x2756 <__vector_11+0x1d2>
    2754:	80 e0       	ldi	r24, 0x00	; 0
    2756:	88 23       	and	r24, r24
    2758:	a9 f0       	breq	.+42     	; 0x2784 <__vector_11+0x200>
    275a:	10 92 d1 01 	sts	0x01D1, r1
    275e:	10 92 e4 01 	sts	0x01E4, r1
    2762:	10 92 e3 01 	sts	0x01E3, r1
    2766:	8d e3       	ldi	r24, 0x3D	; 61
    2768:	90 e0       	ldi	r25, 0x00	; 0
    276a:	2d e3       	ldi	r18, 0x3D	; 61
    276c:	30 e0       	ldi	r19, 0x00	; 0
    276e:	f9 01       	movw	r30, r18
    2770:	20 81       	ld	r18, Z
    2772:	24 60       	ori	r18, 0x04	; 4
    2774:	fc 01       	movw	r30, r24
    2776:	20 83       	st	Z, r18
    2778:	8d e6       	ldi	r24, 0x6D	; 109
    277a:	90 e0       	ldi	r25, 0x00	; 0
    277c:	22 e0       	ldi	r18, 0x02	; 2
    277e:	fc 01       	movw	r30, r24
    2780:	20 83       	st	Z, r18
    2782:	14 c0       	rjmp	.+40     	; 0x27ac <__vector_11+0x228>
	else if (!flagReceivingGAVR && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    2784:	80 91 d1 01 	lds	r24, 0x01D1
    2788:	88 23       	and	r24, r24
    278a:	49 f4       	brne	.+18     	; 0x279e <__vector_11+0x21a>
    278c:	80 91 e3 01 	lds	r24, 0x01E3
    2790:	90 91 e4 01 	lds	r25, 0x01E4
    2794:	18 16       	cp	r1, r24
    2796:	19 06       	cpc	r1, r25
    2798:	14 f4       	brge	.+4      	; 0x279e <__vector_11+0x21a>
    279a:	81 e0       	ldi	r24, 0x01	; 1
    279c:	01 c0       	rjmp	.+2      	; 0x27a0 <__vector_11+0x21c>
    279e:	80 e0       	ldi	r24, 0x00	; 0
    27a0:	88 23       	and	r24, r24
    27a2:	21 f0       	breq	.+8      	; 0x27ac <__vector_11+0x228>
    27a4:	10 92 e4 01 	sts	0x01E4, r1
    27a8:	10 92 e3 01 	sts	0x01E3, r1
	else;

}
    27ac:	df 91       	pop	r29
    27ae:	cf 91       	pop	r28
    27b0:	ff 91       	pop	r31
    27b2:	ef 91       	pop	r30
    27b4:	bf 91       	pop	r27
    27b6:	af 91       	pop	r26
    27b8:	9f 91       	pop	r25
    27ba:	8f 91       	pop	r24
    27bc:	7f 91       	pop	r23
    27be:	6f 91       	pop	r22
    27c0:	5f 91       	pop	r21
    27c2:	4f 91       	pop	r20
    27c4:	3f 91       	pop	r19
    27c6:	2f 91       	pop	r18
    27c8:	0f 90       	pop	r0
    27ca:	0f be       	out	0x3f, r0	; 63
    27cc:	0f 90       	pop	r0
    27ce:	1f 90       	pop	r1
    27d0:	18 95       	reti

000027d2 <__vector_20>:

//UART Receive from BeagleBone
ISR(USART0_RX_vect){
    27d2:	1f 92       	push	r1
    27d4:	0f 92       	push	r0
    27d6:	0f b6       	in	r0, 0x3f	; 63
    27d8:	0f 92       	push	r0
    27da:	11 24       	eor	r1, r1
    27dc:	2f 93       	push	r18
    27de:	3f 93       	push	r19
    27e0:	8f 93       	push	r24
    27e2:	9f 93       	push	r25
    27e4:	ef 93       	push	r30
    27e6:	ff 93       	push	r31
    27e8:	cf 93       	push	r28
    27ea:	df 93       	push	r29
    27ec:	cd b7       	in	r28, 0x3d	; 61
    27ee:	de b7       	in	r29, 0x3e	; 62
	UCSR0B &= ~(1 << RXCIE0);
    27f0:	81 ec       	ldi	r24, 0xC1	; 193
    27f2:	90 e0       	ldi	r25, 0x00	; 0
    27f4:	21 ec       	ldi	r18, 0xC1	; 193
    27f6:	30 e0       	ldi	r19, 0x00	; 0
    27f8:	f9 01       	movw	r30, r18
    27fa:	20 81       	ld	r18, Z
    27fc:	2f 77       	andi	r18, 0x7F	; 127
    27fe:	fc 01       	movw	r30, r24
    2800:	20 83       	st	Z, r18
	__killCommINT();				//make sure all interrupts are disabled that could cripple protocol
    2802:	8d e3       	ldi	r24, 0x3D	; 61
    2804:	90 e0       	ldi	r25, 0x00	; 0
    2806:	fc 01       	movw	r30, r24
    2808:	10 82       	st	Z, r1
    280a:	8d e6       	ldi	r24, 0x6D	; 109
    280c:	90 e0       	ldi	r25, 0x00	; 0
    280e:	fc 01       	movw	r30, r24
    2810:	10 82       	st	Z, r1
	flagReceivingBone=fTrue;
    2812:	81 e0       	ldi	r24, 0x01	; 1
    2814:	80 93 cf 01 	sts	0x01CF, r24
}
    2818:	df 91       	pop	r29
    281a:	cf 91       	pop	r28
    281c:	ff 91       	pop	r31
    281e:	ef 91       	pop	r30
    2820:	9f 91       	pop	r25
    2822:	8f 91       	pop	r24
    2824:	3f 91       	pop	r19
    2826:	2f 91       	pop	r18
    2828:	0f 90       	pop	r0
    282a:	0f be       	out	0x3f, r0	; 63
    282c:	0f 90       	pop	r0
    282e:	1f 90       	pop	r1
    2830:	18 95       	reti

00002832 <__vector_28>:

ISR(USART1_RX_vect){
    2832:	1f 92       	push	r1
    2834:	0f 92       	push	r0
    2836:	0f b6       	in	r0, 0x3f	; 63
    2838:	0f 92       	push	r0
    283a:	11 24       	eor	r1, r1
    283c:	2f 93       	push	r18
    283e:	3f 93       	push	r19
    2840:	8f 93       	push	r24
    2842:	9f 93       	push	r25
    2844:	ef 93       	push	r30
    2846:	ff 93       	push	r31
    2848:	cf 93       	push	r28
    284a:	df 93       	push	r29
    284c:	cd b7       	in	r28, 0x3d	; 61
    284e:	de b7       	in	r29, 0x3e	; 62
	UCSR1B &= ~(1 <<RXCIE1);	//disable interrupt
    2850:	89 ec       	ldi	r24, 0xC9	; 201
    2852:	90 e0       	ldi	r25, 0x00	; 0
    2854:	29 ec       	ldi	r18, 0xC9	; 201
    2856:	30 e0       	ldi	r19, 0x00	; 0
    2858:	f9 01       	movw	r30, r18
    285a:	20 81       	ld	r18, Z
    285c:	2f 77       	andi	r18, 0x7F	; 127
    285e:	fc 01       	movw	r30, r24
    2860:	20 83       	st	Z, r18
	__killCommINT();
    2862:	8d e3       	ldi	r24, 0x3D	; 61
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	fc 01       	movw	r30, r24
    2868:	10 82       	st	Z, r1
    286a:	8d e6       	ldi	r24, 0x6D	; 109
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	fc 01       	movw	r30, r24
    2870:	10 82       	st	Z, r1
	flagReceivingGAVR=fTrue;
    2872:	81 e0       	ldi	r24, 0x01	; 1
    2874:	80 93 d1 01 	sts	0x01D1, r24
}
    2878:	df 91       	pop	r29
    287a:	cf 91       	pop	r28
    287c:	ff 91       	pop	r31
    287e:	ef 91       	pop	r30
    2880:	9f 91       	pop	r25
    2882:	8f 91       	pop	r24
    2884:	3f 91       	pop	r19
    2886:	2f 91       	pop	r18
    2888:	0f 90       	pop	r0
    288a:	0f be       	out	0x3f, r0	; 63
    288c:	0f 90       	pop	r0
    288e:	1f 90       	pop	r1
    2890:	18 95       	reti

00002892 <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    2892:	cf 93       	push	r28
    2894:	df 93       	push	r29
    2896:	00 d0       	rcall	.+0      	; 0x2898 <main+0x6>
    2898:	cd b7       	in	r28, 0x3d	; 61
    289a:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    289c:	0e 94 aa 15 	call	0x2b54	; 0x2b54 <_Z10DeviceInitv>
	AppInit(MYUBRR);
    28a0:	81 e8       	ldi	r24, 0x81	; 129
    28a2:	90 e0       	ldi	r25, 0x00	; 0
    28a4:	0e 94 d1 15 	call	0x2ba2	; 0x2ba2 <_Z7AppInitj>
	EnableRTCTimer();
    28a8:	0e 94 e7 16 	call	0x2dce	; 0x2dce <_Z14EnableRTCTimerv>
	getDateTime_eeprom(fTrue,fTrue);
    28ac:	81 e0       	ldi	r24, 0x01	; 1
    28ae:	61 e0       	ldi	r22, 0x01	; 1
    28b0:	0e 94 8e 07 	call	0xf1c	; 0xf1c <_Z18getDateTime_eepromhh>
	sei();
    28b4:	78 94       	sei
	//Prep/make sure power/temp is good
	GetTemp();
    28b6:	0e 94 a8 18 	call	0x3150	; 0x3150 <_Z7GetTempv>
	//flagGoodTemp=fTrue;
	TakeADC();
    28ba:	0e 94 0b 18 	call	0x3016	; 0x3016 <_Z7TakeADCv>
	if (flagGoodVolts && flagGoodTemp){
    28be:	80 91 de 01 	lds	r24, 0x01DE
    28c2:	88 23       	and	r24, r24
    28c4:	d1 f0       	breq	.+52     	; 0x28fa <main+0x68>
    28c6:	80 91 dd 01 	lds	r24, 0x01DD
    28ca:	88 23       	and	r24, r24
    28cc:	b1 f0       	breq	.+44     	; 0x28fa <main+0x68>
		PowerUp(POWER_UP_INTERVAL);
    28ce:	88 eb       	ldi	r24, 0xB8	; 184
    28d0:	9b e0       	ldi	r25, 0x0B	; 11
    28d2:	0e 94 2e 19 	call	0x325c	; 0x325c <_Z7PowerUpj>
		__enableCommINT();
    28d6:	8d e3       	ldi	r24, 0x3D	; 61
    28d8:	90 e0       	ldi	r25, 0x00	; 0
    28da:	2d e3       	ldi	r18, 0x3D	; 61
    28dc:	30 e0       	ldi	r19, 0x00	; 0
    28de:	f9 01       	movw	r30, r18
    28e0:	20 81       	ld	r18, Z
    28e2:	24 60       	ori	r18, 0x04	; 4
    28e4:	fc 01       	movw	r30, r24
    28e6:	20 83       	st	Z, r18
    28e8:	8d e6       	ldi	r24, 0x6D	; 109
    28ea:	90 e0       	ldi	r25, 0x00	; 0
    28ec:	22 e0       	ldi	r18, 0x02	; 2
    28ee:	fc 01       	movw	r30, r24
    28f0:	20 83       	st	Z, r18
		flagFreshStart=fTrue;
    28f2:	81 e0       	ldi	r24, 0x01	; 1
    28f4:	80 93 e0 01 	sts	0x01E0, r24
    28f8:	07 c0       	rjmp	.+14     	; 0x2908 <main+0x76>
	}
	else {flagNormalMode=fTrue;flagFreshStart=fFalse;}
    28fa:	81 e0       	ldi	r24, 0x01	; 1
    28fc:	80 93 d0 01 	sts	0x01D0, r24
    2900:	10 92 e0 01 	sts	0x01E0, r1
    2904:	01 c0       	rjmp	.+2      	; 0x2908 <main+0x76>
		
	//main programming loop
	while(fTrue)
    2906:	00 00       	nop
	{				
		//If receiving UART string, go get rest of it.
		if (flagReceivingBone){
    2908:	80 91 cf 01 	lds	r24, 0x01CF
    290c:	88 23       	and	r24, r24
    290e:	d1 f0       	breq	.+52     	; 0x2944 <main+0xb2>
			ReceiveBone();
    2910:	0e 94 c2 0b 	call	0x1784	; 0x1784 <_Z11ReceiveBonev>
			__enableCommINT();
    2914:	8d e3       	ldi	r24, 0x3D	; 61
    2916:	90 e0       	ldi	r25, 0x00	; 0
    2918:	2d e3       	ldi	r18, 0x3D	; 61
    291a:	30 e0       	ldi	r19, 0x00	; 0
    291c:	f9 01       	movw	r30, r18
    291e:	20 81       	ld	r18, Z
    2920:	24 60       	ori	r18, 0x04	; 4
    2922:	fc 01       	movw	r30, r24
    2924:	20 83       	st	Z, r18
    2926:	8d e6       	ldi	r24, 0x6D	; 109
    2928:	90 e0       	ldi	r25, 0x00	; 0
    292a:	22 e0       	ldi	r18, 0x02	; 2
    292c:	fc 01       	movw	r30, r24
    292e:	20 83       	st	Z, r18
			if (!flagReceivingGAVR){		//Just in case there was an interrupt IMMEDIATELY after the enabling of Communication interrupts
    2930:	80 91 d1 01 	lds	r24, 0x01D1
    2934:	88 23       	and	r24, r24
    2936:	31 f4       	brne	.+12     	; 0x2944 <main+0xb2>
				flagGoToSleep=fTrue;
    2938:	81 e0       	ldi	r24, 0x01	; 1
    293a:	80 93 ce 01 	sts	0x01CE, r24
				flagNormalMode=fTrue;
    293e:	81 e0       	ldi	r24, 0x01	; 1
    2940:	80 93 d0 01 	sts	0x01D0, r24
			}			
		}
		
		//Receiving Data/Signals from GAVR
		if (flagReceivingGAVR){
    2944:	80 91 d1 01 	lds	r24, 0x01D1
    2948:	88 23       	and	r24, r24
    294a:	d1 f0       	breq	.+52     	; 0x2980 <main+0xee>
			ReceiveGAVR();
    294c:	0e 94 fe 0d 	call	0x1bfc	; 0x1bfc <_Z11ReceiveGAVRv>
			__enableCommINT();
    2950:	8d e3       	ldi	r24, 0x3D	; 61
    2952:	90 e0       	ldi	r25, 0x00	; 0
    2954:	2d e3       	ldi	r18, 0x3D	; 61
    2956:	30 e0       	ldi	r19, 0x00	; 0
    2958:	f9 01       	movw	r30, r18
    295a:	20 81       	ld	r18, Z
    295c:	24 60       	ori	r18, 0x04	; 4
    295e:	fc 01       	movw	r30, r24
    2960:	20 83       	st	Z, r18
    2962:	8d e6       	ldi	r24, 0x6D	; 109
    2964:	90 e0       	ldi	r25, 0x00	; 0
    2966:	22 e0       	ldi	r18, 0x02	; 2
    2968:	fc 01       	movw	r30, r24
    296a:	20 83       	st	Z, r18
			if (!flagReceivingBone){		//Just in case there was an interrupt IMMEDIATELY after the enabling of Communication interrupts
    296c:	80 91 cf 01 	lds	r24, 0x01CF
    2970:	88 23       	and	r24, r24
    2972:	31 f4       	brne	.+12     	; 0x2980 <main+0xee>
				flagGoToSleep=fTrue;
    2974:	81 e0       	ldi	r24, 0x01	; 1
    2976:	80 93 ce 01 	sts	0x01CE, r24
				flagNormalMode=fTrue;
    297a:	81 e0       	ldi	r24, 0x01	; 1
    297c:	80 93 d0 01 	sts	0x01D0, r24
			}			
		}
		
	
		//Communication with GAVR. Either updating the date/time on it or asking for date and time. The internal send machine deals with the flags.
		if (flagUpdateGAVRTime || flagUpdateGAVRDate || flagUserDate || flagUserTime && !flagWaitingForReceiveGAVR){
    2980:	80 91 d3 01 	lds	r24, 0x01D3
    2984:	88 23       	and	r24, r24
    2986:	81 f4       	brne	.+32     	; 0x29a8 <main+0x116>
    2988:	80 91 d4 01 	lds	r24, 0x01D4
    298c:	88 23       	and	r24, r24
    298e:	61 f4       	brne	.+24     	; 0x29a8 <main+0x116>
    2990:	80 91 d6 01 	lds	r24, 0x01D6
    2994:	88 23       	and	r24, r24
    2996:	41 f4       	brne	.+16     	; 0x29a8 <main+0x116>
    2998:	80 91 d7 01 	lds	r24, 0x01D7
    299c:	88 23       	and	r24, r24
    299e:	e1 f0       	breq	.+56     	; 0x29d8 <main+0x146>
    29a0:	80 91 d2 01 	lds	r24, 0x01D2
    29a4:	88 23       	and	r24, r24
    29a6:	c1 f4       	brne	.+48     	; 0x29d8 <main+0x146>
			__killCommINT();
    29a8:	8d e3       	ldi	r24, 0x3D	; 61
    29aa:	90 e0       	ldi	r25, 0x00	; 0
    29ac:	fc 01       	movw	r30, r24
    29ae:	10 82       	st	Z, r1
    29b0:	8d e6       	ldi	r24, 0x6D	; 109
    29b2:	90 e0       	ldi	r25, 0x00	; 0
    29b4:	fc 01       	movw	r30, r24
    29b6:	10 82       	st	Z, r1
			sendGAVR();
    29b8:	0e 94 38 09 	call	0x1270	; 0x1270 <_Z8sendGAVRv>
			__enableCommINT();
    29bc:	8d e3       	ldi	r24, 0x3D	; 61
    29be:	90 e0       	ldi	r25, 0x00	; 0
    29c0:	2d e3       	ldi	r18, 0x3D	; 61
    29c2:	30 e0       	ldi	r19, 0x00	; 0
    29c4:	f9 01       	movw	r30, r18
    29c6:	20 81       	ld	r18, Z
    29c8:	24 60       	ori	r18, 0x04	; 4
    29ca:	fc 01       	movw	r30, r24
    29cc:	20 83       	st	Z, r18
    29ce:	8d e6       	ldi	r24, 0x6D	; 109
    29d0:	90 e0       	ldi	r25, 0x00	; 0
    29d2:	22 e0       	ldi	r18, 0x02	; 2
    29d4:	fc 01       	movw	r30, r24
    29d6:	20 83       	st	Z, r18
		}

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    29d8:	80 91 d0 01 	lds	r24, 0x01D0
    29dc:	88 23       	and	r24, r24
    29de:	49 f1       	breq	.+82     	; 0x2a32 <main+0x1a0>
			if (currentTime.getMinutes()%30 == 0){
    29e0:	86 ea       	ldi	r24, 0xA6	; 166
    29e2:	91 e0       	ldi	r25, 0x01	; 1
    29e4:	0e 94 aa 04 	call	0x954	; 0x954 <_ZN6myTime10getMinutesEv>
    29e8:	9e e1       	ldi	r25, 0x1E	; 30
    29ea:	69 2f       	mov	r22, r25
    29ec:	0e 94 e4 19 	call	0x33c8	; 0x33c8 <__udivmodqi4>
    29f0:	89 2f       	mov	r24, r25
    29f2:	98 2f       	mov	r25, r24
    29f4:	81 e0       	ldi	r24, 0x01	; 1
    29f6:	99 23       	and	r25, r25
    29f8:	09 f0       	breq	.+2      	; 0x29fc <main+0x16a>
    29fa:	80 e0       	ldi	r24, 0x00	; 0
    29fc:	88 23       	and	r24, r24
    29fe:	c9 f0       	breq	.+50     	; 0x2a32 <main+0x1a0>
				if (currentTime.getHours()%12 == 0){
    2a00:	86 ea       	ldi	r24, 0xA6	; 166
    2a02:	91 e0       	ldi	r25, 0x01	; 1
    2a04:	0e 94 bb 04 	call	0x976	; 0x976 <_ZN6myTime8getHoursEv>
    2a08:	9c e0       	ldi	r25, 0x0C	; 12
    2a0a:	69 2f       	mov	r22, r25
    2a0c:	0e 94 e4 19 	call	0x33c8	; 0x33c8 <__udivmodqi4>
    2a10:	89 2f       	mov	r24, r25
    2a12:	98 2f       	mov	r25, r24
    2a14:	81 e0       	ldi	r24, 0x01	; 1
    2a16:	99 23       	and	r25, r25
    2a18:	09 f0       	breq	.+2      	; 0x2a1c <main+0x18a>
    2a1a:	80 e0       	ldi	r24, 0x00	; 0
    2a1c:	88 23       	and	r24, r24
    2a1e:	29 f0       	breq	.+10     	; 0x2a2a <main+0x198>
					saveDateTime_eeprom(fTrue,fTrue);
    2a20:	81 e0       	ldi	r24, 0x01	; 1
    2a22:	61 e0       	ldi	r22, 0x01	; 1
    2a24:	0e 94 46 08 	call	0x108c	; 0x108c <_Z19saveDateTime_eepromhh>
    2a28:	04 c0       	rjmp	.+8      	; 0x2a32 <main+0x1a0>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    2a2a:	81 e0       	ldi	r24, 0x01	; 1
    2a2c:	60 e0       	ldi	r22, 0x00	; 0
    2a2e:	0e 94 46 08 	call	0x108c	; 0x108c <_Z19saveDateTime_eepromhh>
				}	
			}						
		}
		
		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    2a32:	80 91 d0 01 	lds	r24, 0x01D0
    2a36:	88 23       	and	r24, r24
    2a38:	21 f1       	breq	.+72     	; 0x2a82 <main+0x1f0>
			TakeADC();
    2a3a:	0e 94 0b 18 	call	0x3016	; 0x3016 <_Z7TakeADCv>
			GetTemp();
    2a3e:	0e 94 a8 18 	call	0x3150	; 0x3150 <_Z7GetTempv>
			//If both are good & shutodwn is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    2a42:	80 91 de 01 	lds	r24, 0x01DE
    2a46:	88 23       	and	r24, r24
    2a48:	91 f0       	breq	.+36     	; 0x2a6e <main+0x1dc>
    2a4a:	80 91 dd 01 	lds	r24, 0x01DD
    2a4e:	88 23       	and	r24, r24
    2a50:	71 f0       	breq	.+28     	; 0x2a6e <main+0x1dc>
				PowerUp(POWER_UP_INTERVAL);
    2a52:	88 eb       	ldi	r24, 0xB8	; 184
    2a54:	9b e0       	ldi	r25, 0x0B	; 11
    2a56:	0e 94 2e 19 	call	0x325c	; 0x325c <_Z7PowerUpj>
				if( flagShutdown == fTrue){restart = fTrue;}
    2a5a:	80 91 dc 01 	lds	r24, 0x01DC
    2a5e:	81 30       	cpi	r24, 0x01	; 1
    2a60:	19 f4       	brne	.+6      	; 0x2a68 <main+0x1d6>
    2a62:	81 e0       	ldi	r24, 0x01	; 1
    2a64:	80 93 df 01 	sts	0x01DF, r24
				flagShutdown = fFalse;
    2a68:	10 92 dc 01 	sts	0x01DC, r1
    2a6c:	0a c0       	rjmp	.+20     	; 0x2a82 <main+0x1f0>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (flagShutdown == fFalse){
    2a6e:	80 91 dc 01 	lds	r24, 0x01DC
    2a72:	88 23       	and	r24, r24
    2a74:	19 f4       	brne	.+6      	; 0x2a7c <main+0x1ea>
					flagNewShutdown = fTrue;
    2a76:	81 e0       	ldi	r24, 0x01	; 1
    2a78:	80 93 db 01 	sts	0x01DB, r24
				}
				flagShutdown = fTrue;
    2a7c:	81 e0       	ldi	r24, 0x01	; 1
    2a7e:	80 93 dc 01 	sts	0x01DC, r24
			}
		}			
		
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    2a82:	80 91 db 01 	lds	r24, 0x01DB
    2a86:	88 23       	and	r24, r24
    2a88:	b9 f0       	breq	.+46     	; 0x2ab8 <main+0x226>
			//Make sure nothing messes with the routine that we care about
			__killCommINT();
    2a8a:	8d e3       	ldi	r24, 0x3D	; 61
    2a8c:	90 e0       	ldi	r25, 0x00	; 0
    2a8e:	fc 01       	movw	r30, r24
    2a90:	10 82       	st	Z, r1
    2a92:	8d e6       	ldi	r24, 0x6D	; 109
    2a94:	90 e0       	ldi	r25, 0x00	; 0
    2a96:	fc 01       	movw	r30, r24
    2a98:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    2a9a:	81 e0       	ldi	r24, 0x01	; 1
    2a9c:	80 93 ce 01 	sts	0x01CE, r24
			flagReceivingBone = fFalse;
    2aa0:	10 92 cf 01 	sts	0x01CF, r1
			flagNoGPSTime=fFalse;
    2aa4:	10 92 da 01 	sts	0x01DA, r1
			saveDateTime_eeprom(fTrue,fTrue);
    2aa8:	81 e0       	ldi	r24, 0x01	; 1
    2aaa:	61 e0       	ldi	r22, 0x01	; 1
    2aac:	0e 94 46 08 	call	0x108c	; 0x108c <_Z19saveDateTime_eepromhh>
			
			//Kill power--Alert comes in that function
			PowerDown();
    2ab0:	0e 94 70 19 	call	0x32e0	; 0x32e0 <_Z9PowerDownv>
			flagNewShutdown = fFalse;
    2ab4:	10 92 db 01 	sts	0x01DB, r1
		}
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    2ab8:	80 91 df 01 	lds	r24, 0x01DF
    2abc:	88 23       	and	r24, r24
    2abe:	a1 f1       	breq	.+104    	; 0x2b28 <main+0x296>
			__enableCommINT();	//enable BONE interrupt. Will come out with newest time. Give it 10 seconds to kill
    2ac0:	8d e3       	ldi	r24, 0x3D	; 61
    2ac2:	90 e0       	ldi	r25, 0x00	; 0
    2ac4:	2d e3       	ldi	r18, 0x3D	; 61
    2ac6:	30 e0       	ldi	r19, 0x00	; 0
    2ac8:	f9 01       	movw	r30, r18
    2aca:	20 81       	ld	r18, Z
    2acc:	24 60       	ori	r18, 0x04	; 4
    2ace:	fc 01       	movw	r30, r24
    2ad0:	20 83       	st	Z, r18
    2ad2:	8d e6       	ldi	r24, 0x6D	; 109
    2ad4:	90 e0       	ldi	r25, 0x00	; 0
    2ad6:	22 e0       	ldi	r18, 0x02	; 2
    2ad8:	fc 01       	movw	r30, r24
    2ada:	20 83       	st	Z, r18
			PowerUp(POWER_UP_INTERVAL);
    2adc:	88 eb       	ldi	r24, 0xB8	; 184
    2ade:	9b e0       	ldi	r25, 0x0B	; 11
    2ae0:	0e 94 2e 19 	call	0x325c	; 0x325c <_Z7PowerUpj>
			//Check to see if pins are ready. Use timeout of 10 seconds for pins to come high.
			int waitTime = 0;
    2ae4:	1a 82       	std	Y+2, r1	; 0x02
    2ae6:	19 82       	std	Y+1, r1	; 0x01
			while (waitTime < 3 && restart){waitTime++; Wait_sec(1);}
    2ae8:	09 c0       	rjmp	.+18     	; 0x2afc <main+0x26a>
    2aea:	89 81       	ldd	r24, Y+1	; 0x01
    2aec:	9a 81       	ldd	r25, Y+2	; 0x02
    2aee:	01 96       	adiw	r24, 0x01	; 1
    2af0:	9a 83       	std	Y+2, r25	; 0x02
    2af2:	89 83       	std	Y+1, r24	; 0x01
    2af4:	81 e0       	ldi	r24, 0x01	; 1
    2af6:	90 e0       	ldi	r25, 0x00	; 0
    2af8:	0e 94 56 17 	call	0x2eac	; 0x2eac <_Z8Wait_seci>
    2afc:	89 81       	ldd	r24, Y+1	; 0x01
    2afe:	9a 81       	ldd	r25, Y+2	; 0x02
    2b00:	83 30       	cpi	r24, 0x03	; 3
    2b02:	91 05       	cpc	r25, r1
    2b04:	34 f4       	brge	.+12     	; 0x2b12 <main+0x280>
    2b06:	80 91 df 01 	lds	r24, 0x01DF
    2b0a:	88 23       	and	r24, r24
    2b0c:	11 f0       	breq	.+4      	; 0x2b12 <main+0x280>
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	01 c0       	rjmp	.+2      	; 0x2b14 <main+0x282>
    2b12:	80 e0       	ldi	r24, 0x00	; 0
    2b14:	88 23       	and	r24, r24
    2b16:	49 f7       	brne	.-46     	; 0x2aea <main+0x258>
			flagUpdateGAVRDate=fTrue;
    2b18:	81 e0       	ldi	r24, 0x01	; 1
    2b1a:	80 93 d4 01 	sts	0x01D4, r24
			flagUpdateGAVRTime=fTrue;
    2b1e:	81 e0       	ldi	r24, 0x01	; 1
    2b20:	80 93 d3 01 	sts	0x01D3, r24
			flagNoGPSTime=fFalse;
    2b24:	10 92 da 01 	sts	0x01DA, r1
			//If we get to here, the flag is not reset or there was a timeout. If timout, goes to sleep and on the next cycle it's awake it will try and 
			//get an updated date and time from the BeagleBone. Always update GAVR.			
		}		
		
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep){GoToSleep(flagShutdown);}
    2b28:	80 91 ce 01 	lds	r24, 0x01CE
    2b2c:	88 23       	and	r24, r24
    2b2e:	21 f0       	breq	.+8      	; 0x2b38 <main+0x2a6>
    2b30:	80 91 dc 01 	lds	r24, 0x01DC
    2b34:	0e 94 8e 17 	call	0x2f1c	; 0x2f1c <_Z9GoToSleeph>
		
		//Add logic for an invalid date and time somehow getting in here
		if (flagInvalidDateTime){
    2b38:	80 91 d8 01 	lds	r24, 0x01D8
    2b3c:	88 23       	and	r24, r24
    2b3e:	09 f4       	brne	.+2      	; 0x2b42 <main+0x2b0>
    2b40:	e2 ce       	rjmp	.-572    	; 0x2906 <main+0x74>
			flagInvalidDateTime=fFalse;
    2b42:	10 92 d8 01 	sts	0x01D8, r1
			flagUserTime=fTrue;
    2b46:	81 e0       	ldi	r24, 0x01	; 1
    2b48:	80 93 d7 01 	sts	0x01D7, r24
			flagUserDate=fTrue;	//ask user to update/confirm both date and time
    2b4c:	81 e0       	ldi	r24, 0x01	; 1
    2b4e:	80 93 d6 01 	sts	0x01D6, r24
		flagFreshStart=fTrue;
	}
	else {flagNormalMode=fTrue;flagFreshStart=fFalse;}
		
	//main programming loop
	while(fTrue)
    2b52:	d9 ce       	rjmp	.-590    	; 0x2906 <main+0x74>

00002b54 <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    2b54:	cf 93       	push	r28
    2b56:	df 93       	push	r29
    2b58:	cd b7       	in	r28, 0x3d	; 61
    2b5a:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    2b5c:	81 e2       	ldi	r24, 0x21	; 33
    2b5e:	90 e0       	ldi	r25, 0x00	; 0
    2b60:	fc 01       	movw	r30, r24
    2b62:	10 82       	st	Z, r1
	DDRB = 0;
    2b64:	84 e2       	ldi	r24, 0x24	; 36
    2b66:	90 e0       	ldi	r25, 0x00	; 0
    2b68:	fc 01       	movw	r30, r24
    2b6a:	10 82       	st	Z, r1
	DDRC = 0;
    2b6c:	87 e2       	ldi	r24, 0x27	; 39
    2b6e:	90 e0       	ldi	r25, 0x00	; 0
    2b70:	fc 01       	movw	r30, r24
    2b72:	10 82       	st	Z, r1
	DDRD = 0;
    2b74:	8a e2       	ldi	r24, 0x2A	; 42
    2b76:	90 e0       	ldi	r25, 0x00	; 0
    2b78:	fc 01       	movw	r30, r24
    2b7a:	10 82       	st	Z, r1
	
	PORTA = 0;
    2b7c:	82 e2       	ldi	r24, 0x22	; 34
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	fc 01       	movw	r30, r24
    2b82:	10 82       	st	Z, r1
	PORTB = 0;
    2b84:	85 e2       	ldi	r24, 0x25	; 37
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	fc 01       	movw	r30, r24
    2b8a:	10 82       	st	Z, r1
	PORTC = 0;
    2b8c:	88 e2       	ldi	r24, 0x28	; 40
    2b8e:	90 e0       	ldi	r25, 0x00	; 0
    2b90:	fc 01       	movw	r30, r24
    2b92:	10 82       	st	Z, r1
	PORTD = 0;
    2b94:	8b e2       	ldi	r24, 0x2B	; 43
    2b96:	90 e0       	ldi	r25, 0x00	; 0
    2b98:	fc 01       	movw	r30, r24
    2b9a:	10 82       	st	Z, r1
}
    2b9c:	df 91       	pop	r29
    2b9e:	cf 91       	pop	r28
    2ba0:	08 95       	ret

00002ba2 <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    2ba2:	cf 93       	push	r28
    2ba4:	df 93       	push	r29
    2ba6:	00 d0       	rcall	.+0      	; 0x2ba8 <_Z7AppInitj+0x6>
    2ba8:	cd b7       	in	r28, 0x3d	; 61
    2baa:	de b7       	in	r29, 0x3e	; 62
    2bac:	9a 83       	std	Y+2, r25	; 0x02
    2bae:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    2bb0:	84 ec       	ldi	r24, 0xC4	; 196
    2bb2:	90 e0       	ldi	r25, 0x00	; 0
    2bb4:	29 81       	ldd	r18, Y+1	; 0x01
    2bb6:	fc 01       	movw	r30, r24
    2bb8:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    2bba:	85 ec       	ldi	r24, 0xC5	; 197
    2bbc:	90 e0       	ldi	r25, 0x00	; 0
    2bbe:	29 81       	ldd	r18, Y+1	; 0x01
    2bc0:	3a 81       	ldd	r19, Y+2	; 0x02
    2bc2:	23 2f       	mov	r18, r19
    2bc4:	33 27       	eor	r19, r19
    2bc6:	fc 01       	movw	r30, r24
    2bc8:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    2bca:	81 ec       	ldi	r24, 0xC1	; 193
    2bcc:	90 e0       	ldi	r25, 0x00	; 0
    2bce:	28 e1       	ldi	r18, 0x18	; 24
    2bd0:	fc 01       	movw	r30, r24
    2bd2:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    2bd4:	82 ec       	ldi	r24, 0xC2	; 194
    2bd6:	90 e0       	ldi	r25, 0x00	; 0
    2bd8:	26 e0       	ldi	r18, 0x06	; 6
    2bda:	fc 01       	movw	r30, r24
    2bdc:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Set BAUD for UART1
	UBRR1L = ubrr;
    2bde:	8c ec       	ldi	r24, 0xCC	; 204
    2be0:	90 e0       	ldi	r25, 0x00	; 0
    2be2:	29 81       	ldd	r18, Y+1	; 0x01
    2be4:	fc 01       	movw	r30, r24
    2be6:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);
    2be8:	85 ec       	ldi	r24, 0xC5	; 197
    2bea:	90 e0       	ldi	r25, 0x00	; 0
    2bec:	29 81       	ldd	r18, Y+1	; 0x01
    2bee:	3a 81       	ldd	r19, Y+2	; 0x02
    2bf0:	23 2f       	mov	r18, r19
    2bf2:	33 27       	eor	r19, r19
    2bf4:	fc 01       	movw	r30, r24
    2bf6:	20 83       	st	Z, r18
	//UCSR1A |= (1 << U2X1);
	
	//Enable UART_TX1 and UART_RX1
	UCSR1B = (1 << TXEN1)|(1 << RXEN1);
    2bf8:	89 ec       	ldi	r24, 0xC9	; 201
    2bfa:	90 e0       	ldi	r25, 0x00	; 0
    2bfc:	28 e1       	ldi	r18, 0x18	; 24
    2bfe:	fc 01       	movw	r30, r24
    2c00:	20 83       	st	Z, r18
	UCSR1C = (1 << UCSZ11)|(1 << UCSZ10);
    2c02:	8a ec       	ldi	r24, 0xCA	; 202
    2c04:	90 e0       	ldi	r25, 0x00	; 0
    2c06:	26 e0       	ldi	r18, 0x06	; 6
    2c08:	fc 01       	movw	r30, r24
    2c0a:	20 83       	st	Z, r18
	//UCSR1B |= (1 << RXCIE1);
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM2)|(1 << PRTIM0)|(1 << PRUSART1)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    2c0c:	84 e6       	ldi	r24, 0x64	; 100
    2c0e:	90 e0       	ldi	r25, 0x00	; 0
    2c10:	24 e6       	ldi	r18, 0x64	; 100
    2c12:	30 e0       	ldi	r19, 0x00	; 0
    2c14:	f9 01       	movw	r30, r18
    2c16:	20 81       	ld	r18, Z
    2c18:	2d 6f       	ori	r18, 0xFD	; 253
    2c1a:	fc 01       	movw	r30, r24
    2c1c:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    2c1e:	8a e2       	ldi	r24, 0x2A	; 42
    2c20:	90 e0       	ldi	r25, 0x00	; 0
    2c22:	2a e2       	ldi	r18, 0x2A	; 42
    2c24:	30 e0       	ldi	r19, 0x00	; 0
    2c26:	f9 01       	movw	r30, r18
    2c28:	20 81       	ld	r18, Z
    2c2a:	20 68       	ori	r18, 0x80	; 128
    2c2c:	fc 01       	movw	r30, r24
    2c2e:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    2c30:	87 e2       	ldi	r24, 0x27	; 39
    2c32:	90 e0       	ldi	r25, 0x00	; 0
    2c34:	27 e2       	ldi	r18, 0x27	; 39
    2c36:	30 e0       	ldi	r19, 0x00	; 0
    2c38:	f9 01       	movw	r30, r18
    2c3a:	20 81       	ld	r18, Z
    2c3c:	24 60       	ori	r18, 0x04	; 4
    2c3e:	fc 01       	movw	r30, r24
    2c40:	20 83       	st	Z, r18
	prtSLEEPled &= ~(1 << bnSLEEPled);	//turn off initially
    2c42:	8b e2       	ldi	r24, 0x2B	; 43
    2c44:	90 e0       	ldi	r25, 0x00	; 0
    2c46:	2b e2       	ldi	r18, 0x2B	; 43
    2c48:	30 e0       	ldi	r19, 0x00	; 0
    2c4a:	f9 01       	movw	r30, r18
    2c4c:	20 81       	ld	r18, Z
    2c4e:	2f 77       	andi	r18, 0x7F	; 127
    2c50:	fc 01       	movw	r30, r24
    2c52:	20 83       	st	Z, r18
	prtSTATUSled |= (1 << bnSTATUSled);	//turn on initially
    2c54:	88 e2       	ldi	r24, 0x28	; 40
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	28 e2       	ldi	r18, 0x28	; 40
    2c5a:	30 e0       	ldi	r19, 0x00	; 0
    2c5c:	f9 01       	movw	r30, r18
    2c5e:	20 81       	ld	r18, Z
    2c60:	24 60       	ori	r18, 0x04	; 4
    2c62:	fc 01       	movw	r30, r24
    2c64:	20 83       	st	Z, r18
	
	//Enable BB and GAVR alert pins...outputs, no pull by default.
	ddrBONEINT |= (1 << bnBBint);
    2c66:	81 e2       	ldi	r24, 0x21	; 33
    2c68:	90 e0       	ldi	r25, 0x00	; 0
    2c6a:	21 e2       	ldi	r18, 0x21	; 33
    2c6c:	30 e0       	ldi	r19, 0x00	; 0
    2c6e:	f9 01       	movw	r30, r18
    2c70:	20 81       	ld	r18, Z
    2c72:	24 60       	ori	r18, 0x04	; 4
    2c74:	fc 01       	movw	r30, r24
    2c76:	20 83       	st	Z, r18
	ddrGAVRINT |= (1 << bnGAVRint);
    2c78:	84 e2       	ldi	r24, 0x24	; 36
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	24 e2       	ldi	r18, 0x24	; 36
    2c7e:	30 e0       	ldi	r19, 0x00	; 0
    2c80:	f9 01       	movw	r30, r18
    2c82:	20 81       	ld	r18, Z
    2c84:	28 60       	ori	r18, 0x08	; 8
    2c86:	fc 01       	movw	r30, r24
    2c88:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrGAVRINT |= (1 << bnGAVRINT);
    2c8a:	84 e2       	ldi	r24, 0x24	; 36
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	24 e2       	ldi	r18, 0x24	; 36
    2c90:	30 e0       	ldi	r19, 0x00	; 0
    2c92:	f9 01       	movw	r30, r18
    2c94:	20 81       	ld	r18, Z
    2c96:	28 60       	ori	r18, 0x08	; 8
    2c98:	fc 01       	movw	r30, r24
    2c9a:	20 83       	st	Z, r18
	prtGAVRINT &=  ~(1 << bnGAVRINT);	//set low at first
    2c9c:	85 e2       	ldi	r24, 0x25	; 37
    2c9e:	90 e0       	ldi	r25, 0x00	; 0
    2ca0:	25 e2       	ldi	r18, 0x25	; 37
    2ca2:	30 e0       	ldi	r19, 0x00	; 0
    2ca4:	f9 01       	movw	r30, r18
    2ca6:	20 81       	ld	r18, Z
    2ca8:	27 7f       	andi	r18, 0xF7	; 247
    2caa:	fc 01       	movw	r30, r24
    2cac:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen)|(1 << bnBBen);
    2cae:	81 e2       	ldi	r24, 0x21	; 33
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	21 e2       	ldi	r18, 0x21	; 33
    2cb4:	30 e0       	ldi	r19, 0x00	; 0
    2cb6:	f9 01       	movw	r30, r18
    2cb8:	20 81       	ld	r18, Z
    2cba:	20 6f       	ori	r18, 0xF0	; 240
    2cbc:	fc 01       	movw	r30, r24
    2cbe:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    2cc0:	84 e2       	ldi	r24, 0x24	; 36
    2cc2:	90 e0       	ldi	r25, 0x00	; 0
    2cc4:	24 e2       	ldi	r18, 0x24	; 36
    2cc6:	30 e0       	ldi	r19, 0x00	; 0
    2cc8:	f9 01       	movw	r30, r18
    2cca:	20 81       	ld	r18, Z
    2ccc:	21 60       	ori	r18, 0x01	; 1
    2cce:	fc 01       	movw	r30, r24
    2cd0:	20 83       	st	Z, r18
	ddrMAINen |= (1 << bnMAINen);
    2cd2:	87 e2       	ldi	r24, 0x27	; 39
    2cd4:	90 e0       	ldi	r25, 0x00	; 0
    2cd6:	27 e2       	ldi	r18, 0x27	; 39
    2cd8:	30 e0       	ldi	r19, 0x00	; 0
    2cda:	f9 01       	movw	r30, r18
    2cdc:	20 81       	ld	r18, Z
    2cde:	21 60       	ori	r18, 0x01	; 1
    2ce0:	fc 01       	movw	r30, r24
    2ce2:	20 83       	st	Z, r18
	PowerDown();
    2ce4:	0e 94 70 19 	call	0x32e0	; 0x32e0 <_Z9PowerDownv>
	__killTemp();
    2ce8:	85 e2       	ldi	r24, 0x25	; 37
    2cea:	90 e0       	ldi	r25, 0x00	; 0
    2cec:	25 e2       	ldi	r18, 0x25	; 37
    2cee:	30 e0       	ldi	r19, 0x00	; 0
    2cf0:	f9 01       	movw	r30, r18
    2cf2:	20 81       	ld	r18, Z
    2cf4:	2e 7f       	andi	r18, 0xFE	; 254
    2cf6:	fc 01       	movw	r30, r24
    2cf8:	20 83       	st	Z, r18

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    2cfa:	89 e6       	ldi	r24, 0x69	; 105
    2cfc:	90 e0       	ldi	r25, 0x00	; 0
    2cfe:	20 e3       	ldi	r18, 0x30	; 48
    2d00:	fc 01       	movw	r30, r24
    2d02:	20 83       	st	Z, r18
	EIMSK = (1 << INT2);						//enable INT2 global interrupt
    2d04:	8d e3       	ldi	r24, 0x3D	; 61
    2d06:	90 e0       	ldi	r25, 0x00	; 0
    2d08:	24 e0       	ldi	r18, 0x04	; 4
    2d0a:	fc 01       	movw	r30, r24
    2d0c:	20 83       	st	Z, r18
	
	//Enable PCINT17
	PCMSK1 |= (1 << PCINT17);
    2d0e:	8c e6       	ldi	r24, 0x6C	; 108
    2d10:	90 e0       	ldi	r25, 0x00	; 0
    2d12:	2c e6       	ldi	r18, 0x6C	; 108
    2d14:	30 e0       	ldi	r19, 0x00	; 0
    2d16:	f9 01       	movw	r30, r18
    2d18:	20 81       	ld	r18, Z
    2d1a:	22 60       	ori	r18, 0x02	; 2
    2d1c:	fc 01       	movw	r30, r24
    2d1e:	20 83       	st	Z, r18
	PCICR |= (1 << PCIE0);
    2d20:	88 e6       	ldi	r24, 0x68	; 104
    2d22:	90 e0       	ldi	r25, 0x00	; 0
    2d24:	28 e6       	ldi	r18, 0x68	; 104
    2d26:	30 e0       	ldi	r19, 0x00	; 0
    2d28:	f9 01       	movw	r30, r18
    2d2a:	20 81       	ld	r18, Z
    2d2c:	21 60       	ori	r18, 0x01	; 1
    2d2e:	fc 01       	movw	r30, r24
    2d30:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    2d32:	84 e2       	ldi	r24, 0x24	; 36
    2d34:	90 e0       	ldi	r25, 0x00	; 0
    2d36:	24 e2       	ldi	r18, 0x24	; 36
    2d38:	30 e0       	ldi	r19, 0x00	; 0
    2d3a:	f9 01       	movw	r30, r18
    2d3c:	20 81       	ld	r18, Z
    2d3e:	20 6b       	ori	r18, 0xB0	; 176
    2d40:	fc 01       	movw	r30, r24
    2d42:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    2d44:	84 e2       	ldi	r24, 0x24	; 36
    2d46:	90 e0       	ldi	r25, 0x00	; 0
    2d48:	24 e2       	ldi	r18, 0x24	; 36
    2d4a:	30 e0       	ldi	r19, 0x00	; 0
    2d4c:	f9 01       	movw	r30, r18
    2d4e:	20 81       	ld	r18, Z
    2d50:	2f 7b       	andi	r18, 0xBF	; 191
    2d52:	fc 01       	movw	r30, r24
    2d54:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    2d56:	85 e2       	ldi	r24, 0x25	; 37
    2d58:	90 e0       	ldi	r25, 0x00	; 0
    2d5a:	25 e2       	ldi	r18, 0x25	; 37
    2d5c:	30 e0       	ldi	r19, 0x00	; 0
    2d5e:	f9 01       	movw	r30, r18
    2d60:	20 81       	ld	r18, Z
    2d62:	20 69       	ori	r18, 0x90	; 144
    2d64:	fc 01       	movw	r30, r24
    2d66:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    2d68:	85 e2       	ldi	r24, 0x25	; 37
    2d6a:	90 e0       	ldi	r25, 0x00	; 0
    2d6c:	25 e2       	ldi	r18, 0x25	; 37
    2d6e:	30 e0       	ldi	r19, 0x00	; 0
    2d70:	f9 01       	movw	r30, r18
    2d72:	20 81       	ld	r18, Z
    2d74:	2f 7d       	andi	r18, 0xDF	; 223
    2d76:	fc 01       	movw	r30, r24
    2d78:	20 83       	st	Z, r18
	
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    2d7a:	81 e0       	ldi	r24, 0x01	; 1
    2d7c:	80 93 ce 01 	sts	0x01CE, r24
	flagReceivingBone = fFalse;
    2d80:	10 92 cf 01 	sts	0x01CF, r1
	flagNormalMode=fTrue;
    2d84:	81 e0       	ldi	r24, 0x01	; 1
    2d86:	80 93 d0 01 	sts	0x01D0, r24

	flagUpdateGAVRTime=fFalse;
    2d8a:	10 92 d3 01 	sts	0x01D3, r1
	flagUpdateGAVRDate=fFalse;
    2d8e:	10 92 d4 01 	sts	0x01D4, r1
	flagSendingGAVR=fFalse;
    2d92:	10 92 d5 01 	sts	0x01D5, r1
	flagUserTime=fFalse;
    2d96:	10 92 d7 01 	sts	0x01D7, r1
	flagUserDate=fFalse;
    2d9a:	10 92 d6 01 	sts	0x01D6, r1
	flagInvalidDateTime=fFalse;
    2d9e:	10 92 d8 01 	sts	0x01D8, r1
	flagWaitingToSendGAVR=fFalse;
    2da2:	10 92 d9 01 	sts	0x01D9, r1
	flagNoGPSTime=fFalse;
    2da6:	10 92 da 01 	sts	0x01DA, r1
	
	restart=fFalse;
    2daa:	10 92 df 01 	sts	0x01DF, r1
	flagNewShutdown=fFalse;
    2dae:	10 92 db 01 	sts	0x01DB, r1
	flagShutdown  = fFalse;
    2db2:	10 92 dc 01 	sts	0x01DC, r1
	flagGoodVolts=fFalse;
    2db6:	10 92 de 01 	sts	0x01DE, r1
	flagGoodTemp=fFalse;
    2dba:	10 92 dd 01 	sts	0x01DD, r1
	flagFreshStart=fTrue;
    2dbe:	81 e0       	ldi	r24, 0x01	; 1
    2dc0:	80 93 e0 01 	sts	0x01E0, r24
}
    2dc4:	0f 90       	pop	r0
    2dc6:	0f 90       	pop	r0
    2dc8:	df 91       	pop	r29
    2dca:	cf 91       	pop	r28
    2dcc:	08 95       	ret

00002dce <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    2dce:	cf 93       	push	r28
    2dd0:	df 93       	push	r29
    2dd2:	cd b7       	in	r28, 0x3d	; 61
    2dd4:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    2dd6:	84 e6       	ldi	r24, 0x64	; 100
    2dd8:	90 e0       	ldi	r25, 0x00	; 0
    2dda:	24 e6       	ldi	r18, 0x64	; 100
    2ddc:	30 e0       	ldi	r19, 0x00	; 0
    2dde:	f9 01       	movw	r30, r18
    2de0:	20 81       	ld	r18, Z
    2de2:	2f 7b       	andi	r18, 0xBF	; 191
    2de4:	fc 01       	movw	r30, r24
    2de6:	20 83       	st	Z, r18
	Wait_ms(1);	//give it time to power on
    2de8:	81 e0       	ldi	r24, 0x01	; 1
    2dea:	90 e0       	ldi	r25, 0x00	; 0
    2dec:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    2df0:	86 eb       	ldi	r24, 0xB6	; 182
    2df2:	90 e0       	ldi	r25, 0x00	; 0
    2df4:	26 eb       	ldi	r18, 0xB6	; 182
    2df6:	30 e0       	ldi	r19, 0x00	; 0
    2df8:	f9 01       	movw	r30, r18
    2dfa:	20 81       	ld	r18, Z
    2dfc:	20 62       	ori	r18, 0x20	; 32
    2dfe:	fc 01       	movw	r30, r24
    2e00:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    2e02:	81 eb       	ldi	r24, 0xB1	; 177
    2e04:	90 e0       	ldi	r25, 0x00	; 0
    2e06:	21 eb       	ldi	r18, 0xB1	; 177
    2e08:	30 e0       	ldi	r19, 0x00	; 0
    2e0a:	f9 01       	movw	r30, r18
    2e0c:	20 81       	ld	r18, Z
    2e0e:	25 60       	ori	r18, 0x05	; 5
    2e10:	fc 01       	movw	r30, r24
    2e12:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    2e14:	86 eb       	ldi	r24, 0xB6	; 182
    2e16:	90 e0       	ldi	r25, 0x00	; 0
    2e18:	fc 01       	movw	r30, r24
    2e1a:	80 81       	ld	r24, Z
    2e1c:	88 2f       	mov	r24, r24
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	81 71       	andi	r24, 0x11	; 17
    2e22:	90 70       	andi	r25, 0x00	; 0
    2e24:	21 e0       	ldi	r18, 0x01	; 1
    2e26:	00 97       	sbiw	r24, 0x00	; 0
    2e28:	09 f4       	brne	.+2      	; 0x2e2c <_Z14EnableRTCTimerv+0x5e>
    2e2a:	20 e0       	ldi	r18, 0x00	; 0
    2e2c:	22 23       	and	r18, r18
    2e2e:	91 f7       	brne	.-28     	; 0x2e14 <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    2e30:	87 e3       	ldi	r24, 0x37	; 55
    2e32:	90 e0       	ldi	r25, 0x00	; 0
    2e34:	21 e0       	ldi	r18, 0x01	; 1
    2e36:	fc 01       	movw	r30, r24
    2e38:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    2e3a:	80 e7       	ldi	r24, 0x70	; 112
    2e3c:	90 e0       	ldi	r25, 0x00	; 0
    2e3e:	21 e0       	ldi	r18, 0x01	; 1
    2e40:	fc 01       	movw	r30, r24
    2e42:	20 83       	st	Z, r18
	
	//Away we go
}
    2e44:	df 91       	pop	r29
    2e46:	cf 91       	pop	r28
    2e48:	08 95       	ret

00002e4a <_Z7Wait_msi>:
/*************************************************************************************************************/
void Wait_ms(volatile int delay)
{
    2e4a:	cf 93       	push	r28
    2e4c:	df 93       	push	r29
    2e4e:	00 d0       	rcall	.+0      	; 0x2e50 <_Z7Wait_msi+0x6>
    2e50:	00 d0       	rcall	.+0      	; 0x2e52 <_Z7Wait_msi+0x8>
    2e52:	cd b7       	in	r28, 0x3d	; 61
    2e54:	de b7       	in	r29, 0x3e	; 62
    2e56:	9c 83       	std	Y+4, r25	; 0x04
    2e58:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    2e5a:	18 c0       	rjmp	.+48     	; 0x2e8c <_Z7Wait_msi+0x42>
		for(i = 0; i < 800; i++){
    2e5c:	1a 82       	std	Y+2, r1	; 0x02
    2e5e:	19 82       	std	Y+1, r1	; 0x01
    2e60:	06 c0       	rjmp	.+12     	; 0x2e6e <_Z7Wait_msi+0x24>
			asm volatile("nop");
    2e62:	00 00       	nop
void Wait_ms(volatile int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 800; i++){
    2e64:	89 81       	ldd	r24, Y+1	; 0x01
    2e66:	9a 81       	ldd	r25, Y+2	; 0x02
    2e68:	01 96       	adiw	r24, 0x01	; 1
    2e6a:	9a 83       	std	Y+2, r25	; 0x02
    2e6c:	89 83       	std	Y+1, r24	; 0x01
    2e6e:	89 81       	ldd	r24, Y+1	; 0x01
    2e70:	9a 81       	ldd	r25, Y+2	; 0x02
    2e72:	21 e0       	ldi	r18, 0x01	; 1
    2e74:	33 e0       	ldi	r19, 0x03	; 3
    2e76:	80 32       	cpi	r24, 0x20	; 32
    2e78:	93 07       	cpc	r25, r19
    2e7a:	0c f0       	brlt	.+2      	; 0x2e7e <_Z7Wait_msi+0x34>
    2e7c:	20 e0       	ldi	r18, 0x00	; 0
    2e7e:	22 23       	and	r18, r18
    2e80:	81 f7       	brne	.-32     	; 0x2e62 <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    2e82:	8b 81       	ldd	r24, Y+3	; 0x03
    2e84:	9c 81       	ldd	r25, Y+4	; 0x04
    2e86:	01 97       	sbiw	r24, 0x01	; 1
    2e88:	9c 83       	std	Y+4, r25	; 0x04
    2e8a:	8b 83       	std	Y+3, r24	; 0x03
/*************************************************************************************************************/
void Wait_ms(volatile int delay)
{
	volatile int i;

	while(delay > 0){
    2e8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2e8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2e90:	21 e0       	ldi	r18, 0x01	; 1
    2e92:	18 16       	cp	r1, r24
    2e94:	19 06       	cpc	r1, r25
    2e96:	0c f0       	brlt	.+2      	; 0x2e9a <_Z7Wait_msi+0x50>
    2e98:	20 e0       	ldi	r18, 0x00	; 0
    2e9a:	22 23       	and	r18, r18
    2e9c:	f9 f6       	brne	.-66     	; 0x2e5c <_Z7Wait_msi+0x12>
		for(i = 0; i < 800; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    2e9e:	0f 90       	pop	r0
    2ea0:	0f 90       	pop	r0
    2ea2:	0f 90       	pop	r0
    2ea4:	0f 90       	pop	r0
    2ea6:	df 91       	pop	r29
    2ea8:	cf 91       	pop	r28
    2eaa:	08 95       	ret

00002eac <_Z8Wait_seci>:
/*************************************************************************************************************/
void Wait_sec(volatile int sec){
    2eac:	cf 93       	push	r28
    2eae:	df 93       	push	r29
    2eb0:	00 d0       	rcall	.+0      	; 0x2eb2 <_Z8Wait_seci+0x6>
    2eb2:	00 d0       	rcall	.+0      	; 0x2eb4 <_Z8Wait_seci+0x8>
    2eb4:	00 d0       	rcall	.+0      	; 0x2eb6 <_Z8Wait_seci+0xa>
    2eb6:	cd b7       	in	r28, 0x3d	; 61
    2eb8:	de b7       	in	r29, 0x3e	; 62
    2eba:	9e 83       	std	Y+6, r25	; 0x06
    2ebc:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    2ebe:	86 ea       	ldi	r24, 0xA6	; 166
    2ec0:	91 e0       	ldi	r25, 0x01	; 1
    2ec2:	0e 94 99 04 	call	0x932	; 0x932 <_ZN6myTime10getSecondsEv>
    2ec6:	88 2f       	mov	r24, r24
    2ec8:	90 e0       	ldi	r25, 0x00	; 0
    2eca:	9a 83       	std	Y+2, r25	; 0x02
    2ecc:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    2ece:	29 81       	ldd	r18, Y+1	; 0x01
    2ed0:	3a 81       	ldd	r19, Y+2	; 0x02
    2ed2:	8d 81       	ldd	r24, Y+5	; 0x05
    2ed4:	9e 81       	ldd	r25, Y+6	; 0x06
    2ed6:	82 0f       	add	r24, r18
    2ed8:	93 1f       	adc	r25, r19
    2eda:	2c e3       	ldi	r18, 0x3C	; 60
    2edc:	30 e0       	ldi	r19, 0x00	; 0
    2ede:	b9 01       	movw	r22, r18
    2ee0:	0e 94 f0 19 	call	0x33e0	; 0x33e0 <__divmodhi4>
    2ee4:	9c 83       	std	Y+4, r25	; 0x04
    2ee6:	8b 83       	std	Y+3, r24	; 0x03
	while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    2ee8:	01 c0       	rjmp	.+2      	; 0x2eec <_Z8Wait_seci+0x40>
    2eea:	00 00       	nop
    2eec:	86 ea       	ldi	r24, 0xA6	; 166
    2eee:	91 e0       	ldi	r25, 0x01	; 1
    2ef0:	0e 94 99 04 	call	0x932	; 0x932 <_ZN6myTime10getSecondsEv>
    2ef4:	28 2f       	mov	r18, r24
    2ef6:	30 e0       	ldi	r19, 0x00	; 0
    2ef8:	8b 81       	ldd	r24, Y+3	; 0x03
    2efa:	9c 81       	ldd	r25, Y+4	; 0x04
    2efc:	41 e0       	ldi	r20, 0x01	; 1
    2efe:	28 17       	cp	r18, r24
    2f00:	39 07       	cpc	r19, r25
    2f02:	09 f4       	brne	.+2      	; 0x2f06 <_Z8Wait_seci+0x5a>
    2f04:	40 e0       	ldi	r20, 0x00	; 0
    2f06:	44 23       	and	r20, r20
    2f08:	81 f7       	brne	.-32     	; 0x2eea <_Z8Wait_seci+0x3e>
}
    2f0a:	26 96       	adiw	r28, 0x06	; 6
    2f0c:	0f b6       	in	r0, 0x3f	; 63
    2f0e:	f8 94       	cli
    2f10:	de bf       	out	0x3e, r29	; 62
    2f12:	0f be       	out	0x3f, r0	; 63
    2f14:	cd bf       	out	0x3d, r28	; 61
    2f16:	df 91       	pop	r29
    2f18:	cf 91       	pop	r28
    2f1a:	08 95       	ret

00002f1c <_Z9GoToSleeph>:

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    2f1c:	cf 93       	push	r28
    2f1e:	df 93       	push	r29
    2f20:	00 d0       	rcall	.+0      	; 0x2f22 <_Z9GoToSleeph+0x6>
    2f22:	00 d0       	rcall	.+0      	; 0x2f24 <_Z9GoToSleeph+0x8>
    2f24:	0f 92       	push	r0
    2f26:	cd b7       	in	r28, 0x3d	; 61
    2f28:	de b7       	in	r29, 0x3e	; 62
    2f2a:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    2f2c:	78 94       	sei
		volatile int sleepTime, sleepTicks = 0;
    2f2e:	1c 82       	std	Y+4, r1	; 0x04
    2f30:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong == fTrue){
    2f32:	8d 81       	ldd	r24, Y+5	; 0x05
    2f34:	81 30       	cpi	r24, 0x01	; 1
    2f36:	49 f4       	brne	.+18     	; 0x2f4a <_Z9GoToSleeph+0x2e>
			sleepTime = SLEEP_TICKS_LOWV;
    2f38:	8c e0       	ldi	r24, 0x0C	; 12
    2f3a:	90 e0       	ldi	r25, 0x00	; 0
    2f3c:	9a 83       	std	Y+2, r25	; 0x02
    2f3e:	89 83       	std	Y+1, r24	; 0x01
			EIMSK = 0;						//no int2
    2f40:	8d e3       	ldi	r24, 0x3D	; 61
    2f42:	90 e0       	ldi	r25, 0x00	; 0
    2f44:	fc 01       	movw	r30, r24
    2f46:	10 82       	st	Z, r1
    2f48:	0d c0       	rjmp	.+26     	; 0x2f64 <_Z9GoToSleeph+0x48>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    2f4a:	8a e0       	ldi	r24, 0x0A	; 10
    2f4c:	90 e0       	ldi	r25, 0x00	; 0
    2f4e:	9a 83       	std	Y+2, r25	; 0x02
    2f50:	89 83       	std	Y+1, r24	; 0x01
			EIMSK |= (1 << INT2);			//int2 is allowed.
    2f52:	8d e3       	ldi	r24, 0x3D	; 61
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	2d e3       	ldi	r18, 0x3D	; 61
    2f58:	30 e0       	ldi	r19, 0x00	; 0
    2f5a:	f9 01       	movw	r30, r18
    2f5c:	20 81       	ld	r18, Z
    2f5e:	24 60       	ori	r18, 0x04	; 4
    2f60:	fc 01       	movw	r30, r24
    2f62:	20 83       	st	Z, r18
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    2f64:	88 e2       	ldi	r24, 0x28	; 40
    2f66:	90 e0       	ldi	r25, 0x00	; 0
    2f68:	28 e2       	ldi	r18, 0x28	; 40
    2f6a:	30 e0       	ldi	r19, 0x00	; 0
    2f6c:	f9 01       	movw	r30, r18
    2f6e:	20 81       	ld	r18, Z
    2f70:	2b 7f       	andi	r18, 0xFB	; 251
    2f72:	fc 01       	movw	r30, r24
    2f74:	20 83       	st	Z, r18
		prtSLEEPled |= (1 << bnSLEEPled);
    2f76:	8b e2       	ldi	r24, 0x2B	; 43
    2f78:	90 e0       	ldi	r25, 0x00	; 0
    2f7a:	2b e2       	ldi	r18, 0x2B	; 43
    2f7c:	30 e0       	ldi	r19, 0x00	; 0
    2f7e:	f9 01       	movw	r30, r18
    2f80:	20 81       	ld	r18, Z
    2f82:	20 68       	ori	r18, 0x80	; 128
    2f84:	fc 01       	movw	r30, r24
    2f86:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    2f88:	83 e5       	ldi	r24, 0x53	; 83
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	26 e0       	ldi	r18, 0x06	; 6
    2f8e:	fc 01       	movw	r30, r24
    2f90:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    2f92:	83 e5       	ldi	r24, 0x53	; 83
    2f94:	90 e0       	ldi	r25, 0x00	; 0
    2f96:	23 e5       	ldi	r18, 0x53	; 83
    2f98:	30 e0       	ldi	r19, 0x00	; 0
    2f9a:	f9 01       	movw	r30, r18
    2f9c:	20 81       	ld	r18, Z
    2f9e:	21 60       	ori	r18, 0x01	; 1
    2fa0:	fc 01       	movw	r30, r24
    2fa2:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    2fa4:	81 e0       	ldi	r24, 0x01	; 1
    2fa6:	90 e0       	ldi	r25, 0x00	; 0
    2fa8:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    2fac:	06 c0       	rjmp	.+12     	; 0x2fba <_Z9GoToSleeph+0x9e>
			asm volatile("SLEEP");
    2fae:	88 95       	sleep
			sleepTicks++;
    2fb0:	8b 81       	ldd	r24, Y+3	; 0x03
    2fb2:	9c 81       	ldd	r25, Y+4	; 0x04
    2fb4:	01 96       	adiw	r24, 0x01	; 1
    2fb6:	9c 83       	std	Y+4, r25	; 0x04
    2fb8:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    2fba:	2b 81       	ldd	r18, Y+3	; 0x03
    2fbc:	3c 81       	ldd	r19, Y+4	; 0x04
    2fbe:	89 81       	ldd	r24, Y+1	; 0x01
    2fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc2:	28 17       	cp	r18, r24
    2fc4:	39 07       	cpc	r19, r25
    2fc6:	34 f4       	brge	.+12     	; 0x2fd4 <_Z9GoToSleeph+0xb8>
    2fc8:	80 91 ce 01 	lds	r24, 0x01CE
    2fcc:	88 23       	and	r24, r24
    2fce:	11 f0       	breq	.+4      	; 0x2fd4 <_Z9GoToSleeph+0xb8>
    2fd0:	81 e0       	ldi	r24, 0x01	; 1
    2fd2:	01 c0       	rjmp	.+2      	; 0x2fd6 <_Z9GoToSleeph+0xba>
    2fd4:	80 e0       	ldi	r24, 0x00	; 0
    2fd6:	88 23       	and	r24, r24
    2fd8:	51 f7       	brne	.-44     	; 0x2fae <_Z9GoToSleeph+0x92>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(10);
    2fda:	8a e0       	ldi	r24, 0x0A	; 10
    2fdc:	90 e0       	ldi	r25, 0x00	; 0
    2fde:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSLEEPled &= ~(1 << bnSLEEPled);
    2fe2:	8b e2       	ldi	r24, 0x2B	; 43
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
    2fe6:	2b e2       	ldi	r18, 0x2B	; 43
    2fe8:	30 e0       	ldi	r19, 0x00	; 0
    2fea:	f9 01       	movw	r30, r18
    2fec:	20 81       	ld	r18, Z
    2fee:	2f 77       	andi	r18, 0x7F	; 127
    2ff0:	fc 01       	movw	r30, r24
    2ff2:	20 83       	st	Z, r18
		prtSTATUSled |= (1 << bnSTATUSled);
    2ff4:	88 e2       	ldi	r24, 0x28	; 40
    2ff6:	90 e0       	ldi	r25, 0x00	; 0
    2ff8:	28 e2       	ldi	r18, 0x28	; 40
    2ffa:	30 e0       	ldi	r19, 0x00	; 0
    2ffc:	f9 01       	movw	r30, r18
    2ffe:	20 81       	ld	r18, Z
    3000:	24 60       	ori	r18, 0x04	; 4
    3002:	fc 01       	movw	r30, r24
    3004:	20 83       	st	Z, r18
}
    3006:	0f 90       	pop	r0
    3008:	0f 90       	pop	r0
    300a:	0f 90       	pop	r0
    300c:	0f 90       	pop	r0
    300e:	0f 90       	pop	r0
    3010:	df 91       	pop	r29
    3012:	cf 91       	pop	r28
    3014:	08 95       	ret

00003016 <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    3016:	cf 93       	push	r28
    3018:	df 93       	push	r29
    301a:	00 d0       	rcall	.+0      	; 0x301c <_Z7TakeADCv+0x6>
    301c:	00 d0       	rcall	.+0      	; 0x301e <_Z7TakeADCv+0x8>
    301e:	cd b7       	in	r28, 0x3d	; 61
    3020:	de b7       	in	r29, 0x3e	; 62
	WORD adcReading = 0;
    3022:	1c 82       	std	Y+4, r1	; 0x04
    3024:	1b 82       	std	Y+3, r1	; 0x03
	
	cli();
    3026:	f8 94       	cli
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    3028:	84 e6       	ldi	r24, 0x64	; 100
    302a:	90 e0       	ldi	r25, 0x00	; 0
    302c:	24 e6       	ldi	r18, 0x64	; 100
    302e:	30 e0       	ldi	r19, 0x00	; 0
    3030:	f9 01       	movw	r30, r18
    3032:	20 81       	ld	r18, Z
    3034:	2e 7f       	andi	r18, 0xFE	; 254
    3036:	fc 01       	movw	r30, r24
    3038:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    303a:	8c e7       	ldi	r24, 0x7C	; 124
    303c:	90 e0       	ldi	r25, 0x00	; 0
    303e:	2c e7       	ldi	r18, 0x7C	; 124
    3040:	30 e0       	ldi	r19, 0x00	; 0
    3042:	f9 01       	movw	r30, r18
    3044:	20 81       	ld	r18, Z
    3046:	20 68       	ori	r18, 0x80	; 128
    3048:	fc 01       	movw	r30, r24
    304a:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    304c:	8a e7       	ldi	r24, 0x7A	; 122
    304e:	90 e0       	ldi	r25, 0x00	; 0
    3050:	2a e7       	ldi	r18, 0x7A	; 122
    3052:	30 e0       	ldi	r19, 0x00	; 0
    3054:	f9 01       	movw	r30, r18
    3056:	20 81       	ld	r18, Z
    3058:	24 68       	ori	r18, 0x84	; 132
    305a:	fc 01       	movw	r30, r24
    305c:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    305e:	8e e7       	ldi	r24, 0x7E	; 126
    3060:	90 e0       	ldi	r25, 0x00	; 0
    3062:	2e ef       	ldi	r18, 0xFE	; 254
    3064:	fc 01       	movw	r30, r24
    3066:	20 83       	st	Z, r18
	Wait_ms(5);									//Tim for registers to setup
    3068:	85 e0       	ldi	r24, 0x05	; 5
    306a:	90 e0       	ldi	r25, 0x00	; 0
    306c:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <_Z7Wait_msi>
	
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    3070:	1a 82       	std	Y+2, r1	; 0x02
    3072:	19 82       	std	Y+1, r1	; 0x01
    3074:	1c c0       	rjmp	.+56     	; 0x30ae <_Z7TakeADCv+0x98>
    3076:	8a e7       	ldi	r24, 0x7A	; 122
    3078:	90 e0       	ldi	r25, 0x00	; 0
    307a:	2a e7       	ldi	r18, 0x7A	; 122
    307c:	30 e0       	ldi	r19, 0x00	; 0
    307e:	f9 01       	movw	r30, r18
    3080:	20 81       	ld	r18, Z
    3082:	20 64       	ori	r18, 0x40	; 64
    3084:	fc 01       	movw	r30, r24
    3086:	20 83       	st	Z, r18
    3088:	8a e7       	ldi	r24, 0x7A	; 122
    308a:	90 e0       	ldi	r25, 0x00	; 0
    308c:	fc 01       	movw	r30, r24
    308e:	80 81       	ld	r24, Z
    3090:	88 2f       	mov	r24, r24
    3092:	90 e0       	ldi	r25, 0x00	; 0
    3094:	80 74       	andi	r24, 0x40	; 64
    3096:	90 70       	andi	r25, 0x00	; 0
    3098:	21 e0       	ldi	r18, 0x01	; 1
    309a:	00 97       	sbiw	r24, 0x00	; 0
    309c:	09 f4       	brne	.+2      	; 0x30a0 <_Z7TakeADCv+0x8a>
    309e:	20 e0       	ldi	r18, 0x00	; 0
    30a0:	22 23       	and	r18, r18
    30a2:	91 f7       	brne	.-28     	; 0x3088 <_Z7TakeADCv+0x72>
    30a4:	89 81       	ldd	r24, Y+1	; 0x01
    30a6:	9a 81       	ldd	r25, Y+2	; 0x02
    30a8:	01 96       	adiw	r24, 0x01	; 1
    30aa:	9a 83       	std	Y+2, r25	; 0x02
    30ac:	89 83       	std	Y+1, r24	; 0x01
    30ae:	21 e0       	ldi	r18, 0x01	; 1
    30b0:	89 81       	ldd	r24, Y+1	; 0x01
    30b2:	9a 81       	ldd	r25, Y+2	; 0x02
    30b4:	82 30       	cpi	r24, 0x02	; 2
    30b6:	91 05       	cpc	r25, r1
    30b8:	0c f0       	brlt	.+2      	; 0x30bc <_Z7TakeADCv+0xa6>
    30ba:	20 e0       	ldi	r18, 0x00	; 0
    30bc:	22 23       	and	r18, r18
    30be:	d9 f6       	brne	.-74     	; 0x3076 <_Z7TakeADCv+0x60>
	
	//Put conversion into buffer
	adcReading = ADCL;
    30c0:	88 e7       	ldi	r24, 0x78	; 120
    30c2:	90 e0       	ldi	r25, 0x00	; 0
    30c4:	fc 01       	movw	r30, r24
    30c6:	80 81       	ld	r24, Z
    30c8:	88 2f       	mov	r24, r24
    30ca:	90 e0       	ldi	r25, 0x00	; 0
    30cc:	9c 83       	std	Y+4, r25	; 0x04
    30ce:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    30d0:	89 e7       	ldi	r24, 0x79	; 121
    30d2:	90 e0       	ldi	r25, 0x00	; 0
    30d4:	fc 01       	movw	r30, r24
    30d6:	80 81       	ld	r24, Z
    30d8:	88 2f       	mov	r24, r24
    30da:	90 e0       	ldi	r25, 0x00	; 0
    30dc:	98 2f       	mov	r25, r24
    30de:	88 27       	eor	r24, r24
    30e0:	2b 81       	ldd	r18, Y+3	; 0x03
    30e2:	3c 81       	ldd	r19, Y+4	; 0x04
    30e4:	82 2b       	or	r24, r18
    30e6:	93 2b       	or	r25, r19
    30e8:	9c 83       	std	Y+4, r25	; 0x04
    30ea:	8b 83       	std	Y+3, r24	; 0x03
		
	//Assign global reading and set flag
	globalADC=adcReading;
    30ec:	8b 81       	ldd	r24, Y+3	; 0x03
    30ee:	9c 81       	ldd	r25, Y+4	; 0x04
    30f0:	90 93 a3 01 	sts	0x01A3, r25
    30f4:	80 93 a2 01 	sts	0x01A2, r24
	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    30f8:	21 e0       	ldi	r18, 0x01	; 1
    30fa:	8b 81       	ldd	r24, Y+3	; 0x03
    30fc:	9c 81       	ldd	r25, Y+4	; 0x04
    30fe:	f3 e0       	ldi	r31, 0x03	; 3
    3100:	82 37       	cpi	r24, 0x72	; 114
    3102:	9f 07       	cpc	r25, r31
    3104:	08 f4       	brcc	.+2      	; 0x3108 <_Z7TakeADCv+0xf2>
    3106:	20 e0       	ldi	r18, 0x00	; 0
    3108:	20 93 de 01 	sts	0x01DE, r18
		
	//Re-enable interrupts
	sei();
    310c:	78 94       	sei
	
	//Disable ADC hardware/registers
	ADCSRA = 0;
    310e:	8a e7       	ldi	r24, 0x7A	; 122
    3110:	90 e0       	ldi	r25, 0x00	; 0
    3112:	fc 01       	movw	r30, r24
    3114:	10 82       	st	Z, r1
	ADMUX = 0;
    3116:	8c e7       	ldi	r24, 0x7C	; 124
    3118:	90 e0       	ldi	r25, 0x00	; 0
    311a:	fc 01       	movw	r30, r24
    311c:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    311e:	8e e7       	ldi	r24, 0x7E	; 126
    3120:	90 e0       	ldi	r25, 0x00	; 0
    3122:	2e e7       	ldi	r18, 0x7E	; 126
    3124:	30 e0       	ldi	r19, 0x00	; 0
    3126:	f9 01       	movw	r30, r18
    3128:	20 81       	ld	r18, Z
    312a:	21 60       	ori	r18, 0x01	; 1
    312c:	fc 01       	movw	r30, r24
    312e:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    3130:	84 e6       	ldi	r24, 0x64	; 100
    3132:	90 e0       	ldi	r25, 0x00	; 0
    3134:	24 e6       	ldi	r18, 0x64	; 100
    3136:	30 e0       	ldi	r19, 0x00	; 0
    3138:	f9 01       	movw	r30, r18
    313a:	20 81       	ld	r18, Z
    313c:	21 60       	ori	r18, 0x01	; 1
    313e:	fc 01       	movw	r30, r24
    3140:	20 83       	st	Z, r18
}
    3142:	0f 90       	pop	r0
    3144:	0f 90       	pop	r0
    3146:	0f 90       	pop	r0
    3148:	0f 90       	pop	r0
    314a:	df 91       	pop	r29
    314c:	cf 91       	pop	r28
    314e:	08 95       	ret

00003150 <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    3150:	cf 93       	push	r28
    3152:	df 93       	push	r29
    3154:	00 d0       	rcall	.+0      	; 0x3156 <_Z7GetTempv+0x6>
    3156:	cd b7       	in	r28, 0x3d	; 61
    3158:	de b7       	in	r29, 0x3e	; 62
	WORD rawTemp = 0;
    315a:	1a 82       	std	Y+2, r1	; 0x02
    315c:	19 82       	std	Y+1, r1	; 0x01
	
	//Power on temp monitor, let it settle
	prtTEMPen |= (1 << bnTEMPen);
    315e:	85 e2       	ldi	r24, 0x25	; 37
    3160:	90 e0       	ldi	r25, 0x00	; 0
    3162:	25 e2       	ldi	r18, 0x25	; 37
    3164:	30 e0       	ldi	r19, 0x00	; 0
    3166:	f9 01       	movw	r30, r18
    3168:	20 81       	ld	r18, Z
    316a:	21 60       	ori	r18, 0x01	; 1
    316c:	fc 01       	movw	r30, r24
    316e:	20 83       	st	Z, r18
	PRR0 &= ~(1 << PRSPI);	
    3170:	84 e6       	ldi	r24, 0x64	; 100
    3172:	90 e0       	ldi	r25, 0x00	; 0
    3174:	24 e6       	ldi	r18, 0x64	; 100
    3176:	30 e0       	ldi	r19, 0x00	; 0
    3178:	f9 01       	movw	r30, r18
    317a:	20 81       	ld	r18, Z
    317c:	2b 7f       	andi	r18, 0xFB	; 251
    317e:	fc 01       	movw	r30, r24
    3180:	20 83       	st	Z, r18
	SPCR |= (1 << MSTR)|(1 << SPE)|(1 << SPR0);			//enables SPI, master, fck/64
    3182:	8c e4       	ldi	r24, 0x4C	; 76
    3184:	90 e0       	ldi	r25, 0x00	; 0
    3186:	2c e4       	ldi	r18, 0x4C	; 76
    3188:	30 e0       	ldi	r19, 0x00	; 0
    318a:	f9 01       	movw	r30, r18
    318c:	20 81       	ld	r18, Z
    318e:	21 65       	ori	r18, 0x51	; 81
    3190:	fc 01       	movw	r30, r24
    3192:	20 83       	st	Z, r18
	Wait_sec(500);
    3194:	84 ef       	ldi	r24, 0xF4	; 244
    3196:	91 e0       	ldi	r25, 0x01	; 1
    3198:	0e 94 56 17 	call	0x2eac	; 0x2eac <_Z8Wait_seci>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    319c:	85 e2       	ldi	r24, 0x25	; 37
    319e:	90 e0       	ldi	r25, 0x00	; 0
    31a0:	25 e2       	ldi	r18, 0x25	; 37
    31a2:	30 e0       	ldi	r19, 0x00	; 0
    31a4:	f9 01       	movw	r30, r18
    31a6:	20 81       	ld	r18, Z
    31a8:	2f 76       	andi	r18, 0x6F	; 111
    31aa:	fc 01       	movw	r30, r24
    31ac:	20 83       	st	Z, r18
	
	cli();
    31ae:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR = 0x00;
    31b0:	8e e4       	ldi	r24, 0x4E	; 78
    31b2:	90 e0       	ldi	r25, 0x00	; 0
    31b4:	fc 01       	movw	r30, r24
    31b6:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR & (1 << SPIF)));
    31b8:	00 00       	nop
    31ba:	8d e4       	ldi	r24, 0x4D	; 77
    31bc:	90 e0       	ldi	r25, 0x00	; 0
    31be:	fc 01       	movw	r30, r24
    31c0:	80 81       	ld	r24, Z
    31c2:	80 95       	com	r24
    31c4:	88 1f       	adc	r24, r24
    31c6:	88 27       	eor	r24, r24
    31c8:	88 1f       	adc	r24, r24
    31ca:	88 23       	and	r24, r24
    31cc:	b1 f7       	brne	.-20     	; 0x31ba <_Z7GetTempv+0x6a>
	rawTemp = (SPDR0 << 8);
    31ce:	1a 82       	std	Y+2, r1	; 0x02
    31d0:	19 82       	std	Y+1, r1	; 0x01
	SPDR = 0x00;
    31d2:	8e e4       	ldi	r24, 0x4E	; 78
    31d4:	90 e0       	ldi	r25, 0x00	; 0
    31d6:	fc 01       	movw	r30, r24
    31d8:	10 82       	st	Z, r1
	while (!(SPSR & (1 << SPIF)));
    31da:	00 00       	nop
    31dc:	8d e4       	ldi	r24, 0x4D	; 77
    31de:	90 e0       	ldi	r25, 0x00	; 0
    31e0:	fc 01       	movw	r30, r24
    31e2:	80 81       	ld	r24, Z
    31e4:	80 95       	com	r24
    31e6:	88 1f       	adc	r24, r24
    31e8:	88 27       	eor	r24, r24
    31ea:	88 1f       	adc	r24, r24
    31ec:	88 23       	and	r24, r24
    31ee:	b1 f7       	brne	.-20     	; 0x31dc <_Z7GetTempv+0x8c>
	rawTemp |= SPDR0;
	
	//Set flag to correct value, update global value
	flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
    31f0:	89 81       	ldd	r24, Y+1	; 0x01
    31f2:	9a 81       	ldd	r25, Y+2	; 0x02
    31f4:	f2 e3       	ldi	r31, 0x32	; 50
    31f6:	84 36       	cpi	r24, 0x64	; 100
    31f8:	9f 07       	cpc	r25, r31
    31fa:	10 f4       	brcc	.+4      	; 0x3200 <_Z7GetTempv+0xb0>
    31fc:	81 e0       	ldi	r24, 0x01	; 1
    31fe:	01 c0       	rjmp	.+2      	; 0x3202 <_Z7GetTempv+0xb2>
    3200:	80 e0       	ldi	r24, 0x00	; 0
    3202:	80 93 dd 01 	sts	0x01DD, r24
	globalTemp=rawTemp;
    3206:	89 81       	ldd	r24, Y+1	; 0x01
    3208:	9a 81       	ldd	r25, Y+2	; 0x02
    320a:	90 93 a5 01 	sts	0x01A5, r25
    320e:	80 93 a4 01 	sts	0x01A4, r24
	
	//re enable interrupts
	sei();
    3212:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    3214:	85 e2       	ldi	r24, 0x25	; 37
    3216:	90 e0       	ldi	r25, 0x00	; 0
    3218:	25 e2       	ldi	r18, 0x25	; 37
    321a:	30 e0       	ldi	r19, 0x00	; 0
    321c:	f9 01       	movw	r30, r18
    321e:	20 81       	ld	r18, Z
    3220:	20 69       	ori	r18, 0x90	; 144
    3222:	fc 01       	movw	r30, r24
    3224:	20 83       	st	Z, r18
	SPCR=0x00;	
    3226:	8c e4       	ldi	r24, 0x4C	; 76
    3228:	90 e0       	ldi	r25, 0x00	; 0
    322a:	fc 01       	movw	r30, r24
    322c:	10 82       	st	Z, r1
	prtTEMPen &= ~(1 << bnTEMPen);
    322e:	85 e2       	ldi	r24, 0x25	; 37
    3230:	90 e0       	ldi	r25, 0x00	; 0
    3232:	25 e2       	ldi	r18, 0x25	; 37
    3234:	30 e0       	ldi	r19, 0x00	; 0
    3236:	f9 01       	movw	r30, r18
    3238:	20 81       	ld	r18, Z
    323a:	2e 7f       	andi	r18, 0xFE	; 254
    323c:	fc 01       	movw	r30, r24
    323e:	20 83       	st	Z, r18
	PRR0 |= (1 << PRSPI);
    3240:	84 e6       	ldi	r24, 0x64	; 100
    3242:	90 e0       	ldi	r25, 0x00	; 0
    3244:	24 e6       	ldi	r18, 0x64	; 100
    3246:	30 e0       	ldi	r19, 0x00	; 0
    3248:	f9 01       	movw	r30, r18
    324a:	20 81       	ld	r18, Z
    324c:	24 60       	ori	r18, 0x04	; 4
    324e:	fc 01       	movw	r30, r24
    3250:	20 83       	st	Z, r18
}
    3252:	0f 90       	pop	r0
    3254:	0f 90       	pop	r0
    3256:	df 91       	pop	r29
    3258:	cf 91       	pop	r28
    325a:	08 95       	ret

0000325c <_Z7PowerUpj>:
/*************************************************************************************************************/
void PowerUp(WORD interval){
    325c:	cf 93       	push	r28
    325e:	df 93       	push	r29
    3260:	00 d0       	rcall	.+0      	; 0x3262 <_Z7PowerUpj+0x6>
    3262:	cd b7       	in	r28, 0x3d	; 61
    3264:	de b7       	in	r29, 0x3e	; 62
    3266:	9a 83       	std	Y+2, r25	; 0x02
    3268:	89 83       	std	Y+1, r24	; 0x01
	cli();
    326a:	f8 94       	cli
	
	//First power on main regulator
	__enableMain();
    326c:	88 e2       	ldi	r24, 0x28	; 40
    326e:	90 e0       	ldi	r25, 0x00	; 0
    3270:	28 e2       	ldi	r18, 0x28	; 40
    3272:	30 e0       	ldi	r19, 0x00	; 0
    3274:	f9 01       	movw	r30, r18
    3276:	20 81       	ld	r18, Z
    3278:	21 60       	ori	r18, 0x01	; 1
    327a:	fc 01       	movw	r30, r24
    327c:	20 83       	st	Z, r18
	Wait_ms(interval);
    327e:	89 81       	ldd	r24, Y+1	; 0x01
    3280:	9a 81       	ldd	r25, Y+2	; 0x02
    3282:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <_Z7Wait_msi>
	
	//Power on BeagleBone next, takes longer time.
	__enableBeagleBone();
    3286:	82 e2       	ldi	r24, 0x22	; 34
    3288:	90 e0       	ldi	r25, 0x00	; 0
    328a:	22 e2       	ldi	r18, 0x22	; 34
    328c:	30 e0       	ldi	r19, 0x00	; 0
    328e:	f9 01       	movw	r30, r18
    3290:	20 81       	ld	r18, Z
    3292:	20 61       	ori	r18, 0x10	; 16
    3294:	fc 01       	movw	r30, r24
    3296:	20 83       	st	Z, r18
	Wait_ms(interval);
    3298:	89 81       	ldd	r24, Y+1	; 0x01
    329a:	9a 81       	ldd	r25, Y+2	; 0x02
    329c:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <_Z7Wait_msi>
	//while (!(pinBBio & (1 << bnW0B9)));	//Wait for GPIO line to go high
	
	//Power on GAVR and Enable GPS
	__enableGPSandGAVR();
    32a0:	82 e2       	ldi	r24, 0x22	; 34
    32a2:	90 e0       	ldi	r25, 0x00	; 0
    32a4:	22 e2       	ldi	r18, 0x22	; 34
    32a6:	30 e0       	ldi	r19, 0x00	; 0
    32a8:	f9 01       	movw	r30, r18
    32aa:	20 81       	ld	r18, Z
    32ac:	20 6c       	ori	r18, 0xC0	; 192
    32ae:	fc 01       	movw	r30, r24
    32b0:	20 83       	st	Z, r18
	Wait_ms(interval);
    32b2:	89 81       	ldd	r24, Y+1	; 0x01
    32b4:	9a 81       	ldd	r25, Y+2	; 0x02
    32b6:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <_Z7Wait_msi>
	//while (!(pinGAVRio & (1 << bnW3G0)));	//Wait for GPIO line to go high signifying correct boot
	
	//Power on LCD
	__enableLCD();
    32ba:	82 e2       	ldi	r24, 0x22	; 34
    32bc:	90 e0       	ldi	r25, 0x00	; 0
    32be:	22 e2       	ldi	r18, 0x22	; 34
    32c0:	30 e0       	ldi	r19, 0x00	; 0
    32c2:	f9 01       	movw	r30, r18
    32c4:	20 81       	ld	r18, Z
    32c6:	20 62       	ori	r18, 0x20	; 32
    32c8:	fc 01       	movw	r30, r24
    32ca:	20 83       	st	Z, r18
	Wait_ms(interval);
    32cc:	89 81       	ldd	r24, Y+1	; 0x01
    32ce:	9a 81       	ldd	r25, Y+2	; 0x02
    32d0:	0e 94 25 17 	call	0x2e4a	; 0x2e4a <_Z7Wait_msi>
	sei();
    32d4:	78 94       	sei
	
}
    32d6:	0f 90       	pop	r0
    32d8:	0f 90       	pop	r0
    32da:	df 91       	pop	r29
    32dc:	cf 91       	pop	r28
    32de:	08 95       	ret

000032e0 <_Z9PowerDownv>:
/*************************************************************************************************************/
void PowerDown(){
    32e0:	cf 93       	push	r28
    32e2:	df 93       	push	r29
    32e4:	cd b7       	in	r28, 0x3d	; 61
    32e6:	de b7       	in	r29, 0x3e	; 62
	cli();
    32e8:	f8 94       	cli
	//Signify interrupts, wait 6 seconds for all processing to stop.
	prtInterrupts |= (1 << bnBBint)|(1 << bnGAVRint);
    32ea:	82 e2       	ldi	r24, 0x22	; 34
    32ec:	90 e0       	ldi	r25, 0x00	; 0
    32ee:	22 e2       	ldi	r18, 0x22	; 34
    32f0:	30 e0       	ldi	r19, 0x00	; 0
    32f2:	f9 01       	movw	r30, r18
    32f4:	20 81       	ld	r18, Z
    32f6:	2c 60       	ori	r18, 0x0C	; 12
    32f8:	fc 01       	movw	r30, r24
    32fa:	20 83       	st	Z, r18
	Wait_sec(6);
    32fc:	86 e0       	ldi	r24, 0x06	; 6
    32fe:	90 e0       	ldi	r25, 0x00	; 0
    3300:	0e 94 56 17 	call	0x2eac	; 0x2eac <_Z8Wait_seci>
	prtInterrupts &= ~((1 << bnBBint)|(1 << bnGAVRint));
    3304:	82 e2       	ldi	r24, 0x22	; 34
    3306:	90 e0       	ldi	r25, 0x00	; 0
    3308:	22 e2       	ldi	r18, 0x22	; 34
    330a:	30 e0       	ldi	r19, 0x00	; 0
    330c:	f9 01       	movw	r30, r18
    330e:	20 81       	ld	r18, Z
    3310:	23 7f       	andi	r18, 0xF3	; 243
    3312:	fc 01       	movw	r30, r24
    3314:	20 83       	st	Z, r18
	__killLCD();
    3316:	82 e2       	ldi	r24, 0x22	; 34
    3318:	90 e0       	ldi	r25, 0x00	; 0
    331a:	22 e2       	ldi	r18, 0x22	; 34
    331c:	30 e0       	ldi	r19, 0x00	; 0
    331e:	f9 01       	movw	r30, r18
    3320:	20 81       	ld	r18, Z
    3322:	2f 7d       	andi	r18, 0xDF	; 223
    3324:	fc 01       	movw	r30, r24
    3326:	20 83       	st	Z, r18
	__killGPSandGAVR();
    3328:	82 e2       	ldi	r24, 0x22	; 34
    332a:	90 e0       	ldi	r25, 0x00	; 0
    332c:	22 e2       	ldi	r18, 0x22	; 34
    332e:	30 e0       	ldi	r19, 0x00	; 0
    3330:	f9 01       	movw	r30, r18
    3332:	20 81       	ld	r18, Z
    3334:	2f 73       	andi	r18, 0x3F	; 63
    3336:	fc 01       	movw	r30, r24
    3338:	20 83       	st	Z, r18
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
    333a:	86 e0       	ldi	r24, 0x06	; 6
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	0e 94 56 17 	call	0x2eac	; 0x2eac <_Z8Wait_seci>
	__killBeagleBone();
    3342:	82 e2       	ldi	r24, 0x22	; 34
    3344:	90 e0       	ldi	r25, 0x00	; 0
    3346:	22 e2       	ldi	r18, 0x22	; 34
    3348:	30 e0       	ldi	r19, 0x00	; 0
    334a:	f9 01       	movw	r30, r18
    334c:	20 81       	ld	r18, Z
    334e:	2f 7e       	andi	r18, 0xEF	; 239
    3350:	fc 01       	movw	r30, r24
    3352:	20 83       	st	Z, r18
	__killMain();
    3354:	88 e2       	ldi	r24, 0x28	; 40
    3356:	90 e0       	ldi	r25, 0x00	; 0
    3358:	28 e2       	ldi	r18, 0x28	; 40
    335a:	30 e0       	ldi	r19, 0x00	; 0
    335c:	f9 01       	movw	r30, r18
    335e:	20 81       	ld	r18, Z
    3360:	2e 7f       	andi	r18, 0xFE	; 254
    3362:	fc 01       	movw	r30, r24
    3364:	20 83       	st	Z, r18
	sei();
    3366:	78 94       	sei
}
    3368:	df 91       	pop	r29
    336a:	cf 91       	pop	r28
    336c:	08 95       	ret

0000336e <_Z41__static_initialization_and_destruction_0ii>:
    336e:	cf 93       	push	r28
    3370:	df 93       	push	r29
    3372:	00 d0       	rcall	.+0      	; 0x3374 <_Z41__static_initialization_and_destruction_0ii+0x6>
    3374:	00 d0       	rcall	.+0      	; 0x3376 <_Z41__static_initialization_and_destruction_0ii+0x8>
    3376:	cd b7       	in	r28, 0x3d	; 61
    3378:	de b7       	in	r29, 0x3e	; 62
    337a:	9a 83       	std	Y+2, r25	; 0x02
    337c:	89 83       	std	Y+1, r24	; 0x01
    337e:	7c 83       	std	Y+4, r23	; 0x04
    3380:	6b 83       	std	Y+3, r22	; 0x03
    3382:	89 81       	ldd	r24, Y+1	; 0x01
    3384:	9a 81       	ldd	r25, Y+2	; 0x02
    3386:	81 30       	cpi	r24, 0x01	; 1
    3388:	91 05       	cpc	r25, r1
    338a:	51 f4       	brne	.+20     	; 0x33a0 <_Z41__static_initialization_and_destruction_0ii+0x32>
    338c:	8b 81       	ldd	r24, Y+3	; 0x03
    338e:	9c 81       	ldd	r25, Y+4	; 0x04
    3390:	2f ef       	ldi	r18, 0xFF	; 255
    3392:	8f 3f       	cpi	r24, 0xFF	; 255
    3394:	92 07       	cpc	r25, r18
    3396:	21 f4       	brne	.+8      	; 0x33a0 <_Z41__static_initialization_and_destruction_0ii+0x32>

/*********************************************GLOBAL VARIABLES***************************************************/
/****************************************************************************************************************/
WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    3398:	86 ea       	ldi	r24, 0xA6	; 166
    339a:	91 e0       	ldi	r25, 0x01	; 1
    339c:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTimeC1Ev>
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
	__killBeagleBone();
	__killMain();
	sei();
}
    33a0:	0f 90       	pop	r0
    33a2:	0f 90       	pop	r0
    33a4:	0f 90       	pop	r0
    33a6:	0f 90       	pop	r0
    33a8:	df 91       	pop	r29
    33aa:	cf 91       	pop	r28
    33ac:	08 95       	ret

000033ae <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    33ae:	cf 93       	push	r28
    33b0:	df 93       	push	r29
    33b2:	cd b7       	in	r28, 0x3d	; 61
    33b4:	de b7       	in	r29, 0x3e	; 62
    33b6:	81 e0       	ldi	r24, 0x01	; 1
    33b8:	90 e0       	ldi	r25, 0x00	; 0
    33ba:	6f ef       	ldi	r22, 0xFF	; 255
    33bc:	7f ef       	ldi	r23, 0xFF	; 255
    33be:	0e 94 b7 19 	call	0x336e	; 0x336e <_Z41__static_initialization_and_destruction_0ii>
    33c2:	df 91       	pop	r29
    33c4:	cf 91       	pop	r28
    33c6:	08 95       	ret

000033c8 <__udivmodqi4>:
    33c8:	99 1b       	sub	r25, r25
    33ca:	79 e0       	ldi	r23, 0x09	; 9
    33cc:	04 c0       	rjmp	.+8      	; 0x33d6 <__udivmodqi4_ep>

000033ce <__udivmodqi4_loop>:
    33ce:	99 1f       	adc	r25, r25
    33d0:	96 17       	cp	r25, r22
    33d2:	08 f0       	brcs	.+2      	; 0x33d6 <__udivmodqi4_ep>
    33d4:	96 1b       	sub	r25, r22

000033d6 <__udivmodqi4_ep>:
    33d6:	88 1f       	adc	r24, r24
    33d8:	7a 95       	dec	r23
    33da:	c9 f7       	brne	.-14     	; 0x33ce <__udivmodqi4_loop>
    33dc:	80 95       	com	r24
    33de:	08 95       	ret

000033e0 <__divmodhi4>:
    33e0:	97 fb       	bst	r25, 7
    33e2:	09 2e       	mov	r0, r25
    33e4:	07 26       	eor	r0, r23
    33e6:	0a d0       	rcall	.+20     	; 0x33fc <__divmodhi4_neg1>
    33e8:	77 fd       	sbrc	r23, 7
    33ea:	04 d0       	rcall	.+8      	; 0x33f4 <__divmodhi4_neg2>
    33ec:	0c d0       	rcall	.+24     	; 0x3406 <__udivmodhi4>
    33ee:	06 d0       	rcall	.+12     	; 0x33fc <__divmodhi4_neg1>
    33f0:	00 20       	and	r0, r0
    33f2:	1a f4       	brpl	.+6      	; 0x33fa <__divmodhi4_exit>

000033f4 <__divmodhi4_neg2>:
    33f4:	70 95       	com	r23
    33f6:	61 95       	neg	r22
    33f8:	7f 4f       	sbci	r23, 0xFF	; 255

000033fa <__divmodhi4_exit>:
    33fa:	08 95       	ret

000033fc <__divmodhi4_neg1>:
    33fc:	f6 f7       	brtc	.-4      	; 0x33fa <__divmodhi4_exit>
    33fe:	90 95       	com	r25
    3400:	81 95       	neg	r24
    3402:	9f 4f       	sbci	r25, 0xFF	; 255
    3404:	08 95       	ret

00003406 <__udivmodhi4>:
    3406:	aa 1b       	sub	r26, r26
    3408:	bb 1b       	sub	r27, r27
    340a:	51 e1       	ldi	r21, 0x11	; 17
    340c:	07 c0       	rjmp	.+14     	; 0x341c <__udivmodhi4_ep>

0000340e <__udivmodhi4_loop>:
    340e:	aa 1f       	adc	r26, r26
    3410:	bb 1f       	adc	r27, r27
    3412:	a6 17       	cp	r26, r22
    3414:	b7 07       	cpc	r27, r23
    3416:	10 f0       	brcs	.+4      	; 0x341c <__udivmodhi4_ep>
    3418:	a6 1b       	sub	r26, r22
    341a:	b7 0b       	sbc	r27, r23

0000341c <__udivmodhi4_ep>:
    341c:	88 1f       	adc	r24, r24
    341e:	99 1f       	adc	r25, r25
    3420:	5a 95       	dec	r21
    3422:	a9 f7       	brne	.-22     	; 0x340e <__udivmodhi4_loop>
    3424:	80 95       	com	r24
    3426:	90 95       	com	r25
    3428:	bc 01       	movw	r22, r24
    342a:	cd 01       	movw	r24, r26
    342c:	08 95       	ret

0000342e <__tablejump2__>:
    342e:	ee 0f       	add	r30, r30
    3430:	ff 1f       	adc	r31, r31

00003432 <__tablejump__>:
    3432:	05 90       	lpm	r0, Z+
    3434:	f4 91       	lpm	r31, Z
    3436:	e0 2d       	mov	r30, r0
    3438:	09 94       	ijmp

0000343a <atoi>:
    343a:	fc 01       	movw	r30, r24
    343c:	88 27       	eor	r24, r24
    343e:	99 27       	eor	r25, r25
    3440:	e8 94       	clt
    3442:	21 91       	ld	r18, Z+
    3444:	20 32       	cpi	r18, 0x20	; 32
    3446:	e9 f3       	breq	.-6      	; 0x3442 <atoi+0x8>
    3448:	29 30       	cpi	r18, 0x09	; 9
    344a:	10 f0       	brcs	.+4      	; 0x3450 <atoi+0x16>
    344c:	2e 30       	cpi	r18, 0x0E	; 14
    344e:	c8 f3       	brcs	.-14     	; 0x3442 <atoi+0x8>
    3450:	2b 32       	cpi	r18, 0x2B	; 43
    3452:	41 f0       	breq	.+16     	; 0x3464 <atoi+0x2a>
    3454:	2d 32       	cpi	r18, 0x2D	; 45
    3456:	39 f4       	brne	.+14     	; 0x3466 <atoi+0x2c>
    3458:	68 94       	set
    345a:	04 c0       	rjmp	.+8      	; 0x3464 <atoi+0x2a>
    345c:	0e 94 85 1a 	call	0x350a	; 0x350a <__mulhi_const_10>
    3460:	82 0f       	add	r24, r18
    3462:	91 1d       	adc	r25, r1
    3464:	21 91       	ld	r18, Z+
    3466:	20 53       	subi	r18, 0x30	; 48
    3468:	2a 30       	cpi	r18, 0x0A	; 10
    346a:	c0 f3       	brcs	.-16     	; 0x345c <atoi+0x22>
    346c:	1e f4       	brtc	.+6      	; 0x3474 <atoi+0x3a>
    346e:	90 95       	com	r25
    3470:	81 95       	neg	r24
    3472:	9f 4f       	sbci	r25, 0xFF	; 255
    3474:	08 95       	ret

00003476 <strcat>:
    3476:	fb 01       	movw	r30, r22
    3478:	dc 01       	movw	r26, r24
    347a:	0d 90       	ld	r0, X+
    347c:	00 20       	and	r0, r0
    347e:	e9 f7       	brne	.-6      	; 0x347a <strcat+0x4>
    3480:	11 97       	sbiw	r26, 0x01	; 1
    3482:	01 90       	ld	r0, Z+
    3484:	0d 92       	st	X+, r0
    3486:	00 20       	and	r0, r0
    3488:	e1 f7       	brne	.-8      	; 0x3482 <strcat+0xc>
    348a:	08 95       	ret

0000348c <strcmp>:
    348c:	fb 01       	movw	r30, r22
    348e:	dc 01       	movw	r26, r24
    3490:	8d 91       	ld	r24, X+
    3492:	01 90       	ld	r0, Z+
    3494:	80 19       	sub	r24, r0
    3496:	01 10       	cpse	r0, r1
    3498:	d9 f3       	breq	.-10     	; 0x3490 <strcmp+0x4>
    349a:	99 0b       	sbc	r25, r25
    349c:	08 95       	ret

0000349e <strcpy>:
    349e:	fb 01       	movw	r30, r22
    34a0:	dc 01       	movw	r26, r24
    34a2:	01 90       	ld	r0, Z+
    34a4:	0d 92       	st	X+, r0
    34a6:	00 20       	and	r0, r0
    34a8:	e1 f7       	brne	.-8      	; 0x34a2 <strcpy+0x4>
    34aa:	08 95       	ret

000034ac <strncmp>:
    34ac:	fb 01       	movw	r30, r22
    34ae:	dc 01       	movw	r26, r24
    34b0:	41 50       	subi	r20, 0x01	; 1
    34b2:	50 40       	sbci	r21, 0x00	; 0
    34b4:	30 f0       	brcs	.+12     	; 0x34c2 <strncmp+0x16>
    34b6:	8d 91       	ld	r24, X+
    34b8:	01 90       	ld	r0, Z+
    34ba:	80 19       	sub	r24, r0
    34bc:	19 f4       	brne	.+6      	; 0x34c4 <strncmp+0x18>
    34be:	00 20       	and	r0, r0
    34c0:	b9 f7       	brne	.-18     	; 0x34b0 <strncmp+0x4>
    34c2:	88 1b       	sub	r24, r24
    34c4:	99 0b       	sbc	r25, r25
    34c6:	08 95       	ret

000034c8 <itoa>:
    34c8:	fb 01       	movw	r30, r22
    34ca:	9f 01       	movw	r18, r30
    34cc:	e8 94       	clt
    34ce:	42 30       	cpi	r20, 0x02	; 2
    34d0:	c4 f0       	brlt	.+48     	; 0x3502 <itoa+0x3a>
    34d2:	45 32       	cpi	r20, 0x25	; 37
    34d4:	b4 f4       	brge	.+44     	; 0x3502 <itoa+0x3a>
    34d6:	4a 30       	cpi	r20, 0x0A	; 10
    34d8:	29 f4       	brne	.+10     	; 0x34e4 <itoa+0x1c>
    34da:	97 fb       	bst	r25, 7
    34dc:	1e f4       	brtc	.+6      	; 0x34e4 <itoa+0x1c>
    34de:	90 95       	com	r25
    34e0:	81 95       	neg	r24
    34e2:	9f 4f       	sbci	r25, 0xFF	; 255
    34e4:	64 2f       	mov	r22, r20
    34e6:	77 27       	eor	r23, r23
    34e8:	0e 94 03 1a 	call	0x3406	; 0x3406 <__udivmodhi4>
    34ec:	80 5d       	subi	r24, 0xD0	; 208
    34ee:	8a 33       	cpi	r24, 0x3A	; 58
    34f0:	0c f0       	brlt	.+2      	; 0x34f4 <itoa+0x2c>
    34f2:	89 5d       	subi	r24, 0xD9	; 217
    34f4:	81 93       	st	Z+, r24
    34f6:	cb 01       	movw	r24, r22
    34f8:	00 97       	sbiw	r24, 0x00	; 0
    34fa:	a1 f7       	brne	.-24     	; 0x34e4 <itoa+0x1c>
    34fc:	16 f4       	brtc	.+4      	; 0x3502 <itoa+0x3a>
    34fe:	5d e2       	ldi	r21, 0x2D	; 45
    3500:	51 93       	st	Z+, r21
    3502:	10 82       	st	Z, r1
    3504:	c9 01       	movw	r24, r18
    3506:	0c 94 c4 1a 	jmp	0x3588	; 0x3588 <strrev>

0000350a <__mulhi_const_10>:
    350a:	7a e0       	ldi	r23, 0x0A	; 10
    350c:	97 9f       	mul	r25, r23
    350e:	90 2d       	mov	r25, r0
    3510:	87 9f       	mul	r24, r23
    3512:	80 2d       	mov	r24, r0
    3514:	91 0d       	add	r25, r1
    3516:	11 24       	eor	r1, r1
    3518:	08 95       	ret

0000351a <utoa>:
    351a:	fb 01       	movw	r30, r22
    351c:	9f 01       	movw	r18, r30
    351e:	42 30       	cpi	r20, 0x02	; 2
    3520:	74 f0       	brlt	.+28     	; 0x353e <utoa+0x24>
    3522:	45 32       	cpi	r20, 0x25	; 37
    3524:	64 f4       	brge	.+24     	; 0x353e <utoa+0x24>
    3526:	64 2f       	mov	r22, r20
    3528:	77 27       	eor	r23, r23
    352a:	0e 94 03 1a 	call	0x3406	; 0x3406 <__udivmodhi4>
    352e:	80 5d       	subi	r24, 0xD0	; 208
    3530:	8a 33       	cpi	r24, 0x3A	; 58
    3532:	0c f0       	brlt	.+2      	; 0x3536 <utoa+0x1c>
    3534:	89 5d       	subi	r24, 0xD9	; 217
    3536:	81 93       	st	Z+, r24
    3538:	cb 01       	movw	r24, r22
    353a:	00 97       	sbiw	r24, 0x00	; 0
    353c:	a1 f7       	brne	.-24     	; 0x3526 <utoa+0xc>
    353e:	10 82       	st	Z, r1
    3540:	c9 01       	movw	r24, r18
    3542:	0c 94 c4 1a 	jmp	0x3588	; 0x3588 <strrev>

00003546 <__eerd_byte_m644pa>:
    3546:	f9 99       	sbic	0x1f, 1	; 31
    3548:	fe cf       	rjmp	.-4      	; 0x3546 <__eerd_byte_m644pa>
    354a:	92 bd       	out	0x22, r25	; 34
    354c:	81 bd       	out	0x21, r24	; 33
    354e:	f8 9a       	sbi	0x1f, 0	; 31
    3550:	99 27       	eor	r25, r25
    3552:	80 b5       	in	r24, 0x20	; 32
    3554:	08 95       	ret

00003556 <__eerd_word_m644pa>:
    3556:	a8 e1       	ldi	r26, 0x18	; 24
    3558:	b0 e0       	ldi	r27, 0x00	; 0
    355a:	42 e0       	ldi	r20, 0x02	; 2
    355c:	50 e0       	ldi	r21, 0x00	; 0
    355e:	0c 94 d6 1a 	jmp	0x35ac	; 0x35ac <__eerd_blraw_m644pa>

00003562 <__eewr_byte_m644pa>:
    3562:	26 2f       	mov	r18, r22

00003564 <__eewr_r18_m644pa>:
    3564:	f9 99       	sbic	0x1f, 1	; 31
    3566:	fe cf       	rjmp	.-4      	; 0x3564 <__eewr_r18_m644pa>
    3568:	1f ba       	out	0x1f, r1	; 31
    356a:	92 bd       	out	0x22, r25	; 34
    356c:	81 bd       	out	0x21, r24	; 33
    356e:	20 bd       	out	0x20, r18	; 32
    3570:	0f b6       	in	r0, 0x3f	; 63
    3572:	f8 94       	cli
    3574:	fa 9a       	sbi	0x1f, 2	; 31
    3576:	f9 9a       	sbi	0x1f, 1	; 31
    3578:	0f be       	out	0x3f, r0	; 63
    357a:	01 96       	adiw	r24, 0x01	; 1
    357c:	08 95       	ret

0000357e <__eewr_word_m644pa>:
    357e:	0e 94 b1 1a 	call	0x3562	; 0x3562 <__eewr_byte_m644pa>
    3582:	27 2f       	mov	r18, r23
    3584:	0c 94 b2 1a 	jmp	0x3564	; 0x3564 <__eewr_r18_m644pa>

00003588 <strrev>:
    3588:	dc 01       	movw	r26, r24
    358a:	fc 01       	movw	r30, r24
    358c:	67 2f       	mov	r22, r23
    358e:	71 91       	ld	r23, Z+
    3590:	77 23       	and	r23, r23
    3592:	e1 f7       	brne	.-8      	; 0x358c <strrev+0x4>
    3594:	32 97       	sbiw	r30, 0x02	; 2
    3596:	04 c0       	rjmp	.+8      	; 0x35a0 <strrev+0x18>
    3598:	7c 91       	ld	r23, X
    359a:	6d 93       	st	X+, r22
    359c:	70 83       	st	Z, r23
    359e:	62 91       	ld	r22, -Z
    35a0:	ae 17       	cp	r26, r30
    35a2:	bf 07       	cpc	r27, r31
    35a4:	c8 f3       	brcs	.-14     	; 0x3598 <strrev+0x10>
    35a6:	08 95       	ret

000035a8 <__eerd_block_m644pa>:
    35a8:	dc 01       	movw	r26, r24
    35aa:	cb 01       	movw	r24, r22

000035ac <__eerd_blraw_m644pa>:
    35ac:	fc 01       	movw	r30, r24
    35ae:	f9 99       	sbic	0x1f, 1	; 31
    35b0:	fe cf       	rjmp	.-4      	; 0x35ae <__eerd_blraw_m644pa+0x2>
    35b2:	06 c0       	rjmp	.+12     	; 0x35c0 <__eerd_blraw_m644pa+0x14>
    35b4:	f2 bd       	out	0x22, r31	; 34
    35b6:	e1 bd       	out	0x21, r30	; 33
    35b8:	f8 9a       	sbi	0x1f, 0	; 31
    35ba:	31 96       	adiw	r30, 0x01	; 1
    35bc:	00 b4       	in	r0, 0x20	; 32
    35be:	0d 92       	st	X+, r0
    35c0:	41 50       	subi	r20, 0x01	; 1
    35c2:	50 40       	sbci	r21, 0x00	; 0
    35c4:	b8 f7       	brcc	.-18     	; 0x35b4 <__eerd_blraw_m644pa+0x8>
    35c6:	08 95       	ret

000035c8 <_exit>:
    35c8:	f8 94       	cli

000035ca <__stop_program>:
    35ca:	ff cf       	rjmp	.-2      	; 0x35ca <__stop_program>
