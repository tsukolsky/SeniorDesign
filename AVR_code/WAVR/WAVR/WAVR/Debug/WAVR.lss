
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000009e  00800100  000038b2  00003966  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000038b2  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004a  0080019e  0080019e  00003a04  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  00003a04  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000011f4  00000000  00000000  00003a0c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000005eb  00000000  00000000  00004c00  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  000051f0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002207  00000000  00000000  00005310  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000003b5  00000000  00000000  00007517  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000f62  00000000  00000000  000078cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008ac  00000000  00000000  00008830  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b02  00000000  00000000  000090dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001255  00000000  00000000  00009bde  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  0000ae33  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 86 13 	jmp	0x270c	; 0x270c <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 30 13 	jmp	0x2660	; 0x2660 <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 cd 13 	jmp	0x279a	; 0x279a <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 d1 14 	jmp	0x29a2	; 0x29a2 <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 03 15 	jmp	0x2a06	; 0x2a06 <__vector_28>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	4a 1b       	sub	r20, r26

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d0 e1       	ldi	r29, 0x10	; 16
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	e2 eb       	ldi	r30, 0xB2	; 178
      92:	f8 e3       	ldi	r31, 0x38	; 56
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	ae 39       	cpi	r26, 0x9E	; 158
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	ae e9       	ldi	r26, 0x9E	; 158
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	a8 3e       	cpi	r26, 0xE8	; 232
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 8c 1b 	call	0x3718	; 0x3718 <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 35 15 	call	0x2a6a	; 0x2a6a <main>
      ca:	0c 94 57 1c 	jmp	0x38ae	; 0x38ae <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate17checkValidityDateEv>:

BOOL myDate::checkValidityDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	00 d0       	rcall	.+0      	; 0x60a <_ZN6myDate17checkValidityDateEv+0x6>
     60a:	0f 92       	push	r0
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	9b 83       	std	Y+3, r25	; 0x03
     612:	8a 83       	std	Y+2, r24	; 0x02
	BOOL checkYear=fFalse;
     614:	19 82       	std	Y+1, r1	; 0x01
	if (month/13==0){
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	9b 81       	ldd	r25, Y+3	; 0x03
     61a:	fc 01       	movw	r30, r24
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	0c 96       	adiw	r24, 0x0c	; 12
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	89 31       	cpi	r24, 0x19	; 25
     626:	91 05       	cpc	r25, r1
     628:	08 f0       	brcs	.+2      	; 0x62c <_ZN6myDate17checkValidityDateEv+0x28>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	22 23       	and	r18, r18
     62e:	09 f4       	brne	.+2      	; 0x632 <_ZN6myDate17checkValidityDateEv+0x2e>
     630:	66 c0       	rjmp	.+204    	; 0x6fe <_ZN6myDate17checkValidityDateEv+0xfa>
			if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	89 30       	cpi	r24, 0x09	; 9
     63e:	91 05       	cpc	r25, r1
     640:	81 f0       	breq	.+32     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     642:	8a 81       	ldd	r24, Y+2	; 0x02
     644:	9b 81       	ldd	r25, Y+3	; 0x03
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
     64a:	91 81       	ldd	r25, Z+1	; 0x01
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	91 05       	cpc	r25, r1
     650:	41 f0       	breq	.+16     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	9b 81       	ldd	r25, Y+3	; 0x03
     656:	fc 01       	movw	r30, r24
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	86 30       	cpi	r24, 0x06	; 6
     65e:	91 05       	cpc	r25, r1
     660:	59 f4       	brne	.+22     	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	4e 96       	adiw	r24, 0x1e	; 30
     66e:	8d 33       	cpi	r24, 0x3D	; 61
     670:	91 05       	cpc	r25, r1
     672:	10 f4       	brcc	.+4      	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	01 c0       	rjmp	.+2      	; 0x67a <_ZN6myDate17checkValidityDateEv+0x76>
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	88 23       	and	r24, r24
     67c:	19 f0       	breq	.+6      	; 0x684 <_ZN6myDate17checkValidityDateEv+0x80>
				checkYear=fTrue;
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	89 83       	std	Y+1, r24	; 0x01
     682:	28 c0       	rjmp	.+80     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else if (month == 2 && day/29 == 0){
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	fc 01       	movw	r30, r24
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	91 05       	cpc	r25, r1
     692:	59 f4       	brne	.+22     	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     694:	8a 81       	ldd	r24, Y+2	; 0x02
     696:	9b 81       	ldd	r25, Y+3	; 0x03
     698:	fc 01       	movw	r30, r24
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	4c 96       	adiw	r24, 0x1c	; 28
     6a0:	89 33       	cpi	r24, 0x39	; 57
     6a2:	91 05       	cpc	r25, r1
     6a4:	10 f4       	brcc	.+4      	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_ZN6myDate17checkValidityDateEv+0xa8>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	88 23       	and	r24, r24
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_ZN6myDate17checkValidityDateEv+0xb2>
				checkYear=fTrue;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	89 83       	std	Y+1, r24	; 0x01
     6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else{
				if (day/32 == 0){
     6b6:	8a 81       	ldd	r24, Y+2	; 0x02
     6b8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ba:	fc 01       	movw	r30, r24
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	4f 96       	adiw	r24, 0x1f	; 31
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	8f 33       	cpi	r24, 0x3F	; 63
     6c6:	91 05       	cpc	r25, r1
     6c8:	08 f0       	brcs	.+2      	; 0x6cc <_ZN6myDate17checkValidityDateEv+0xc8>
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	22 23       	and	r18, r18
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
					checkYear=fTrue;
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
			
			//Check year
			if (checkYear && year>=2013){return fTrue;}
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	88 23       	and	r24, r24
     6d8:	59 f0       	breq	.+22     	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	84 81       	ldd	r24, Z+4	; 0x04
     6e2:	95 81       	ldd	r25, Z+5	; 0x05
     6e4:	f7 e0       	ldi	r31, 0x07	; 7
     6e6:	8d 3d       	cpi	r24, 0xDD	; 221
     6e8:	9f 07       	cpc	r25, r31
     6ea:	14 f0       	brlt	.+4      	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <_ZN6myDate17checkValidityDateEv+0xee>
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	88 23       	and	r24, r24
     6f4:	11 f0       	breq	.+4      	; 0x6fa <_ZN6myDate17checkValidityDateEv+0xf6>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	03 c0       	rjmp	.+6      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
			else {return fFalse;}
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
	} else {return fFalse;}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	cd b7       	in	r28, 0x3d	; 61
     712:	de b7       	in	r29, 0x3e	; 62
     714:	2d 97       	sbiw	r28, 0x0d	; 13
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	9d 87       	std	Y+13, r25	; 0x0d
     722:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     724:	8c 85       	ldd	r24, Y+12	; 0x0c
     726:	9d 85       	ldd	r25, Y+13	; 0x0d
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	91 81       	ldd	r25, Z+1	; 0x01
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <itoa>
	itoa(day,dayString,10);
     73e:	8c 85       	ldd	r24, Y+12	; 0x0c
     740:	9d 85       	ldd	r25, Y+13	; 0x0d
     742:	fc 01       	movw	r30, r24
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9e 01       	movw	r18, r28
     74a:	2c 5f       	subi	r18, 0xFC	; 252
     74c:	3f 4f       	sbci	r19, 0xFF	; 255
     74e:	b9 01       	movw	r22, r18
     750:	4a e0       	ldi	r20, 0x0A	; 10
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <itoa>
	itoa(year,yearString,10);
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	fc 01       	movw	r30, r24
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9e 01       	movw	r18, r28
     764:	29 5f       	subi	r18, 0xF9	; 249
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	4a e0       	ldi	r20, 0x0A	; 10
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <itoa>
	strcpy(dateString,monthString);
     772:	8c 85       	ldd	r24, Y+12	; 0x0c
     774:	9d 85       	ldd	r25, Y+13	; 0x0d
     776:	06 96       	adiw	r24, 0x06	; 6
     778:	9e 01       	movw	r18, r28
     77a:	2f 5f       	subi	r18, 0xFF	; 255
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	0e 94 c2 1b 	call	0x3784	; 0x3784 <strcpy>
	strcat(dateString,",");
     784:	8c 85       	ldd	r24, Y+12	; 0x0c
     786:	9d 85       	ldd	r25, Y+13	; 0x0d
     788:	9c 01       	movw	r18, r24
     78a:	2a 5f       	subi	r18, 0xFA	; 250
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	c9 01       	movw	r24, r18
     790:	ac 01       	movw	r20, r24
     792:	fa 01       	movw	r30, r20
     794:	01 90       	ld	r0, Z+
     796:	00 20       	and	r0, r0
     798:	e9 f7       	brne	.-6      	; 0x794 <_ZN6myDate7getDateEv+0x88>
     79a:	cf 01       	movw	r24, r30
     79c:	01 97       	sbiw	r24, 0x01	; 1
     79e:	84 1b       	sub	r24, r20
     7a0:	95 0b       	sbc	r25, r21
     7a2:	82 0f       	add	r24, r18
     7a4:	93 1f       	adc	r25, r19
     7a6:	2c e2       	ldi	r18, 0x2C	; 44
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	fc 01       	movw	r30, r24
     7ac:	31 83       	std	Z+1, r19	; 0x01
     7ae:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     7b0:	8c 85       	ldd	r24, Y+12	; 0x0c
     7b2:	9d 85       	ldd	r25, Y+13	; 0x0d
     7b4:	06 96       	adiw	r24, 0x06	; 6
     7b6:	9e 01       	movw	r18, r28
     7b8:	2c 5f       	subi	r18, 0xFC	; 252
     7ba:	3f 4f       	sbci	r19, 0xFF	; 255
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 ae 1b 	call	0x375c	; 0x375c <strcat>
	strcat(dateString,",");
     7c2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7c4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7c6:	9c 01       	movw	r18, r24
     7c8:	2a 5f       	subi	r18, 0xFA	; 250
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	c9 01       	movw	r24, r18
     7ce:	ac 01       	movw	r20, r24
     7d0:	fa 01       	movw	r30, r20
     7d2:	01 90       	ld	r0, Z+
     7d4:	00 20       	and	r0, r0
     7d6:	e9 f7       	brne	.-6      	; 0x7d2 <_ZN6myDate7getDateEv+0xc6>
     7d8:	cf 01       	movw	r24, r30
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	84 1b       	sub	r24, r20
     7de:	95 0b       	sbc	r25, r21
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	2c e2       	ldi	r18, 0x2C	; 44
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	fc 01       	movw	r30, r24
     7ea:	31 83       	std	Z+1, r19	; 0x01
     7ec:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     7ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     7f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f2:	06 96       	adiw	r24, 0x06	; 6
     7f4:	9e 01       	movw	r18, r28
     7f6:	29 5f       	subi	r18, 0xF9	; 249
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 ae 1b 	call	0x375c	; 0x375c <strcat>
	dateString[16] = '\0';
     800:	8c 85       	ldd	r24, Y+12	; 0x0c
     802:	9d 85       	ldd	r25, Y+13	; 0x0d
     804:	fc 01       	movw	r30, r24
     806:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     808:	8c 85       	ldd	r24, Y+12	; 0x0c
     80a:	9d 85       	ldd	r25, Y+13	; 0x0d
     80c:	06 96       	adiw	r24, 0x06	; 6
     80e:	2d 96       	adiw	r28, 0x0d	; 13
     810:	0f b6       	in	r0, 0x3f	; 63
     812:	f8 94       	cli
     814:	de bf       	out	0x3e, r29	; 62
     816:	0f be       	out	0x3f, r0	; 63
     818:	cd bf       	out	0x3d, r28	; 61
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	08 95       	ret

00000820 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	00 d0       	rcall	.+0      	; 0x826 <_ZN6myTimeC1Ev+0x6>
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	9a 83       	std	Y+2, r25	; 0x02
     82c:	89 83       	std	Y+1, r24	; 0x01
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     836:	89 81       	ldd	r24, Y+1	; 0x01
     838:	9a 81       	ldd	r25, Y+2	; 0x02
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	40 e0       	ldi	r20, 0x00	; 0
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	08 95       	ret

00000854 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	28 97       	sbiw	r28, 0x08	; 8
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 83       	std	Y+2, r25	; 0x02
     86a:	89 83       	std	Y+1, r24	; 0x01
     86c:	7c 83       	std	Y+4, r23	; 0x04
     86e:	6b 83       	std	Y+3, r22	; 0x03
     870:	5e 83       	std	Y+6, r21	; 0x06
     872:	4d 83       	std	Y+5, r20	; 0x05
     874:	38 87       	std	Y+8, r19	; 0x08
     876:	2f 83       	std	Y+7, r18	; 0x07
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	9a 81       	ldd	r25, Y+2	; 0x02
     87c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	9a 81       	ldd	r25, Y+2	; 0x02
     884:	6b 81       	ldd	r22, Y+3	; 0x03
     886:	7c 81       	ldd	r23, Y+4	; 0x04
     888:	4d 81       	ldd	r20, Y+5	; 0x05
     88a:	5e 81       	ldd	r21, Y+6	; 0x06
     88c:	2f 81       	ldd	r18, Y+7	; 0x07
     88e:	38 85       	ldd	r19, Y+8	; 0x08
     890:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     894:	28 96       	adiw	r28, 0x08	; 8
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	de bf       	out	0x3e, r29	; 62
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	cd bf       	out	0x3d, r28	; 61
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	08 95       	ret

000008a6 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     8a6:	cf 92       	push	r12
     8a8:	df 92       	push	r13
     8aa:	ef 92       	push	r14
     8ac:	ff 92       	push	r15
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
     8ba:	2e 97       	sbiw	r28, 0x0e	; 14
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	f8 94       	cli
     8c0:	de bf       	out	0x3e, r29	; 62
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	cd bf       	out	0x3d, r28	; 61
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01
     8ca:	7c 83       	std	Y+4, r23	; 0x04
     8cc:	6b 83       	std	Y+3, r22	; 0x03
     8ce:	5e 83       	std	Y+6, r21	; 0x06
     8d0:	4d 83       	std	Y+5, r20	; 0x05
     8d2:	38 87       	std	Y+8, r19	; 0x08
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	1a 87       	std	Y+10, r17	; 0x0a
     8d8:	09 87       	std	Y+9, r16	; 0x09
     8da:	fc 86       	std	Y+12, r15	; 0x0c
     8dc:	eb 86       	std	Y+11, r14	; 0x0b
     8de:	de 86       	std	Y+14, r13	; 0x0e
     8e0:	cd 86       	std	Y+13, r12	; 0x0d
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	69 85       	ldd	r22, Y+9	; 0x09
     8e8:	7a 85       	ldd	r23, Y+10	; 0x0a
     8ea:	4b 85       	ldd	r20, Y+11	; 0x0b
     8ec:	5c 85       	ldd	r21, Y+12	; 0x0c
     8ee:	2d 85       	ldd	r18, Y+13	; 0x0d
     8f0:	3e 85       	ldd	r19, Y+14	; 0x0e
     8f2:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	9a 81       	ldd	r25, Y+2	; 0x02
     8fa:	6b 81       	ldd	r22, Y+3	; 0x03
     8fc:	7c 81       	ldd	r23, Y+4	; 0x04
     8fe:	4d 81       	ldd	r20, Y+5	; 0x05
     900:	5e 81       	ldd	r21, Y+6	; 0x06
     902:	2f 81       	ldd	r18, Y+7	; 0x07
     904:	38 85       	ldd	r19, Y+8	; 0x08
     906:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     90a:	2e 96       	adiw	r28, 0x0e	; 14
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	de bf       	out	0x3e, r29	; 62
     912:	0f be       	out	0x3f, r0	; 63
     914:	cd bf       	out	0x3d, r28	; 61
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	08 95       	ret

00000928 <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	00 d0       	rcall	.+0      	; 0x92e <_ZN6myTime10getSecondsEv+0x6>
     92e:	cd b7       	in	r28, 0x3d	; 61
     930:	de b7       	in	r29, 0x3e	; 62
     932:	9a 83       	std	Y+2, r25	; 0x02
     934:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     936:	89 81       	ldd	r24, Y+1	; 0x01
     938:	9a 81       	ldd	r25, Y+2	; 0x02
     93a:	fc 01       	movw	r30, r24
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	00 d0       	rcall	.+0      	; 0x950 <_ZN6myTime10getMinutesEv+0x6>
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	9a 83       	std	Y+2, r25	; 0x02
     956:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	9a 81       	ldd	r25, Y+2	; 0x02
     95c:	fc 01       	movw	r30, r24
     95e:	81 8d       	ldd	r24, Z+25	; 0x19
     960:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	00 d0       	rcall	.+0      	; 0x972 <_ZN6myTime8getHoursEv+0x6>
     972:	cd b7       	in	r28, 0x3d	; 61
     974:	de b7       	in	r29, 0x3e	; 62
     976:	9a 83       	std	Y+2, r25	; 0x02
     978:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	87 89       	ldd	r24, Z+23	; 0x17
     982:	90 8d       	ldd	r25, Z+24	; 0x18
}
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
     996:	a2 97       	sbiw	r28, 0x22	; 34
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	f8 94       	cli
     99c:	de bf       	out	0x3e, r29	; 62
     99e:	0f be       	out	0x3f, r0	; 63
     9a0:	cd bf       	out	0x3d, r28	; 61
     9a2:	98 a3       	lds	r25, 0x58
     9a4:	8f 8f       	std	Y+31, r24	; 0x1f
     9a6:	7a a3       	lds	r23, 0x5a
     9a8:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     9aa:	ce 01       	movw	r24, r28
     9ac:	0b 96       	adiw	r24, 0x0b	; 11
     9ae:	29 a1       	lds	r18, 0x49
     9b0:	3a a1       	lds	r19, 0x4a
     9b2:	b9 01       	movw	r22, r18
     9b4:	0e 94 c2 1b 	call	0x3784	; 0x3784 <strcpy>
	for (int j=0; j<3; j++){
     9b8:	1a 82       	std	Y+2, r1	; 0x02
     9ba:	19 82       	std	Y+1, r1	; 0x01
     9bc:	43 c0       	rjmp	.+134    	; 0xa44 <_ZN6myTime7setTimeEPc+0xb6>
		for (int i=0; i<2; i++){
     9be:	1c 82       	std	Y+4, r1	; 0x04
     9c0:	1b 82       	std	Y+3, r1	; 0x03
     9c2:	20 c0       	rjmp	.+64     	; 0xa04 <_ZN6myTime7setTimeEPc+0x76>
				tempString[i]=currentString[i+j*3];
     9c4:	29 81       	ldd	r18, Y+1	; 0x01
     9c6:	3a 81       	ldd	r19, Y+2	; 0x02
     9c8:	c9 01       	movw	r24, r18
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	28 0f       	add	r18, r24
     9d0:	39 1f       	adc	r19, r25
     9d2:	8b 81       	ldd	r24, Y+3	; 0x03
     9d4:	9c 81       	ldd	r25, Y+4	; 0x04
     9d6:	82 0f       	add	r24, r18
     9d8:	93 1f       	adc	r25, r19
     9da:	9e 01       	movw	r18, r28
     9dc:	25 5f       	subi	r18, 0xF5	; 245
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	fc 01       	movw	r30, r24
     9e6:	40 81       	ld	r20, Z
     9e8:	9e 01       	movw	r18, r28
     9ea:	2b 5e       	subi	r18, 0xEB	; 235
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	8b 81       	ldd	r24, Y+3	; 0x03
     9f0:	9c 81       	ldd	r25, Y+4	; 0x04
     9f2:	82 0f       	add	r24, r18
     9f4:	93 1f       	adc	r25, r19
     9f6:	fc 01       	movw	r30, r24
     9f8:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
     9fc:	9c 81       	ldd	r25, Y+4	; 0x04
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	9c 83       	std	Y+4, r25	; 0x04
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	21 e0       	ldi	r18, 0x01	; 1
     a06:	8b 81       	ldd	r24, Y+3	; 0x03
     a08:	9c 81       	ldd	r25, Y+4	; 0x04
     a0a:	82 30       	cpi	r24, 0x02	; 2
     a0c:	91 05       	cpc	r25, r1
     a0e:	0c f0       	brlt	.+2      	; 0xa12 <_ZN6myTime7setTimeEPc+0x84>
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	22 23       	and	r18, r18
     a14:	b9 f6       	brne	.-82     	; 0x9c4 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     a16:	ce 01       	movw	r24, r28
     a18:	45 96       	adiw	r24, 0x15	; 21
     a1a:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
     a1e:	9c 01       	movw	r18, r24
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	ae 01       	movw	r20, r28
     a2a:	4f 5f       	subi	r20, 0xFF	; 255
     a2c:	5f 4f       	sbci	r21, 0xFF	; 255
     a2e:	84 0f       	add	r24, r20
     a30:	95 1f       	adc	r25, r21
     a32:	04 96       	adiw	r24, 0x04	; 4
     a34:	fc 01       	movw	r30, r24
     a36:	31 83       	std	Z+1, r19	; 0x01
     a38:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	9a 81       	ldd	r25, Y+2	; 0x02
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	9a 83       	std	Y+2, r25	; 0x02
     a42:	89 83       	std	Y+1, r24	; 0x01
     a44:	21 e0       	ldi	r18, 0x01	; 1
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	9a 81       	ldd	r25, Y+2	; 0x02
     a4a:	83 30       	cpi	r24, 0x03	; 3
     a4c:	91 05       	cpc	r25, r1
     a4e:	0c f0       	brlt	.+2      	; 0xa52 <_ZN6myTime7setTimeEPc+0xc4>
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	22 23       	and	r18, r18
     a54:	09 f0       	breq	.+2      	; 0xa58 <_ZN6myTime7setTimeEPc+0xca>
     a56:	b3 cf       	rjmp	.-154    	; 0x9be <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	9e 81       	ldd	r25, Y+6	; 0x06
     a5c:	47 96       	adiw	r24, 0x17	; 23
     a5e:	8f 32       	cpi	r24, 0x2F	; 47
     a60:	91 05       	cpc	r25, r1
     a62:	c0 f4       	brcc	.+48     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a64:	8f 81       	ldd	r24, Y+7	; 0x07
     a66:	98 85       	ldd	r25, Y+8	; 0x08
     a68:	cb 96       	adiw	r24, 0x3b	; 59
     a6a:	87 37       	cpi	r24, 0x77	; 119
     a6c:	91 05       	cpc	r25, r1
     a6e:	90 f4       	brcc	.+36     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a70:	89 85       	ldd	r24, Y+9	; 0x09
     a72:	9a 85       	ldd	r25, Y+10	; 0x0a
     a74:	cb 96       	adiw	r24, 0x3b	; 59
     a76:	87 37       	cpi	r24, 0x77	; 119
     a78:	91 05       	cpc	r25, r1
     a7a:	60 f4       	brcc	.+24     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     a7c:	6d 81       	ldd	r22, Y+5	; 0x05
     a7e:	7e 81       	ldd	r23, Y+6	; 0x06
     a80:	4f 81       	ldd	r20, Y+7	; 0x07
     a82:	58 85       	ldd	r21, Y+8	; 0x08
     a84:	29 85       	ldd	r18, Y+9	; 0x09
     a86:	3a 85       	ldd	r19, Y+10	; 0x0a
     a88:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a8a:	98 a1       	lds	r25, 0x48
     a8c:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
		return fTrue;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	01 c0       	rjmp	.+2      	; 0xa96 <_ZN6myTime7setTimeEPc+0x108>
	} 
	return fFalse;
     a94:	80 e0       	ldi	r24, 0x00	; 0
}
     a96:	a2 96       	adiw	r28, 0x22	; 34
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	cd bf       	out	0x3d, r28	; 61
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	cd b7       	in	r28, 0x3d	; 61
     aae:	de b7       	in	r29, 0x3e	; 62
     ab0:	28 97       	sbiw	r28, 0x08	; 8
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	9a 83       	std	Y+2, r25	; 0x02
     abe:	89 83       	std	Y+1, r24	; 0x01
     ac0:	7c 83       	std	Y+4, r23	; 0x04
     ac2:	6b 83       	std	Y+3, r22	; 0x03
     ac4:	5e 83       	std	Y+6, r21	; 0x06
     ac6:	4d 83       	std	Y+5, r20	; 0x05
     ac8:	38 87       	std	Y+8, r19	; 0x08
     aca:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
     ad0:	2b 81       	ldd	r18, Y+3	; 0x03
     ad2:	3c 81       	ldd	r19, Y+4	; 0x04
     ad4:	b9 01       	movw	r22, r18
     ad6:	0e 94 84 05 	call	0xb08	; 0xb08 <_ZN6myTime7setHourEi>
	setMinute(minute);
     ada:	89 81       	ldd	r24, Y+1	; 0x01
     adc:	9a 81       	ldd	r25, Y+2	; 0x02
     ade:	2d 81       	ldd	r18, Y+5	; 0x05
     ae0:	3e 81       	ldd	r19, Y+6	; 0x06
     ae2:	b9 01       	movw	r22, r18
     ae4:	0e 94 a2 05 	call	0xb44	; 0xb44 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     ae8:	89 81       	ldd	r24, Y+1	; 0x01
     aea:	9a 81       	ldd	r25, Y+2	; 0x02
     aec:	2f 81       	ldd	r18, Y+7	; 0x07
     aee:	38 85       	ldd	r19, Y+8	; 0x08
     af0:	b9 01       	movw	r22, r18
     af2:	0e 94 c0 05 	call	0xb80	; 0xb80 <_ZN6myTime9setSecondEi>
}
     af6:	28 96       	adiw	r28, 0x08	; 8
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	de bf       	out	0x3e, r29	; 62
     afe:	0f be       	out	0x3f, r0	; 63
     b00:	cd bf       	out	0x3d, r28	; 61
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     b08:	cf 93       	push	r28
     b0a:	df 93       	push	r29
     b0c:	00 d0       	rcall	.+0      	; 0xb0e <_ZN6myTime7setHourEi+0x6>
     b0e:	00 d0       	rcall	.+0      	; 0xb10 <_ZN6myTime7setHourEi+0x8>
     b10:	cd b7       	in	r28, 0x3d	; 61
     b12:	de b7       	in	r29, 0x3e	; 62
     b14:	9a 83       	std	Y+2, r25	; 0x02
     b16:	89 83       	std	Y+1, r24	; 0x01
     b18:	7c 83       	std	Y+4, r23	; 0x04
     b1a:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     b1c:	8b 81       	ldd	r24, Y+3	; 0x03
     b1e:	9c 81       	ldd	r25, Y+4	; 0x04
     b20:	47 96       	adiw	r24, 0x17	; 23
     b22:	8f 32       	cpi	r24, 0x2F	; 47
     b24:	91 05       	cpc	r25, r1
     b26:	38 f4       	brcc	.+14     	; 0xb36 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     b28:	89 81       	ldd	r24, Y+1	; 0x01
     b2a:	9a 81       	ldd	r25, Y+2	; 0x02
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	3c 81       	ldd	r19, Y+4	; 0x04
     b30:	fc 01       	movw	r30, r24
     b32:	30 8f       	std	Z+24, r19	; 0x18
     b34:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	0f 90       	pop	r0
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <_ZN6myTime9setMinuteEi+0x6>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <_ZN6myTime9setMinuteEi+0x8>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01
     b54:	7c 83       	std	Y+4, r23	; 0x04
     b56:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	cb 96       	adiw	r24, 0x3b	; 59
     b5e:	87 37       	cpi	r24, 0x77	; 119
     b60:	91 05       	cpc	r25, r1
     b62:	38 f4       	brcc	.+14     	; 0xb72 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	2b 81       	ldd	r18, Y+3	; 0x03
     b6a:	3c 81       	ldd	r19, Y+4	; 0x04
     b6c:	fc 01       	movw	r30, r24
     b6e:	32 8f       	std	Z+26, r19	; 0x1a
     b70:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     b72:	0f 90       	pop	r0
     b74:	0f 90       	pop	r0
     b76:	0f 90       	pop	r0
     b78:	0f 90       	pop	r0
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	00 d0       	rcall	.+0      	; 0xb86 <_ZN6myTime9setSecondEi+0x6>
     b86:	00 d0       	rcall	.+0      	; 0xb88 <_ZN6myTime9setSecondEi+0x8>
     b88:	cd b7       	in	r28, 0x3d	; 61
     b8a:	de b7       	in	r29, 0x3e	; 62
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
     b90:	7c 83       	std	Y+4, r23	; 0x04
     b92:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	cb 96       	adiw	r24, 0x3b	; 59
     b9a:	87 37       	cpi	r24, 0x77	; 119
     b9c:	91 05       	cpc	r25, r1
     b9e:	38 f4       	brcc	.+14     	; 0xbae <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	9a 81       	ldd	r25, Y+2	; 0x02
     ba4:	2b 81       	ldd	r18, Y+3	; 0x03
     ba6:	3c 81       	ldd	r19, Y+4	; 0x04
     ba8:	fc 01       	movw	r30, r24
     baa:	34 8f       	std	Z+28, r19	; 0x1c
     bac:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	28 97       	sbiw	r28, 0x08	; 8
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	de bf       	out	0x3e, r29	; 62
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	cd bf       	out	0x3d, r28	; 61
     bd0:	9e 83       	std	Y+6, r25	; 0x06
     bd2:	8d 83       	std	Y+5, r24	; 0x05
     bd4:	78 87       	std	Y+8, r23	; 0x08
     bd6:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     bd8:	8d 81       	ldd	r24, Y+5	; 0x05
     bda:	9e 81       	ldd	r25, Y+6	; 0x06
     bdc:	fc 01       	movw	r30, r24
     bde:	27 89       	ldd	r18, Z+23	; 0x17
     be0:	30 8d       	ldd	r19, Z+24	; 0x18
     be2:	8f 81       	ldd	r24, Y+7	; 0x07
     be4:	98 85       	ldd	r25, Y+8	; 0x08
     be6:	82 0f       	add	r24, r18
     be8:	93 1f       	adc	r25, r19
     bea:	9a 83       	std	Y+2, r25	; 0x02
     bec:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	9a 81       	ldd	r25, Y+2	; 0x02
     bf2:	28 e1       	ldi	r18, 0x18	; 24
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	b9 01       	movw	r22, r18
     bf8:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     bfc:	9c 01       	movw	r18, r24
     bfe:	8d 81       	ldd	r24, Y+5	; 0x05
     c00:	9e 81       	ldd	r25, Y+6	; 0x06
     c02:	fc 01       	movw	r30, r24
     c04:	30 8f       	std	Z+24, r19	; 0x18
     c06:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a 81       	ldd	r25, Y+2	; 0x02
     c0c:	21 e0       	ldi	r18, 0x01	; 1
     c0e:	88 31       	cpi	r24, 0x18	; 24
     c10:	91 05       	cpc	r25, r1
     c12:	0c f4       	brge	.+2      	; 0xc16 <_ZN6myTime8addHoursEi+0x5a>
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	22 23       	and	r18, r18
     c18:	91 f0       	breq	.+36     	; 0xc3e <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	28 e1       	ldi	r18, 0x18	; 24
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	b9 01       	movw	r22, r18
     c24:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     c28:	9b 01       	movw	r18, r22
     c2a:	c9 01       	movw	r24, r18
     c2c:	9c 83       	std	Y+4, r25	; 0x04
     c2e:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     c30:	8d 81       	ldd	r24, Y+5	; 0x05
     c32:	9e 81       	ldd	r25, Y+6	; 0x06
     c34:	2b 81       	ldd	r18, Y+3	; 0x03
     c36:	3c 81       	ldd	r19, Y+4	; 0x04
     c38:	b9 01       	movw	r22, r18
     c3a:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     c3e:	28 96       	adiw	r28, 0x08	; 8
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	08 95       	ret

00000c50 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
     c58:	28 97       	sbiw	r28, 0x08	; 8
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	9e 83       	std	Y+6, r25	; 0x06
     c66:	8d 83       	std	Y+5, r24	; 0x05
     c68:	78 87       	std	Y+8, r23	; 0x08
     c6a:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     c6c:	8d 81       	ldd	r24, Y+5	; 0x05
     c6e:	9e 81       	ldd	r25, Y+6	; 0x06
     c70:	fc 01       	movw	r30, r24
     c72:	21 8d       	ldd	r18, Z+25	; 0x19
     c74:	32 8d       	ldd	r19, Z+26	; 0x1a
     c76:	8f 81       	ldd	r24, Y+7	; 0x07
     c78:	98 85       	ldd	r25, Y+8	; 0x08
     c7a:	82 0f       	add	r24, r18
     c7c:	93 1f       	adc	r25, r19
     c7e:	9a 83       	std	Y+2, r25	; 0x02
     c80:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	9a 81       	ldd	r25, Y+2	; 0x02
     c86:	2c e3       	ldi	r18, 0x3C	; 60
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	b9 01       	movw	r22, r18
     c8c:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     c90:	9c 01       	movw	r18, r24
     c92:	8d 81       	ldd	r24, Y+5	; 0x05
     c94:	9e 81       	ldd	r25, Y+6	; 0x06
     c96:	fc 01       	movw	r30, r24
     c98:	32 8f       	std	Z+26, r19	; 0x1a
     c9a:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ca0:	21 e0       	ldi	r18, 0x01	; 1
     ca2:	8c 33       	cpi	r24, 0x3C	; 60
     ca4:	91 05       	cpc	r25, r1
     ca6:	0c f4       	brge	.+2      	; 0xcaa <_ZN6myTime10addMinutesEi+0x5a>
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	22 23       	and	r18, r18
     cac:	91 f0       	breq	.+36     	; 0xcd2 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	2c e3       	ldi	r18, 0x3C	; 60
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	b9 01       	movw	r22, r18
     cb8:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     cbc:	9b 01       	movw	r18, r22
     cbe:	c9 01       	movw	r24, r18
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     cc4:	2b 81       	ldd	r18, Y+3	; 0x03
     cc6:	3c 81       	ldd	r19, Y+4	; 0x04
     cc8:	8d 81       	ldd	r24, Y+5	; 0x05
     cca:	9e 81       	ldd	r25, Y+6	; 0x06
     ccc:	b9 01       	movw	r22, r18
     cce:	0e 94 de 05 	call	0xbbc	; 0xbbc <_ZN6myTime8addHoursEi>
	}
}
     cd2:	28 96       	adiw	r28, 0x08	; 8
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	cd b7       	in	r28, 0x3d	; 61
     cea:	de b7       	in	r29, 0x3e	; 62
     cec:	28 97       	sbiw	r28, 0x08	; 8
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	de bf       	out	0x3e, r29	; 62
     cf4:	0f be       	out	0x3f, r0	; 63
     cf6:	cd bf       	out	0x3d, r28	; 61
     cf8:	9e 83       	std	Y+6, r25	; 0x06
     cfa:	8d 83       	std	Y+5, r24	; 0x05
     cfc:	78 87       	std	Y+8, r23	; 0x08
     cfe:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	9e 81       	ldd	r25, Y+6	; 0x06
     d04:	fc 01       	movw	r30, r24
     d06:	23 8d       	ldd	r18, Z+27	; 0x1b
     d08:	34 8d       	ldd	r19, Z+28	; 0x1c
     d0a:	8f 81       	ldd	r24, Y+7	; 0x07
     d0c:	98 85       	ldd	r25, Y+8	; 0x08
     d0e:	82 0f       	add	r24, r18
     d10:	93 1f       	adc	r25, r19
     d12:	9a 83       	std	Y+2, r25	; 0x02
     d14:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     d16:	89 81       	ldd	r24, Y+1	; 0x01
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	2c e3       	ldi	r18, 0x3C	; 60
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	b9 01       	movw	r22, r18
     d20:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     d24:	9c 01       	movw	r18, r24
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	fc 01       	movw	r30, r24
     d2c:	34 8f       	std	Z+28, r19	; 0x1c
     d2e:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	9a 81       	ldd	r25, Y+2	; 0x02
     d34:	21 e0       	ldi	r18, 0x01	; 1
     d36:	8c 33       	cpi	r24, 0x3C	; 60
     d38:	91 05       	cpc	r25, r1
     d3a:	0c f4       	brge	.+2      	; 0xd3e <_ZN6myTime10addSecondsEi+0x5a>
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	22 23       	and	r18, r18
     d40:	91 f0       	breq	.+36     	; 0xd66 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     d42:	89 81       	ldd	r24, Y+1	; 0x01
     d44:	9a 81       	ldd	r25, Y+2	; 0x02
     d46:	2c e3       	ldi	r18, 0x3C	; 60
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	b9 01       	movw	r22, r18
     d4c:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
     d50:	9b 01       	movw	r18, r22
     d52:	c9 01       	movw	r24, r18
     d54:	9c 83       	std	Y+4, r25	; 0x04
     d56:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     d58:	2b 81       	ldd	r18, Y+3	; 0x03
     d5a:	3c 81       	ldd	r19, Y+4	; 0x04
     d5c:	8d 81       	ldd	r24, Y+5	; 0x05
     d5e:	9e 81       	ldd	r25, Y+6	; 0x06
     d60:	b9 01       	movw	r22, r18
     d62:	0e 94 28 06 	call	0xc50	; 0xc50 <_ZN6myTime10addMinutesEi>
	}
}
     d66:	28 96       	adiw	r28, 0x08	; 8
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	08 95       	ret

00000d78 <_ZN6myTime13checkValidityEv>:

BOOL myTime::checkValidity(){
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	00 d0       	rcall	.+0      	; 0xd7e <_ZN6myTime13checkValidityEv+0x6>
     d7e:	0f 92       	push	r0
     d80:	cd b7       	in	r28, 0x3d	; 61
     d82:	de b7       	in	r29, 0x3e	; 62
     d84:	9b 83       	std	Y+3, r25	; 0x03
     d86:	8a 83       	std	Y+2, r24	; 0x02
	BOOL stillValid=fTrue;
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	89 83       	std	Y+1, r24	; 0x01
	if (second/60==0 && minute/60==0 && hour/24==0){
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	fc 01       	movw	r30, r24
     d92:	83 8d       	ldd	r24, Z+27	; 0x1b
     d94:	94 8d       	ldd	r25, Z+28	; 0x1c
     d96:	cb 96       	adiw	r24, 0x3b	; 59
     d98:	87 37       	cpi	r24, 0x77	; 119
     d9a:	91 05       	cpc	r25, r1
     d9c:	a0 f4       	brcc	.+40     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	fc 01       	movw	r30, r24
     da4:	81 8d       	ldd	r24, Z+25	; 0x19
     da6:	92 8d       	ldd	r25, Z+26	; 0x1a
     da8:	cb 96       	adiw	r24, 0x3b	; 59
     daa:	87 37       	cpi	r24, 0x77	; 119
     dac:	91 05       	cpc	r25, r1
     dae:	58 f4       	brcc	.+22     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	9b 81       	ldd	r25, Y+3	; 0x03
     db4:	fc 01       	movw	r30, r24
     db6:	87 89       	ldd	r24, Z+23	; 0x17
     db8:	90 8d       	ldd	r25, Z+24	; 0x18
     dba:	47 96       	adiw	r24, 0x17	; 23
     dbc:	8f 32       	cpi	r24, 0x2F	; 47
     dbe:	91 05       	cpc	r25, r1
     dc0:	10 f4       	brcc	.+4      	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <_ZN6myTime13checkValidityEv+0x50>
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	88 23       	and	r24, r24
     dca:	69 f0       	breq	.+26     	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
		if (checkValidityDate()){return fTrue;}
     dcc:	8a 81       	ldd	r24, Y+2	; 0x02
     dce:	9b 81       	ldd	r25, Y+3	; 0x03
     dd0:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate17checkValidityDateEv>
     dd4:	98 2f       	mov	r25, r24
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	99 23       	and	r25, r25
     dda:	09 f4       	brne	.+2      	; 0xdde <_ZN6myTime13checkValidityEv+0x66>
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	88 23       	and	r24, r24
     de0:	11 f0       	breq	.+4      	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	01 c0       	rjmp	.+2      	; 0xde8 <_ZN6myTime13checkValidityEv+0x70>
	}
	return fFalse;
     de6:	80 e0       	ldi	r24, 0x00	; 0
}
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	cd b7       	in	r28, 0x3d	; 61
     dfa:	de b7       	in	r29, 0x3e	; 62
     dfc:	2b 97       	sbiw	r28, 0x0b	; 11
     dfe:	0f b6       	in	r0, 0x3f	; 63
     e00:	f8 94       	cli
     e02:	de bf       	out	0x3e, r29	; 62
     e04:	0f be       	out	0x3f, r0	; 63
     e06:	cd bf       	out	0x3d, r28	; 61
     e08:	9b 87       	std	Y+11, r25	; 0x0b
     e0a:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e10:	fc 01       	movw	r30, r24
     e12:	87 89       	ldd	r24, Z+23	; 0x17
     e14:	90 8d       	ldd	r25, Z+24	; 0x18
     e16:	9e 01       	movw	r18, r28
     e18:	2f 5f       	subi	r18, 0xFF	; 255
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	b9 01       	movw	r22, r18
     e1e:	4a e0       	ldi	r20, 0x0A	; 10
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <itoa>
	itoa(minute,minuteString,10);
     e26:	8a 85       	ldd	r24, Y+10	; 0x0a
     e28:	9b 85       	ldd	r25, Y+11	; 0x0b
     e2a:	fc 01       	movw	r30, r24
     e2c:	81 8d       	ldd	r24, Z+25	; 0x19
     e2e:	92 8d       	ldd	r25, Z+26	; 0x1a
     e30:	9e 01       	movw	r18, r28
     e32:	2c 5f       	subi	r18, 0xFC	; 252
     e34:	3f 4f       	sbci	r19, 0xFF	; 255
     e36:	b9 01       	movw	r22, r18
     e38:	4a e0       	ldi	r20, 0x0A	; 10
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <itoa>
	itoa(second,secondString,10);
     e40:	8a 85       	ldd	r24, Y+10	; 0x0a
     e42:	9b 85       	ldd	r25, Y+11	; 0x0b
     e44:	fc 01       	movw	r30, r24
     e46:	83 8d       	ldd	r24, Z+27	; 0x1b
     e48:	94 8d       	ldd	r25, Z+28	; 0x1c
     e4a:	9e 01       	movw	r18, r28
     e4c:	29 5f       	subi	r18, 0xF9	; 249
     e4e:	3f 4f       	sbci	r19, 0xFF	; 255
     e50:	b9 01       	movw	r22, r18
     e52:	4a e0       	ldi	r20, 0x0A	; 10
     e54:	50 e0       	ldi	r21, 0x00	; 0
     e56:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <itoa>
	strcpy(timeString,hourString);
     e5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e5e:	4d 96       	adiw	r24, 0x1d	; 29
     e60:	9e 01       	movw	r18, r28
     e62:	2f 5f       	subi	r18, 0xFF	; 255
     e64:	3f 4f       	sbci	r19, 0xFF	; 255
     e66:	b9 01       	movw	r22, r18
     e68:	0e 94 c2 1b 	call	0x3784	; 0x3784 <strcpy>
	strcat(timeString,":");
     e6c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e6e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e70:	9c 01       	movw	r18, r24
     e72:	23 5e       	subi	r18, 0xE3	; 227
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	c9 01       	movw	r24, r18
     e78:	ac 01       	movw	r20, r24
     e7a:	fa 01       	movw	r30, r20
     e7c:	01 90       	ld	r0, Z+
     e7e:	00 20       	and	r0, r0
     e80:	e9 f7       	brne	.-6      	; 0xe7c <_ZN6myTime7getTimeEv+0x88>
     e82:	cf 01       	movw	r24, r30
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	84 1b       	sub	r24, r20
     e88:	95 0b       	sbc	r25, r21
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	2a e3       	ldi	r18, 0x3A	; 58
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	fc 01       	movw	r30, r24
     e94:	31 83       	std	Z+1, r19	; 0x01
     e96:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     e98:	8a 85       	ldd	r24, Y+10	; 0x0a
     e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9c:	4d 96       	adiw	r24, 0x1d	; 29
     e9e:	9e 01       	movw	r18, r28
     ea0:	2c 5f       	subi	r18, 0xFC	; 252
     ea2:	3f 4f       	sbci	r19, 0xFF	; 255
     ea4:	b9 01       	movw	r22, r18
     ea6:	0e 94 ae 1b 	call	0x375c	; 0x375c <strcat>
	strcat(timeString,":");
     eaa:	8a 85       	ldd	r24, Y+10	; 0x0a
     eac:	9b 85       	ldd	r25, Y+11	; 0x0b
     eae:	9c 01       	movw	r18, r24
     eb0:	23 5e       	subi	r18, 0xE3	; 227
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	c9 01       	movw	r24, r18
     eb6:	ac 01       	movw	r20, r24
     eb8:	fa 01       	movw	r30, r20
     eba:	01 90       	ld	r0, Z+
     ebc:	00 20       	and	r0, r0
     ebe:	e9 f7       	brne	.-6      	; 0xeba <_ZN6myTime7getTimeEv+0xc6>
     ec0:	cf 01       	movw	r24, r30
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	84 1b       	sub	r24, r20
     ec6:	95 0b       	sbc	r25, r21
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	2a e3       	ldi	r18, 0x3A	; 58
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	fc 01       	movw	r30, r24
     ed2:	31 83       	std	Z+1, r19	; 0x01
     ed4:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
     eda:	4d 96       	adiw	r24, 0x1d	; 29
     edc:	9e 01       	movw	r18, r28
     ede:	29 5f       	subi	r18, 0xF9	; 249
     ee0:	3f 4f       	sbci	r19, 0xFF	; 255
     ee2:	b9 01       	movw	r22, r18
     ee4:	0e 94 ae 1b 	call	0x375c	; 0x375c <strcat>
	timeString[11] = '\0';
     ee8:	8a 85       	ldd	r24, Y+10	; 0x0a
     eea:	9b 85       	ldd	r25, Y+11	; 0x0b
     eec:	fc 01       	movw	r30, r24
     eee:	10 a6       	lds	r17, 0xb0
	return timeString;
     ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ef4:	4d 96       	adiw	r24, 0x1d	; 29
     ef6:	2b 96       	adiw	r28, 0x0b	; 11
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 31;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	2f 97       	sbiw	r28, 0x0f	; 15
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	8e 87       	std	Y+14, r24	; 0x0e
     f1e:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     f20:	f8 94       	cli
	if (gTime){
     f22:	8e 85       	ldd	r24, Y+14	; 0x0e
     f24:	88 23       	and	r24, r24
     f26:	09 f4       	brne	.+2      	; 0xf2a <_Z18getDateTime_eepromhh+0x22>
     f28:	4b c0       	rjmp	.+150    	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     f2a:	1a 82       	std	Y+2, r1	; 0x02
     f2c:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     f32:	2c c0       	rjmp	.+88     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 16 1c 	call	0x382c	; 0x382c <__eerd_byte_m644pa>
     f3c:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	0e 94 16 1c 	call	0x382c	; 0x382c <__eerd_byte_m644pa>
     f46:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 16 1c 	call	0x382c	; 0x382c <__eerd_byte_m644pa>
     f50:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     f52:	8f 81       	ldd	r24, Y+7	; 0x07
     f54:	8c 33       	cpi	r24, 0x3C	; 60
     f56:	a8 f4       	brcc	.+42     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f58:	88 85       	ldd	r24, Y+8	; 0x08
     f5a:	8c 33       	cpi	r24, 0x3C	; 60
     f5c:	90 f4       	brcc	.+36     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f5e:	89 85       	ldd	r24, Y+9	; 0x09
     f60:	88 31       	cpi	r24, 0x18	; 24
     f62:	78 f4       	brcc	.+30     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	68 2f       	mov	r22, r24
     f68:	70 e0       	ldi	r23, 0x00	; 0
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	48 2f       	mov	r20, r24
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	8f 81       	ldd	r24, Y+7	; 0x07
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	82 ea       	ldi	r24, 0xA2	; 162
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
     f7e:	1b 82       	std	Y+3, r1	; 0x03
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	9a 81       	ldd	r25, Y+2	; 0x02
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     f8c:	8b 81       	ldd	r24, Y+3	; 0x03
     f8e:	88 23       	and	r24, r24
     f90:	39 f0       	breq	.+14     	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	9a 81       	ldd	r25, Y+2	; 0x02
     f96:	83 30       	cpi	r24, 0x03	; 3
     f98:	91 05       	cpc	r25, r1
     f9a:	14 f4       	brge	.+4      	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <_Z18getDateTime_eepromhh+0x9a>
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	88 23       	and	r24, r24
     fa4:	39 f6       	brne	.-114    	; 0xf34 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     fa6:	8b 81       	ldd	r24, Y+3	; 0x03
     fa8:	88 23       	and	r24, r24
     faa:	51 f0       	breq	.+20     	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
     fac:	82 ea       	ldi	r24, 0xA2	; 162
     fae:	91 e0       	ldi	r25, 0x01	; 1
     fb0:	61 e0       	ldi	r22, 0x01	; 1
     fb2:	70 e0       	ldi	r23, 0x00	; 0
     fb4:	41 e0       	ldi	r20, 0x01	; 1
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	21 e0       	ldi	r18, 0x01	; 1
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
     fc2:	88 23       	and	r24, r24
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <_Z18getDateTime_eepromhh+0xc0>
     fc6:	4e c0       	rjmp	.+156    	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     fc8:	1d 82       	std	Y+5, r1	; 0x05
     fca:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     fcc:	81 e0       	ldi	r24, 0x01	; 1
     fce:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     fd0:	2f c0       	rjmp	.+94     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     fd2:	84 e0       	ldi	r24, 0x04	; 4
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	0e 94 16 1c 	call	0x382c	; 0x382c <__eerd_byte_m644pa>
     fda:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 16 1c 	call	0x382c	; 0x382c <__eerd_byte_m644pa>
     fe4:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     fe6:	85 e0       	ldi	r24, 0x05	; 5
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	0e 94 1e 1c 	call	0x383c	; 0x383c <__eerd_word_m644pa>
     fee:	9d 87       	std	Y+13, r25	; 0x0d
     ff0:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     ff2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff4:	8f 31       	cpi	r24, 0x1F	; 31
     ff6:	b8 f4       	brcc	.+46     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ff8:	8b 85       	ldd	r24, Y+11	; 0x0b
     ffa:	8d 30       	cpi	r24, 0x0D	; 13
     ffc:	a0 f4       	brcc	.+40     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ffe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1000:	9d 85       	ldd	r25, Y+13	; 0x0d
    1002:	27 e2       	ldi	r18, 0x27	; 39
    1004:	80 31       	cpi	r24, 0x10	; 16
    1006:	92 07       	cpc	r25, r18
    1008:	70 f4       	brcc	.+28     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
    100a:	8b 85       	ldd	r24, Y+11	; 0x0b
    100c:	68 2f       	mov	r22, r24
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	8a 85       	ldd	r24, Y+10	; 0x0a
    1012:	48 2f       	mov	r20, r24
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	2c 85       	ldd	r18, Y+12	; 0x0c
    1018:	3d 85       	ldd	r19, Y+13	; 0x0d
    101a:	82 ea       	ldi	r24, 0xA2	; 162
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
    1022:	1e 82       	std	Y+6, r1	; 0x06
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
    1026:	8c 81       	ldd	r24, Y+4	; 0x04
    1028:	9d 81       	ldd	r25, Y+5	; 0x05
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	9d 83       	std	Y+5, r25	; 0x05
    102e:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
    1030:	8e 81       	ldd	r24, Y+6	; 0x06
    1032:	88 23       	and	r24, r24
    1034:	39 f0       	breq	.+14     	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	9d 81       	ldd	r25, Y+5	; 0x05
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	91 05       	cpc	r25, r1
    103e:	14 f4       	brge	.+4      	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <_Z18getDateTime_eepromhh+0x13e>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	88 23       	and	r24, r24
    1048:	21 f6       	brne	.-120    	; 0xfd2 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	88 23       	and	r24, r24
    104e:	51 f0       	breq	.+20     	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
    1050:	82 ea       	ldi	r24, 0xA2	; 162
    1052:	91 e0       	ldi	r25, 0x01	; 1
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	70 e0       	ldi	r23, 0x00	; 0
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	21 ed       	ldi	r18, 0xD1	; 209
    105e:	37 e0       	ldi	r19, 0x07	; 7
    1060:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
    1064:	78 94       	sei
}
    1066:	2f 96       	adiw	r28, 0x0f	; 15
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	29 97       	sbiw	r28, 0x09	; 9
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	88 87       	std	Y+8, r24	; 0x08
    108e:	69 87       	std	Y+9, r22	; 0x09
	cli();
    1090:	f8 94       	cli
	if (sTime){
    1092:	88 85       	ldd	r24, Y+8	; 0x08
    1094:	88 23       	and	r24, r24
    1096:	f1 f0       	breq	.+60     	; 0x10d4 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
    1098:	82 ea       	ldi	r24, 0xA2	; 162
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    10a0:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
    10a2:	82 ea       	ldi	r24, 0xA2	; 162
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    10aa:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
    10ac:	82 ea       	ldi	r24, 0xA2	; 162
    10ae:	91 e0       	ldi	r25, 0x01	; 1
    10b0:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    10b4:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	6b 81       	ldd	r22, Y+3	; 0x03
    10bc:	0e 94 24 1c 	call	0x3848	; 0x3848 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeMinute,tempMin);
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	6a 81       	ldd	r22, Y+2	; 0x02
    10c6:	0e 94 24 1c 	call	0x3848	; 0x3848 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeHour,tempHour);
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	69 81       	ldd	r22, Y+1	; 0x01
    10d0:	0e 94 24 1c 	call	0x3848	; 0x3848 <__eewr_byte_m644pa>
	}
	if (sDate){
    10d4:	89 85       	ldd	r24, Y+9	; 0x09
    10d6:	88 23       	and	r24, r24
    10d8:	09 f1       	breq	.+66     	; 0x111c <__stack+0x1d>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
    10da:	82 ea       	ldi	r24, 0xA2	; 162
    10dc:	91 e0       	ldi	r25, 0x01	; 1
    10de:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
    10e2:	9d 83       	std	Y+5, r25	; 0x05
    10e4:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
    10e6:	82 ea       	ldi	r24, 0xA2	; 162
    10e8:	91 e0       	ldi	r25, 0x01	; 1
    10ea:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
    10ee:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
    10f0:	82 ea       	ldi	r24, 0xA2	; 162
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
    10f8:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
    10fa:	85 e0       	ldi	r24, 0x05	; 5
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1100:	3d 81       	ldd	r19, Y+5	; 0x05
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 32 1c 	call	0x3864	; 0x3864 <__eewr_word_m644pa>
		eeprom_write_byte(&eeMonth,tempMonth);
    1108:	83 e0       	ldi	r24, 0x03	; 3
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	6e 81       	ldd	r22, Y+6	; 0x06
    110e:	0e 94 24 1c 	call	0x3848	; 0x3848 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeDay,tempDay);
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	6f 81       	ldd	r22, Y+7	; 0x07
    1118:	0e 94 24 1c 	call	0x3848	; 0x3848 <__eewr_byte_m644pa>
	}
	sei();
    111c:	78 94       	sei
}
    111e:	29 96       	adiw	r28, 0x09	; 9
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	cd bf       	out	0x3d, r28	; 61
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	08 95       	ret

00001130 <_Z13PutUartChBonec>:
extern BOOL flagReceivingBone, flagFreshStart, restart, flagReceivingGAVR,flagWaitingForReceiveGAVR;
extern WORD globalADC, globalTemp;
extern myTime currentTime;

/**************************************************************************************************************/
void PutUartChBone(char ch){
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	0f 92       	push	r0
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
    113a:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
    113c:	00 00       	nop
    113e:	80 ec       	ldi	r24, 0xC0	; 192
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	fc 01       	movw	r30, r24
    1144:	80 81       	ld	r24, Z
    1146:	88 2f       	mov	r24, r24
    1148:	90 e0       	ldi	r25, 0x00	; 0
    114a:	80 72       	andi	r24, 0x20	; 32
    114c:	90 70       	andi	r25, 0x00	; 0
    114e:	21 e0       	ldi	r18, 0x01	; 1
    1150:	00 97       	sbiw	r24, 0x00	; 0
    1152:	09 f0       	breq	.+2      	; 0x1156 <_Z13PutUartChBonec+0x26>
    1154:	20 e0       	ldi	r18, 0x00	; 0
    1156:	22 23       	and	r18, r18
    1158:	91 f7       	brne	.-28     	; 0x113e <_Z13PutUartChBonec+0xe>
	UDR0=ch;
    115a:	86 ec       	ldi	r24, 0xC6	; 198
    115c:	90 e0       	ldi	r25, 0x00	; 0
    115e:	29 81       	ldd	r18, Y+1	; 0x01
    1160:	fc 01       	movw	r30, r24
    1162:	20 83       	st	Z, r18
}
    1164:	0f 90       	pop	r0
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	08 95       	ret

0000116c <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	00 d0       	rcall	.+0      	; 0x1172 <_Z9PrintBonePc+0x6>
    1172:	0f 92       	push	r0
    1174:	cd b7       	in	r28, 0x3d	; 61
    1176:	de b7       	in	r29, 0x3e	; 62
    1178:	9b 83       	std	Y+3, r25	; 0x03
    117a:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    117c:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    117e:	0e c0       	rjmp	.+28     	; 0x119c <_Z9PrintBonePc+0x30>
		PutUartChBone(string[i++]);
    1180:	89 81       	ldd	r24, Y+1	; 0x01
    1182:	88 2f       	mov	r24, r24
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	2a 81       	ldd	r18, Y+2	; 0x02
    1188:	3b 81       	ldd	r19, Y+3	; 0x03
    118a:	82 0f       	add	r24, r18
    118c:	93 1f       	adc	r25, r19
    118e:	fc 01       	movw	r30, r24
    1190:	80 81       	ld	r24, Z
    1192:	99 81       	ldd	r25, Y+1	; 0x01
    1194:	9f 5f       	subi	r25, 0xFF	; 255
    1196:	99 83       	std	Y+1, r25	; 0x01
    1198:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z13PutUartChBonec>
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	88 2f       	mov	r24, r24
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	2a 81       	ldd	r18, Y+2	; 0x02
    11a4:	3b 81       	ldd	r19, Y+3	; 0x03
    11a6:	82 0f       	add	r24, r18
    11a8:	93 1f       	adc	r25, r19
    11aa:	fc 01       	movw	r30, r24
    11ac:	90 81       	ld	r25, Z
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	99 23       	and	r25, r25
    11b2:	09 f4       	brne	.+2      	; 0x11b6 <_Z9PrintBonePc+0x4a>
    11b4:	80 e0       	ldi	r24, 0x00	; 0
    11b6:	88 23       	and	r24, r24
    11b8:	19 f7       	brne	.-58     	; 0x1180 <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i++]);
	}
}
    11ba:	0f 90       	pop	r0
    11bc:	0f 90       	pop	r0
    11be:	0f 90       	pop	r0
    11c0:	df 91       	pop	r29
    11c2:	cf 91       	pop	r28
    11c4:	08 95       	ret

000011c6 <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    11c6:	cf 93       	push	r28
    11c8:	df 93       	push	r29
    11ca:	0f 92       	push	r0
    11cc:	cd b7       	in	r28, 0x3d	; 61
    11ce:	de b7       	in	r29, 0x3e	; 62
    11d0:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    11d2:	00 00       	nop
    11d4:	88 ec       	ldi	r24, 0xC8	; 200
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	fc 01       	movw	r30, r24
    11da:	80 81       	ld	r24, Z
    11dc:	88 2f       	mov	r24, r24
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	80 72       	andi	r24, 0x20	; 32
    11e2:	90 70       	andi	r25, 0x00	; 0
    11e4:	21 e0       	ldi	r18, 0x01	; 1
    11e6:	00 97       	sbiw	r24, 0x00	; 0
    11e8:	09 f0       	breq	.+2      	; 0x11ec <_Z13PutUartChGAVRc+0x26>
    11ea:	20 e0       	ldi	r18, 0x00	; 0
    11ec:	22 23       	and	r18, r18
    11ee:	91 f7       	brne	.-28     	; 0x11d4 <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    11f0:	8e ec       	ldi	r24, 0xCE	; 206
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	29 81       	ldd	r18, Y+1	; 0x01
    11f6:	fc 01       	movw	r30, r24
    11f8:	20 83       	st	Z, r18
}
    11fa:	0f 90       	pop	r0
    11fc:	df 91       	pop	r29
    11fe:	cf 91       	pop	r28
    1200:	08 95       	ret

00001202 <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    1202:	cf 93       	push	r28
    1204:	df 93       	push	r29
    1206:	00 d0       	rcall	.+0      	; 0x1208 <_Z9PrintGAVRPc+0x6>
    1208:	0f 92       	push	r0
    120a:	cd b7       	in	r28, 0x3d	; 61
    120c:	de b7       	in	r29, 0x3e	; 62
    120e:	9b 83       	std	Y+3, r25	; 0x03
    1210:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    1212:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    1214:	0e c0       	rjmp	.+28     	; 0x1232 <_Z9PrintGAVRPc+0x30>
		PutUartChGAVR(string[i++]);
    1216:	89 81       	ldd	r24, Y+1	; 0x01
    1218:	88 2f       	mov	r24, r24
    121a:	90 e0       	ldi	r25, 0x00	; 0
    121c:	2a 81       	ldd	r18, Y+2	; 0x02
    121e:	3b 81       	ldd	r19, Y+3	; 0x03
    1220:	82 0f       	add	r24, r18
    1222:	93 1f       	adc	r25, r19
    1224:	fc 01       	movw	r30, r24
    1226:	80 81       	ld	r24, Z
    1228:	99 81       	ldd	r25, Y+1	; 0x01
    122a:	9f 5f       	subi	r25, 0xFF	; 255
    122c:	99 83       	std	Y+1, r25	; 0x01
    122e:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_Z13PutUartChGAVRc>
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    1232:	89 81       	ldd	r24, Y+1	; 0x01
    1234:	88 2f       	mov	r24, r24
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	2a 81       	ldd	r18, Y+2	; 0x02
    123a:	3b 81       	ldd	r19, Y+3	; 0x03
    123c:	82 0f       	add	r24, r18
    123e:	93 1f       	adc	r25, r19
    1240:	fc 01       	movw	r30, r24
    1242:	90 81       	ld	r25, Z
    1244:	81 e0       	ldi	r24, 0x01	; 1
    1246:	99 23       	and	r25, r25
    1248:	09 f4       	brne	.+2      	; 0x124c <_Z9PrintGAVRPc+0x4a>
    124a:	80 e0       	ldi	r24, 0x00	; 0
    124c:	88 23       	and	r24, r24
    124e:	19 f7       	brne	.-58     	; 0x1216 <_Z9PrintGAVRPc+0x14>
		PutUartChGAVR(string[i++]);
	}
}
    1250:	0f 90       	pop	r0
    1252:	0f 90       	pop	r0
    1254:	0f 90       	pop	r0
    1256:	df 91       	pop	r29
    1258:	cf 91       	pop	r28
    125a:	08 95       	ret

0000125c <_Z8sendGAVRv>:
/*************************************************************************************************************/
void sendGAVR(){
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	cd b7       	in	r28, 0x3d	; 61
    1262:	de b7       	in	r29, 0x3e	; 62
    1264:	ca 55       	subi	r28, 0x5A	; 90
    1266:	d0 40       	sbci	r29, 0x00	; 0
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	de bf       	out	0x3e, r29	; 62
    126e:	0f be       	out	0x3f, r0	; 63
    1270:	cd bf       	out	0x3d, r28	; 61
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    1272:	81 e0       	ldi	r24, 0x01	; 1
    1274:	8a 87       	std	Y+10, r24	; 0x0a
	char recChar, recString[40], sentString[40];
	unsigned int strLoc=0;
    1276:	1a 82       	std	Y+2, r1	; 0x02
    1278:	19 82       	std	Y+1, r1	; 0x01
	
	//Used for shutdown connection logic if there was a timeout in sending or receiving
	BOOL flagTimeout=fFalse;
    127a:	1b 82       	std	Y+3, r1	; 0x03
	
	//Set sending flag
	flagSendingGAVR=fTrue;
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	80 93 cf 01 	sts	0x01CF, r24
	
	//Transmission protocol
	while (flagSendingGAVR && !flagTimeout){
    1282:	fc c1       	rjmp	.+1016   	; 0x167c <_Z8sendGAVRv+0x420>
		/* State 5: Successful transmission and reception. Kill sending flag, reset state, exit.					 */
		/* State 6: ACKBAD received, check to see if we have an invalid date/time in our clock or it was just noisy  */
		/*			and had error in transmission/reception. If valid, go to waiting state. Else exit and set flag.	 */
		/* State 7: Got the wrong ack for something, set a flag to let the WAVR do its thing then try again.		 */
		/*************************************************************************************************************/
		switch (state){
    1284:	80 91 e6 01 	lds	r24, 0x01E6
    1288:	90 91 e7 01 	lds	r25, 0x01E7
    128c:	83 30       	cpi	r24, 0x03	; 3
    128e:	91 05       	cpc	r25, r1
    1290:	09 f4       	brne	.+2      	; 0x1294 <_Z8sendGAVRv+0x38>
    1292:	1e c1       	rjmp	.+572    	; 0x14d0 <_Z8sendGAVRv+0x274>
    1294:	84 30       	cpi	r24, 0x04	; 4
    1296:	91 05       	cpc	r25, r1
    1298:	48 f4       	brcc	.+18     	; 0x12ac <_Z8sendGAVRv+0x50>
    129a:	81 30       	cpi	r24, 0x01	; 1
    129c:	91 05       	cpc	r25, r1
    129e:	09 f4       	brne	.+2      	; 0x12a2 <_Z8sendGAVRv+0x46>
    12a0:	98 c0       	rjmp	.+304    	; 0x13d2 <_Z8sendGAVRv+0x176>
    12a2:	82 30       	cpi	r24, 0x02	; 2
    12a4:	91 05       	cpc	r25, r1
    12a6:	08 f0       	brcs	.+2      	; 0x12aa <_Z8sendGAVRv+0x4e>
    12a8:	a2 c0       	rjmp	.+324    	; 0x13ee <_Z8sendGAVRv+0x192>
    12aa:	11 c0       	rjmp	.+34     	; 0x12ce <_Z8sendGAVRv+0x72>
    12ac:	85 30       	cpi	r24, 0x05	; 5
    12ae:	91 05       	cpc	r25, r1
    12b0:	09 f4       	brne	.+2      	; 0x12b4 <_Z8sendGAVRv+0x58>
    12b2:	ad c1       	rjmp	.+858    	; 0x160e <_Z8sendGAVRv+0x3b2>
    12b4:	85 30       	cpi	r24, 0x05	; 5
    12b6:	91 05       	cpc	r25, r1
    12b8:	08 f4       	brcc	.+2      	; 0x12bc <_Z8sendGAVRv+0x60>
    12ba:	9e c1       	rjmp	.+828    	; 0x15f8 <_Z8sendGAVRv+0x39c>
    12bc:	86 30       	cpi	r24, 0x06	; 6
    12be:	91 05       	cpc	r25, r1
    12c0:	09 f4       	brne	.+2      	; 0x12c4 <_Z8sendGAVRv+0x68>
    12c2:	af c1       	rjmp	.+862    	; 0x1622 <_Z8sendGAVRv+0x3c6>
    12c4:	87 30       	cpi	r24, 0x07	; 7
    12c6:	91 05       	cpc	r25, r1
    12c8:	09 f4       	brne	.+2      	; 0x12cc <_Z8sendGAVRv+0x70>
    12ca:	c4 c1       	rjmp	.+904    	; 0x1654 <_Z8sendGAVRv+0x3f8>
    12cc:	ce c1       	rjmp	.+924    	; 0x166a <_Z8sendGAVRv+0x40e>
			case 0: {
				//Raise interrupts to GAVR for three ish clock cycles.
				prtGAVRINT |= (1 << bnGAVRINT);
    12ce:	85 e2       	ldi	r24, 0x25	; 37
    12d0:	90 e0       	ldi	r25, 0x00	; 0
    12d2:	25 e2       	ldi	r18, 0x25	; 37
    12d4:	30 e0       	ldi	r19, 0x00	; 0
    12d6:	f9 01       	movw	r30, r18
    12d8:	20 81       	ld	r18, Z
    12da:	28 60       	ori	r18, 0x08	; 8
    12dc:	fc 01       	movw	r30, r24
    12de:	20 83       	st	Z, r18
				for (int i=0; i<2; i++){asm volatile("nop");}
    12e0:	1d 82       	std	Y+5, r1	; 0x05
    12e2:	1c 82       	std	Y+4, r1	; 0x04
    12e4:	06 c0       	rjmp	.+12     	; 0x12f2 <_Z8sendGAVRv+0x96>
    12e6:	00 00       	nop
    12e8:	8c 81       	ldd	r24, Y+4	; 0x04
    12ea:	9d 81       	ldd	r25, Y+5	; 0x05
    12ec:	01 96       	adiw	r24, 0x01	; 1
    12ee:	9d 83       	std	Y+5, r25	; 0x05
    12f0:	8c 83       	std	Y+4, r24	; 0x04
    12f2:	21 e0       	ldi	r18, 0x01	; 1
    12f4:	8c 81       	ldd	r24, Y+4	; 0x04
    12f6:	9d 81       	ldd	r25, Y+5	; 0x05
    12f8:	82 30       	cpi	r24, 0x02	; 2
    12fa:	91 05       	cpc	r25, r1
    12fc:	0c f0       	brlt	.+2      	; 0x1300 <_Z8sendGAVRv+0xa4>
    12fe:	20 e0       	ldi	r18, 0x00	; 0
    1300:	22 23       	and	r18, r18
    1302:	89 f7       	brne	.-30     	; 0x12e6 <_Z8sendGAVRv+0x8a>
				prtGAVRINT &= ~(1 << bnGAVRINT);
    1304:	85 e2       	ldi	r24, 0x25	; 37
    1306:	90 e0       	ldi	r25, 0x00	; 0
    1308:	25 e2       	ldi	r18, 0x25	; 37
    130a:	30 e0       	ldi	r19, 0x00	; 0
    130c:	f9 01       	movw	r30, r18
    130e:	20 81       	ld	r18, Z
    1310:	27 7f       	andi	r18, 0xF7	; 247
    1312:	fc 01       	movw	r30, r24
    1314:	20 83       	st	Z, r18
				state=1;
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	90 93 e7 01 	sts	0x01E7, r25
    131e:	80 93 e6 01 	sts	0x01E6, r24
				break;
    1322:	ac c1       	rjmp	.+856    	; 0x167c <_Z8sendGAVRv+0x420>
			}//end case 0
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
    1324:	00 00       	nop
    1326:	88 ec       	ldi	r24, 0xC8	; 200
    1328:	90 e0       	ldi	r25, 0x00	; 0
    132a:	fc 01       	movw	r30, r24
    132c:	80 81       	ld	r24, Z
    132e:	88 23       	and	r24, r24
    1330:	34 f0       	brlt	.+12     	; 0x133e <_Z8sendGAVRv+0xe2>
    1332:	80 91 cf 01 	lds	r24, 0x01CF
    1336:	88 23       	and	r24, r24
    1338:	11 f0       	breq	.+4      	; 0x133e <_Z8sendGAVRv+0xe2>
    133a:	81 e0       	ldi	r24, 0x01	; 1
    133c:	01 c0       	rjmp	.+2      	; 0x1340 <_Z8sendGAVRv+0xe4>
    133e:	80 e0       	ldi	r24, 0x00	; 0
    1340:	88 23       	and	r24, r24
    1342:	89 f7       	brne	.-30     	; 0x1326 <_Z8sendGAVRv+0xca>
					if (!flagSendingGAVR){state=0; flagTimeout=fTrue; break;}		//if timeout is why we broke, just exit
    1344:	80 91 cf 01 	lds	r24, 0x01CF
    1348:	88 23       	and	r24, r24
    134a:	41 f4       	brne	.+16     	; 0x135c <_Z8sendGAVRv+0x100>
    134c:	10 92 e7 01 	sts	0x01E7, r1
    1350:	10 92 e6 01 	sts	0x01E6, r1
    1354:	81 e0       	ldi	r24, 0x01	; 1
    1356:	8b 83       	std	Y+3, r24	; 0x03
    1358:	00 00       	nop
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    135a:	90 c1       	rjmp	.+800    	; 0x167c <_Z8sendGAVRv+0x420>
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
					if (!flagSendingGAVR){state=0; flagTimeout=fTrue; break;}		//if timeout is why we broke, just exit
					recChar=UDR1;
    135c:	8e ec       	ldi	r24, 0xCE	; 206
    135e:	90 e0       	ldi	r25, 0x00	; 0
    1360:	fc 01       	movw	r30, r24
    1362:	80 81       	ld	r24, Z
    1364:	88 87       	std	Y+8, r24	; 0x08
					recString[strLoc++]=recChar;
    1366:	9e 01       	movw	r18, r28
    1368:	2d 5c       	subi	r18, 0xCD	; 205
    136a:	3f 4f       	sbci	r19, 0xFF	; 255
    136c:	89 81       	ldd	r24, Y+1	; 0x01
    136e:	9a 81       	ldd	r25, Y+2	; 0x02
    1370:	82 0f       	add	r24, r18
    1372:	93 1f       	adc	r25, r19
    1374:	28 85       	ldd	r18, Y+8	; 0x08
    1376:	fc 01       	movw	r30, r24
    1378:	20 83       	st	Z, r18
    137a:	89 81       	ldd	r24, Y+1	; 0x01
    137c:	9a 81       	ldd	r25, Y+2	; 0x02
    137e:	01 96       	adiw	r24, 0x01	; 1
    1380:	9a 83       	std	Y+2, r25	; 0x02
    1382:	89 83       	std	Y+1, r24	; 0x01
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
    1384:	88 85       	ldd	r24, Y+8	; 0x08
    1386:	8e 32       	cpi	r24, 0x2E	; 46
    1388:	b1 f4       	brne	.+44     	; 0x13b6 <_Z8sendGAVRv+0x15a>
    138a:	9e 01       	movw	r18, r28
    138c:	2d 5c       	subi	r18, 0xCD	; 205
    138e:	3f 4f       	sbci	r19, 0xFF	; 255
    1390:	89 81       	ldd	r24, Y+1	; 0x01
    1392:	9a 81       	ldd	r25, Y+2	; 0x02
    1394:	82 0f       	add	r24, r18
    1396:	93 1f       	adc	r25, r19
    1398:	fc 01       	movw	r30, r24
    139a:	10 82       	st	Z, r1
    139c:	89 81       	ldd	r24, Y+1	; 0x01
    139e:	9a 81       	ldd	r25, Y+2	; 0x02
    13a0:	01 96       	adiw	r24, 0x01	; 1
    13a2:	9a 83       	std	Y+2, r25	; 0x02
    13a4:	89 83       	std	Y+1, r24	; 0x01
    13a6:	82 e0       	ldi	r24, 0x02	; 2
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	90 93 e7 01 	sts	0x01E7, r25
    13ae:	80 93 e6 01 	sts	0x01E6, r24
    13b2:	1a 86       	std	Y+10, r1	; 0x0a
    13b4:	0e c0       	rjmp	.+28     	; 0x13d2 <_Z8sendGAVRv+0x176>
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
    13b6:	89 81       	ldd	r24, Y+1	; 0x01
    13b8:	9a 81       	ldd	r25, Y+2	; 0x02
    13ba:	87 32       	cpi	r24, 0x27	; 39
    13bc:	91 05       	cpc	r25, r1
    13be:	48 f0       	brcs	.+18     	; 0x13d2 <_Z8sendGAVRv+0x176>
    13c0:	1a 82       	std	Y+2, r1	; 0x02
    13c2:	19 82       	std	Y+1, r1	; 0x01
    13c4:	1a 86       	std	Y+10, r1	; 0x0a
    13c6:	87 e0       	ldi	r24, 0x07	; 7
    13c8:	90 e0       	ldi	r25, 0x00	; 0
    13ca:	90 93 e7 01 	sts	0x01E7, r25
    13ce:	80 93 e6 01 	sts	0x01E6, r24
				state=1;
				break;
			}//end case 0
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    13d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    13d4:	88 23       	and	r24, r24
    13d6:	31 f0       	breq	.+12     	; 0x13e4 <_Z8sendGAVRv+0x188>
    13d8:	80 91 cf 01 	lds	r24, 0x01CF
    13dc:	88 23       	and	r24, r24
    13de:	11 f0       	breq	.+4      	; 0x13e4 <_Z8sendGAVRv+0x188>
    13e0:	81 e0       	ldi	r24, 0x01	; 1
    13e2:	01 c0       	rjmp	.+2      	; 0x13e6 <_Z8sendGAVRv+0x18a>
    13e4:	80 e0       	ldi	r24, 0x00	; 0
    13e6:	88 23       	and	r24, r24
    13e8:	09 f0       	breq	.+2      	; 0x13ec <_Z8sendGAVRv+0x190>
    13ea:	9c cf       	rjmp	.-200    	; 0x1324 <_Z8sendGAVRv+0xc8>
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    13ec:	47 c1       	rjmp	.+654    	; 0x167c <_Z8sendGAVRv+0x420>
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
    13ee:	ce 01       	movw	r24, r28
    13f0:	c3 96       	adiw	r24, 0x33	; 51
    13f2:	20 e0       	ldi	r18, 0x00	; 0
    13f4:	31 e0       	ldi	r19, 0x01	; 1
    13f6:	b9 01       	movw	r22, r18
    13f8:	45 e0       	ldi	r20, 0x05	; 5
    13fa:	50 e0       	ldi	r21, 0x00	; 0
    13fc:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    1400:	00 97       	sbiw	r24, 0x00	; 0
    1402:	39 f4       	brne	.+14     	; 0x1412 <_Z8sendGAVRv+0x1b6>
    1404:	83 e0       	ldi	r24, 0x03	; 3
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	90 93 e7 01 	sts	0x01E7, r25
    140c:	80 93 e6 01 	sts	0x01E6, r24
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1410:	35 c1       	rjmp	.+618    	; 0x167c <_Z8sendGAVRv+0x420>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
    1412:	ce 01       	movw	r24, r28
    1414:	c3 96       	adiw	r24, 0x33	; 51
    1416:	26 e0       	ldi	r18, 0x06	; 6
    1418:	31 e0       	ldi	r19, 0x01	; 1
    141a:	b9 01       	movw	r22, r18
    141c:	46 e0       	ldi	r20, 0x06	; 6
    141e:	50 e0       	ldi	r21, 0x00	; 0
    1420:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    1424:	00 97       	sbiw	r24, 0x00	; 0
    1426:	39 f4       	brne	.+14     	; 0x1436 <_Z8sendGAVRv+0x1da>
    1428:	84 e0       	ldi	r24, 0x04	; 4
    142a:	90 e0       	ldi	r25, 0x00	; 0
    142c:	90 93 e7 01 	sts	0x01E7, r25
    1430:	80 93 e6 01 	sts	0x01E6, r24
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1434:	23 c1       	rjmp	.+582    	; 0x167c <_Z8sendGAVRv+0x420>
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
    1436:	ce 01       	movw	r24, r28
    1438:	c3 96       	adiw	r24, 0x33	; 51
    143a:	2d e0       	ldi	r18, 0x0D	; 13
    143c:	31 e0       	ldi	r19, 0x01	; 1
    143e:	b9 01       	movw	r22, r18
    1440:	47 e0       	ldi	r20, 0x07	; 7
    1442:	50 e0       	ldi	r21, 0x00	; 0
    1444:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    1448:	00 97       	sbiw	r24, 0x00	; 0
    144a:	39 f4       	brne	.+14     	; 0x145a <_Z8sendGAVRv+0x1fe>
    144c:	86 e0       	ldi	r24, 0x06	; 6
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	90 93 e7 01 	sts	0x01E7, r25
    1454:	80 93 e6 01 	sts	0x01E6, r24
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1458:	11 c1       	rjmp	.+546    	; 0x167c <_Z8sendGAVRv+0x420>
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
    145a:	80 91 ce 01 	lds	r24, 0x01CE
    145e:	88 23       	and	r24, r24
    1460:	89 f0       	breq	.+34     	; 0x1484 <_Z8sendGAVRv+0x228>
    1462:	ce 01       	movw	r24, r28
    1464:	c3 96       	adiw	r24, 0x33	; 51
    1466:	9e 01       	movw	r18, r28
    1468:	25 5f       	subi	r18, 0xF5	; 245
    146a:	3f 4f       	sbci	r19, 0xFF	; 255
    146c:	b9 01       	movw	r22, r18
    146e:	0e 94 b9 1b 	call	0x3772	; 0x3772 <strcmp>
    1472:	00 97       	sbiw	r24, 0x00	; 0
    1474:	39 f4       	brne	.+14     	; 0x1484 <_Z8sendGAVRv+0x228>
    1476:	85 e0       	ldi	r24, 0x05	; 5
    1478:	90 e0       	ldi	r25, 0x00	; 0
    147a:	90 93 e7 01 	sts	0x01E7, r25
    147e:	80 93 e6 01 	sts	0x01E6, r24
    1482:	25 c0       	rjmp	.+74     	; 0x14ce <_Z8sendGAVRv+0x272>
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
    1484:	80 91 ce 01 	lds	r24, 0x01CE
    1488:	88 23       	and	r24, r24
    148a:	d1 f0       	breq	.+52     	; 0x14c0 <_Z8sendGAVRv+0x264>
    148c:	ce 01       	movw	r24, r28
    148e:	c3 96       	adiw	r24, 0x33	; 51
    1490:	9e 01       	movw	r18, r28
    1492:	25 5f       	subi	r18, 0xF5	; 245
    1494:	3f 4f       	sbci	r19, 0xFF	; 255
    1496:	b9 01       	movw	r22, r18
    1498:	0e 94 b9 1b 	call	0x3772	; 0x3772 <strcmp>
    149c:	00 97       	sbiw	r24, 0x00	; 0
    149e:	81 f0       	breq	.+32     	; 0x14c0 <_Z8sendGAVRv+0x264>
    14a0:	ce 01       	movw	r24, r28
    14a2:	c3 96       	adiw	r24, 0x33	; 51
    14a4:	2d e0       	ldi	r18, 0x0D	; 13
    14a6:	31 e0       	ldi	r19, 0x01	; 1
    14a8:	b9 01       	movw	r22, r18
    14aa:	0e 94 b9 1b 	call	0x3772	; 0x3772 <strcmp>
    14ae:	00 97       	sbiw	r24, 0x00	; 0
    14b0:	39 f0       	breq	.+14     	; 0x14c0 <_Z8sendGAVRv+0x264>
    14b2:	87 e0       	ldi	r24, 0x07	; 7
    14b4:	90 e0       	ldi	r25, 0x00	; 0
    14b6:	90 93 e7 01 	sts	0x01E7, r25
    14ba:	80 93 e6 01 	sts	0x01E6, r24
    14be:	07 c0       	rjmp	.+14     	; 0x14ce <_Z8sendGAVRv+0x272>
				else{state=7;} //invalid ack. ACKERROR goes here.
    14c0:	87 e0       	ldi	r24, 0x07	; 7
    14c2:	90 e0       	ldi	r25, 0x00	; 0
    14c4:	90 93 e7 01 	sts	0x01E7, r25
    14c8:	80 93 e6 01 	sts	0x01E6, r24
				break;
    14cc:	d7 c0       	rjmp	.+430    	; 0x167c <_Z8sendGAVRv+0x420>
    14ce:	d6 c0       	rjmp	.+428    	; 0x167c <_Z8sendGAVRv+0x420>
				}//end case 2
			case 3:{
				if (flagUserClock && !flagUpdateGAVRClock){
    14d0:	80 91 d0 01 	lds	r24, 0x01D0
    14d4:	88 23       	and	r24, r24
    14d6:	61 f0       	breq	.+24     	; 0x14f0 <_Z8sendGAVRv+0x294>
    14d8:	80 91 ce 01 	lds	r24, 0x01CE
    14dc:	88 23       	and	r24, r24
    14de:	41 f4       	brne	.+16     	; 0x14f0 <_Z8sendGAVRv+0x294>
					PrintGAVR("SYNGB.");
    14e0:	85 e1       	ldi	r24, 0x15	; 21
    14e2:	91 e0       	ldi	r25, 0x01	; 1
    14e4:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
					flagWaitingForReceiveGAVR=fTrue;				
    14e8:	81 e0       	ldi	r24, 0x01	; 1
    14ea:	80 93 cd 01 	sts	0x01CD, r24
    14ee:	5d c0       	rjmp	.+186    	; 0x15aa <_Z8sendGAVRv+0x34e>
				//If we are updating the gavr, send the time and date together regardless. preface with SYN
				} else if (flagUpdateGAVRClock && !flagUserClock){
    14f0:	80 91 ce 01 	lds	r24, 0x01CE
    14f4:	88 23       	and	r24, r24
    14f6:	09 f4       	brne	.+2      	; 0x14fa <_Z8sendGAVRv+0x29e>
    14f8:	58 c0       	rjmp	.+176    	; 0x15aa <_Z8sendGAVRv+0x34e>
    14fa:	80 91 d0 01 	lds	r24, 0x01D0
    14fe:	88 23       	and	r24, r24
    1500:	09 f0       	breq	.+2      	; 0x1504 <_Z8sendGAVRv+0x2a8>
    1502:	53 c0       	rjmp	.+166    	; 0x15aa <_Z8sendGAVRv+0x34e>
					strcpy(sentString,"ACK");			//this is a syn, not ack to save logic in GAVR code. Can change if we want.
    1504:	9e 01       	movw	r18, r28
    1506:	25 5f       	subi	r18, 0xF5	; 245
    1508:	3f 4f       	sbci	r19, 0xFF	; 255
    150a:	81 e4       	ldi	r24, 0x41	; 65
    150c:	93 e4       	ldi	r25, 0x43	; 67
    150e:	ab e4       	ldi	r26, 0x4B	; 75
    1510:	b0 e0       	ldi	r27, 0x00	; 0
    1512:	f9 01       	movw	r30, r18
    1514:	80 83       	st	Z, r24
    1516:	91 83       	std	Z+1, r25	; 0x01
    1518:	a2 83       	std	Z+2, r26	; 0x02
    151a:	b3 83       	std	Z+3, r27	; 0x03
					strcat(sentString,currentTime.getTime());
    151c:	82 ea       	ldi	r24, 0xA2	; 162
    151e:	91 e0       	ldi	r25, 0x01	; 1
    1520:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    1524:	9c 01       	movw	r18, r24
    1526:	ce 01       	movw	r24, r28
    1528:	0b 96       	adiw	r24, 0x0b	; 11
    152a:	b9 01       	movw	r22, r18
    152c:	0e 94 ae 1b 	call	0x375c	; 0x375c <strcat>
					strcat(sentString,"/");	//add delimiter.
    1530:	ce 01       	movw	r24, r28
    1532:	0b 96       	adiw	r24, 0x0b	; 11
    1534:	9c 01       	movw	r18, r24
    1536:	f9 01       	movw	r30, r18
    1538:	01 90       	ld	r0, Z+
    153a:	00 20       	and	r0, r0
    153c:	e9 f7       	brne	.-6      	; 0x1538 <_Z8sendGAVRv+0x2dc>
    153e:	cf 01       	movw	r24, r30
    1540:	01 97       	sbiw	r24, 0x01	; 1
    1542:	82 1b       	sub	r24, r18
    1544:	93 0b       	sbc	r25, r19
    1546:	9e 01       	movw	r18, r28
    1548:	25 5f       	subi	r18, 0xF5	; 245
    154a:	3f 4f       	sbci	r19, 0xFF	; 255
    154c:	82 0f       	add	r24, r18
    154e:	93 1f       	adc	r25, r19
    1550:	2f e2       	ldi	r18, 0x2F	; 47
    1552:	30 e0       	ldi	r19, 0x00	; 0
    1554:	fc 01       	movw	r30, r24
    1556:	31 83       	std	Z+1, r19	; 0x01
    1558:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getDate());
    155a:	82 ea       	ldi	r24, 0xA2	; 162
    155c:	91 e0       	ldi	r25, 0x01	; 1
    155e:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    1562:	9c 01       	movw	r18, r24
    1564:	ce 01       	movw	r24, r28
    1566:	0b 96       	adiw	r24, 0x0b	; 11
    1568:	b9 01       	movw	r22, r18
    156a:	0e 94 ae 1b 	call	0x375c	; 0x375c <strcat>
					strcat(sentString,".\0");
    156e:	ce 01       	movw	r24, r28
    1570:	0b 96       	adiw	r24, 0x0b	; 11
    1572:	9c 01       	movw	r18, r24
    1574:	f9 01       	movw	r30, r18
    1576:	01 90       	ld	r0, Z+
    1578:	00 20       	and	r0, r0
    157a:	e9 f7       	brne	.-6      	; 0x1576 <_Z8sendGAVRv+0x31a>
    157c:	cf 01       	movw	r24, r30
    157e:	01 97       	sbiw	r24, 0x01	; 1
    1580:	82 1b       	sub	r24, r18
    1582:	93 0b       	sbc	r25, r19
    1584:	9e 01       	movw	r18, r28
    1586:	25 5f       	subi	r18, 0xF5	; 245
    1588:	3f 4f       	sbci	r19, 0xFF	; 255
    158a:	82 0f       	add	r24, r18
    158c:	93 1f       	adc	r25, r19
    158e:	2e e2       	ldi	r18, 0x2E	; 46
    1590:	30 e0       	ldi	r19, 0x00	; 0
    1592:	fc 01       	movw	r30, r24
    1594:	31 83       	std	Z+1, r19	; 0x01
    1596:	20 83       	st	Z, r18
					PrintGAVR("SYN");
    1598:	8c e1       	ldi	r24, 0x1C	; 28
    159a:	91 e0       	ldi	r25, 0x01	; 1
    159c:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
    15a0:	80 e0       	ldi	r24, 0x00	; 0
    15a2:	61 e0       	ldi	r22, 0x01	; 1
    15a4:	41 e0       	ldi	r20, 0x01	; 1
    15a6:	0e 94 c6 12 	call	0x258c	; 0x258c <_Z13printTimeDatehhh>
				} else;	//end if-else (what we are doing).
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){
    15aa:	1f 82       	std	Y+7, r1	; 0x07
    15ac:	1e 82       	std	Y+6, r1	; 0x06
    15ae:	0e c0       	rjmp	.+28     	; 0x15cc <_Z8sendGAVRv+0x370>
					recString[i]=NULL;
    15b0:	9e 01       	movw	r18, r28
    15b2:	2d 5c       	subi	r18, 0xCD	; 205
    15b4:	3f 4f       	sbci	r19, 0xFF	; 255
    15b6:	8e 81       	ldd	r24, Y+6	; 0x06
    15b8:	9f 81       	ldd	r25, Y+7	; 0x07
    15ba:	82 0f       	add	r24, r18
    15bc:	93 1f       	adc	r25, r19
    15be:	fc 01       	movw	r30, r24
    15c0:	10 82       	st	Z, r1
					PrintGAVR("SYN");
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
				} else;	//end if-else (what we are doing).
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){
    15c2:	8e 81       	ldd	r24, Y+6	; 0x06
    15c4:	9f 81       	ldd	r25, Y+7	; 0x07
    15c6:	01 96       	adiw	r24, 0x01	; 1
    15c8:	9f 83       	std	Y+7, r25	; 0x07
    15ca:	8e 83       	std	Y+6, r24	; 0x06
    15cc:	2e 81       	ldd	r18, Y+6	; 0x06
    15ce:	3f 81       	ldd	r19, Y+7	; 0x07
    15d0:	41 e0       	ldi	r20, 0x01	; 1
    15d2:	89 81       	ldd	r24, Y+1	; 0x01
    15d4:	9a 81       	ldd	r25, Y+2	; 0x02
    15d6:	28 17       	cp	r18, r24
    15d8:	39 07       	cpc	r19, r25
    15da:	08 f0       	brcs	.+2      	; 0x15de <_Z8sendGAVRv+0x382>
    15dc:	40 e0       	ldi	r20, 0x00	; 0
    15de:	44 23       	and	r20, r20
    15e0:	39 f7       	brne	.-50     	; 0x15b0 <_Z8sendGAVRv+0x354>
					recString[i]=NULL;
				}
				//Reset the carriage feature, string location and go back to the receiving state.
				noCarriage=fTrue;
    15e2:	81 e0       	ldi	r24, 0x01	; 1
    15e4:	8a 87       	std	Y+10, r24	; 0x0a
				strLoc=0;
    15e6:	1a 82       	std	Y+2, r1	; 0x02
    15e8:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	90 e0       	ldi	r25, 0x00	; 0
    15ee:	90 93 e7 01 	sts	0x01E7, r25
    15f2:	80 93 e6 01 	sts	0x01E6, r24
				break;
    15f6:	42 c0       	rjmp	.+132    	; 0x167c <_Z8sendGAVRv+0x420>
				}//end case 3
			case 4:{
				//Successful communication with just flags
				PrintGAVR("SYNDONE.");	//end the communication
    15f8:	80 e2       	ldi	r24, 0x20	; 32
    15fa:	91 e0       	ldi	r25, 0x01	; 1
    15fc:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
				state=5;
    1600:	85 e0       	ldi	r24, 0x05	; 5
    1602:	90 e0       	ldi	r25, 0x00	; 0
    1604:	90 93 e7 01 	sts	0x01E7, r25
    1608:	80 93 e6 01 	sts	0x01E6, r24
				break;				
    160c:	37 c0       	rjmp	.+110    	; 0x167c <_Z8sendGAVRv+0x420>
				}//end case 4	
			case 5:{
				//Successful communications overall
				flagSendingGAVR=fFalse;
    160e:	10 92 cf 01 	sts	0x01CF, r1
				flagWaitingToSendGAVR=fFalse;
    1612:	10 92 d2 01 	sts	0x01D2, r1
				flagTimeout=fFalse;
    1616:	1b 82       	std	Y+3, r1	; 0x03
				state=0;
    1618:	10 92 e7 01 	sts	0x01E7, r1
    161c:	10 92 e6 01 	sts	0x01E6, r1
				break;
    1620:	2d c0       	rjmp	.+90     	; 0x167c <_Z8sendGAVRv+0x420>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
    1622:	82 ea       	ldi	r24, 0xA2	; 162
    1624:	91 e0       	ldi	r25, 0x01	; 1
    1626:	0e 94 bc 06 	call	0xd78	; 0xd78 <_ZN6myTime13checkValidityEv>
    162a:	89 87       	std	Y+9, r24	; 0x09
				if (dateOK){state=7;}
    162c:	89 85       	ldd	r24, Y+9	; 0x09
    162e:	88 23       	and	r24, r24
    1630:	39 f0       	breq	.+14     	; 0x1640 <_Z8sendGAVRv+0x3e4>
    1632:	87 e0       	ldi	r24, 0x07	; 7
    1634:	90 e0       	ldi	r25, 0x00	; 0
    1636:	90 93 e7 01 	sts	0x01E7, r25
    163a:	80 93 e6 01 	sts	0x01E6, r24
				else {state=5; flagInvalidDateTime=fTrue;}
				break;
    163e:	1e c0       	rjmp	.+60     	; 0x167c <_Z8sendGAVRv+0x420>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
				if (dateOK){state=7;}
				else {state=5; flagInvalidDateTime=fTrue;}
    1640:	85 e0       	ldi	r24, 0x05	; 5
    1642:	90 e0       	ldi	r25, 0x00	; 0
    1644:	90 93 e7 01 	sts	0x01E7, r25
    1648:	80 93 e6 01 	sts	0x01E6, r24
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	80 93 d1 01 	sts	0x01D1, r24
				break;
    1652:	14 c0       	rjmp	.+40     	; 0x167c <_Z8sendGAVRv+0x420>
				}//end case 6
			case 7:{
				//Got the wrong ACK back, or invalid ACK. Wait for next cycle then resend. Keep all the flags the same
				flagWaitingToSendGAVR=fTrue;
    1654:	81 e0       	ldi	r24, 0x01	; 1
    1656:	80 93 d2 01 	sts	0x01D2, r24
				flagSendingGAVR=fFalse;
    165a:	10 92 cf 01 	sts	0x01CF, r1
				flagTimeout=fFalse;
    165e:	1b 82       	std	Y+3, r1	; 0x03
				state=0;
    1660:	10 92 e7 01 	sts	0x01E7, r1
    1664:	10 92 e6 01 	sts	0x01E6, r1
				break;
    1668:	09 c0       	rjmp	.+18     	; 0x167c <_Z8sendGAVRv+0x420>
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; flagTimeout=fFalse;break;}
    166a:	10 92 e7 01 	sts	0x01E7, r1
    166e:	10 92 e6 01 	sts	0x01E6, r1
    1672:	10 92 cf 01 	sts	0x01CF, r1
    1676:	1a 86       	std	Y+10, r1	; 0x0a
    1678:	1b 82       	std	Y+3, r1	; 0x03
    167a:	00 00       	nop
	
	//Set sending flag
	flagSendingGAVR=fTrue;
	
	//Transmission protocol
	while (flagSendingGAVR && !flagTimeout){
    167c:	80 91 cf 01 	lds	r24, 0x01CF
    1680:	88 23       	and	r24, r24
    1682:	29 f0       	breq	.+10     	; 0x168e <_Z8sendGAVRv+0x432>
    1684:	8b 81       	ldd	r24, Y+3	; 0x03
    1686:	88 23       	and	r24, r24
    1688:	11 f4       	brne	.+4      	; 0x168e <_Z8sendGAVRv+0x432>
    168a:	81 e0       	ldi	r24, 0x01	; 1
    168c:	01 c0       	rjmp	.+2      	; 0x1690 <_Z8sendGAVRv+0x434>
    168e:	80 e0       	ldi	r24, 0x00	; 0
    1690:	88 23       	and	r24, r24
    1692:	09 f0       	breq	.+2      	; 0x1696 <_Z8sendGAVRv+0x43a>
    1694:	f7 cd       	rjmp	.-1042   	; 0x1284 <_Z8sendGAVRv+0x28>
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; flagTimeout=fFalse;break;}
		}//end switch
	}//end while
	
	//If there was a timeout and the wiating flag has not been set yet, make sure waiting flag.
	if (noCarriage || flagTimeout){
    1696:	8a 85       	ldd	r24, Y+10	; 0x0a
    1698:	88 23       	and	r24, r24
    169a:	19 f4       	brne	.+6      	; 0x16a2 <_Z8sendGAVRv+0x446>
    169c:	8b 81       	ldd	r24, Y+3	; 0x03
    169e:	88 23       	and	r24, r24
    16a0:	11 f0       	breq	.+4      	; 0x16a6 <_Z8sendGAVRv+0x44a>
    16a2:	81 e0       	ldi	r24, 0x01	; 1
    16a4:	01 c0       	rjmp	.+2      	; 0x16a8 <_Z8sendGAVRv+0x44c>
    16a6:	80 e0       	ldi	r24, 0x00	; 0
    16a8:	88 23       	and	r24, r24
    16aa:	19 f0       	breq	.+6      	; 0x16b2 <_Z8sendGAVRv+0x456>
		flagWaitingToSendGAVR=fTrue;
    16ac:	81 e0       	ldi	r24, 0x01	; 1
    16ae:	80 93 d2 01 	sts	0x01D2, r24
	}
	
	//If we aren't waiting for the next round, don't reset the flags. If we are waiting, just reset the waiting flag->the UserCLock and GAVRClcok flags
	//will still be at the values they were before.
	if (!flagWaitingToSendGAVR){
    16b2:	80 91 d2 01 	lds	r24, 0x01D2
    16b6:	88 23       	and	r24, r24
    16b8:	29 f4       	brne	.+10     	; 0x16c4 <_Z8sendGAVRv+0x468>
		flagUserClock=fFalse;
    16ba:	10 92 d0 01 	sts	0x01D0, r1
		flagUpdateGAVRClock=fFalse;	
    16be:	10 92 ce 01 	sts	0x01CE, r1
    16c2:	02 c0       	rjmp	.+4      	; 0x16c8 <_Z8sendGAVRv+0x46c>
	} else {flagWaitingToSendGAVR=fFalse;}
    16c4:	10 92 d2 01 	sts	0x01D2, r1
}//end function 	
    16c8:	c6 5a       	subi	r28, 0xA6	; 166
    16ca:	df 4f       	sbci	r29, 0xFF	; 255
    16cc:	0f b6       	in	r0, 0x3f	; 63
    16ce:	f8 94       	cli
    16d0:	de bf       	out	0x3e, r29	; 62
    16d2:	0f be       	out	0x3f, r0	; 63
    16d4:	cd bf       	out	0x3d, r28	; 61
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	08 95       	ret

000016dc <_Z11ReceiveBonev>:
	
/*************************************************************************************************************/
void ReceiveBone(){
    16dc:	cf 93       	push	r28
    16de:	df 93       	push	r29
    16e0:	cd b7       	in	r28, 0x3d	; 61
    16e2:	de b7       	in	r29, 0x3e	; 62
    16e4:	cb 55       	subi	r28, 0x5B	; 91
    16e6:	d0 40       	sbci	r29, 0x00	; 0
    16e8:	0f b6       	in	r0, 0x3f	; 63
    16ea:	f8 94       	cli
    16ec:	de bf       	out	0x3e, r29	; 62
    16ee:	0f be       	out	0x3f, r0	; 63
    16f0:	cd bf       	out	0x3d, r28	; 61
	volatile static unsigned int state=0;
	char recChar, recString[40];
	volatile unsigned int strLoc=0;
    16f2:	1c 8a       	std	Y+20, r1	; 0x14
    16f4:	1b 8a       	std	Y+19, r1	; 0x13
	BOOL noCarriage=fTrue;
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	89 83       	std	Y+1, r24	; 0x01
	
	while (flagReceivingBone){
    16fa:	b9 c3       	rjmp	.+1906   	; 0x1e6e <_Z11ReceiveBonev+0x792>
			/* State 6: Graceful exit. Exit from a command like adc or temp.																*/
			/* State 7: Parse the input string for the time and date. Should be time(:)'/'date(,) where : and , are the delimiters. Term by */
			/*			'.'																													*/
			/********************************************************************************************************************************/
			
			switch(state){
    16fc:	80 91 e4 01 	lds	r24, 0x01E4
    1700:	90 91 e5 01 	lds	r25, 0x01E5
    1704:	83 30       	cpi	r24, 0x03	; 3
    1706:	91 05       	cpc	r25, r1
    1708:	09 f4       	brne	.+2      	; 0x170c <_Z11ReceiveBonev+0x30>
    170a:	76 c1       	rjmp	.+748    	; 0x19f8 <_Z11ReceiveBonev+0x31c>
    170c:	84 30       	cpi	r24, 0x04	; 4
    170e:	91 05       	cpc	r25, r1
    1710:	48 f4       	brcc	.+18     	; 0x1724 <_Z11ReceiveBonev+0x48>
    1712:	81 30       	cpi	r24, 0x01	; 1
    1714:	91 05       	cpc	r25, r1
    1716:	09 f4       	brne	.+2      	; 0x171a <_Z11ReceiveBonev+0x3e>
    1718:	8b c0       	rjmp	.+278    	; 0x1830 <_Z11ReceiveBonev+0x154>
    171a:	82 30       	cpi	r24, 0x02	; 2
    171c:	91 05       	cpc	r25, r1
    171e:	08 f0       	brcs	.+2      	; 0x1722 <_Z11ReceiveBonev+0x46>
    1720:	95 c0       	rjmp	.+298    	; 0x184c <_Z11ReceiveBonev+0x170>
    1722:	11 c0       	rjmp	.+34     	; 0x1746 <_Z11ReceiveBonev+0x6a>
    1724:	85 30       	cpi	r24, 0x05	; 5
    1726:	91 05       	cpc	r25, r1
    1728:	09 f4       	brne	.+2      	; 0x172c <_Z11ReceiveBonev+0x50>
    172a:	82 c1       	rjmp	.+772    	; 0x1a30 <_Z11ReceiveBonev+0x354>
    172c:	85 30       	cpi	r24, 0x05	; 5
    172e:	91 05       	cpc	r25, r1
    1730:	08 f4       	brcc	.+2      	; 0x1734 <_Z11ReceiveBonev+0x58>
    1732:	73 c1       	rjmp	.+742    	; 0x1a1a <_Z11ReceiveBonev+0x33e>
    1734:	86 30       	cpi	r24, 0x06	; 6
    1736:	91 05       	cpc	r25, r1
    1738:	09 f4       	brne	.+2      	; 0x173c <_Z11ReceiveBonev+0x60>
    173a:	85 c1       	rjmp	.+778    	; 0x1a46 <_Z11ReceiveBonev+0x36a>
    173c:	87 30       	cpi	r24, 0x07	; 7
    173e:	91 05       	cpc	r25, r1
    1740:	09 f4       	brne	.+2      	; 0x1744 <_Z11ReceiveBonev+0x68>
    1742:	88 c1       	rjmp	.+784    	; 0x1a54 <_Z11ReceiveBonev+0x378>
    1744:	8d c3       	rjmp	.+1818   	; 0x1e60 <_Z11ReceiveBonev+0x784>
				case 0:{
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
    1746:	1c 8a       	std	Y+20, r1	; 0x14
    1748:	1b 8a       	std	Y+19, r1	; 0x13
					recChar = UDR0;
    174a:	86 ec       	ldi	r24, 0xC6	; 198
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	fc 01       	movw	r30, r24
    1750:	80 81       	ld	r24, Z
    1752:	8a 8b       	std	Y+18, r24	; 0x12
					if (recChar=='.'){
    1754:	8a 89       	ldd	r24, Y+18	; 0x12
    1756:	8e 32       	cpi	r24, 0x2E	; 46
    1758:	39 f4       	brne	.+14     	; 0x1768 <_Z11ReceiveBonev+0x8c>
						state=5;
    175a:	85 e0       	ldi	r24, 0x05	; 5
    175c:	90 e0       	ldi	r25, 0x00	; 0
    175e:	90 93 e5 01 	sts	0x01E5, r25
    1762:	80 93 e4 01 	sts	0x01E4, r24
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
    1766:	83 c3       	rjmp	.+1798   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
					recChar = UDR0;
					if (recChar=='.'){
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
    1768:	8b 89       	ldd	r24, Y+19	; 0x13
    176a:	9c 89       	ldd	r25, Y+20	; 0x14
    176c:	9e 01       	movw	r18, r28
    176e:	2c 5c       	subi	r18, 0xCC	; 204
    1770:	3f 4f       	sbci	r19, 0xFF	; 255
    1772:	28 0f       	add	r18, r24
    1774:	39 1f       	adc	r19, r25
    1776:	4a 89       	ldd	r20, Y+18	; 0x12
    1778:	f9 01       	movw	r30, r18
    177a:	40 83       	st	Z, r20
    177c:	01 96       	adiw	r24, 0x01	; 1
    177e:	9c 8b       	std	Y+20, r25	; 0x14
    1780:	8b 8b       	std	Y+19, r24	; 0x13
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	90 93 e5 01 	sts	0x01E5, r25
    178a:	80 93 e4 01 	sts	0x01E4, r24
					break;				
    178e:	6f c3       	rjmp	.+1758   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while (!(UCSR0A & (1 << RXC0)) && flagReceivingBone);		//get the next character
    1790:	00 00       	nop
    1792:	80 ec       	ldi	r24, 0xC0	; 192
    1794:	90 e0       	ldi	r25, 0x00	; 0
    1796:	fc 01       	movw	r30, r24
    1798:	80 81       	ld	r24, Z
    179a:	88 23       	and	r24, r24
    179c:	34 f0       	brlt	.+12     	; 0x17aa <_Z11ReceiveBonev+0xce>
    179e:	80 91 ca 01 	lds	r24, 0x01CA
    17a2:	88 23       	and	r24, r24
    17a4:	11 f0       	breq	.+4      	; 0x17aa <_Z11ReceiveBonev+0xce>
    17a6:	81 e0       	ldi	r24, 0x01	; 1
    17a8:	01 c0       	rjmp	.+2      	; 0x17ac <_Z11ReceiveBonev+0xd0>
    17aa:	80 e0       	ldi	r24, 0x00	; 0
    17ac:	88 23       	and	r24, r24
    17ae:	89 f7       	brne	.-30     	; 0x1792 <_Z11ReceiveBonev+0xb6>
						if (!flagReceivingBone){state=0; break;}					//if there was a timeout, break out and reset state
    17b0:	80 91 ca 01 	lds	r24, 0x01CA
    17b4:	88 23       	and	r24, r24
    17b6:	31 f4       	brne	.+12     	; 0x17c4 <_Z11ReceiveBonev+0xe8>
    17b8:	10 92 e5 01 	sts	0x01E5, r1
    17bc:	10 92 e4 01 	sts	0x01E4, r1
    17c0:	00 00       	nop
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 19){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    17c2:	55 c3       	rjmp	.+1706   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while (!(UCSR0A & (1 << RXC0)) && flagReceivingBone);		//get the next character
						if (!flagReceivingBone){state=0; break;}					//if there was a timeout, break out and reset state
						recChar=UDR0;
    17c4:	86 ec       	ldi	r24, 0xC6	; 198
    17c6:	90 e0       	ldi	r25, 0x00	; 0
    17c8:	fc 01       	movw	r30, r24
    17ca:	80 81       	ld	r24, Z
    17cc:	8a 8b       	std	Y+18, r24	; 0x12
						recString[strLoc++]=recChar;
    17ce:	8b 89       	ldd	r24, Y+19	; 0x13
    17d0:	9c 89       	ldd	r25, Y+20	; 0x14
    17d2:	9e 01       	movw	r18, r28
    17d4:	2c 5c       	subi	r18, 0xCC	; 204
    17d6:	3f 4f       	sbci	r19, 0xFF	; 255
    17d8:	28 0f       	add	r18, r24
    17da:	39 1f       	adc	r19, r25
    17dc:	4a 89       	ldd	r20, Y+18	; 0x12
    17de:	f9 01       	movw	r30, r18
    17e0:	40 83       	st	Z, r20
    17e2:	01 96       	adiw	r24, 0x01	; 1
    17e4:	9c 8b       	std	Y+20, r25	; 0x14
    17e6:	8b 8b       	std	Y+19, r24	; 0x13
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    17e8:	8a 89       	ldd	r24, Y+18	; 0x12
    17ea:	8e 32       	cpi	r24, 0x2E	; 46
    17ec:	89 f4       	brne	.+34     	; 0x1810 <_Z11ReceiveBonev+0x134>
    17ee:	8b 89       	ldd	r24, Y+19	; 0x13
    17f0:	9c 89       	ldd	r25, Y+20	; 0x14
    17f2:	9e 01       	movw	r18, r28
    17f4:	2c 5c       	subi	r18, 0xCC	; 204
    17f6:	3f 4f       	sbci	r19, 0xFF	; 255
    17f8:	82 0f       	add	r24, r18
    17fa:	93 1f       	adc	r25, r19
    17fc:	fc 01       	movw	r30, r24
    17fe:	10 82       	st	Z, r1
    1800:	19 82       	std	Y+1, r1	; 0x01
    1802:	82 e0       	ldi	r24, 0x02	; 2
    1804:	90 e0       	ldi	r25, 0x00	; 0
    1806:	90 93 e5 01 	sts	0x01E5, r25
    180a:	80 93 e4 01 	sts	0x01E4, r24
    180e:	10 c0       	rjmp	.+32     	; 0x1830 <_Z11ReceiveBonev+0x154>
						else if (strLoc >= 19){state=5;noCarriage=fFalse;}
    1810:	8b 89       	ldd	r24, Y+19	; 0x13
    1812:	9c 89       	ldd	r25, Y+20	; 0x14
    1814:	21 e0       	ldi	r18, 0x01	; 1
    1816:	83 31       	cpi	r24, 0x13	; 19
    1818:	91 05       	cpc	r25, r1
    181a:	08 f4       	brcc	.+2      	; 0x181e <_Z11ReceiveBonev+0x142>
    181c:	20 e0       	ldi	r18, 0x00	; 0
    181e:	22 23       	and	r18, r18
    1820:	39 f0       	breq	.+14     	; 0x1830 <_Z11ReceiveBonev+0x154>
    1822:	85 e0       	ldi	r24, 0x05	; 5
    1824:	90 e0       	ldi	r25, 0x00	; 0
    1826:	90 93 e5 01 	sts	0x01E5, r25
    182a:	80 93 e4 01 	sts	0x01E4, r24
    182e:	19 82       	std	Y+1, r1	; 0x01
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    1830:	89 81       	ldd	r24, Y+1	; 0x01
    1832:	88 23       	and	r24, r24
    1834:	31 f0       	breq	.+12     	; 0x1842 <_Z11ReceiveBonev+0x166>
    1836:	80 91 ca 01 	lds	r24, 0x01CA
    183a:	88 23       	and	r24, r24
    183c:	11 f0       	breq	.+4      	; 0x1842 <_Z11ReceiveBonev+0x166>
    183e:	81 e0       	ldi	r24, 0x01	; 1
    1840:	01 c0       	rjmp	.+2      	; 0x1844 <_Z11ReceiveBonev+0x168>
    1842:	80 e0       	ldi	r24, 0x00	; 0
    1844:	88 23       	and	r24, r24
    1846:	09 f0       	breq	.+2      	; 0x184a <_Z11ReceiveBonev+0x16e>
    1848:	a3 cf       	rjmp	.-186    	; 0x1790 <_Z11ReceiveBonev+0xb4>
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 19){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    184a:	11 c3       	rjmp	.+1570   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
    184c:	ce 01       	movw	r24, r28
    184e:	c4 96       	adiw	r24, 0x34	; 52
    1850:	29 e2       	ldi	r18, 0x29	; 41
    1852:	31 e0       	ldi	r19, 0x01	; 1
    1854:	b9 01       	movw	r22, r18
    1856:	45 e0       	ldi	r20, 0x05	; 5
    1858:	50 e0       	ldi	r21, 0x00	; 0
    185a:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    185e:	00 97       	sbiw	r24, 0x00	; 0
    1860:	61 f4       	brne	.+24     	; 0x187a <_Z11ReceiveBonev+0x19e>
    1862:	81 e0       	ldi	r24, 0x01	; 1
    1864:	60 e0       	ldi	r22, 0x00	; 0
    1866:	41 e0       	ldi	r20, 0x01	; 1
    1868:	0e 94 c6 12 	call	0x258c	; 0x258c <_Z13printTimeDatehhh>
    186c:	86 e0       	ldi	r24, 0x06	; 6
    186e:	90 e0       	ldi	r25, 0x00	; 0
    1870:	90 93 e5 01 	sts	0x01E5, r25
    1874:	80 93 e4 01 	sts	0x01E4, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1878:	fa c2       	rjmp	.+1524   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end while
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
    187a:	ce 01       	movw	r24, r28
    187c:	c4 96       	adiw	r24, 0x34	; 52
    187e:	2f e2       	ldi	r18, 0x2F	; 47
    1880:	31 e0       	ldi	r19, 0x01	; 1
    1882:	b9 01       	movw	r22, r18
    1884:	45 e0       	ldi	r20, 0x05	; 5
    1886:	50 e0       	ldi	r21, 0x00	; 0
    1888:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    188c:	00 97       	sbiw	r24, 0x00	; 0
    188e:	61 f4       	brne	.+24     	; 0x18a8 <_Z11ReceiveBonev+0x1cc>
    1890:	81 e0       	ldi	r24, 0x01	; 1
    1892:	61 e0       	ldi	r22, 0x01	; 1
    1894:	40 e0       	ldi	r20, 0x00	; 0
    1896:	0e 94 c6 12 	call	0x258c	; 0x258c <_Z13printTimeDatehhh>
    189a:	86 e0       	ldi	r24, 0x06	; 6
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	90 93 e5 01 	sts	0x01E5, r25
    18a2:	80 93 e4 01 	sts	0x01E4, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    18a6:	e3 c2       	rjmp	.+1478   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
    18a8:	ce 01       	movw	r24, r28
    18aa:	c4 96       	adiw	r24, 0x34	; 52
    18ac:	25 e3       	ldi	r18, 0x35	; 53
    18ae:	31 e0       	ldi	r19, 0x01	; 1
    18b0:	b9 01       	movw	r22, r18
    18b2:	45 e0       	ldi	r20, 0x05	; 5
    18b4:	50 e0       	ldi	r21, 0x00	; 0
    18b6:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    18ba:	00 97       	sbiw	r24, 0x00	; 0
    18bc:	61 f4       	brne	.+24     	; 0x18d6 <_Z11ReceiveBonev+0x1fa>
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	61 e0       	ldi	r22, 0x01	; 1
    18c2:	41 e0       	ldi	r20, 0x01	; 1
    18c4:	0e 94 c6 12 	call	0x258c	; 0x258c <_Z13printTimeDatehhh>
    18c8:	86 e0       	ldi	r24, 0x06	; 6
    18ca:	90 e0       	ldi	r25, 0x00	; 0
    18cc:	90 93 e5 01 	sts	0x01E5, r25
    18d0:	80 93 e4 01 	sts	0x01E4, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    18d4:	cc c2       	rjmp	.+1432   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
    18d6:	ce 01       	movw	r24, r28
    18d8:	c4 96       	adiw	r24, 0x34	; 52
    18da:	2b e3       	ldi	r18, 0x3B	; 59
    18dc:	31 e0       	ldi	r19, 0x01	; 1
    18de:	b9 01       	movw	r22, r18
    18e0:	45 e0       	ldi	r20, 0x05	; 5
    18e2:	50 e0       	ldi	r21, 0x00	; 0
    18e4:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    18e8:	00 97       	sbiw	r24, 0x00	; 0
    18ea:	79 f4       	brne	.+30     	; 0x190a <_Z11ReceiveBonev+0x22e>
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	60 e0       	ldi	r22, 0x00	; 0
    18f0:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    18f4:	ce 01       	movw	r24, r28
    18f6:	c4 96       	adiw	r24, 0x34	; 52
    18f8:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    18fc:	86 e0       	ldi	r24, 0x06	; 6
    18fe:	90 e0       	ldi	r25, 0x00	; 0
    1900:	90 93 e5 01 	sts	0x01E5, r25
    1904:	80 93 e4 01 	sts	0x01E4, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1908:	b2 c2       	rjmp	.+1380   	; 0x1e6e <_Z11ReceiveBonev+0x792>
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    190a:	ce 01       	movw	r24, r28
    190c:	c4 96       	adiw	r24, 0x34	; 52
    190e:	21 e4       	ldi	r18, 0x41	; 65
    1910:	31 e0       	ldi	r19, 0x01	; 1
    1912:	b9 01       	movw	r22, r18
    1914:	44 e0       	ldi	r20, 0x04	; 4
    1916:	50 e0       	ldi	r21, 0x00	; 0
    1918:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    191c:	00 97       	sbiw	r24, 0x00	; 0
    191e:	c1 f4       	brne	.+48     	; 0x1950 <_Z11ReceiveBonev+0x274>
    1920:	80 91 9e 01 	lds	r24, 0x019E
    1924:	90 91 9f 01 	lds	r25, 0x019F
    1928:	9e 01       	movw	r18, r28
    192a:	2b 5e       	subi	r18, 0xEB	; 235
    192c:	3f 4f       	sbci	r19, 0xFF	; 255
    192e:	b9 01       	movw	r22, r18
    1930:	4a e0       	ldi	r20, 0x0A	; 10
    1932:	50 e0       	ldi	r21, 0x00	; 0
    1934:	0e 94 00 1c 	call	0x3800	; 0x3800 <utoa>
    1938:	1b 8e       	std	Y+27, r1	; 0x1b
    193a:	ce 01       	movw	r24, r28
    193c:	45 96       	adiw	r24, 0x15	; 21
    193e:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    1942:	86 e0       	ldi	r24, 0x06	; 6
    1944:	90 e0       	ldi	r25, 0x00	; 0
    1946:	90 93 e5 01 	sts	0x01E5, r25
    194a:	80 93 e4 01 	sts	0x01E4, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    194e:	8f c2       	rjmp	.+1310   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    1950:	ce 01       	movw	r24, r28
    1952:	c4 96       	adiw	r24, 0x34	; 52
    1954:	26 e4       	ldi	r18, 0x46	; 70
    1956:	31 e0       	ldi	r19, 0x01	; 1
    1958:	b9 01       	movw	r22, r18
    195a:	45 e0       	ldi	r20, 0x05	; 5
    195c:	50 e0       	ldi	r21, 0x00	; 0
    195e:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    1962:	00 97       	sbiw	r24, 0x00	; 0
    1964:	c1 f4       	brne	.+48     	; 0x1996 <_Z11ReceiveBonev+0x2ba>
    1966:	80 91 a0 01 	lds	r24, 0x01A0
    196a:	90 91 a1 01 	lds	r25, 0x01A1
    196e:	9e 01       	movw	r18, r28
    1970:	24 5e       	subi	r18, 0xE4	; 228
    1972:	3f 4f       	sbci	r19, 0xFF	; 255
    1974:	b9 01       	movw	r22, r18
    1976:	4a e0       	ldi	r20, 0x0A	; 10
    1978:	50 e0       	ldi	r21, 0x00	; 0
    197a:	0e 94 00 1c 	call	0x3800	; 0x3800 <utoa>
    197e:	1a a2       	lds	r17, 0x9a
    1980:	ce 01       	movw	r24, r28
    1982:	4c 96       	adiw	r24, 0x1c	; 28
    1984:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    1988:	86 e0       	ldi	r24, 0x06	; 6
    198a:	90 e0       	ldi	r25, 0x00	; 0
    198c:	90 93 e5 01 	sts	0x01E5, r25
    1990:	80 93 e4 01 	sts	0x01E4, r24
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1994:	6c c2       	rjmp	.+1240   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
    1996:	88 ad       	sts	0x68, r24
    1998:	91 e0       	ldi	r25, 0x01	; 1
    199a:	8a 33       	cpi	r24, 0x3A	; 58
    199c:	09 f0       	breq	.+2      	; 0x19a0 <_Z11ReceiveBonev+0x2c4>
    199e:	90 e0       	ldi	r25, 0x00	; 0
    19a0:	29 ad       	sts	0x69, r18
    19a2:	81 e0       	ldi	r24, 0x01	; 1
    19a4:	2a 33       	cpi	r18, 0x3A	; 58
    19a6:	09 f0       	breq	.+2      	; 0x19aa <_Z11ReceiveBonev+0x2ce>
    19a8:	80 e0       	ldi	r24, 0x00	; 0
    19aa:	89 27       	eor	r24, r25
    19ac:	88 23       	and	r24, r24
    19ae:	39 f0       	breq	.+14     	; 0x19be <_Z11ReceiveBonev+0x2e2>
						state=7;	
    19b0:	87 e0       	ldi	r24, 0x07	; 7
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	90 93 e5 01 	sts	0x01E5, r25
    19b8:	80 93 e4 01 	sts	0x01E4, r24
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    19bc:	58 c2       	rjmp	.+1200   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
    19be:	ce 01       	movw	r24, r28
    19c0:	c4 96       	adiw	r24, 0x34	; 52
    19c2:	2c e4       	ldi	r18, 0x4C	; 76
    19c4:	31 e0       	ldi	r19, 0x01	; 1
    19c6:	b9 01       	movw	r22, r18
    19c8:	48 e0       	ldi	r20, 0x08	; 8
    19ca:	50 e0       	ldi	r21, 0x00	; 0
    19cc:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    19d0:	00 97       	sbiw	r24, 0x00	; 0
    19d2:	59 f4       	brne	.+22     	; 0x19ea <_Z11ReceiveBonev+0x30e>
    19d4:	85 e5       	ldi	r24, 0x55	; 85
    19d6:	91 e0       	ldi	r25, 0x01	; 1
    19d8:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    19dc:	86 e0       	ldi	r24, 0x06	; 6
    19de:	90 e0       	ldi	r25, 0x00	; 0
    19e0:	90 93 e5 01 	sts	0x01E5, r25
    19e4:	80 93 e4 01 	sts	0x01E4, r24
					else {state=5;}						
					break;
    19e8:	42 c2       	rjmp	.+1156   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
    19ea:	85 e0       	ldi	r24, 0x05	; 5
    19ec:	90 e0       	ldi	r25, 0x00	; 0
    19ee:	90 93 e5 01 	sts	0x01E5, r25
    19f2:	80 93 e4 01 	sts	0x01E4, r24
					break;
    19f6:	3b c2       	rjmp	.+1142   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 2
				case 3:{
					//Successful receive state of time, change SYN to ACK, then print what we got.
					recString[0]='A';
    19f8:	81 e4       	ldi	r24, 0x41	; 65
    19fa:	8c ab       	sts	0x5c, r24
					recString[1]='C';
    19fc:	83 e4       	ldi	r24, 0x43	; 67
    19fe:	8d ab       	sts	0x5d, r24
					recString[2]='K';
    1a00:	8b e4       	ldi	r24, 0x4B	; 75
    1a02:	8e ab       	sts	0x5e, r24
					PrintBone(recString);
    1a04:	ce 01       	movw	r24, r28
    1a06:	c4 96       	adiw	r24, 0x34	; 52
    1a08:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					state=0;
    1a0c:	10 92 e5 01 	sts	0x01E5, r1
    1a10:	10 92 e4 01 	sts	0x01E4, r1
					flagReceivingBone=fFalse;
    1a14:	10 92 ca 01 	sts	0x01CA, r1
					break;
    1a18:	2a c2       	rjmp	.+1108   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 3
				case 4:{
					//Bad time string.
					PrintBone("ACKBAD.");
    1a1a:	8d e0       	ldi	r24, 0x0D	; 13
    1a1c:	91 e0       	ldi	r25, 0x01	; 1
    1a1e:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1a22:	10 92 ca 01 	sts	0x01CA, r1
					state=0;
    1a26:	10 92 e5 01 	sts	0x01E5, r1
    1a2a:	10 92 e4 01 	sts	0x01E4, r1
					break;
    1a2e:	1f c2       	rjmp	.+1086   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 4
				case 5:{
					//Didn't get a good ack or there was an error.
					PrintBone("ACKERROR.");
    1a30:	8e e5       	ldi	r24, 0x5E	; 94
    1a32:	91 e0       	ldi	r25, 0x01	; 1
    1a34:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1a38:	10 92 ca 01 	sts	0x01CA, r1
					state=0;
    1a3c:	10 92 e5 01 	sts	0x01E5, r1
    1a40:	10 92 e4 01 	sts	0x01E4, r1
					break;
    1a44:	14 c2       	rjmp	.+1064   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 5
				case 6:{
					//Graceful exit.
					flagReceivingBone=fFalse;
    1a46:	10 92 ca 01 	sts	0x01CA, r1
					state=0;
    1a4a:	10 92 e5 01 	sts	0x01E5, r1
    1a4e:	10 92 e4 01 	sts	0x01E4, r1
					break;
    1a52:	0d c2       	rjmp	.+1050   	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 6
				case 7:{
					//Parse the string
					//Go through the string and parse for the time. Must go through the time to get the date.
					BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    1a54:	1a 82       	std	Y+2, r1	; 0x02
    1a56:	1b 82       	std	Y+3, r1	; 0x03
					int counter=0;
    1a58:	1d 82       	std	Y+5, r1	; 0x05
    1a5a:	1c 82       	std	Y+4, r1	; 0x04
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    1a5c:	1c a2       	lds	r17, 0x9c
    1a5e:	1b a2       	lds	r17, 0x9b
    1a60:	1e a2       	lds	r17, 0x9e
    1a62:	1d a2       	lds	r17, 0x9d
    1a64:	18 a6       	lds	r17, 0xb8
    1a66:	1f a2       	lds	r17, 0x9f
    1a68:	1a a6       	lds	r17, 0xba
    1a6a:	19 a6       	lds	r17, 0xb9
    1a6c:	1c a6       	lds	r17, 0xbc
    1a6e:	1b a6       	lds	r17, 0xbb
    1a70:	1e a6       	lds	r17, 0xbe
    1a72:	1d a6       	lds	r17, 0xbd
    1a74:	1f 82       	std	Y+7, r1	; 0x07
    1a76:	1e 82       	std	Y+6, r1	; 0x06
    1a78:	19 86       	std	Y+9, r1	; 0x09
    1a7a:	18 86       	std	Y+8, r1	; 0x08
    1a7c:	1b 86       	std	Y+11, r1	; 0x0b
    1a7e:	1a 86       	std	Y+10, r1	; 0x0a
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    1a80:	73 c0       	rjmp	.+230    	; 0x1b68 <_Z11ReceiveBonev+0x48c>
						//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
						if (recString[counter]!=':' && hms<3){
    1a82:	9e 01       	movw	r18, r28
    1a84:	2c 5c       	subi	r18, 0xCC	; 204
    1a86:	3f 4f       	sbci	r19, 0xFF	; 255
    1a88:	8c 81       	ldd	r24, Y+4	; 0x04
    1a8a:	9d 81       	ldd	r25, Y+5	; 0x05
    1a8c:	82 0f       	add	r24, r18
    1a8e:	93 1f       	adc	r25, r19
    1a90:	fc 01       	movw	r30, r24
    1a92:	80 81       	ld	r24, Z
    1a94:	8a 33       	cpi	r24, 0x3A	; 58
    1a96:	e9 f0       	breq	.+58     	; 0x1ad2 <_Z11ReceiveBonev+0x3f6>
    1a98:	88 85       	ldd	r24, Y+8	; 0x08
    1a9a:	99 85       	ldd	r25, Y+9	; 0x09
    1a9c:	83 30       	cpi	r24, 0x03	; 3
    1a9e:	91 05       	cpc	r25, r1
    1aa0:	c4 f4       	brge	.+48     	; 0x1ad2 <_Z11ReceiveBonev+0x3f6>
							tempStringNum[placement++]=recString[counter];
    1aa2:	9e 01       	movw	r18, r28
    1aa4:	2c 5c       	subi	r18, 0xCC	; 204
    1aa6:	3f 4f       	sbci	r19, 0xFF	; 255
    1aa8:	8c 81       	ldd	r24, Y+4	; 0x04
    1aaa:	9d 81       	ldd	r25, Y+5	; 0x05
    1aac:	82 0f       	add	r24, r18
    1aae:	93 1f       	adc	r25, r19
    1ab0:	fc 01       	movw	r30, r24
    1ab2:	40 81       	ld	r20, Z
    1ab4:	9e 01       	movw	r18, r28
    1ab6:	21 5d       	subi	r18, 0xD1	; 209
    1ab8:	3f 4f       	sbci	r19, 0xFF	; 255
    1aba:	8a 85       	ldd	r24, Y+10	; 0x0a
    1abc:	9b 85       	ldd	r25, Y+11	; 0x0b
    1abe:	82 0f       	add	r24, r18
    1ac0:	93 1f       	adc	r25, r19
    1ac2:	fc 01       	movw	r30, r24
    1ac4:	40 83       	st	Z, r20
    1ac6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ac8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1aca:	01 96       	adiw	r24, 0x01	; 1
    1acc:	9b 87       	std	Y+11, r25	; 0x0b
    1ace:	8a 87       	std	Y+10, r24	; 0x0a
    1ad0:	46 c0       	rjmp	.+140    	; 0x1b5e <_Z11ReceiveBonev+0x482>
						//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
						} else if (hms<2 && recString[counter] == ':') {
    1ad2:	88 85       	ldd	r24, Y+8	; 0x08
    1ad4:	99 85       	ldd	r25, Y+9	; 0x09
    1ad6:	82 30       	cpi	r24, 0x02	; 2
    1ad8:	91 05       	cpc	r25, r1
    1ada:	0c f0       	brlt	.+2      	; 0x1ade <_Z11ReceiveBonev+0x402>
    1adc:	40 c0       	rjmp	.+128    	; 0x1b5e <_Z11ReceiveBonev+0x482>
    1ade:	9e 01       	movw	r18, r28
    1ae0:	2c 5c       	subi	r18, 0xCC	; 204
    1ae2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ae4:	8c 81       	ldd	r24, Y+4	; 0x04
    1ae6:	9d 81       	ldd	r25, Y+5	; 0x05
    1ae8:	82 0f       	add	r24, r18
    1aea:	93 1f       	adc	r25, r19
    1aec:	fc 01       	movw	r30, r24
    1aee:	80 81       	ld	r24, Z
    1af0:	8a 33       	cpi	r24, 0x3A	; 58
    1af2:	a9 f5       	brne	.+106    	; 0x1b5e <_Z11ReceiveBonev+0x482>
							tempNum[hms++] = atoi(tempStringNum);
    1af4:	ce 01       	movw	r24, r28
    1af6:	8f 96       	adiw	r24, 0x2f	; 47
    1af8:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
    1afc:	9c 01       	movw	r18, r24
    1afe:	88 85       	ldd	r24, Y+8	; 0x08
    1b00:	99 85       	ldd	r25, Y+9	; 0x09
    1b02:	88 0f       	add	r24, r24
    1b04:	99 1f       	adc	r25, r25
    1b06:	ae 01       	movw	r20, r28
    1b08:	4f 5f       	subi	r20, 0xFF	; 255
    1b0a:	5f 4f       	sbci	r21, 0xFF	; 255
    1b0c:	84 0f       	add	r24, r20
    1b0e:	95 1f       	adc	r25, r21
    1b10:	82 96       	adiw	r24, 0x22	; 34
    1b12:	fc 01       	movw	r30, r24
    1b14:	31 83       	std	Z+1, r19	; 0x01
    1b16:	20 83       	st	Z, r18
    1b18:	88 85       	ldd	r24, Y+8	; 0x08
    1b1a:	99 85       	ldd	r25, Y+9	; 0x09
    1b1c:	01 96       	adiw	r24, 0x01	; 1
    1b1e:	99 87       	std	Y+9, r25	; 0x09
    1b20:	88 87       	std	Y+8, r24	; 0x08
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1b22:	1d 86       	std	Y+13, r1	; 0x0d
    1b24:	1c 86       	std	Y+12, r1	; 0x0c
    1b26:	0e c0       	rjmp	.+28     	; 0x1b44 <_Z11ReceiveBonev+0x468>
    1b28:	9e 01       	movw	r18, r28
    1b2a:	21 5d       	subi	r18, 0xD1	; 209
    1b2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b30:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b32:	82 0f       	add	r24, r18
    1b34:	93 1f       	adc	r25, r19
    1b36:	fc 01       	movw	r30, r24
    1b38:	10 82       	st	Z, r1
    1b3a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b3c:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b3e:	01 96       	adiw	r24, 0x01	; 1
    1b40:	9d 87       	std	Y+13, r25	; 0x0d
    1b42:	8c 87       	std	Y+12, r24	; 0x0c
    1b44:	41 e0       	ldi	r20, 0x01	; 1
    1b46:	2c 85       	ldd	r18, Y+12	; 0x0c
    1b48:	3d 85       	ldd	r19, Y+13	; 0x0d
    1b4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b4c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b4e:	82 17       	cp	r24, r18
    1b50:	93 07       	cpc	r25, r19
    1b52:	0c f4       	brge	.+2      	; 0x1b56 <_Z11ReceiveBonev+0x47a>
    1b54:	40 e0       	ldi	r20, 0x00	; 0
    1b56:	44 23       	and	r20, r20
    1b58:	39 f7       	brne	.-50     	; 0x1b28 <_Z11ReceiveBonev+0x44c>
							placement=0;												//reset placement
    1b5a:	1b 86       	std	Y+11, r1	; 0x0b
    1b5c:	1a 86       	std	Y+10, r1	; 0x0a
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
    1b5e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b60:	9d 81       	ldd	r25, Y+5	; 0x05
    1b62:	01 96       	adiw	r24, 0x01	; 1
    1b64:	9d 83       	std	Y+5, r25	; 0x05
    1b66:	8c 83       	std	Y+4, r24	; 0x04
					int counter=0;
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    1b68:	9e 01       	movw	r18, r28
    1b6a:	2c 5c       	subi	r18, 0xCC	; 204
    1b6c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b6e:	8c 81       	ldd	r24, Y+4	; 0x04
    1b70:	9d 81       	ldd	r25, Y+5	; 0x05
    1b72:	82 0f       	add	r24, r18
    1b74:	93 1f       	adc	r25, r19
    1b76:	fc 01       	movw	r30, r24
    1b78:	80 81       	ld	r24, Z
    1b7a:	8f 32       	cpi	r24, 0x2F	; 47
    1b7c:	69 f0       	breq	.+26     	; 0x1b98 <_Z11ReceiveBonev+0x4bc>
    1b7e:	9e 01       	movw	r18, r28
    1b80:	2c 5c       	subi	r18, 0xCC	; 204
    1b82:	3f 4f       	sbci	r19, 0xFF	; 255
    1b84:	8c 81       	ldd	r24, Y+4	; 0x04
    1b86:	9d 81       	ldd	r25, Y+5	; 0x05
    1b88:	82 0f       	add	r24, r18
    1b8a:	93 1f       	adc	r25, r19
    1b8c:	fc 01       	movw	r30, r24
    1b8e:	80 81       	ld	r24, Z
    1b90:	88 23       	and	r24, r24
    1b92:	11 f0       	breq	.+4      	; 0x1b98 <_Z11ReceiveBonev+0x4bc>
    1b94:	81 e0       	ldi	r24, 0x01	; 1
    1b96:	01 c0       	rjmp	.+2      	; 0x1b9a <_Z11ReceiveBonev+0x4be>
    1b98:	80 e0       	ldi	r24, 0x00	; 0
    1b9a:	88 23       	and	r24, r24
    1b9c:	09 f0       	breq	.+2      	; 0x1ba0 <_Z11ReceiveBonev+0x4c4>
    1b9e:	71 cf       	rjmp	.-286    	; 0x1a82 <_Z11ReceiveBonev+0x3a6>
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
					}//end while
					//Found a '/', assign tempNum otherwise exit with ACKBAD
					if (recString[counter] == '/'){
    1ba0:	9e 01       	movw	r18, r28
    1ba2:	2c 5c       	subi	r18, 0xCC	; 204
    1ba4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ba6:	8c 81       	ldd	r24, Y+4	; 0x04
    1ba8:	9d 81       	ldd	r25, Y+5	; 0x05
    1baa:	82 0f       	add	r24, r18
    1bac:	93 1f       	adc	r25, r19
    1bae:	fc 01       	movw	r30, r24
    1bb0:	80 81       	ld	r24, Z
    1bb2:	8f 32       	cpi	r24, 0x2F	; 47
    1bb4:	a9 f4       	brne	.+42     	; 0x1be0 <_Z11ReceiveBonev+0x504>
						tempNum[hms] = atoi(tempStringNum);
    1bb6:	ce 01       	movw	r24, r28
    1bb8:	8f 96       	adiw	r24, 0x2f	; 47
    1bba:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
    1bbe:	9c 01       	movw	r18, r24
    1bc0:	88 85       	ldd	r24, Y+8	; 0x08
    1bc2:	99 85       	ldd	r25, Y+9	; 0x09
    1bc4:	88 0f       	add	r24, r24
    1bc6:	99 1f       	adc	r25, r25
    1bc8:	ae 01       	movw	r20, r28
    1bca:	4f 5f       	subi	r20, 0xFF	; 255
    1bcc:	5f 4f       	sbci	r21, 0xFF	; 255
    1bce:	84 0f       	add	r24, r20
    1bd0:	95 1f       	adc	r25, r21
    1bd2:	82 96       	adiw	r24, 0x22	; 34
    1bd4:	fc 01       	movw	r30, r24
    1bd6:	31 83       	std	Z+1, r19	; 0x01
    1bd8:	20 83       	st	Z, r18
						successTime=fTrue;
    1bda:	81 e0       	ldi	r24, 0x01	; 1
    1bdc:	8a 83       	std	Y+2, r24	; 0x02
    1bde:	06 c0       	rjmp	.+12     	; 0x1bec <_Z11ReceiveBonev+0x510>
					} else {
						state=4;
    1be0:	84 e0       	ldi	r24, 0x04	; 4
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	90 93 e5 01 	sts	0x01E5, r25
    1be8:	80 93 e4 01 	sts	0x01E4, r24
					}
					
					//If flag for Date is set, then parse the string and do something with it.
					//Now get the date. have to null the tempStringNum
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1bec:	1f 86       	std	Y+15, r1	; 0x0f
    1bee:	1e 86       	std	Y+14, r1	; 0x0e
    1bf0:	0e c0       	rjmp	.+28     	; 0x1c0e <_Z11ReceiveBonev+0x532>
    1bf2:	9e 01       	movw	r18, r28
    1bf4:	21 5d       	subi	r18, 0xD1	; 209
    1bf6:	3f 4f       	sbci	r19, 0xFF	; 255
    1bf8:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bfa:	9f 85       	ldd	r25, Y+15	; 0x0f
    1bfc:	82 0f       	add	r24, r18
    1bfe:	93 1f       	adc	r25, r19
    1c00:	fc 01       	movw	r30, r24
    1c02:	10 82       	st	Z, r1
    1c04:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c06:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c08:	01 96       	adiw	r24, 0x01	; 1
    1c0a:	9f 87       	std	Y+15, r25	; 0x0f
    1c0c:	8e 87       	std	Y+14, r24	; 0x0e
    1c0e:	41 e0       	ldi	r20, 0x01	; 1
    1c10:	2e 85       	ldd	r18, Y+14	; 0x0e
    1c12:	3f 85       	ldd	r19, Y+15	; 0x0f
    1c14:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c16:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c18:	82 17       	cp	r24, r18
    1c1a:	93 07       	cpc	r25, r19
    1c1c:	0c f4       	brge	.+2      	; 0x1c20 <_Z11ReceiveBonev+0x544>
    1c1e:	40 e0       	ldi	r20, 0x00	; 0
    1c20:	44 23       	and	r20, r20
    1c22:	39 f7       	brne	.-50     	; 0x1bf2 <_Z11ReceiveBonev+0x516>
					placement=0;
    1c24:	1b 86       	std	Y+11, r1	; 0x0b
    1c26:	1a 86       	std	Y+10, r1	; 0x0a
					counter++;	//get past the '/'
    1c28:	8c 81       	ldd	r24, Y+4	; 0x04
    1c2a:	9d 81       	ldd	r25, Y+5	; 0x05
    1c2c:	01 96       	adiw	r24, 0x01	; 1
    1c2e:	9d 83       	std	Y+5, r25	; 0x05
    1c30:	8c 83       	std	Y+4, r24	; 0x04
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1c32:	73 c0       	rjmp	.+230    	; 0x1d1a <_Z11ReceiveBonev+0x63e>
						//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
						if  (recString[counter] != ',' && dmy < 3){
    1c34:	9e 01       	movw	r18, r28
    1c36:	2c 5c       	subi	r18, 0xCC	; 204
    1c38:	3f 4f       	sbci	r19, 0xFF	; 255
    1c3a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c3c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c3e:	82 0f       	add	r24, r18
    1c40:	93 1f       	adc	r25, r19
    1c42:	fc 01       	movw	r30, r24
    1c44:	80 81       	ld	r24, Z
    1c46:	8c 32       	cpi	r24, 0x2C	; 44
    1c48:	e9 f0       	breq	.+58     	; 0x1c84 <_Z11ReceiveBonev+0x5a8>
    1c4a:	8e 81       	ldd	r24, Y+6	; 0x06
    1c4c:	9f 81       	ldd	r25, Y+7	; 0x07
    1c4e:	83 30       	cpi	r24, 0x03	; 3
    1c50:	91 05       	cpc	r25, r1
    1c52:	c4 f4       	brge	.+48     	; 0x1c84 <_Z11ReceiveBonev+0x5a8>
							tempStringNum[placement++]=recString[counter];
    1c54:	9e 01       	movw	r18, r28
    1c56:	2c 5c       	subi	r18, 0xCC	; 204
    1c58:	3f 4f       	sbci	r19, 0xFF	; 255
    1c5a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c5c:	9d 81       	ldd	r25, Y+5	; 0x05
    1c5e:	82 0f       	add	r24, r18
    1c60:	93 1f       	adc	r25, r19
    1c62:	fc 01       	movw	r30, r24
    1c64:	40 81       	ld	r20, Z
    1c66:	9e 01       	movw	r18, r28
    1c68:	21 5d       	subi	r18, 0xD1	; 209
    1c6a:	3f 4f       	sbci	r19, 0xFF	; 255
    1c6c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c6e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c70:	82 0f       	add	r24, r18
    1c72:	93 1f       	adc	r25, r19
    1c74:	fc 01       	movw	r30, r24
    1c76:	40 83       	st	Z, r20
    1c78:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c7a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c7c:	01 96       	adiw	r24, 0x01	; 1
    1c7e:	9b 87       	std	Y+11, r25	; 0x0b
    1c80:	8a 87       	std	Y+10, r24	; 0x0a
    1c82:	46 c0       	rjmp	.+140    	; 0x1d10 <_Z11ReceiveBonev+0x634>
						//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
						} else if (dmy<2 && recString[counter]==','){
    1c84:	8e 81       	ldd	r24, Y+6	; 0x06
    1c86:	9f 81       	ldd	r25, Y+7	; 0x07
    1c88:	82 30       	cpi	r24, 0x02	; 2
    1c8a:	91 05       	cpc	r25, r1
    1c8c:	0c f0       	brlt	.+2      	; 0x1c90 <_Z11ReceiveBonev+0x5b4>
    1c8e:	40 c0       	rjmp	.+128    	; 0x1d10 <_Z11ReceiveBonev+0x634>
    1c90:	9e 01       	movw	r18, r28
    1c92:	2c 5c       	subi	r18, 0xCC	; 204
    1c94:	3f 4f       	sbci	r19, 0xFF	; 255
    1c96:	8c 81       	ldd	r24, Y+4	; 0x04
    1c98:	9d 81       	ldd	r25, Y+5	; 0x05
    1c9a:	82 0f       	add	r24, r18
    1c9c:	93 1f       	adc	r25, r19
    1c9e:	fc 01       	movw	r30, r24
    1ca0:	80 81       	ld	r24, Z
    1ca2:	8c 32       	cpi	r24, 0x2C	; 44
    1ca4:	a9 f5       	brne	.+106    	; 0x1d10 <_Z11ReceiveBonev+0x634>
							tempNum1[dmy++] = atoi(tempStringNum);
    1ca6:	ce 01       	movw	r24, r28
    1ca8:	8f 96       	adiw	r24, 0x2f	; 47
    1caa:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
    1cae:	9c 01       	movw	r18, r24
    1cb0:	8e 81       	ldd	r24, Y+6	; 0x06
    1cb2:	9f 81       	ldd	r25, Y+7	; 0x07
    1cb4:	88 0f       	add	r24, r24
    1cb6:	99 1f       	adc	r25, r25
    1cb8:	ae 01       	movw	r20, r28
    1cba:	4f 5f       	subi	r20, 0xFF	; 255
    1cbc:	5f 4f       	sbci	r21, 0xFF	; 255
    1cbe:	84 0f       	add	r24, r20
    1cc0:	95 1f       	adc	r25, r21
    1cc2:	88 96       	adiw	r24, 0x28	; 40
    1cc4:	fc 01       	movw	r30, r24
    1cc6:	31 83       	std	Z+1, r19	; 0x01
    1cc8:	20 83       	st	Z, r18
    1cca:	8e 81       	ldd	r24, Y+6	; 0x06
    1ccc:	9f 81       	ldd	r25, Y+7	; 0x07
    1cce:	01 96       	adiw	r24, 0x01	; 1
    1cd0:	9f 83       	std	Y+7, r25	; 0x07
    1cd2:	8e 83       	std	Y+6, r24	; 0x06
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    1cd4:	19 8a       	std	Y+17, r1	; 0x11
    1cd6:	18 8a       	std	Y+16, r1	; 0x10
    1cd8:	0e c0       	rjmp	.+28     	; 0x1cf6 <_Z11ReceiveBonev+0x61a>
    1cda:	9e 01       	movw	r18, r28
    1cdc:	21 5d       	subi	r18, 0xD1	; 209
    1cde:	3f 4f       	sbci	r19, 0xFF	; 255
    1ce0:	88 89       	ldd	r24, Y+16	; 0x10
    1ce2:	99 89       	ldd	r25, Y+17	; 0x11
    1ce4:	82 0f       	add	r24, r18
    1ce6:	93 1f       	adc	r25, r19
    1ce8:	fc 01       	movw	r30, r24
    1cea:	10 82       	st	Z, r1
    1cec:	88 89       	ldd	r24, Y+16	; 0x10
    1cee:	99 89       	ldd	r25, Y+17	; 0x11
    1cf0:	01 96       	adiw	r24, 0x01	; 1
    1cf2:	99 8b       	std	Y+17, r25	; 0x11
    1cf4:	88 8b       	std	Y+16, r24	; 0x10
    1cf6:	41 e0       	ldi	r20, 0x01	; 1
    1cf8:	28 89       	ldd	r18, Y+16	; 0x10
    1cfa:	39 89       	ldd	r19, Y+17	; 0x11
    1cfc:	8a 85       	ldd	r24, Y+10	; 0x0a
    1cfe:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d00:	82 17       	cp	r24, r18
    1d02:	93 07       	cpc	r25, r19
    1d04:	0c f4       	brge	.+2      	; 0x1d08 <_Z11ReceiveBonev+0x62c>
    1d06:	40 e0       	ldi	r20, 0x00	; 0
    1d08:	44 23       	and	r20, r20
    1d0a:	39 f7       	brne	.-50     	; 0x1cda <_Z11ReceiveBonev+0x5fe>
							placement=0;
    1d0c:	1b 86       	std	Y+11, r1	; 0x0b
    1d0e:	1a 86       	std	Y+10, r1	; 0x0a
						} else;
						counter++;							
    1d10:	8c 81       	ldd	r24, Y+4	; 0x04
    1d12:	9d 81       	ldd	r25, Y+5	; 0x05
    1d14:	01 96       	adiw	r24, 0x01	; 1
    1d16:	9d 83       	std	Y+5, r25	; 0x05
    1d18:	8c 83       	std	Y+4, r24	; 0x04
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
					placement=0;
					counter++;	//get past the '/'
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1d1a:	9e 01       	movw	r18, r28
    1d1c:	2c 5c       	subi	r18, 0xCC	; 204
    1d1e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d20:	8c 81       	ldd	r24, Y+4	; 0x04
    1d22:	9d 81       	ldd	r25, Y+5	; 0x05
    1d24:	82 0f       	add	r24, r18
    1d26:	93 1f       	adc	r25, r19
    1d28:	fc 01       	movw	r30, r24
    1d2a:	80 81       	ld	r24, Z
    1d2c:	8e 32       	cpi	r24, 0x2E	; 46
    1d2e:	a1 f0       	breq	.+40     	; 0x1d58 <_Z11ReceiveBonev+0x67c>
    1d30:	9e 01       	movw	r18, r28
    1d32:	2c 5c       	subi	r18, 0xCC	; 204
    1d34:	3f 4f       	sbci	r19, 0xFF	; 255
    1d36:	8c 81       	ldd	r24, Y+4	; 0x04
    1d38:	9d 81       	ldd	r25, Y+5	; 0x05
    1d3a:	82 0f       	add	r24, r18
    1d3c:	93 1f       	adc	r25, r19
    1d3e:	fc 01       	movw	r30, r24
    1d40:	80 81       	ld	r24, Z
    1d42:	88 23       	and	r24, r24
    1d44:	49 f0       	breq	.+18     	; 0x1d58 <_Z11ReceiveBonev+0x67c>
    1d46:	2c 81       	ldd	r18, Y+4	; 0x04
    1d48:	3d 81       	ldd	r19, Y+5	; 0x05
    1d4a:	8b 89       	ldd	r24, Y+19	; 0x13
    1d4c:	9c 89       	ldd	r25, Y+20	; 0x14
    1d4e:	28 17       	cp	r18, r24
    1d50:	39 07       	cpc	r19, r25
    1d52:	11 f0       	breq	.+4      	; 0x1d58 <_Z11ReceiveBonev+0x67c>
    1d54:	81 e0       	ldi	r24, 0x01	; 1
    1d56:	01 c0       	rjmp	.+2      	; 0x1d5a <_Z11ReceiveBonev+0x67e>
    1d58:	80 e0       	ldi	r24, 0x00	; 0
    1d5a:	88 23       	and	r24, r24
    1d5c:	09 f0       	breq	.+2      	; 0x1d60 <_Z11ReceiveBonev+0x684>
    1d5e:	6a cf       	rjmp	.-300    	; 0x1c34 <_Z11ReceiveBonev+0x558>
						} else;
						counter++;							
					}//end while
					
					//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
					if (recString[counter] == '.'){
    1d60:	9e 01       	movw	r18, r28
    1d62:	2c 5c       	subi	r18, 0xCC	; 204
    1d64:	3f 4f       	sbci	r19, 0xFF	; 255
    1d66:	8c 81       	ldd	r24, Y+4	; 0x04
    1d68:	9d 81       	ldd	r25, Y+5	; 0x05
    1d6a:	82 0f       	add	r24, r18
    1d6c:	93 1f       	adc	r25, r19
    1d6e:	fc 01       	movw	r30, r24
    1d70:	80 81       	ld	r24, Z
    1d72:	8e 32       	cpi	r24, 0x2E	; 46
    1d74:	a9 f4       	brne	.+42     	; 0x1da0 <_Z11ReceiveBonev+0x6c4>
						tempNum1[dmy] = atoi(tempStringNum);
    1d76:	ce 01       	movw	r24, r28
    1d78:	8f 96       	adiw	r24, 0x2f	; 47
    1d7a:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
    1d7e:	9c 01       	movw	r18, r24
    1d80:	8e 81       	ldd	r24, Y+6	; 0x06
    1d82:	9f 81       	ldd	r25, Y+7	; 0x07
    1d84:	88 0f       	add	r24, r24
    1d86:	99 1f       	adc	r25, r25
    1d88:	ae 01       	movw	r20, r28
    1d8a:	4f 5f       	subi	r20, 0xFF	; 255
    1d8c:	5f 4f       	sbci	r21, 0xFF	; 255
    1d8e:	84 0f       	add	r24, r20
    1d90:	95 1f       	adc	r25, r21
    1d92:	88 96       	adiw	r24, 0x28	; 40
    1d94:	fc 01       	movw	r30, r24
    1d96:	31 83       	std	Z+1, r19	; 0x01
    1d98:	20 83       	st	Z, r18
						successDate=fTrue;
    1d9a:	81 e0       	ldi	r24, 0x01	; 1
    1d9c:	8b 83       	std	Y+3, r24	; 0x03
    1d9e:	06 c0       	rjmp	.+12     	; 0x1dac <_Z11ReceiveBonev+0x6d0>
					} else {//something in the string was wrong, ACKBAD and then exit
						state=4;
    1da0:	84 e0       	ldi	r24, 0x04	; 4
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	90 93 e5 01 	sts	0x01E5, r25
    1da8:	80 93 e4 01 	sts	0x01E4, r24
					}	
					
					//NOw set the time and date, then save it to EEPROM
					if (successDate && successTime){
    1dac:	8b 81       	ldd	r24, Y+3	; 0x03
    1dae:	88 23       	and	r24, r24
    1db0:	39 f1       	breq	.+78     	; 0x1e00 <_Z11ReceiveBonev+0x724>
    1db2:	8a 81       	ldd	r24, Y+2	; 0x02
    1db4:	88 23       	and	r24, r24
    1db6:	21 f1       	breq	.+72     	; 0x1e00 <_Z11ReceiveBonev+0x724>
						currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    1db8:	69 a5       	lds	r22, 0x69
    1dba:	7a a5       	lds	r23, 0x6a
    1dbc:	4b a5       	lds	r20, 0x6b
    1dbe:	5c a5       	lds	r21, 0x6c
    1dc0:	2d a5       	lds	r18, 0x6d
    1dc2:	3e a5       	lds	r19, 0x6e
    1dc4:	82 ea       	ldi	r24, 0xA2	; 162
    1dc6:	91 e0       	ldi	r25, 0x01	; 1
    1dc8:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
						currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    1dcc:	6b a1       	lds	r22, 0x4b
    1dce:	7c a1       	lds	r23, 0x4c
    1dd0:	4d a1       	lds	r20, 0x4d
    1dd2:	5e a1       	lds	r21, 0x4e
    1dd4:	2f a1       	lds	r18, 0x4f
    1dd6:	38 a5       	lds	r19, 0x68
    1dd8:	82 ea       	ldi	r24, 0xA2	; 162
    1dda:	91 e0       	ldi	r25, 0x01	; 1
    1ddc:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
						saveDateTime_eeprom(fTrue,fTrue);
    1de0:	81 e0       	ldi	r24, 0x01	; 1
    1de2:	61 e0       	ldi	r22, 0x01	; 1
    1de4:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    1de8:	81 e0       	ldi	r24, 0x01	; 1
    1dea:	80 93 ce 01 	sts	0x01CE, r24
						//Make sure UserCLock flags are down
						flagUserClock=fFalse;
    1dee:	10 92 d0 01 	sts	0x01D0, r1
						state=3;	//Graceful exit
    1df2:	83 e0       	ldi	r24, 0x03	; 3
    1df4:	90 e0       	ldi	r25, 0x00	; 0
    1df6:	90 93 e5 01 	sts	0x01E5, r25
    1dfa:	80 93 e4 01 	sts	0x01E4, r24
    1dfe:	2b c0       	rjmp	.+86     	; 0x1e56 <_Z11ReceiveBonev+0x77a>
					} else if (!(successDate && successTime) && restart){
    1e00:	8b 81       	ldd	r24, Y+3	; 0x03
    1e02:	88 23       	and	r24, r24
    1e04:	19 f0       	breq	.+6      	; 0x1e0c <_Z11ReceiveBonev+0x730>
    1e06:	8a 81       	ldd	r24, Y+2	; 0x02
    1e08:	88 23       	and	r24, r24
    1e0a:	81 f4       	brne	.+32     	; 0x1e2c <_Z11ReceiveBonev+0x750>
    1e0c:	80 91 d8 01 	lds	r24, 0x01D8
    1e10:	88 23       	and	r24, r24
    1e12:	61 f0       	breq	.+24     	; 0x1e2c <_Z11ReceiveBonev+0x750>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    1e14:	81 e0       	ldi	r24, 0x01	; 1
    1e16:	80 93 ce 01 	sts	0x01CE, r24
						flagUserClock=fFalse;
    1e1a:	10 92 d0 01 	sts	0x01D0, r1
						state=4;	//ACKBAD
    1e1e:	84 e0       	ldi	r24, 0x04	; 4
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	90 93 e5 01 	sts	0x01E5, r25
    1e26:	80 93 e4 01 	sts	0x01E4, r24
    1e2a:	15 c0       	rjmp	.+42     	; 0x1e56 <_Z11ReceiveBonev+0x77a>
					} else if (!(successDate && successTime) && flagFreshStart){
    1e2c:	8b 81       	ldd	r24, Y+3	; 0x03
    1e2e:	88 23       	and	r24, r24
    1e30:	19 f0       	breq	.+6      	; 0x1e38 <_Z11ReceiveBonev+0x75c>
    1e32:	8a 81       	ldd	r24, Y+2	; 0x02
    1e34:	88 23       	and	r24, r24
    1e36:	79 f4       	brne	.+30     	; 0x1e56 <_Z11ReceiveBonev+0x77a>
    1e38:	80 91 d9 01 	lds	r24, 0x01D9
    1e3c:	88 23       	and	r24, r24
    1e3e:	59 f0       	breq	.+22     	; 0x1e56 <_Z11ReceiveBonev+0x77a>
						flagUserClock=fTrue;
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	80 93 d0 01 	sts	0x01D0, r24
						flagUpdateGAVRClock=fFalse;
    1e46:	10 92 ce 01 	sts	0x01CE, r1
						state=4;	//ACKBAD
    1e4a:	84 e0       	ldi	r24, 0x04	; 4
    1e4c:	90 e0       	ldi	r25, 0x00	; 0
    1e4e:	90 93 e5 01 	sts	0x01E5, r25
    1e52:	80 93 e4 01 	sts	0x01E4, r24
					} else;		
					
					//Lower restart flags. Should have parallel case in timer just in case this state doesn't happen.
					flagFreshStart=fFalse;
    1e56:	10 92 d9 01 	sts	0x01D9, r1
					restart=fFalse;		
    1e5a:	10 92 d8 01 	sts	0x01D8, r1
					break;
    1e5e:	07 c0       	rjmp	.+14     	; 0x1e6e <_Z11ReceiveBonev+0x792>
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
    1e60:	10 92 ca 01 	sts	0x01CA, r1
    1e64:	10 92 e5 01 	sts	0x01E5, r1
    1e68:	10 92 e4 01 	sts	0x01E4, r1
    1e6c:	00 00       	nop
	volatile static unsigned int state=0;
	char recChar, recString[40];
	volatile unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	while (flagReceivingBone){
    1e6e:	90 91 ca 01 	lds	r25, 0x01CA
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	99 23       	and	r25, r25
    1e76:	09 f4       	brne	.+2      	; 0x1e7a <_Z11ReceiveBonev+0x79e>
    1e78:	80 e0       	ldi	r24, 0x00	; 0
    1e7a:	88 23       	and	r24, r24
    1e7c:	09 f0       	breq	.+2      	; 0x1e80 <_Z11ReceiveBonev+0x7a4>
    1e7e:	3e cc       	rjmp	.-1924   	; 0x16fc <_Z11ReceiveBonev+0x20>
					break;
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
			}//end switch
	}//end while(flagUARTbone)	
}//end ReceiveBone()
    1e80:	c5 5a       	subi	r28, 0xA5	; 165
    1e82:	df 4f       	sbci	r29, 0xFF	; 255
    1e84:	0f b6       	in	r0, 0x3f	; 63
    1e86:	f8 94       	cli
    1e88:	de bf       	out	0x3e, r29	; 62
    1e8a:	0f be       	out	0x3f, r0	; 63
    1e8c:	cd bf       	out	0x3d, r28	; 61
    1e8e:	df 91       	pop	r29
    1e90:	cf 91       	pop	r28
    1e92:	08 95       	ret

00001e94 <_Z11ReceiveGAVRv>:

/*************************************************************************************************************/
void ReceiveGAVR(){
    1e94:	cf 93       	push	r28
    1e96:	df 93       	push	r29
    1e98:	cd b7       	in	r28, 0x3d	; 61
    1e9a:	de b7       	in	r29, 0x3e	; 62
    1e9c:	cd 54       	subi	r28, 0x4D	; 77
    1e9e:	d0 40       	sbci	r29, 0x00	; 0
    1ea0:	0f b6       	in	r0, 0x3f	; 63
    1ea2:	f8 94       	cli
    1ea4:	de bf       	out	0x3e, r29	; 62
    1ea6:	0f be       	out	0x3f, r0	; 63
    1ea8:	cd bf       	out	0x3d, r28	; 61
	volatile static unsigned int state=0;
	char recChar, recString[40];
	volatile unsigned int strLoc=0;
    1eaa:	1c 8a       	std	Y+20, r1	; 0x14
    1eac:	1b 8a       	std	Y+19, r1	; 0x13
	BOOL noCarriage=fTrue;
    1eae:	81 e0       	ldi	r24, 0x01	; 1
    1eb0:	89 83       	std	Y+1, r24	; 0x01
	
	//While Loop
	while (flagReceivingGAVR){
    1eb2:	59 c3       	rjmp	.+1714   	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
			/** State 5: Exit case. Lower "flagReceivingGAVR" which causes and exit.													   **/
			/** State 6: ACKERROR state. Send "ACKERROR", then exit through state 5.													   **/
			/** State 7: Successful acquire of time/date.																				   **/
			/** Default: Set state to 0, doesn't really matter though. Exit signalling timeout to sender.								   **/
			/********************************************************************************************************************************/			
			switch(state){
    1eb4:	80 91 e2 01 	lds	r24, 0x01E2
    1eb8:	90 91 e3 01 	lds	r25, 0x01E3
    1ebc:	83 30       	cpi	r24, 0x03	; 3
    1ebe:	91 05       	cpc	r25, r1
    1ec0:	09 f4       	brne	.+2      	; 0x1ec4 <_Z11ReceiveGAVRv+0x30>
    1ec2:	cd c0       	rjmp	.+410    	; 0x205e <_Z11ReceiveGAVRv+0x1ca>
    1ec4:	84 30       	cpi	r24, 0x04	; 4
    1ec6:	91 05       	cpc	r25, r1
    1ec8:	48 f4       	brcc	.+18     	; 0x1edc <_Z11ReceiveGAVRv+0x48>
    1eca:	81 30       	cpi	r24, 0x01	; 1
    1ecc:	91 05       	cpc	r25, r1
    1ece:	09 f4       	brne	.+2      	; 0x1ed2 <_Z11ReceiveGAVRv+0x3e>
    1ed0:	8b c0       	rjmp	.+278    	; 0x1fe8 <_Z11ReceiveGAVRv+0x154>
    1ed2:	82 30       	cpi	r24, 0x02	; 2
    1ed4:	91 05       	cpc	r25, r1
    1ed6:	08 f0       	brcs	.+2      	; 0x1eda <_Z11ReceiveGAVRv+0x46>
    1ed8:	95 c0       	rjmp	.+298    	; 0x2004 <_Z11ReceiveGAVRv+0x170>
    1eda:	11 c0       	rjmp	.+34     	; 0x1efe <_Z11ReceiveGAVRv+0x6a>
    1edc:	85 30       	cpi	r24, 0x05	; 5
    1ede:	91 05       	cpc	r25, r1
    1ee0:	09 f4       	brne	.+2      	; 0x1ee4 <_Z11ReceiveGAVRv+0x50>
    1ee2:	15 c3       	rjmp	.+1578   	; 0x250e <_Z11ReceiveGAVRv+0x67a>
    1ee4:	85 30       	cpi	r24, 0x05	; 5
    1ee6:	91 05       	cpc	r25, r1
    1ee8:	08 f4       	brcc	.+2      	; 0x1eec <_Z11ReceiveGAVRv+0x58>
    1eea:	fa c2       	rjmp	.+1524   	; 0x24e0 <_Z11ReceiveGAVRv+0x64c>
    1eec:	86 30       	cpi	r24, 0x06	; 6
    1eee:	91 05       	cpc	r25, r1
    1ef0:	09 f4       	brne	.+2      	; 0x1ef4 <_Z11ReceiveGAVRv+0x60>
    1ef2:	14 c3       	rjmp	.+1576   	; 0x251c <_Z11ReceiveGAVRv+0x688>
    1ef4:	87 30       	cpi	r24, 0x07	; 7
    1ef6:	91 05       	cpc	r25, r1
    1ef8:	09 f4       	brne	.+2      	; 0x1efc <_Z11ReceiveGAVRv+0x68>
    1efa:	1b c3       	rjmp	.+1590   	; 0x2532 <_Z11ReceiveGAVRv+0x69e>
    1efc:	2b c3       	rjmp	.+1622   	; 0x2554 <_Z11ReceiveGAVRv+0x6c0>
				case 0:{
					//Beginning case
					strLoc=0;
    1efe:	1c 8a       	std	Y+20, r1	; 0x14
    1f00:	1b 8a       	std	Y+19, r1	; 0x13
					recChar = UDR1;
    1f02:	8e ec       	ldi	r24, 0xCE	; 206
    1f04:	90 e0       	ldi	r25, 0x00	; 0
    1f06:	fc 01       	movw	r30, r24
    1f08:	80 81       	ld	r24, Z
    1f0a:	8a 8b       	std	Y+18, r24	; 0x12
					if (recChar=='.'){
    1f0c:	8a 89       	ldd	r24, Y+18	; 0x12
    1f0e:	8e 32       	cpi	r24, 0x2E	; 46
    1f10:	39 f4       	brne	.+14     	; 0x1f20 <_Z11ReceiveGAVRv+0x8c>
						state=6;															//Go to error state.
    1f12:	86 e0       	ldi	r24, 0x06	; 6
    1f14:	90 e0       	ldi	r25, 0x00	; 0
    1f16:	90 93 e3 01 	sts	0x01E3, r25
    1f1a:	80 93 e2 01 	sts	0x01E2, r24
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
    1f1e:	23 c3       	rjmp	.+1606   	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
					//Beginning case
					strLoc=0;
					recChar = UDR1;
					if (recChar=='.'){
						state=6;															//Go to error state.
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
    1f20:	8b 89       	ldd	r24, Y+19	; 0x13
    1f22:	9c 89       	ldd	r25, Y+20	; 0x14
    1f24:	9e 01       	movw	r18, r28
    1f26:	2a 5d       	subi	r18, 0xDA	; 218
    1f28:	3f 4f       	sbci	r19, 0xFF	; 255
    1f2a:	28 0f       	add	r18, r24
    1f2c:	39 1f       	adc	r19, r25
    1f2e:	4a 89       	ldd	r20, Y+18	; 0x12
    1f30:	f9 01       	movw	r30, r18
    1f32:	40 83       	st	Z, r20
    1f34:	01 96       	adiw	r24, 0x01	; 1
    1f36:	9c 8b       	std	Y+20, r25	; 0x14
    1f38:	8b 8b       	std	Y+19, r24	; 0x13
    1f3a:	81 e0       	ldi	r24, 0x01	; 1
    1f3c:	90 e0       	ldi	r25, 0x00	; 0
    1f3e:	90 93 e3 01 	sts	0x01E3, r25
    1f42:	80 93 e2 01 	sts	0x01E2, r24
					break;
    1f46:	0f c3       	rjmp	.+1566   	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
    1f48:	00 00       	nop
    1f4a:	88 ec       	ldi	r24, 0xC8	; 200
    1f4c:	90 e0       	ldi	r25, 0x00	; 0
    1f4e:	fc 01       	movw	r30, r24
    1f50:	80 81       	ld	r24, Z
    1f52:	88 23       	and	r24, r24
    1f54:	34 f0       	brlt	.+12     	; 0x1f62 <_Z11ReceiveGAVRv+0xce>
    1f56:	80 91 cc 01 	lds	r24, 0x01CC
    1f5a:	88 23       	and	r24, r24
    1f5c:	11 f0       	breq	.+4      	; 0x1f62 <_Z11ReceiveGAVRv+0xce>
    1f5e:	81 e0       	ldi	r24, 0x01	; 1
    1f60:	01 c0       	rjmp	.+2      	; 0x1f64 <_Z11ReceiveGAVRv+0xd0>
    1f62:	80 e0       	ldi	r24, 0x00	; 0
    1f64:	88 23       	and	r24, r24
    1f66:	89 f7       	brne	.-30     	; 0x1f4a <_Z11ReceiveGAVRv+0xb6>
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
    1f68:	80 91 cc 01 	lds	r24, 0x01CC
    1f6c:	88 23       	and	r24, r24
    1f6e:	31 f4       	brne	.+12     	; 0x1f7c <_Z11ReceiveGAVRv+0xe8>
    1f70:	10 92 e3 01 	sts	0x01E3, r1
    1f74:	10 92 e2 01 	sts	0x01E2, r1
    1f78:	00 00       	nop
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    1f7a:	f5 c2       	rjmp	.+1514   	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
						recChar=UDR1;
    1f7c:	8e ec       	ldi	r24, 0xCE	; 206
    1f7e:	90 e0       	ldi	r25, 0x00	; 0
    1f80:	fc 01       	movw	r30, r24
    1f82:	80 81       	ld	r24, Z
    1f84:	8a 8b       	std	Y+18, r24	; 0x12
						recString[strLoc++]=recChar;										//'.' always included into recString
    1f86:	8b 89       	ldd	r24, Y+19	; 0x13
    1f88:	9c 89       	ldd	r25, Y+20	; 0x14
    1f8a:	9e 01       	movw	r18, r28
    1f8c:	2a 5d       	subi	r18, 0xDA	; 218
    1f8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f90:	28 0f       	add	r18, r24
    1f92:	39 1f       	adc	r19, r25
    1f94:	4a 89       	ldd	r20, Y+18	; 0x12
    1f96:	f9 01       	movw	r30, r18
    1f98:	40 83       	st	Z, r20
    1f9a:	01 96       	adiw	r24, 0x01	; 1
    1f9c:	9c 8b       	std	Y+20, r25	; 0x14
    1f9e:	8b 8b       	std	Y+19, r24	; 0x13
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1fa0:	8a 89       	ldd	r24, Y+18	; 0x12
    1fa2:	8e 32       	cpi	r24, 0x2E	; 46
    1fa4:	89 f4       	brne	.+34     	; 0x1fc8 <_Z11ReceiveGAVRv+0x134>
    1fa6:	8b 89       	ldd	r24, Y+19	; 0x13
    1fa8:	9c 89       	ldd	r25, Y+20	; 0x14
    1faa:	9e 01       	movw	r18, r28
    1fac:	2a 5d       	subi	r18, 0xDA	; 218
    1fae:	3f 4f       	sbci	r19, 0xFF	; 255
    1fb0:	82 0f       	add	r24, r18
    1fb2:	93 1f       	adc	r25, r19
    1fb4:	fc 01       	movw	r30, r24
    1fb6:	10 82       	st	Z, r1
    1fb8:	19 82       	std	Y+1, r1	; 0x01
    1fba:	82 e0       	ldi	r24, 0x02	; 2
    1fbc:	90 e0       	ldi	r25, 0x00	; 0
    1fbe:	90 93 e3 01 	sts	0x01E3, r25
    1fc2:	80 93 e2 01 	sts	0x01E2, r24
    1fc6:	10 c0       	rjmp	.+32     	; 0x1fe8 <_Z11ReceiveGAVRv+0x154>
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
    1fc8:	8b 89       	ldd	r24, Y+19	; 0x13
    1fca:	9c 89       	ldd	r25, Y+20	; 0x14
    1fcc:	21 e0       	ldi	r18, 0x01	; 1
    1fce:	87 32       	cpi	r24, 0x27	; 39
    1fd0:	91 05       	cpc	r25, r1
    1fd2:	08 f4       	brcc	.+2      	; 0x1fd6 <_Z11ReceiveGAVRv+0x142>
    1fd4:	20 e0       	ldi	r18, 0x00	; 0
    1fd6:	22 23       	and	r18, r18
    1fd8:	39 f0       	breq	.+14     	; 0x1fe8 <_Z11ReceiveGAVRv+0x154>
    1fda:	86 e0       	ldi	r24, 0x06	; 6
    1fdc:	90 e0       	ldi	r25, 0x00	; 0
    1fde:	90 93 e3 01 	sts	0x01E3, r25
    1fe2:	80 93 e2 01 	sts	0x01E2, r24
    1fe6:	19 82       	std	Y+1, r1	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
    1fe8:	89 81       	ldd	r24, Y+1	; 0x01
    1fea:	88 23       	and	r24, r24
    1fec:	31 f0       	breq	.+12     	; 0x1ffa <_Z11ReceiveGAVRv+0x166>
    1fee:	80 91 cc 01 	lds	r24, 0x01CC
    1ff2:	88 23       	and	r24, r24
    1ff4:	11 f0       	breq	.+4      	; 0x1ffa <_Z11ReceiveGAVRv+0x166>
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
    1ff8:	01 c0       	rjmp	.+2      	; 0x1ffc <_Z11ReceiveGAVRv+0x168>
    1ffa:	80 e0       	ldi	r24, 0x00	; 0
    1ffc:	88 23       	and	r24, r24
    1ffe:	09 f0       	breq	.+2      	; 0x2002 <_Z11ReceiveGAVRv+0x16e>
    2000:	a3 cf       	rjmp	.-186    	; 0x1f48 <_Z11ReceiveGAVRv+0xb4>
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    2002:	b1 c2       	rjmp	.+1378   	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
    2004:	ce 01       	movw	r24, r28
    2006:	86 96       	adiw	r24, 0x26	; 38
    2008:	28 e6       	ldi	r18, 0x68	; 104
    200a:	31 e0       	ldi	r19, 0x01	; 1
    200c:	b9 01       	movw	r22, r18
    200e:	48 e0       	ldi	r20, 0x08	; 8
    2010:	50 e0       	ldi	r21, 0x00	; 0
    2012:	0e 94 c9 1b 	call	0x3792	; 0x3792 <strncmp>
    2016:	00 97       	sbiw	r24, 0x00	; 0
    2018:	39 f4       	brne	.+14     	; 0x2028 <_Z11ReceiveGAVRv+0x194>
    201a:	84 e0       	ldi	r24, 0x04	; 4
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	90 93 e3 01 	sts	0x01E3, r25
    2022:	80 93 e2 01 	sts	0x01E2, r24
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
					break;
    2026:	9f c2       	rjmp	.+1342   	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
					break;
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
    2028:	8a a5       	lds	r24, 0x6a
    202a:	91 e0       	ldi	r25, 0x01	; 1
    202c:	8a 33       	cpi	r24, 0x3A	; 58
    202e:	09 f0       	breq	.+2      	; 0x2032 <_Z11ReceiveGAVRv+0x19e>
    2030:	90 e0       	ldi	r25, 0x00	; 0
    2032:	2b a5       	lds	r18, 0x6b
    2034:	81 e0       	ldi	r24, 0x01	; 1
    2036:	2a 33       	cpi	r18, 0x3A	; 58
    2038:	09 f0       	breq	.+2      	; 0x203c <_Z11ReceiveGAVRv+0x1a8>
    203a:	80 e0       	ldi	r24, 0x00	; 0
    203c:	89 27       	eor	r24, r25
    203e:	88 23       	and	r24, r24
    2040:	39 f0       	breq	.+14     	; 0x2050 <_Z11ReceiveGAVRv+0x1bc>
    2042:	83 e0       	ldi	r24, 0x03	; 3
    2044:	90 e0       	ldi	r25, 0x00	; 0
    2046:	90 93 e3 01 	sts	0x01E3, r25
    204a:	80 93 e2 01 	sts	0x01E2, r24
					else {state=6;}
					break;
    204e:	8b c2       	rjmp	.+1302   	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
    2050:	86 e0       	ldi	r24, 0x06	; 6
    2052:	90 e0       	ldi	r25, 0x00	; 0
    2054:	90 93 e3 01 	sts	0x01E3, r25
    2058:	80 93 e2 01 	sts	0x01E2, r24
					break;
    205c:	84 c2       	rjmp	.+1288   	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 2
				case 3:{
					//Parse for date/time case
					if (flagUserClock){
    205e:	80 91 d0 01 	lds	r24, 0x01D0
    2062:	88 23       	and	r24, r24
    2064:	09 f4       	brne	.+2      	; 0x2068 <_Z11ReceiveGAVRv+0x1d4>
    2066:	31 c2       	rjmp	.+1122   	; 0x24ca <_Z11ReceiveGAVRv+0x636>
						//Go through the string and parse for the time. Must go through the time to get the date.
						BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    2068:	1a 82       	std	Y+2, r1	; 0x02
    206a:	1b 82       	std	Y+3, r1	; 0x03
						int counter=0;
    206c:	1d 82       	std	Y+5, r1	; 0x05
    206e:	1c 82       	std	Y+4, r1	; 0x04
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    2070:	1e 8a       	std	Y+22, r1	; 0x16
    2072:	1d 8a       	std	Y+21, r1	; 0x15
    2074:	18 8e       	std	Y+24, r1	; 0x18
    2076:	1f 8a       	std	Y+23, r1	; 0x17
    2078:	1a 8e       	std	Y+26, r1	; 0x1a
    207a:	19 8e       	std	Y+25, r1	; 0x19
    207c:	1c 8e       	std	Y+28, r1	; 0x1c
    207e:	1b 8e       	std	Y+27, r1	; 0x1b
    2080:	1e 8e       	std	Y+30, r1	; 0x1e
    2082:	1d 8e       	std	Y+29, r1	; 0x1d
    2084:	18 a2       	lds	r17, 0x98
    2086:	1f 8e       	std	Y+31, r1	; 0x1f
    2088:	1f 82       	std	Y+7, r1	; 0x07
    208a:	1e 82       	std	Y+6, r1	; 0x06
    208c:	19 86       	std	Y+9, r1	; 0x09
    208e:	18 86       	std	Y+8, r1	; 0x08
    2090:	1b 86       	std	Y+11, r1	; 0x0b
    2092:	1a 86       	std	Y+10, r1	; 0x0a
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    2094:	73 c0       	rjmp	.+230    	; 0x217c <_Z11ReceiveGAVRv+0x2e8>
							//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
							if (recString[counter]!=':' && hms<3){
    2096:	9e 01       	movw	r18, r28
    2098:	2a 5d       	subi	r18, 0xDA	; 218
    209a:	3f 4f       	sbci	r19, 0xFF	; 255
    209c:	8c 81       	ldd	r24, Y+4	; 0x04
    209e:	9d 81       	ldd	r25, Y+5	; 0x05
    20a0:	82 0f       	add	r24, r18
    20a2:	93 1f       	adc	r25, r19
    20a4:	fc 01       	movw	r30, r24
    20a6:	80 81       	ld	r24, Z
    20a8:	8a 33       	cpi	r24, 0x3A	; 58
    20aa:	e9 f0       	breq	.+58     	; 0x20e6 <_Z11ReceiveGAVRv+0x252>
    20ac:	88 85       	ldd	r24, Y+8	; 0x08
    20ae:	99 85       	ldd	r25, Y+9	; 0x09
    20b0:	83 30       	cpi	r24, 0x03	; 3
    20b2:	91 05       	cpc	r25, r1
    20b4:	c4 f4       	brge	.+48     	; 0x20e6 <_Z11ReceiveGAVRv+0x252>
								tempStringNum[placement++]=recString[counter];
    20b6:	9e 01       	movw	r18, r28
    20b8:	2a 5d       	subi	r18, 0xDA	; 218
    20ba:	3f 4f       	sbci	r19, 0xFF	; 255
    20bc:	8c 81       	ldd	r24, Y+4	; 0x04
    20be:	9d 81       	ldd	r25, Y+5	; 0x05
    20c0:	82 0f       	add	r24, r18
    20c2:	93 1f       	adc	r25, r19
    20c4:	fc 01       	movw	r30, r24
    20c6:	40 81       	ld	r20, Z
    20c8:	9e 01       	movw	r18, r28
    20ca:	2f 5d       	subi	r18, 0xDF	; 223
    20cc:	3f 4f       	sbci	r19, 0xFF	; 255
    20ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    20d0:	9b 85       	ldd	r25, Y+11	; 0x0b
    20d2:	82 0f       	add	r24, r18
    20d4:	93 1f       	adc	r25, r19
    20d6:	fc 01       	movw	r30, r24
    20d8:	40 83       	st	Z, r20
    20da:	8a 85       	ldd	r24, Y+10	; 0x0a
    20dc:	9b 85       	ldd	r25, Y+11	; 0x0b
    20de:	01 96       	adiw	r24, 0x01	; 1
    20e0:	9b 87       	std	Y+11, r25	; 0x0b
    20e2:	8a 87       	std	Y+10, r24	; 0x0a
    20e4:	46 c0       	rjmp	.+140    	; 0x2172 <_Z11ReceiveGAVRv+0x2de>
							//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
							} else if (hms<2 && recString[counter] == ':') {
    20e6:	88 85       	ldd	r24, Y+8	; 0x08
    20e8:	99 85       	ldd	r25, Y+9	; 0x09
    20ea:	82 30       	cpi	r24, 0x02	; 2
    20ec:	91 05       	cpc	r25, r1
    20ee:	0c f0       	brlt	.+2      	; 0x20f2 <_Z11ReceiveGAVRv+0x25e>
    20f0:	40 c0       	rjmp	.+128    	; 0x2172 <_Z11ReceiveGAVRv+0x2de>
    20f2:	9e 01       	movw	r18, r28
    20f4:	2a 5d       	subi	r18, 0xDA	; 218
    20f6:	3f 4f       	sbci	r19, 0xFF	; 255
    20f8:	8c 81       	ldd	r24, Y+4	; 0x04
    20fa:	9d 81       	ldd	r25, Y+5	; 0x05
    20fc:	82 0f       	add	r24, r18
    20fe:	93 1f       	adc	r25, r19
    2100:	fc 01       	movw	r30, r24
    2102:	80 81       	ld	r24, Z
    2104:	8a 33       	cpi	r24, 0x3A	; 58
    2106:	a9 f5       	brne	.+106    	; 0x2172 <_Z11ReceiveGAVRv+0x2de>
								tempNum[hms++] = atoi(tempStringNum);
    2108:	ce 01       	movw	r24, r28
    210a:	81 96       	adiw	r24, 0x21	; 33
    210c:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
    2110:	9c 01       	movw	r18, r24
    2112:	88 85       	ldd	r24, Y+8	; 0x08
    2114:	99 85       	ldd	r25, Y+9	; 0x09
    2116:	88 0f       	add	r24, r24
    2118:	99 1f       	adc	r25, r25
    211a:	ae 01       	movw	r20, r28
    211c:	4f 5f       	subi	r20, 0xFF	; 255
    211e:	5f 4f       	sbci	r21, 0xFF	; 255
    2120:	84 0f       	add	r24, r20
    2122:	95 1f       	adc	r25, r21
    2124:	44 96       	adiw	r24, 0x14	; 20
    2126:	fc 01       	movw	r30, r24
    2128:	31 83       	std	Z+1, r19	; 0x01
    212a:	20 83       	st	Z, r18
    212c:	88 85       	ldd	r24, Y+8	; 0x08
    212e:	99 85       	ldd	r25, Y+9	; 0x09
    2130:	01 96       	adiw	r24, 0x01	; 1
    2132:	99 87       	std	Y+9, r25	; 0x09
    2134:	88 87       	std	Y+8, r24	; 0x08
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    2136:	1d 86       	std	Y+13, r1	; 0x0d
    2138:	1c 86       	std	Y+12, r1	; 0x0c
    213a:	0e c0       	rjmp	.+28     	; 0x2158 <_Z11ReceiveGAVRv+0x2c4>
    213c:	9e 01       	movw	r18, r28
    213e:	2f 5d       	subi	r18, 0xDF	; 223
    2140:	3f 4f       	sbci	r19, 0xFF	; 255
    2142:	8c 85       	ldd	r24, Y+12	; 0x0c
    2144:	9d 85       	ldd	r25, Y+13	; 0x0d
    2146:	82 0f       	add	r24, r18
    2148:	93 1f       	adc	r25, r19
    214a:	fc 01       	movw	r30, r24
    214c:	10 82       	st	Z, r1
    214e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2150:	9d 85       	ldd	r25, Y+13	; 0x0d
    2152:	01 96       	adiw	r24, 0x01	; 1
    2154:	9d 87       	std	Y+13, r25	; 0x0d
    2156:	8c 87       	std	Y+12, r24	; 0x0c
    2158:	41 e0       	ldi	r20, 0x01	; 1
    215a:	2c 85       	ldd	r18, Y+12	; 0x0c
    215c:	3d 85       	ldd	r19, Y+13	; 0x0d
    215e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2160:	9b 85       	ldd	r25, Y+11	; 0x0b
    2162:	82 17       	cp	r24, r18
    2164:	93 07       	cpc	r25, r19
    2166:	0c f4       	brge	.+2      	; 0x216a <_Z11ReceiveGAVRv+0x2d6>
    2168:	40 e0       	ldi	r20, 0x00	; 0
    216a:	44 23       	and	r20, r20
    216c:	39 f7       	brne	.-50     	; 0x213c <_Z11ReceiveGAVRv+0x2a8>
								placement=0;												//reset placement
    216e:	1b 86       	std	Y+11, r1	; 0x0b
    2170:	1a 86       	std	Y+10, r1	; 0x0a
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
    2172:	8c 81       	ldd	r24, Y+4	; 0x04
    2174:	9d 81       	ldd	r25, Y+5	; 0x05
    2176:	01 96       	adiw	r24, 0x01	; 1
    2178:	9d 83       	std	Y+5, r25	; 0x05
    217a:	8c 83       	std	Y+4, r24	; 0x04
						int counter=0;
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    217c:	9e 01       	movw	r18, r28
    217e:	2a 5d       	subi	r18, 0xDA	; 218
    2180:	3f 4f       	sbci	r19, 0xFF	; 255
    2182:	8c 81       	ldd	r24, Y+4	; 0x04
    2184:	9d 81       	ldd	r25, Y+5	; 0x05
    2186:	82 0f       	add	r24, r18
    2188:	93 1f       	adc	r25, r19
    218a:	fc 01       	movw	r30, r24
    218c:	80 81       	ld	r24, Z
    218e:	8f 32       	cpi	r24, 0x2F	; 47
    2190:	69 f0       	breq	.+26     	; 0x21ac <_Z11ReceiveGAVRv+0x318>
    2192:	9e 01       	movw	r18, r28
    2194:	2a 5d       	subi	r18, 0xDA	; 218
    2196:	3f 4f       	sbci	r19, 0xFF	; 255
    2198:	8c 81       	ldd	r24, Y+4	; 0x04
    219a:	9d 81       	ldd	r25, Y+5	; 0x05
    219c:	82 0f       	add	r24, r18
    219e:	93 1f       	adc	r25, r19
    21a0:	fc 01       	movw	r30, r24
    21a2:	80 81       	ld	r24, Z
    21a4:	88 23       	and	r24, r24
    21a6:	11 f0       	breq	.+4      	; 0x21ac <_Z11ReceiveGAVRv+0x318>
    21a8:	81 e0       	ldi	r24, 0x01	; 1
    21aa:	01 c0       	rjmp	.+2      	; 0x21ae <_Z11ReceiveGAVRv+0x31a>
    21ac:	80 e0       	ldi	r24, 0x00	; 0
    21ae:	88 23       	and	r24, r24
    21b0:	09 f0       	breq	.+2      	; 0x21b4 <_Z11ReceiveGAVRv+0x320>
    21b2:	71 cf       	rjmp	.-286    	; 0x2096 <_Z11ReceiveGAVRv+0x202>
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
						}//end while
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
    21b4:	9e 01       	movw	r18, r28
    21b6:	2a 5d       	subi	r18, 0xDA	; 218
    21b8:	3f 4f       	sbci	r19, 0xFF	; 255
    21ba:	8c 81       	ldd	r24, Y+4	; 0x04
    21bc:	9d 81       	ldd	r25, Y+5	; 0x05
    21be:	82 0f       	add	r24, r18
    21c0:	93 1f       	adc	r25, r19
    21c2:	fc 01       	movw	r30, r24
    21c4:	80 81       	ld	r24, Z
    21c6:	8f 32       	cpi	r24, 0x2F	; 47
    21c8:	a9 f4       	brne	.+42     	; 0x21f4 <_Z11ReceiveGAVRv+0x360>
							tempNum[hms] = atoi(tempStringNum);
    21ca:	ce 01       	movw	r24, r28
    21cc:	81 96       	adiw	r24, 0x21	; 33
    21ce:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
    21d2:	9c 01       	movw	r18, r24
    21d4:	88 85       	ldd	r24, Y+8	; 0x08
    21d6:	99 85       	ldd	r25, Y+9	; 0x09
    21d8:	88 0f       	add	r24, r24
    21da:	99 1f       	adc	r25, r25
    21dc:	ae 01       	movw	r20, r28
    21de:	4f 5f       	subi	r20, 0xFF	; 255
    21e0:	5f 4f       	sbci	r21, 0xFF	; 255
    21e2:	84 0f       	add	r24, r20
    21e4:	95 1f       	adc	r25, r21
    21e6:	44 96       	adiw	r24, 0x14	; 20
    21e8:	fc 01       	movw	r30, r24
    21ea:	31 83       	std	Z+1, r19	; 0x01
    21ec:	20 83       	st	Z, r18
							successTime=fTrue;
    21ee:	81 e0       	ldi	r24, 0x01	; 1
    21f0:	8a 83       	std	Y+2, r24	; 0x02
    21f2:	0a c0       	rjmp	.+20     	; 0x2208 <_Z11ReceiveGAVRv+0x374>
						} else {
							state=5;
    21f4:	85 e0       	ldi	r24, 0x05	; 5
    21f6:	90 e0       	ldi	r25, 0x00	; 0
    21f8:	90 93 e3 01 	sts	0x01E3, r25
    21fc:	80 93 e2 01 	sts	0x01E2, r24
							PrintGAVR("ACKBAD.");
    2200:	8d e0       	ldi	r24, 0x0D	; 13
    2202:	91 e0       	ldi	r25, 0x01	; 1
    2204:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    2208:	1f 86       	std	Y+15, r1	; 0x0f
    220a:	1e 86       	std	Y+14, r1	; 0x0e
    220c:	0e c0       	rjmp	.+28     	; 0x222a <_Z11ReceiveGAVRv+0x396>
    220e:	9e 01       	movw	r18, r28
    2210:	2f 5d       	subi	r18, 0xDF	; 223
    2212:	3f 4f       	sbci	r19, 0xFF	; 255
    2214:	8e 85       	ldd	r24, Y+14	; 0x0e
    2216:	9f 85       	ldd	r25, Y+15	; 0x0f
    2218:	82 0f       	add	r24, r18
    221a:	93 1f       	adc	r25, r19
    221c:	fc 01       	movw	r30, r24
    221e:	10 82       	st	Z, r1
    2220:	8e 85       	ldd	r24, Y+14	; 0x0e
    2222:	9f 85       	ldd	r25, Y+15	; 0x0f
    2224:	01 96       	adiw	r24, 0x01	; 1
    2226:	9f 87       	std	Y+15, r25	; 0x0f
    2228:	8e 87       	std	Y+14, r24	; 0x0e
    222a:	41 e0       	ldi	r20, 0x01	; 1
    222c:	2e 85       	ldd	r18, Y+14	; 0x0e
    222e:	3f 85       	ldd	r19, Y+15	; 0x0f
    2230:	8a 85       	ldd	r24, Y+10	; 0x0a
    2232:	9b 85       	ldd	r25, Y+11	; 0x0b
    2234:	82 17       	cp	r24, r18
    2236:	93 07       	cpc	r25, r19
    2238:	0c f4       	brge	.+2      	; 0x223c <_Z11ReceiveGAVRv+0x3a8>
    223a:	40 e0       	ldi	r20, 0x00	; 0
    223c:	44 23       	and	r20, r20
    223e:	39 f7       	brne	.-50     	; 0x220e <_Z11ReceiveGAVRv+0x37a>
						placement=0;
    2240:	1b 86       	std	Y+11, r1	; 0x0b
    2242:	1a 86       	std	Y+10, r1	; 0x0a
						counter++;	//get past the '/'
    2244:	8c 81       	ldd	r24, Y+4	; 0x04
    2246:	9d 81       	ldd	r25, Y+5	; 0x05
    2248:	01 96       	adiw	r24, 0x01	; 1
    224a:	9d 83       	std	Y+5, r25	; 0x05
    224c:	8c 83       	std	Y+4, r24	; 0x04
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    224e:	73 c0       	rjmp	.+230    	; 0x2336 <_Z11ReceiveGAVRv+0x4a2>
							//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
							if  (recString[counter] != ',' && dmy < 3){
    2250:	9e 01       	movw	r18, r28
    2252:	2a 5d       	subi	r18, 0xDA	; 218
    2254:	3f 4f       	sbci	r19, 0xFF	; 255
    2256:	8c 81       	ldd	r24, Y+4	; 0x04
    2258:	9d 81       	ldd	r25, Y+5	; 0x05
    225a:	82 0f       	add	r24, r18
    225c:	93 1f       	adc	r25, r19
    225e:	fc 01       	movw	r30, r24
    2260:	80 81       	ld	r24, Z
    2262:	8c 32       	cpi	r24, 0x2C	; 44
    2264:	e9 f0       	breq	.+58     	; 0x22a0 <_Z11ReceiveGAVRv+0x40c>
    2266:	8e 81       	ldd	r24, Y+6	; 0x06
    2268:	9f 81       	ldd	r25, Y+7	; 0x07
    226a:	83 30       	cpi	r24, 0x03	; 3
    226c:	91 05       	cpc	r25, r1
    226e:	c4 f4       	brge	.+48     	; 0x22a0 <_Z11ReceiveGAVRv+0x40c>
								tempStringNum[placement++]=recString[counter];
    2270:	9e 01       	movw	r18, r28
    2272:	2a 5d       	subi	r18, 0xDA	; 218
    2274:	3f 4f       	sbci	r19, 0xFF	; 255
    2276:	8c 81       	ldd	r24, Y+4	; 0x04
    2278:	9d 81       	ldd	r25, Y+5	; 0x05
    227a:	82 0f       	add	r24, r18
    227c:	93 1f       	adc	r25, r19
    227e:	fc 01       	movw	r30, r24
    2280:	40 81       	ld	r20, Z
    2282:	9e 01       	movw	r18, r28
    2284:	2f 5d       	subi	r18, 0xDF	; 223
    2286:	3f 4f       	sbci	r19, 0xFF	; 255
    2288:	8a 85       	ldd	r24, Y+10	; 0x0a
    228a:	9b 85       	ldd	r25, Y+11	; 0x0b
    228c:	82 0f       	add	r24, r18
    228e:	93 1f       	adc	r25, r19
    2290:	fc 01       	movw	r30, r24
    2292:	40 83       	st	Z, r20
    2294:	8a 85       	ldd	r24, Y+10	; 0x0a
    2296:	9b 85       	ldd	r25, Y+11	; 0x0b
    2298:	01 96       	adiw	r24, 0x01	; 1
    229a:	9b 87       	std	Y+11, r25	; 0x0b
    229c:	8a 87       	std	Y+10, r24	; 0x0a
    229e:	46 c0       	rjmp	.+140    	; 0x232c <_Z11ReceiveGAVRv+0x498>
							//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
							} else if (dmy<2 && recString[counter]==','){
    22a0:	8e 81       	ldd	r24, Y+6	; 0x06
    22a2:	9f 81       	ldd	r25, Y+7	; 0x07
    22a4:	82 30       	cpi	r24, 0x02	; 2
    22a6:	91 05       	cpc	r25, r1
    22a8:	0c f0       	brlt	.+2      	; 0x22ac <_Z11ReceiveGAVRv+0x418>
    22aa:	40 c0       	rjmp	.+128    	; 0x232c <_Z11ReceiveGAVRv+0x498>
    22ac:	9e 01       	movw	r18, r28
    22ae:	2a 5d       	subi	r18, 0xDA	; 218
    22b0:	3f 4f       	sbci	r19, 0xFF	; 255
    22b2:	8c 81       	ldd	r24, Y+4	; 0x04
    22b4:	9d 81       	ldd	r25, Y+5	; 0x05
    22b6:	82 0f       	add	r24, r18
    22b8:	93 1f       	adc	r25, r19
    22ba:	fc 01       	movw	r30, r24
    22bc:	80 81       	ld	r24, Z
    22be:	8c 32       	cpi	r24, 0x2C	; 44
    22c0:	a9 f5       	brne	.+106    	; 0x232c <_Z11ReceiveGAVRv+0x498>
								tempNum1[dmy++] = atoi(tempStringNum);
    22c2:	ce 01       	movw	r24, r28
    22c4:	81 96       	adiw	r24, 0x21	; 33
    22c6:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
    22ca:	9c 01       	movw	r18, r24
    22cc:	8e 81       	ldd	r24, Y+6	; 0x06
    22ce:	9f 81       	ldd	r25, Y+7	; 0x07
    22d0:	88 0f       	add	r24, r24
    22d2:	99 1f       	adc	r25, r25
    22d4:	ae 01       	movw	r20, r28
    22d6:	4f 5f       	subi	r20, 0xFF	; 255
    22d8:	5f 4f       	sbci	r21, 0xFF	; 255
    22da:	84 0f       	add	r24, r20
    22dc:	95 1f       	adc	r25, r21
    22de:	4a 96       	adiw	r24, 0x1a	; 26
    22e0:	fc 01       	movw	r30, r24
    22e2:	31 83       	std	Z+1, r19	; 0x01
    22e4:	20 83       	st	Z, r18
    22e6:	8e 81       	ldd	r24, Y+6	; 0x06
    22e8:	9f 81       	ldd	r25, Y+7	; 0x07
    22ea:	01 96       	adiw	r24, 0x01	; 1
    22ec:	9f 83       	std	Y+7, r25	; 0x07
    22ee:	8e 83       	std	Y+6, r24	; 0x06
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    22f0:	19 8a       	std	Y+17, r1	; 0x11
    22f2:	18 8a       	std	Y+16, r1	; 0x10
    22f4:	0e c0       	rjmp	.+28     	; 0x2312 <_Z11ReceiveGAVRv+0x47e>
    22f6:	9e 01       	movw	r18, r28
    22f8:	2f 5d       	subi	r18, 0xDF	; 223
    22fa:	3f 4f       	sbci	r19, 0xFF	; 255
    22fc:	88 89       	ldd	r24, Y+16	; 0x10
    22fe:	99 89       	ldd	r25, Y+17	; 0x11
    2300:	82 0f       	add	r24, r18
    2302:	93 1f       	adc	r25, r19
    2304:	fc 01       	movw	r30, r24
    2306:	10 82       	st	Z, r1
    2308:	88 89       	ldd	r24, Y+16	; 0x10
    230a:	99 89       	ldd	r25, Y+17	; 0x11
    230c:	01 96       	adiw	r24, 0x01	; 1
    230e:	99 8b       	std	Y+17, r25	; 0x11
    2310:	88 8b       	std	Y+16, r24	; 0x10
    2312:	41 e0       	ldi	r20, 0x01	; 1
    2314:	28 89       	ldd	r18, Y+16	; 0x10
    2316:	39 89       	ldd	r19, Y+17	; 0x11
    2318:	8a 85       	ldd	r24, Y+10	; 0x0a
    231a:	9b 85       	ldd	r25, Y+11	; 0x0b
    231c:	82 17       	cp	r24, r18
    231e:	93 07       	cpc	r25, r19
    2320:	0c f4       	brge	.+2      	; 0x2324 <_Z11ReceiveGAVRv+0x490>
    2322:	40 e0       	ldi	r20, 0x00	; 0
    2324:	44 23       	and	r20, r20
    2326:	39 f7       	brne	.-50     	; 0x22f6 <_Z11ReceiveGAVRv+0x462>
								placement=0;
    2328:	1b 86       	std	Y+11, r1	; 0x0b
    232a:	1a 86       	std	Y+10, r1	; 0x0a
							} else;
							counter++;							
    232c:	8c 81       	ldd	r24, Y+4	; 0x04
    232e:	9d 81       	ldd	r25, Y+5	; 0x05
    2330:	01 96       	adiw	r24, 0x01	; 1
    2332:	9d 83       	std	Y+5, r25	; 0x05
    2334:	8c 83       	std	Y+4, r24	; 0x04
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
						placement=0;
						counter++;	//get past the '/'
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    2336:	9e 01       	movw	r18, r28
    2338:	2a 5d       	subi	r18, 0xDA	; 218
    233a:	3f 4f       	sbci	r19, 0xFF	; 255
    233c:	8c 81       	ldd	r24, Y+4	; 0x04
    233e:	9d 81       	ldd	r25, Y+5	; 0x05
    2340:	82 0f       	add	r24, r18
    2342:	93 1f       	adc	r25, r19
    2344:	fc 01       	movw	r30, r24
    2346:	80 81       	ld	r24, Z
    2348:	8e 32       	cpi	r24, 0x2E	; 46
    234a:	a1 f0       	breq	.+40     	; 0x2374 <_Z11ReceiveGAVRv+0x4e0>
    234c:	9e 01       	movw	r18, r28
    234e:	2a 5d       	subi	r18, 0xDA	; 218
    2350:	3f 4f       	sbci	r19, 0xFF	; 255
    2352:	8c 81       	ldd	r24, Y+4	; 0x04
    2354:	9d 81       	ldd	r25, Y+5	; 0x05
    2356:	82 0f       	add	r24, r18
    2358:	93 1f       	adc	r25, r19
    235a:	fc 01       	movw	r30, r24
    235c:	80 81       	ld	r24, Z
    235e:	88 23       	and	r24, r24
    2360:	49 f0       	breq	.+18     	; 0x2374 <_Z11ReceiveGAVRv+0x4e0>
    2362:	2c 81       	ldd	r18, Y+4	; 0x04
    2364:	3d 81       	ldd	r19, Y+5	; 0x05
    2366:	8b 89       	ldd	r24, Y+19	; 0x13
    2368:	9c 89       	ldd	r25, Y+20	; 0x14
    236a:	28 17       	cp	r18, r24
    236c:	39 07       	cpc	r19, r25
    236e:	11 f0       	breq	.+4      	; 0x2374 <_Z11ReceiveGAVRv+0x4e0>
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	01 c0       	rjmp	.+2      	; 0x2376 <_Z11ReceiveGAVRv+0x4e2>
    2374:	80 e0       	ldi	r24, 0x00	; 0
    2376:	88 23       	and	r24, r24
    2378:	09 f0       	breq	.+2      	; 0x237c <_Z11ReceiveGAVRv+0x4e8>
    237a:	6a cf       	rjmp	.-300    	; 0x2250 <_Z11ReceiveGAVRv+0x3bc>
								placement=0;
							} else;
							counter++;							
						}//end while
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
    237c:	9e 01       	movw	r18, r28
    237e:	2a 5d       	subi	r18, 0xDA	; 218
    2380:	3f 4f       	sbci	r19, 0xFF	; 255
    2382:	8c 81       	ldd	r24, Y+4	; 0x04
    2384:	9d 81       	ldd	r25, Y+5	; 0x05
    2386:	82 0f       	add	r24, r18
    2388:	93 1f       	adc	r25, r19
    238a:	fc 01       	movw	r30, r24
    238c:	80 81       	ld	r24, Z
    238e:	8e 32       	cpi	r24, 0x2E	; 46
    2390:	a9 f4       	brne	.+42     	; 0x23bc <_Z11ReceiveGAVRv+0x528>
							tempNum1[dmy] = atoi(tempStringNum);
    2392:	ce 01       	movw	r24, r28
    2394:	81 96       	adiw	r24, 0x21	; 33
    2396:	0e 94 90 1b 	call	0x3720	; 0x3720 <atoi>
    239a:	9c 01       	movw	r18, r24
    239c:	8e 81       	ldd	r24, Y+6	; 0x06
    239e:	9f 81       	ldd	r25, Y+7	; 0x07
    23a0:	88 0f       	add	r24, r24
    23a2:	99 1f       	adc	r25, r25
    23a4:	ae 01       	movw	r20, r28
    23a6:	4f 5f       	subi	r20, 0xFF	; 255
    23a8:	5f 4f       	sbci	r21, 0xFF	; 255
    23aa:	84 0f       	add	r24, r20
    23ac:	95 1f       	adc	r25, r21
    23ae:	4a 96       	adiw	r24, 0x1a	; 26
    23b0:	fc 01       	movw	r30, r24
    23b2:	31 83       	std	Z+1, r19	; 0x01
    23b4:	20 83       	st	Z, r18
							successDate=fTrue;
    23b6:	81 e0       	ldi	r24, 0x01	; 1
    23b8:	8b 83       	std	Y+3, r24	; 0x03
    23ba:	0a c0       	rjmp	.+20     	; 0x23d0 <_Z11ReceiveGAVRv+0x53c>
						} else {//something in the string was wrong, ACKBAD and then exit
							PrintGAVR("ACKBAD.");
    23bc:	8d e0       	ldi	r24, 0x0D	; 13
    23be:	91 e0       	ldi	r25, 0x01	; 1
    23c0:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
							state=5;
    23c4:	85 e0       	ldi	r24, 0x05	; 5
    23c6:	90 e0       	ldi	r25, 0x00	; 0
    23c8:	90 93 e3 01 	sts	0x01E3, r25
    23cc:	80 93 e2 01 	sts	0x01E2, r24
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0 && successTime){
    23d0:	8d 89       	ldd	r24, Y+21	; 0x15
    23d2:	9e 89       	ldd	r25, Y+22	; 0x16
    23d4:	47 96       	adiw	r24, 0x17	; 23
    23d6:	8f 32       	cpi	r24, 0x2F	; 47
    23d8:	91 05       	cpc	r25, r1
    23da:	f0 f4       	brcc	.+60     	; 0x2418 <_Z11ReceiveGAVRv+0x584>
    23dc:	8f 89       	ldd	r24, Y+23	; 0x17
    23de:	98 8d       	ldd	r25, Y+24	; 0x18
    23e0:	cb 96       	adiw	r24, 0x3b	; 59
    23e2:	87 37       	cpi	r24, 0x77	; 119
    23e4:	91 05       	cpc	r25, r1
    23e6:	c0 f4       	brcc	.+48     	; 0x2418 <_Z11ReceiveGAVRv+0x584>
    23e8:	89 8d       	ldd	r24, Y+25	; 0x19
    23ea:	9a 8d       	ldd	r25, Y+26	; 0x1a
    23ec:	cb 96       	adiw	r24, 0x3b	; 59
    23ee:	87 37       	cpi	r24, 0x77	; 119
    23f0:	91 05       	cpc	r25, r1
    23f2:	90 f4       	brcc	.+36     	; 0x2418 <_Z11ReceiveGAVRv+0x584>
    23f4:	8a 81       	ldd	r24, Y+2	; 0x02
    23f6:	88 23       	and	r24, r24
    23f8:	79 f0       	breq	.+30     	; 0x2418 <_Z11ReceiveGAVRv+0x584>
							currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    23fa:	6d 89       	ldd	r22, Y+21	; 0x15
    23fc:	7e 89       	ldd	r23, Y+22	; 0x16
    23fe:	4f 89       	ldd	r20, Y+23	; 0x17
    2400:	58 8d       	ldd	r21, Y+24	; 0x18
    2402:	29 8d       	ldd	r18, Y+25	; 0x19
    2404:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2406:	82 ea       	ldi	r24, 0xA2	; 162
    2408:	91 e0       	ldi	r25, 0x01	; 1
    240a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
							saveDateTime_eeprom(fTrue,fFalse);
    240e:	81 e0       	ldi	r24, 0x01	; 1
    2410:	60 e0       	ldi	r22, 0x00	; 0
    2412:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    2416:	0a c0       	rjmp	.+20     	; 0x242c <_Z11ReceiveGAVRv+0x598>
						} else {
							PrintGAVR("ACKBAD.");
    2418:	8d e0       	ldi	r24, 0x0D	; 13
    241a:	91 e0       	ldi	r25, 0x01	; 1
    241c:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
							state=5;
    2420:	85 e0       	ldi	r24, 0x05	; 5
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	90 93 e3 01 	sts	0x01E3, r25
    2428:	80 93 e2 01 	sts	0x01E2, r24
						}//end if-else time
						
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && successDate){
    242c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    242e:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2430:	0c 96       	adiw	r24, 0x0c	; 12
    2432:	89 31       	cpi	r24, 0x19	; 25
    2434:	91 05       	cpc	r25, r1
    2436:	10 f5       	brcc	.+68     	; 0x247c <_Z11ReceiveGAVRv+0x5e8>
    2438:	8d 8d       	ldd	r24, Y+29	; 0x1d
    243a:	9e 8d       	ldd	r25, Y+30	; 0x1e
    243c:	4f 96       	adiw	r24, 0x1f	; 31
    243e:	8f 33       	cpi	r24, 0x3F	; 63
    2440:	91 05       	cpc	r25, r1
    2442:	e0 f4       	brcc	.+56     	; 0x247c <_Z11ReceiveGAVRv+0x5e8>
    2444:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2446:	98 a1       	lds	r25, 0x48
    2448:	f7 e0       	ldi	r31, 0x07	; 7
    244a:	80 3d       	cpi	r24, 0xD0	; 208
    244c:	9f 07       	cpc	r25, r31
    244e:	b4 f0       	brlt	.+44     	; 0x247c <_Z11ReceiveGAVRv+0x5e8>
    2450:	8b 81       	ldd	r24, Y+3	; 0x03
    2452:	88 23       	and	r24, r24
    2454:	99 f0       	breq	.+38     	; 0x247c <_Z11ReceiveGAVRv+0x5e8>
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
    2456:	6b 8d       	ldd	r22, Y+27	; 0x1b
    2458:	7c 8d       	ldd	r23, Y+28	; 0x1c
    245a:	4d 8d       	ldd	r20, Y+29	; 0x1d
    245c:	5e 8d       	ldd	r21, Y+30	; 0x1e
    245e:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2460:	38 a1       	lds	r19, 0x48
    2462:	82 ea       	ldi	r24, 0xA2	; 162
    2464:	91 e0       	ldi	r25, 0x01	; 1
    2466:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
							saveDateTime_eeprom(fFalse,fTrue);
    246a:	80 e0       	ldi	r24, 0x00	; 0
    246c:	61 e0       	ldi	r22, 0x01	; 1
    246e:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
							state=5;
							break;
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    2472:	80 91 d0 01 	lds	r24, 0x01D0
    2476:	88 23       	and	r24, r24
    2478:	61 f4       	brne	.+24     	; 0x2492 <_Z11ReceiveGAVRv+0x5fe>
    247a:	1c c0       	rjmp	.+56     	; 0x24b4 <_Z11ReceiveGAVRv+0x620>
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && successDate){
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
							saveDateTime_eeprom(fFalse,fTrue);
						} else {
							PrintGAVR("ACKBAD.");
    247c:	8d e0       	ldi	r24, 0x0D	; 13
    247e:	91 e0       	ldi	r25, 0x01	; 1
    2480:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
							state=5;
    2484:	85 e0       	ldi	r24, 0x05	; 5
    2486:	90 e0       	ldi	r25, 0x00	; 0
    2488:	90 93 e3 01 	sts	0x01E3, r25
    248c:	80 93 e2 01 	sts	0x01E2, r24
							break;
    2490:	6a c0       	rjmp	.+212    	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    2492:	8b 81       	ldd	r24, Y+3	; 0x03
    2494:	88 23       	and	r24, r24
    2496:	71 f0       	breq	.+28     	; 0x24b4 <_Z11ReceiveGAVRv+0x620>
    2498:	8a 81       	ldd	r24, Y+2	; 0x02
    249a:	88 23       	and	r24, r24
    249c:	59 f0       	breq	.+22     	; 0x24b4 <_Z11ReceiveGAVRv+0x620>
							flagUserClock=fFalse;
    249e:	10 92 d0 01 	sts	0x01D0, r1
							flagWaitingForReceiveGAVR=fFalse;
    24a2:	10 92 cd 01 	sts	0x01CD, r1
							state=7;					//Respond with correct string ACK
    24a6:	87 e0       	ldi	r24, 0x07	; 7
    24a8:	90 e0       	ldi	r25, 0x00	; 0
    24aa:	90 93 e3 01 	sts	0x01E3, r25
    24ae:	80 93 e2 01 	sts	0x01E2, r24
						PrintGAVR("ACKNO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    24b2:	59 c0       	rjmp	.+178    	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
						if (flagUserClock && successDate && successTime){
							flagUserClock=fFalse;
							flagWaitingForReceiveGAVR=fFalse;
							state=7;					//Respond with correct string ACK
						} else {
							PrintGAVR("ACKBAD.");
    24b4:	8d e0       	ldi	r24, 0x0D	; 13
    24b6:	91 e0       	ldi	r25, 0x01	; 1
    24b8:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
							state=5;
    24bc:	85 e0       	ldi	r24, 0x05	; 5
    24be:	90 e0       	ldi	r25, 0x00	; 0
    24c0:	90 93 e3 01 	sts	0x01E3, r25
    24c4:	80 93 e2 01 	sts	0x01E2, r24
						PrintGAVR("ACKNO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    24c8:	4e c0       	rjmp	.+156    	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
						} else {
							PrintGAVR("ACKBAD.");
							state=5;
						}																										
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("ACKNO.");
    24ca:	81 e7       	ldi	r24, 0x71	; 113
    24cc:	91 e0       	ldi	r25, 0x01	; 1
    24ce:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
						state=5;
    24d2:	85 e0       	ldi	r24, 0x05	; 5
    24d4:	90 e0       	ldi	r25, 0x00	; 0
    24d6:	90 93 e3 01 	sts	0x01E3, r25
    24da:	80 93 e2 01 	sts	0x01E2, r24
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    24de:	43 c0       	rjmp	.+134    	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
					}//end case 3				
				case 4:{
					//Successful SYNNEED case.
					if (!flagUserClock){	//If we don't need the date or time, update with what we have.
    24e0:	80 91 d0 01 	lds	r24, 0x01D0
    24e4:	88 23       	and	r24, r24
    24e6:	41 f4       	brne	.+16     	; 0x24f8 <_Z11ReceiveGAVRv+0x664>
						flagUpdateGAVRClock=fTrue;
    24e8:	81 e0       	ldi	r24, 0x01	; 1
    24ea:	80 93 ce 01 	sts	0x01CE, r24
						PrintGAVR("ACKNEED.");				//respond with correct ack
    24ee:	88 e7       	ldi	r24, 0x78	; 120
    24f0:	91 e0       	ldi	r25, 0x01	; 1
    24f2:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
    24f6:	04 c0       	rjmp	.+8      	; 0x2500 <_Z11ReceiveGAVRv+0x66c>
					} else {
						PrintGAVR("ACKNO.");	//say we can't give you anything, ask the user.
    24f8:	81 e7       	ldi	r24, 0x71	; 113
    24fa:	91 e0       	ldi	r25, 0x01	; 1
    24fc:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
						//Should be expecting something from the GAVR with user date and time, this reminds the GAVR.
					} //end if-else
					state=5;
    2500:	85 e0       	ldi	r24, 0x05	; 5
    2502:	90 e0       	ldi	r25, 0x00	; 0
    2504:	90 93 e3 01 	sts	0x01E3, r25
    2508:	80 93 e2 01 	sts	0x01E2, r24
					break;					
    250c:	2c c0       	rjmp	.+88     	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 4
				case 5:{
					//Exit case
					flagReceivingGAVR=fFalse;
    250e:	10 92 cc 01 	sts	0x01CC, r1
					state=0;		//just in case
    2512:	10 92 e3 01 	sts	0x01E3, r1
    2516:	10 92 e2 01 	sts	0x01E2, r1
					break;
    251a:	25 c0       	rjmp	.+74     	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 5
				case 6:{
					//Error in ACK case
					PrintGAVR("ACKERROR.");
    251c:	8e e5       	ldi	r24, 0x5E	; 94
    251e:	91 e0       	ldi	r25, 0x01	; 1
    2520:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
					state=5;
    2524:	85 e0       	ldi	r24, 0x05	; 5
    2526:	90 e0       	ldi	r25, 0x00	; 0
    2528:	90 93 e3 01 	sts	0x01E3, r25
    252c:	80 93 e2 01 	sts	0x01E2, r24
					break;
    2530:	1a c0       	rjmp	.+52     	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 6
				case 7:{
					//Successful grab of date/time case
					recString[0]='A';
    2532:	81 e4       	ldi	r24, 0x41	; 65
    2534:	8e a3       	lds	r24, 0x5e
					recString[1]='C';
    2536:	83 e4       	ldi	r24, 0x43	; 67
    2538:	8f a3       	lds	r24, 0x5f
					recString[2]='K';
    253a:	8b e4       	ldi	r24, 0x4B	; 75
    253c:	88 a7       	lds	r24, 0x78
					PrintGAVR(recString);
    253e:	ce 01       	movw	r24, r28
    2540:	86 96       	adiw	r24, 0x26	; 38
    2542:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
					state=5;
    2546:	85 e0       	ldi	r24, 0x05	; 5
    2548:	90 e0       	ldi	r25, 0x00	; 0
    254a:	90 93 e3 01 	sts	0x01E3, r25
    254e:	80 93 e2 01 	sts	0x01E2, r24
					break;		
    2552:	09 c0       	rjmp	.+18     	; 0x2566 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
    2554:	10 92 e3 01 	sts	0x01E3, r1
    2558:	10 92 e2 01 	sts	0x01E2, r1
    255c:	1c 8a       	std	Y+20, r1	; 0x14
    255e:	1b 8a       	std	Y+19, r1	; 0x13
    2560:	10 92 cc 01 	sts	0x01CC, r1
    2564:	00 00       	nop
	char recChar, recString[40];
	volatile unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	//While Loop
	while (flagReceivingGAVR){
    2566:	90 91 cc 01 	lds	r25, 0x01CC
    256a:	81 e0       	ldi	r24, 0x01	; 1
    256c:	99 23       	and	r25, r25
    256e:	09 f4       	brne	.+2      	; 0x2572 <_Z11ReceiveGAVRv+0x6de>
    2570:	80 e0       	ldi	r24, 0x00	; 0
    2572:	88 23       	and	r24, r24
    2574:	09 f0       	breq	.+2      	; 0x2578 <_Z11ReceiveGAVRv+0x6e4>
    2576:	9e cc       	rjmp	.-1732   	; 0x1eb4 <_Z11ReceiveGAVRv+0x20>
					break;		
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
			}//end switch	
		}//end while flagReceivingGAVR	
}
    2578:	c3 5b       	subi	r28, 0xB3	; 179
    257a:	df 4f       	sbci	r29, 0xFF	; 255
    257c:	0f b6       	in	r0, 0x3f	; 63
    257e:	f8 94       	cli
    2580:	de bf       	out	0x3e, r29	; 62
    2582:	0f be       	out	0x3f, r0	; 63
    2584:	cd bf       	out	0x3d, r28	; 61
    2586:	df 91       	pop	r29
    2588:	cf 91       	pop	r28
    258a:	08 95       	ret

0000258c <_Z13printTimeDatehhh>:
/*************************************************************************************************************/
//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    258c:	cf 93       	push	r28
    258e:	df 93       	push	r29
    2590:	cd b7       	in	r28, 0x3d	; 61
    2592:	de b7       	in	r29, 0x3e	; 62
    2594:	eb 97       	sbiw	r28, 0x3b	; 59
    2596:	0f b6       	in	r0, 0x3f	; 63
    2598:	f8 94       	cli
    259a:	de bf       	out	0x3e, r29	; 62
    259c:	0f be       	out	0x3f, r0	; 63
    259e:	cd bf       	out	0x3d, r28	; 61
    25a0:	89 af       	sts	0x79, r24
    25a2:	6a af       	sts	0x7a, r22
    25a4:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    25a6:	89 ad       	sts	0x69, r24
    25a8:	88 23       	and	r24, r24
    25aa:	49 f1       	breq	.+82     	; 0x25fe <_Z13printTimeDatehhh+0x72>
		if (pTime){
    25ac:	8a ad       	sts	0x6a, r24
    25ae:	88 23       	and	r24, r24
    25b0:	89 f0       	breq	.+34     	; 0x25d4 <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    25b2:	82 ea       	ldi	r24, 0xA2	; 162
    25b4:	91 e0       	ldi	r25, 0x01	; 1
    25b6:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    25ba:	9c 01       	movw	r18, r24
    25bc:	ce 01       	movw	r24, r28
    25be:	01 96       	adiw	r24, 0x01	; 1
    25c0:	b9 01       	movw	r22, r18
    25c2:	0e 94 c2 1b 	call	0x3784	; 0x3784 <strcpy>
			PrintBone(tempTime);
    25c6:	ce 01       	movw	r24, r28
    25c8:	01 96       	adiw	r24, 0x01	; 1
    25ca:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
			PutUartChBone('/');
    25ce:	8f e2       	ldi	r24, 0x2F	; 47
    25d0:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z13PutUartChBonec>
		}
		if (pDate){
    25d4:	8b ad       	sts	0x6b, r24
    25d6:	88 23       	and	r24, r24
    25d8:	d1 f1       	breq	.+116    	; 0x264e <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    25da:	82 ea       	ldi	r24, 0xA2	; 162
    25dc:	91 e0       	ldi	r25, 0x01	; 1
    25de:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    25e2:	9c 01       	movw	r18, r24
    25e4:	ce 01       	movw	r24, r28
    25e6:	0c 96       	adiw	r24, 0x0c	; 12
    25e8:	b9 01       	movw	r22, r18
    25ea:	0e 94 c2 1b 	call	0x3784	; 0x3784 <strcpy>
			PrintBone(tempDate);
    25ee:	ce 01       	movw	r24, r28
    25f0:	0c 96       	adiw	r24, 0x0c	; 12
    25f2:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
			PutUartChGAVR('.');
    25f6:	8e e2       	ldi	r24, 0x2E	; 46
    25f8:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_Z13PutUartChGAVRc>
    25fc:	28 c0       	rjmp	.+80     	; 0x264e <_Z13printTimeDatehhh+0xc2>
		}
	} else { //Printing to GAVR
		if (pTime){
    25fe:	8a ad       	sts	0x6a, r24
    2600:	88 23       	and	r24, r24
    2602:	89 f0       	breq	.+34     	; 0x2626 <_Z13printTimeDatehhh+0x9a>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    2604:	82 ea       	ldi	r24, 0xA2	; 162
    2606:	91 e0       	ldi	r25, 0x01	; 1
    2608:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    260c:	9c 01       	movw	r18, r24
    260e:	ce 01       	movw	r24, r28
    2610:	4d 96       	adiw	r24, 0x1d	; 29
    2612:	b9 01       	movw	r22, r18
    2614:	0e 94 c2 1b 	call	0x3784	; 0x3784 <strcpy>
			PrintGAVR(tempTime);
    2618:	ce 01       	movw	r24, r28
    261a:	4d 96       	adiw	r24, 0x1d	; 29
    261c:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    2620:	8f e2       	ldi	r24, 0x2F	; 47
    2622:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_Z13PutUartChGAVRc>
		}
		if (pDate){
    2626:	8b ad       	sts	0x6b, r24
    2628:	88 23       	and	r24, r24
    262a:	89 f0       	breq	.+34     	; 0x264e <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    262c:	82 ea       	ldi	r24, 0xA2	; 162
    262e:	91 e0       	ldi	r25, 0x01	; 1
    2630:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    2634:	9c 01       	movw	r18, r24
    2636:	ce 01       	movw	r24, r28
    2638:	88 96       	adiw	r24, 0x28	; 40
    263a:	b9 01       	movw	r22, r18
    263c:	0e 94 c2 1b 	call	0x3784	; 0x3784 <strcpy>
			PrintGAVR(tempDate);
    2640:	ce 01       	movw	r24, r28
    2642:	88 96       	adiw	r24, 0x28	; 40
    2644:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
			PutUartChGAVR('.');
    2648:	8e e2       	ldi	r24, 0x2E	; 46
    264a:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_Z13PutUartChGAVRc>
		}
	}
}
    264e:	eb 96       	adiw	r28, 0x3b	; 59
    2650:	0f b6       	in	r0, 0x3f	; 63
    2652:	f8 94       	cli
    2654:	de bf       	out	0x3e, r29	; 62
    2656:	0f be       	out	0x3f, r0	; 63
    2658:	cd bf       	out	0x3d, r28	; 61
    265a:	df 91       	pop	r29
    265c:	cf 91       	pop	r28
    265e:	08 95       	ret

00002660 <__vector_6>:
/****************************************************************************************************************/


/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
//PCINT_17: Getting information from the GAVR
ISR(PCINT2_vect){
    2660:	1f 92       	push	r1
    2662:	0f 92       	push	r0
    2664:	0f b6       	in	r0, 0x3f	; 63
    2666:	0f 92       	push	r0
    2668:	11 24       	eor	r1, r1
    266a:	2f 93       	push	r18
    266c:	3f 93       	push	r19
    266e:	4f 93       	push	r20
    2670:	5f 93       	push	r21
    2672:	6f 93       	push	r22
    2674:	7f 93       	push	r23
    2676:	8f 93       	push	r24
    2678:	9f 93       	push	r25
    267a:	af 93       	push	r26
    267c:	bf 93       	push	r27
    267e:	ef 93       	push	r30
    2680:	ff 93       	push	r31
    2682:	cf 93       	push	r28
    2684:	df 93       	push	r29
    2686:	cd b7       	in	r28, 0x3d	; 61
    2688:	de b7       	in	r29, 0x3e	; 62
	cli();
    268a:	f8 94       	cli
	if ((PINC & (1 << PCINT17)) && !flagShutdown){
    268c:	86 e2       	ldi	r24, 0x26	; 38
    268e:	90 e0       	ldi	r25, 0x00	; 0
    2690:	fc 01       	movw	r30, r24
    2692:	80 81       	ld	r24, Z
    2694:	88 2f       	mov	r24, r24
    2696:	90 e0       	ldi	r25, 0x00	; 0
    2698:	82 70       	andi	r24, 0x02	; 2
    269a:	90 70       	andi	r25, 0x00	; 0
    269c:	00 97       	sbiw	r24, 0x00	; 0
    269e:	31 f0       	breq	.+12     	; 0x26ac <__vector_6+0x4c>
    26a0:	80 91 d5 01 	lds	r24, 0x01D5
    26a4:	88 23       	and	r24, r24
    26a6:	11 f4       	brne	.+4      	; 0x26ac <__vector_6+0x4c>
    26a8:	81 e0       	ldi	r24, 0x01	; 1
    26aa:	01 c0       	rjmp	.+2      	; 0x26ae <__vector_6+0x4e>
    26ac:	80 e0       	ldi	r24, 0x00	; 0
    26ae:	88 23       	and	r24, r24
    26b0:	c9 f0       	breq	.+50     	; 0x26e4 <__vector_6+0x84>
		//Do work, correct interrupt
		UCSR1B |= (1 << RXCIE1);
    26b2:	89 ec       	ldi	r24, 0xC9	; 201
    26b4:	90 e0       	ldi	r25, 0x00	; 0
    26b6:	29 ec       	ldi	r18, 0xC9	; 201
    26b8:	30 e0       	ldi	r19, 0x00	; 0
    26ba:	f9 01       	movw	r30, r18
    26bc:	20 81       	ld	r18, Z
    26be:	20 68       	ori	r18, 0x80	; 128
    26c0:	fc 01       	movw	r30, r24
    26c2:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;
    26c4:	10 92 81 01 	sts	0x0181, r1
		flagNormalMode=fFalse;
    26c8:	10 92 cb 01 	sts	0x01CB, r1
		__killCommINT();
    26cc:	8d e3       	ldi	r24, 0x3D	; 61
    26ce:	90 e0       	ldi	r25, 0x00	; 0
    26d0:	fc 01       	movw	r30, r24
    26d2:	10 82       	st	Z, r1
    26d4:	8d e6       	ldi	r24, 0x6D	; 109
    26d6:	90 e0       	ldi	r25, 0x00	; 0
    26d8:	fc 01       	movw	r30, r24
    26da:	10 82       	st	Z, r1
		//Acknowledge
		PrintGAVR("ACKG");
    26dc:	82 e8       	ldi	r24, 0x82	; 130
    26de:	91 e0       	ldi	r25, 0x01	; 1
    26e0:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
	}
	sei();
    26e4:	78 94       	sei
}	
    26e6:	df 91       	pop	r29
    26e8:	cf 91       	pop	r28
    26ea:	ff 91       	pop	r31
    26ec:	ef 91       	pop	r30
    26ee:	bf 91       	pop	r27
    26f0:	af 91       	pop	r26
    26f2:	9f 91       	pop	r25
    26f4:	8f 91       	pop	r24
    26f6:	7f 91       	pop	r23
    26f8:	6f 91       	pop	r22
    26fa:	5f 91       	pop	r21
    26fc:	4f 91       	pop	r20
    26fe:	3f 91       	pop	r19
    2700:	2f 91       	pop	r18
    2702:	0f 90       	pop	r0
    2704:	0f be       	out	0x3f, r0	; 63
    2706:	0f 90       	pop	r0
    2708:	1f 90       	pop	r1
    270a:	18 95       	reti

0000270c <__vector_3>:

//INT2: Getting information from BeagleBone
ISR(INT2_vect){	//about to get time, get things ready
    270c:	1f 92       	push	r1
    270e:	0f 92       	push	r0
    2710:	0f b6       	in	r0, 0x3f	; 63
    2712:	0f 92       	push	r0
    2714:	11 24       	eor	r1, r1
    2716:	2f 93       	push	r18
    2718:	3f 93       	push	r19
    271a:	4f 93       	push	r20
    271c:	5f 93       	push	r21
    271e:	6f 93       	push	r22
    2720:	7f 93       	push	r23
    2722:	8f 93       	push	r24
    2724:	9f 93       	push	r25
    2726:	af 93       	push	r26
    2728:	bf 93       	push	r27
    272a:	ef 93       	push	r30
    272c:	ff 93       	push	r31
    272e:	cf 93       	push	r28
    2730:	df 93       	push	r29
    2732:	cd b7       	in	r28, 0x3d	; 61
    2734:	de b7       	in	r29, 0x3e	; 62
	cli();
    2736:	f8 94       	cli
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    2738:	80 91 d5 01 	lds	r24, 0x01D5
    273c:	88 23       	and	r24, r24
    273e:	c9 f4       	brne	.+50     	; 0x2772 <__vector_3+0x66>
		UCSR0B |= (1 << RXCIE0);
    2740:	81 ec       	ldi	r24, 0xC1	; 193
    2742:	90 e0       	ldi	r25, 0x00	; 0
    2744:	21 ec       	ldi	r18, 0xC1	; 193
    2746:	30 e0       	ldi	r19, 0x00	; 0
    2748:	f9 01       	movw	r30, r18
    274a:	20 81       	ld	r18, Z
    274c:	20 68       	ori	r18, 0x80	; 128
    274e:	fc 01       	movw	r30, r24
    2750:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    2752:	10 92 81 01 	sts	0x0181, r1
		flagNormalMode=fFalse;
    2756:	10 92 cb 01 	sts	0x01CB, r1
		__killCommINT();
    275a:	8d e3       	ldi	r24, 0x3D	; 61
    275c:	90 e0       	ldi	r25, 0x00	; 0
    275e:	fc 01       	movw	r30, r24
    2760:	10 82       	st	Z, r1
    2762:	8d e6       	ldi	r24, 0x6D	; 109
    2764:	90 e0       	ldi	r25, 0x00	; 0
    2766:	fc 01       	movw	r30, r24
    2768:	10 82       	st	Z, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("ACKT");
    276a:	87 e8       	ldi	r24, 0x87	; 135
    276c:	91 e0       	ldi	r25, 0x01	; 1
    276e:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
	}
	sei();
    2772:	78 94       	sei
}
    2774:	df 91       	pop	r29
    2776:	cf 91       	pop	r28
    2778:	ff 91       	pop	r31
    277a:	ef 91       	pop	r30
    277c:	bf 91       	pop	r27
    277e:	af 91       	pop	r26
    2780:	9f 91       	pop	r25
    2782:	8f 91       	pop	r24
    2784:	7f 91       	pop	r23
    2786:	6f 91       	pop	r22
    2788:	5f 91       	pop	r21
    278a:	4f 91       	pop	r20
    278c:	3f 91       	pop	r19
    278e:	2f 91       	pop	r18
    2790:	0f 90       	pop	r0
    2792:	0f be       	out	0x3f, r0	; 63
    2794:	0f 90       	pop	r0
    2796:	1f 90       	pop	r1
    2798:	18 95       	reti

0000279a <__vector_11>:

//RTC Timer.
ISR(TIMER2_OVF_vect){
    279a:	1f 92       	push	r1
    279c:	0f 92       	push	r0
    279e:	0f b6       	in	r0, 0x3f	; 63
    27a0:	0f 92       	push	r0
    27a2:	11 24       	eor	r1, r1
    27a4:	2f 93       	push	r18
    27a6:	3f 93       	push	r19
    27a8:	4f 93       	push	r20
    27aa:	5f 93       	push	r21
    27ac:	6f 93       	push	r22
    27ae:	7f 93       	push	r23
    27b0:	8f 93       	push	r24
    27b2:	9f 93       	push	r25
    27b4:	af 93       	push	r26
    27b6:	bf 93       	push	r27
    27b8:	ef 93       	push	r30
    27ba:	ff 93       	push	r31
    27bc:	cf 93       	push	r28
    27be:	df 93       	push	r29
    27c0:	cd b7       	in	r28, 0x3d	; 61
    27c2:	de b7       	in	r29, 0x3e	; 62
	prtSLEEPled ^= (1 << bnSLEEPled);
    27c4:	8b e2       	ldi	r24, 0x2B	; 43
    27c6:	90 e0       	ldi	r25, 0x00	; 0
    27c8:	2b e2       	ldi	r18, 0x2B	; 43
    27ca:	30 e0       	ldi	r19, 0x00	; 0
    27cc:	f9 01       	movw	r30, r18
    27ce:	30 81       	ld	r19, Z
    27d0:	20 e8       	ldi	r18, 0x80	; 128
    27d2:	23 27       	eor	r18, r19
    27d4:	fc 01       	movw	r30, r24
    27d6:	20 83       	st	Z, r18
	static int gavrSendTimeout=0, boneReceiveTimeout=0, gavrReceiveTimeout=0, startupTimeout=0;
	
	currentTime.addSeconds(1);
    27d8:	82 ea       	ldi	r24, 0xA2	; 162
    27da:	91 e0       	ldi	r25, 0x01	; 1
    27dc:	61 e0       	ldi	r22, 0x01	; 1
    27de:	70 e0       	ldi	r23, 0x00	; 0
    27e0:	0e 94 72 06 	call	0xce4	; 0xce4 <_ZN6myTime10addSecondsEi>
	
	//GAVR Transmission Timeout
	if (flagSendingGAVR && gavrSendTimeout <=COMM_TIMEOUT_SEC){gavrSendTimeout++;}
    27e4:	80 91 cf 01 	lds	r24, 0x01CF
    27e8:	88 23       	and	r24, r24
    27ea:	89 f0       	breq	.+34     	; 0x280e <__vector_11+0x74>
    27ec:	80 91 da 01 	lds	r24, 0x01DA
    27f0:	90 91 db 01 	lds	r25, 0x01DB
    27f4:	87 30       	cpi	r24, 0x07	; 7
    27f6:	91 05       	cpc	r25, r1
    27f8:	54 f4       	brge	.+20     	; 0x280e <__vector_11+0x74>
    27fa:	80 91 da 01 	lds	r24, 0x01DA
    27fe:	90 91 db 01 	lds	r25, 0x01DB
    2802:	01 96       	adiw	r24, 0x01	; 1
    2804:	90 93 db 01 	sts	0x01DB, r25
    2808:	80 93 da 01 	sts	0x01DA, r24
    280c:	2f c0       	rjmp	.+94     	; 0x286c <__vector_11+0xd2>
	else if (flagSendingGAVR && gavrSendTimeout > COMM_TIMEOUT_SEC){flagSendingGAVR=fFalse; gavrSendTimeout=0; __enableCommINT();}
    280e:	80 91 cf 01 	lds	r24, 0x01CF
    2812:	88 23       	and	r24, r24
    2814:	e1 f0       	breq	.+56     	; 0x284e <__vector_11+0xb4>
    2816:	80 91 da 01 	lds	r24, 0x01DA
    281a:	90 91 db 01 	lds	r25, 0x01DB
    281e:	87 30       	cpi	r24, 0x07	; 7
    2820:	91 05       	cpc	r25, r1
    2822:	ac f0       	brlt	.+42     	; 0x284e <__vector_11+0xb4>
    2824:	10 92 cf 01 	sts	0x01CF, r1
    2828:	10 92 db 01 	sts	0x01DB, r1
    282c:	10 92 da 01 	sts	0x01DA, r1
    2830:	8d e3       	ldi	r24, 0x3D	; 61
    2832:	90 e0       	ldi	r25, 0x00	; 0
    2834:	2d e3       	ldi	r18, 0x3D	; 61
    2836:	30 e0       	ldi	r19, 0x00	; 0
    2838:	f9 01       	movw	r30, r18
    283a:	20 81       	ld	r18, Z
    283c:	24 60       	ori	r18, 0x04	; 4
    283e:	fc 01       	movw	r30, r24
    2840:	20 83       	st	Z, r18
    2842:	8d e6       	ldi	r24, 0x6D	; 109
    2844:	90 e0       	ldi	r25, 0x00	; 0
    2846:	22 e0       	ldi	r18, 0x02	; 2
    2848:	fc 01       	movw	r30, r24
    284a:	20 83       	st	Z, r18
    284c:	0f c0       	rjmp	.+30     	; 0x286c <__vector_11+0xd2>
	else if (!flagSendingGAVR && gavrSendTimeout > 0){gavrSendTimeout=0;}
    284e:	80 91 cf 01 	lds	r24, 0x01CF
    2852:	88 23       	and	r24, r24
    2854:	59 f4       	brne	.+22     	; 0x286c <__vector_11+0xd2>
    2856:	80 91 da 01 	lds	r24, 0x01DA
    285a:	90 91 db 01 	lds	r25, 0x01DB
    285e:	18 16       	cp	r1, r24
    2860:	19 06       	cpc	r1, r25
    2862:	24 f4       	brge	.+8      	; 0x286c <__vector_11+0xd2>
    2864:	10 92 db 01 	sts	0x01DB, r1
    2868:	10 92 da 01 	sts	0x01DA, r1
	else;
	
	//BeagleBone Reception Timeout
	if (flagReceivingBone && boneReceiveTimeout <=COMM_TIMEOUT_SEC){boneReceiveTimeout++;}
    286c:	80 91 ca 01 	lds	r24, 0x01CA
    2870:	88 23       	and	r24, r24
    2872:	89 f0       	breq	.+34     	; 0x2896 <__vector_11+0xfc>
    2874:	80 91 dc 01 	lds	r24, 0x01DC
    2878:	90 91 dd 01 	lds	r25, 0x01DD
    287c:	87 30       	cpi	r24, 0x07	; 7
    287e:	91 05       	cpc	r25, r1
    2880:	54 f4       	brge	.+20     	; 0x2896 <__vector_11+0xfc>
    2882:	80 91 dc 01 	lds	r24, 0x01DC
    2886:	90 91 dd 01 	lds	r25, 0x01DD
    288a:	01 96       	adiw	r24, 0x01	; 1
    288c:	90 93 dd 01 	sts	0x01DD, r25
    2890:	80 93 dc 01 	sts	0x01DC, r24
    2894:	2f c0       	rjmp	.+94     	; 0x28f4 <__vector_11+0x15a>
	else if (flagReceivingBone && boneReceiveTimeout > COMM_TIMEOUT_SEC){flagReceivingBone=fFalse; boneReceiveTimeout=0; __enableCommINT();}
    2896:	80 91 ca 01 	lds	r24, 0x01CA
    289a:	88 23       	and	r24, r24
    289c:	e1 f0       	breq	.+56     	; 0x28d6 <__vector_11+0x13c>
    289e:	80 91 dc 01 	lds	r24, 0x01DC
    28a2:	90 91 dd 01 	lds	r25, 0x01DD
    28a6:	87 30       	cpi	r24, 0x07	; 7
    28a8:	91 05       	cpc	r25, r1
    28aa:	ac f0       	brlt	.+42     	; 0x28d6 <__vector_11+0x13c>
    28ac:	10 92 ca 01 	sts	0x01CA, r1
    28b0:	10 92 dd 01 	sts	0x01DD, r1
    28b4:	10 92 dc 01 	sts	0x01DC, r1
    28b8:	8d e3       	ldi	r24, 0x3D	; 61
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	2d e3       	ldi	r18, 0x3D	; 61
    28be:	30 e0       	ldi	r19, 0x00	; 0
    28c0:	f9 01       	movw	r30, r18
    28c2:	20 81       	ld	r18, Z
    28c4:	24 60       	ori	r18, 0x04	; 4
    28c6:	fc 01       	movw	r30, r24
    28c8:	20 83       	st	Z, r18
    28ca:	8d e6       	ldi	r24, 0x6D	; 109
    28cc:	90 e0       	ldi	r25, 0x00	; 0
    28ce:	22 e0       	ldi	r18, 0x02	; 2
    28d0:	fc 01       	movw	r30, r24
    28d2:	20 83       	st	Z, r18
    28d4:	0f c0       	rjmp	.+30     	; 0x28f4 <__vector_11+0x15a>
	else if (!flagReceivingBone && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    28d6:	80 91 ca 01 	lds	r24, 0x01CA
    28da:	88 23       	and	r24, r24
    28dc:	59 f4       	brne	.+22     	; 0x28f4 <__vector_11+0x15a>
    28de:	80 91 dc 01 	lds	r24, 0x01DC
    28e2:	90 91 dd 01 	lds	r25, 0x01DD
    28e6:	18 16       	cp	r1, r24
    28e8:	19 06       	cpc	r1, r25
    28ea:	24 f4       	brge	.+8      	; 0x28f4 <__vector_11+0x15a>
    28ec:	10 92 dd 01 	sts	0x01DD, r1
    28f0:	10 92 dc 01 	sts	0x01DC, r1
	else;
	
	//GAVR Reception Timeout
	if (flagReceivingGAVR && gavrReceiveTimeout <= COMM_TIMEOUT_SEC){gavrReceiveTimeout++;}
    28f4:	80 91 cc 01 	lds	r24, 0x01CC
    28f8:	88 23       	and	r24, r24
    28fa:	89 f0       	breq	.+34     	; 0x291e <__vector_11+0x184>
    28fc:	80 91 de 01 	lds	r24, 0x01DE
    2900:	90 91 df 01 	lds	r25, 0x01DF
    2904:	87 30       	cpi	r24, 0x07	; 7
    2906:	91 05       	cpc	r25, r1
    2908:	54 f4       	brge	.+20     	; 0x291e <__vector_11+0x184>
    290a:	80 91 de 01 	lds	r24, 0x01DE
    290e:	90 91 df 01 	lds	r25, 0x01DF
    2912:	01 96       	adiw	r24, 0x01	; 1
    2914:	90 93 df 01 	sts	0x01DF, r25
    2918:	80 93 de 01 	sts	0x01DE, r24
    291c:	2f c0       	rjmp	.+94     	; 0x297c <__vector_11+0x1e2>
	else if (flagReceivingGAVR && gavrReceiveTimeout > COMM_TIMEOUT_SEC){flagReceivingGAVR=fFalse; boneReceiveTimeout=0; __enableCommINT();}
    291e:	80 91 cc 01 	lds	r24, 0x01CC
    2922:	88 23       	and	r24, r24
    2924:	e1 f0       	breq	.+56     	; 0x295e <__vector_11+0x1c4>
    2926:	80 91 de 01 	lds	r24, 0x01DE
    292a:	90 91 df 01 	lds	r25, 0x01DF
    292e:	87 30       	cpi	r24, 0x07	; 7
    2930:	91 05       	cpc	r25, r1
    2932:	ac f0       	brlt	.+42     	; 0x295e <__vector_11+0x1c4>
    2934:	10 92 cc 01 	sts	0x01CC, r1
    2938:	10 92 dd 01 	sts	0x01DD, r1
    293c:	10 92 dc 01 	sts	0x01DC, r1
    2940:	8d e3       	ldi	r24, 0x3D	; 61
    2942:	90 e0       	ldi	r25, 0x00	; 0
    2944:	2d e3       	ldi	r18, 0x3D	; 61
    2946:	30 e0       	ldi	r19, 0x00	; 0
    2948:	f9 01       	movw	r30, r18
    294a:	20 81       	ld	r18, Z
    294c:	24 60       	ori	r18, 0x04	; 4
    294e:	fc 01       	movw	r30, r24
    2950:	20 83       	st	Z, r18
    2952:	8d e6       	ldi	r24, 0x6D	; 109
    2954:	90 e0       	ldi	r25, 0x00	; 0
    2956:	22 e0       	ldi	r18, 0x02	; 2
    2958:	fc 01       	movw	r30, r24
    295a:	20 83       	st	Z, r18
    295c:	0f c0       	rjmp	.+30     	; 0x297c <__vector_11+0x1e2>
	else if (!flagReceivingGAVR && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    295e:	80 91 cc 01 	lds	r24, 0x01CC
    2962:	88 23       	and	r24, r24
    2964:	59 f4       	brne	.+22     	; 0x297c <__vector_11+0x1e2>
    2966:	80 91 dc 01 	lds	r24, 0x01DC
    296a:	90 91 dd 01 	lds	r25, 0x01DD
    296e:	18 16       	cp	r1, r24
    2970:	19 06       	cpc	r1, r25
    2972:	24 f4       	brge	.+8      	; 0x297c <__vector_11+0x1e2>
    2974:	10 92 dd 01 	sts	0x01DD, r1
    2978:	10 92 dc 01 	sts	0x01DC, r1
		else if (restart){restart=fFalse; flagUserClock=fFalse; flagUpdateGAVRClock=fTrue;}				//Gps didn't send valid data, we have valid data. This is redundant to the main
		__enableCommINT();																				//--procedure that depends on "if (restart)"
		startupTimeout=0;
	} else if (!(flagFreshStart || restart) && startupTimeout > 0){startupTimeout=0;}
	else;*/
}//End timer 2 overflow.
    297c:	df 91       	pop	r29
    297e:	cf 91       	pop	r28
    2980:	ff 91       	pop	r31
    2982:	ef 91       	pop	r30
    2984:	bf 91       	pop	r27
    2986:	af 91       	pop	r26
    2988:	9f 91       	pop	r25
    298a:	8f 91       	pop	r24
    298c:	7f 91       	pop	r23
    298e:	6f 91       	pop	r22
    2990:	5f 91       	pop	r21
    2992:	4f 91       	pop	r20
    2994:	3f 91       	pop	r19
    2996:	2f 91       	pop	r18
    2998:	0f 90       	pop	r0
    299a:	0f be       	out	0x3f, r0	; 63
    299c:	0f 90       	pop	r0
    299e:	1f 90       	pop	r1
    29a0:	18 95       	reti

000029a2 <__vector_20>:

//UART Receive from BeagleBone
ISR(USART0_RX_vect){
    29a2:	1f 92       	push	r1
    29a4:	0f 92       	push	r0
    29a6:	0f b6       	in	r0, 0x3f	; 63
    29a8:	0f 92       	push	r0
    29aa:	11 24       	eor	r1, r1
    29ac:	2f 93       	push	r18
    29ae:	3f 93       	push	r19
    29b0:	8f 93       	push	r24
    29b2:	9f 93       	push	r25
    29b4:	ef 93       	push	r30
    29b6:	ff 93       	push	r31
    29b8:	cf 93       	push	r28
    29ba:	df 93       	push	r29
    29bc:	cd b7       	in	r28, 0x3d	; 61
    29be:	de b7       	in	r29, 0x3e	; 62
	cli();
    29c0:	f8 94       	cli
	UCSR0B &= ~(1 << RXCIE0);
    29c2:	81 ec       	ldi	r24, 0xC1	; 193
    29c4:	90 e0       	ldi	r25, 0x00	; 0
    29c6:	21 ec       	ldi	r18, 0xC1	; 193
    29c8:	30 e0       	ldi	r19, 0x00	; 0
    29ca:	f9 01       	movw	r30, r18
    29cc:	20 81       	ld	r18, Z
    29ce:	2f 77       	andi	r18, 0x7F	; 127
    29d0:	fc 01       	movw	r30, r24
    29d2:	20 83       	st	Z, r18
	__killCommINT();				//make sure all interrupts are disabled that could cripple protocol
    29d4:	8d e3       	ldi	r24, 0x3D	; 61
    29d6:	90 e0       	ldi	r25, 0x00	; 0
    29d8:	fc 01       	movw	r30, r24
    29da:	10 82       	st	Z, r1
    29dc:	8d e6       	ldi	r24, 0x6D	; 109
    29de:	90 e0       	ldi	r25, 0x00	; 0
    29e0:	fc 01       	movw	r30, r24
    29e2:	10 82       	st	Z, r1
	flagReceivingBone=fTrue;
    29e4:	81 e0       	ldi	r24, 0x01	; 1
    29e6:	80 93 ca 01 	sts	0x01CA, r24
	sei();
    29ea:	78 94       	sei
}
    29ec:	df 91       	pop	r29
    29ee:	cf 91       	pop	r28
    29f0:	ff 91       	pop	r31
    29f2:	ef 91       	pop	r30
    29f4:	9f 91       	pop	r25
    29f6:	8f 91       	pop	r24
    29f8:	3f 91       	pop	r19
    29fa:	2f 91       	pop	r18
    29fc:	0f 90       	pop	r0
    29fe:	0f be       	out	0x3f, r0	; 63
    2a00:	0f 90       	pop	r0
    2a02:	1f 90       	pop	r1
    2a04:	18 95       	reti

00002a06 <__vector_28>:

ISR(USART1_RX_vect){
    2a06:	1f 92       	push	r1
    2a08:	0f 92       	push	r0
    2a0a:	0f b6       	in	r0, 0x3f	; 63
    2a0c:	0f 92       	push	r0
    2a0e:	11 24       	eor	r1, r1
    2a10:	2f 93       	push	r18
    2a12:	3f 93       	push	r19
    2a14:	8f 93       	push	r24
    2a16:	9f 93       	push	r25
    2a18:	ef 93       	push	r30
    2a1a:	ff 93       	push	r31
    2a1c:	cf 93       	push	r28
    2a1e:	df 93       	push	r29
    2a20:	cd b7       	in	r28, 0x3d	; 61
    2a22:	de b7       	in	r29, 0x3e	; 62
	cli();
    2a24:	f8 94       	cli
	UCSR1B &= ~(1 <<RXCIE1);	//disable interrupt
    2a26:	89 ec       	ldi	r24, 0xC9	; 201
    2a28:	90 e0       	ldi	r25, 0x00	; 0
    2a2a:	29 ec       	ldi	r18, 0xC9	; 201
    2a2c:	30 e0       	ldi	r19, 0x00	; 0
    2a2e:	f9 01       	movw	r30, r18
    2a30:	20 81       	ld	r18, Z
    2a32:	2f 77       	andi	r18, 0x7F	; 127
    2a34:	fc 01       	movw	r30, r24
    2a36:	20 83       	st	Z, r18
	__killCommINT();
    2a38:	8d e3       	ldi	r24, 0x3D	; 61
    2a3a:	90 e0       	ldi	r25, 0x00	; 0
    2a3c:	fc 01       	movw	r30, r24
    2a3e:	10 82       	st	Z, r1
    2a40:	8d e6       	ldi	r24, 0x6D	; 109
    2a42:	90 e0       	ldi	r25, 0x00	; 0
    2a44:	fc 01       	movw	r30, r24
    2a46:	10 82       	st	Z, r1
	flagReceivingGAVR=fTrue;
    2a48:	81 e0       	ldi	r24, 0x01	; 1
    2a4a:	80 93 cc 01 	sts	0x01CC, r24
	sei();
    2a4e:	78 94       	sei
}
    2a50:	df 91       	pop	r29
    2a52:	cf 91       	pop	r28
    2a54:	ff 91       	pop	r31
    2a56:	ef 91       	pop	r30
    2a58:	9f 91       	pop	r25
    2a5a:	8f 91       	pop	r24
    2a5c:	3f 91       	pop	r19
    2a5e:	2f 91       	pop	r18
    2a60:	0f 90       	pop	r0
    2a62:	0f be       	out	0x3f, r0	; 63
    2a64:	0f 90       	pop	r0
    2a66:	1f 90       	pop	r1
    2a68:	18 95       	reti

00002a6a <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    2a6a:	cf 93       	push	r28
    2a6c:	df 93       	push	r29
    2a6e:	00 d0       	rcall	.+0      	; 0x2a70 <main+0x6>
    2a70:	cd b7       	in	r28, 0x3d	; 61
    2a72:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    2a74:	0e 94 b4 16 	call	0x2d68	; 0x2d68 <_Z10DeviceInitv>
	AppInit(MYUBRR);
    2a78:	85 e0       	ldi	r24, 0x05	; 5
    2a7a:	90 e0       	ldi	r25, 0x00	; 0
    2a7c:	0e 94 db 16 	call	0x2db6	; 0x2db6 <_Z7AppInitj>
	EnableRTCTimer();
    2a80:	0e 94 33 18 	call	0x3066	; 0x3066 <_Z14EnableRTCTimerv>
	InitBools();
    2a84:	0e 94 0c 18 	call	0x3018	; 0x3018 <_Z9InitBoolsv>
	getDateTime_eeprom(fTrue,fTrue);
    2a88:	81 e0       	ldi	r24, 0x01	; 1
    2a8a:	61 e0       	ldi	r22, 0x01	; 1
    2a8c:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z18getDateTime_eepromhh>
	//Prep/make sure power/temp is good
	Wait_sec(2);
    2a90:	82 e0       	ldi	r24, 0x02	; 2
    2a92:	90 e0       	ldi	r25, 0x00	; 0
    2a94:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
	GetTemp();
    2a98:	0e 94 08 1a 	call	0x3410	; 0x3410 <_Z7GetTempv>
	TakeADC();
    2a9c:	0e 94 32 19 	call	0x3264	; 0x3264 <_Z7TakeADCv>
	if (flagGoodVolts && flagGoodTemp){				//Good to power on system
    2aa0:	80 91 d7 01 	lds	r24, 0x01D7
    2aa4:	88 23       	and	r24, r24
    2aa6:	e1 f0       	breq	.+56     	; 0x2ae0 <main+0x76>
    2aa8:	80 91 d6 01 	lds	r24, 0x01D6
    2aac:	88 23       	and	r24, r24
    2aae:	c1 f0       	breq	.+48     	; 0x2ae0 <main+0x76>
		__enableCommINT();
    2ab0:	8d e3       	ldi	r24, 0x3D	; 61
    2ab2:	90 e0       	ldi	r25, 0x00	; 0
    2ab4:	2d e3       	ldi	r18, 0x3D	; 61
    2ab6:	30 e0       	ldi	r19, 0x00	; 0
    2ab8:	f9 01       	movw	r30, r18
    2aba:	20 81       	ld	r18, Z
    2abc:	24 60       	ori	r18, 0x04	; 4
    2abe:	fc 01       	movw	r30, r24
    2ac0:	20 83       	st	Z, r18
    2ac2:	8d e6       	ldi	r24, 0x6D	; 109
    2ac4:	90 e0       	ldi	r25, 0x00	; 0
    2ac6:	22 e0       	ldi	r18, 0x02	; 2
    2ac8:	fc 01       	movw	r30, r24
    2aca:	20 83       	st	Z, r18
		PowerUp(POWER_UP_INTERVAL);
    2acc:	83 e0       	ldi	r24, 0x03	; 3
    2ace:	90 e0       	ldi	r25, 0x00	; 0
    2ad0:	0e 94 87 1a 	call	0x350e	; 0x350e <_Z7PowerUpj>
		flagFreshStart=fTrue;
    2ad4:	81 e0       	ldi	r24, 0x01	; 1
    2ad6:	80 93 d9 01 	sts	0x01D9, r24
		flagShutdown=fFalse;
    2ada:	10 92 d5 01 	sts	0x01D5, r1
    2ade:	0d c0       	rjmp	.+26     	; 0x2afa <main+0x90>
	} else {										//Something isn't right, don't power on the system.
		__killCommINT();
    2ae0:	8d e3       	ldi	r24, 0x3D	; 61
    2ae2:	90 e0       	ldi	r25, 0x00	; 0
    2ae4:	fc 01       	movw	r30, r24
    2ae6:	10 82       	st	Z, r1
    2ae8:	8d e6       	ldi	r24, 0x6D	; 109
    2aea:	90 e0       	ldi	r25, 0x00	; 0
    2aec:	fc 01       	movw	r30, r24
    2aee:	10 82       	st	Z, r1
		flagShutdown=fTrue;
    2af0:	81 e0       	ldi	r24, 0x01	; 1
    2af2:	80 93 d5 01 	sts	0x01D5, r24
		flagFreshStart=fFalse;
    2af6:	10 92 d9 01 	sts	0x01D9, r1
	}
	
	PrintBone("Hello BeagleBone.");	
    2afa:	8c e8       	ldi	r24, 0x8C	; 140
    2afc:	91 e0       	ldi	r25, 0x01	; 1
    2afe:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
	printTimeDate(fTrue,fTrue);
    2b02:	81 e0       	ldi	r24, 0x01	; 1
    2b04:	61 e0       	ldi	r22, 0x01	; 1
    2b06:	41 e0       	ldi	r20, 0x01	; 1
    2b08:	0e 94 c6 12 	call	0x258c	; 0x258c <_Z13printTimeDatehhh>
	prtSTATUSled |= (1 << bnSTATUSled);
    2b0c:	88 e2       	ldi	r24, 0x28	; 40
    2b0e:	90 e0       	ldi	r25, 0x00	; 0
    2b10:	28 e2       	ldi	r18, 0x28	; 40
    2b12:	30 e0       	ldi	r19, 0x00	; 0
    2b14:	f9 01       	movw	r30, r18
    2b16:	20 81       	ld	r18, Z
    2b18:	24 60       	ori	r18, 0x04	; 4
    2b1a:	fc 01       	movw	r30, r24
    2b1c:	20 83       	st	Z, r18
	//main programming loop
	unsigned int counter=0;
    2b1e:	1a 82       	std	Y+2, r1	; 0x02
    2b20:	19 82       	std	Y+1, r1	; 0x01
    2b22:	01 c0       	rjmp	.+2      	; 0x2b26 <main+0xbc>
	while(fTrue)
    2b24:	00 00       	nop
	{		
		Wait_sec(3);
    2b26:	83 e0       	ldi	r24, 0x03	; 3
    2b28:	90 e0       	ldi	r25, 0x00	; 0
    2b2a:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
		//If receiving UART string, go get rest of it.
		if (flagReceivingBone){
    2b2e:	80 91 ca 01 	lds	r24, 0x01CA
    2b32:	88 23       	and	r24, r24
    2b34:	c1 f0       	breq	.+48     	; 0x2b66 <main+0xfc>
			//ReceiveBone();
			__enableCommINT();
    2b36:	8d e3       	ldi	r24, 0x3D	; 61
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	2d e3       	ldi	r18, 0x3D	; 61
    2b3c:	30 e0       	ldi	r19, 0x00	; 0
    2b3e:	f9 01       	movw	r30, r18
    2b40:	20 81       	ld	r18, Z
    2b42:	24 60       	ori	r18, 0x04	; 4
    2b44:	fc 01       	movw	r30, r24
    2b46:	20 83       	st	Z, r18
    2b48:	8d e6       	ldi	r24, 0x6D	; 109
    2b4a:	90 e0       	ldi	r25, 0x00	; 0
    2b4c:	22 e0       	ldi	r18, 0x02	; 2
    2b4e:	fc 01       	movw	r30, r24
    2b50:	20 83       	st	Z, r18
			if (!flagReceivingGAVR){		//Just in case there was an interrupt IMMEDIATELY after the enabling of Communication interrupts
    2b52:	80 91 cc 01 	lds	r24, 0x01CC
    2b56:	88 23       	and	r24, r24
    2b58:	31 f4       	brne	.+12     	; 0x2b66 <main+0xfc>
				flagGoToSleep=fTrue;
    2b5a:	81 e0       	ldi	r24, 0x01	; 1
    2b5c:	80 93 81 01 	sts	0x0181, r24
				flagNormalMode=fTrue;
    2b60:	81 e0       	ldi	r24, 0x01	; 1
    2b62:	80 93 cb 01 	sts	0x01CB, r24
			}			
		}//end flag Receiving from Bone 
		
		//Receiving Data/Signals from GAVR
		if (flagReceivingGAVR){
    2b66:	80 91 cc 01 	lds	r24, 0x01CC
    2b6a:	88 23       	and	r24, r24
    2b6c:	d1 f0       	breq	.+52     	; 0x2ba2 <main+0x138>
			ReceiveGAVR();
    2b6e:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <_Z11ReceiveGAVRv>
			__enableCommINT();
    2b72:	8d e3       	ldi	r24, 0x3D	; 61
    2b74:	90 e0       	ldi	r25, 0x00	; 0
    2b76:	2d e3       	ldi	r18, 0x3D	; 61
    2b78:	30 e0       	ldi	r19, 0x00	; 0
    2b7a:	f9 01       	movw	r30, r18
    2b7c:	20 81       	ld	r18, Z
    2b7e:	24 60       	ori	r18, 0x04	; 4
    2b80:	fc 01       	movw	r30, r24
    2b82:	20 83       	st	Z, r18
    2b84:	8d e6       	ldi	r24, 0x6D	; 109
    2b86:	90 e0       	ldi	r25, 0x00	; 0
    2b88:	22 e0       	ldi	r18, 0x02	; 2
    2b8a:	fc 01       	movw	r30, r24
    2b8c:	20 83       	st	Z, r18
			if (!flagReceivingBone){		//Just in case there was an interrupt IMMEDIATELY after the enabling of Communication interrupts
    2b8e:	80 91 ca 01 	lds	r24, 0x01CA
    2b92:	88 23       	and	r24, r24
    2b94:	31 f4       	brne	.+12     	; 0x2ba2 <main+0x138>
				flagGoToSleep=fTrue;
    2b96:	81 e0       	ldi	r24, 0x01	; 1
    2b98:	80 93 81 01 	sts	0x0181, r24
				flagNormalMode=fTrue;
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
    2b9e:	80 93 cb 01 	sts	0x01CB, r24
			}			
		}//end flag Receiving from GAVR case
		
	
		//Communication with GAVR. Either updating the date/time on it or asking for date and time. The internal send machine deals with the flags.
		if ((flagUpdateGAVRClock  || flagUserClock) && !flagWaitingForReceiveGAVR){
    2ba2:	80 91 ce 01 	lds	r24, 0x01CE
    2ba6:	88 23       	and	r24, r24
    2ba8:	21 f4       	brne	.+8      	; 0x2bb2 <main+0x148>
    2baa:	80 91 d0 01 	lds	r24, 0x01D0
    2bae:	88 23       	and	r24, r24
    2bb0:	e1 f0       	breq	.+56     	; 0x2bea <main+0x180>
    2bb2:	80 91 cd 01 	lds	r24, 0x01CD
    2bb6:	88 23       	and	r24, r24
    2bb8:	c1 f4       	brne	.+48     	; 0x2bea <main+0x180>
			__killCommINT();
    2bba:	8d e3       	ldi	r24, 0x3D	; 61
    2bbc:	90 e0       	ldi	r25, 0x00	; 0
    2bbe:	fc 01       	movw	r30, r24
    2bc0:	10 82       	st	Z, r1
    2bc2:	8d e6       	ldi	r24, 0x6D	; 109
    2bc4:	90 e0       	ldi	r25, 0x00	; 0
    2bc6:	fc 01       	movw	r30, r24
    2bc8:	10 82       	st	Z, r1
			sendGAVR();
    2bca:	0e 94 2e 09 	call	0x125c	; 0x125c <_Z8sendGAVRv>
			__enableCommINT();
    2bce:	8d e3       	ldi	r24, 0x3D	; 61
    2bd0:	90 e0       	ldi	r25, 0x00	; 0
    2bd2:	2d e3       	ldi	r18, 0x3D	; 61
    2bd4:	30 e0       	ldi	r19, 0x00	; 0
    2bd6:	f9 01       	movw	r30, r18
    2bd8:	20 81       	ld	r18, Z
    2bda:	24 60       	ori	r18, 0x04	; 4
    2bdc:	fc 01       	movw	r30, r24
    2bde:	20 83       	st	Z, r18
    2be0:	8d e6       	ldi	r24, 0x6D	; 109
    2be2:	90 e0       	ldi	r25, 0x00	; 0
    2be4:	22 e0       	ldi	r18, 0x02	; 2
    2be6:	fc 01       	movw	r30, r24
    2be8:	20 83       	st	Z, r18
		}//end send to GAVR case

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    2bea:	80 91 cb 01 	lds	r24, 0x01CB
    2bee:	88 23       	and	r24, r24
    2bf0:	49 f1       	breq	.+82     	; 0x2c44 <main+0x1da>
			if (currentTime.getMinutes()%30 == 0){
    2bf2:	82 ea       	ldi	r24, 0xA2	; 162
    2bf4:	91 e0       	ldi	r25, 0x01	; 1
    2bf6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    2bfa:	9e e1       	ldi	r25, 0x1E	; 30
    2bfc:	69 2f       	mov	r22, r25
    2bfe:	0e 94 57 1b 	call	0x36ae	; 0x36ae <__udivmodqi4>
    2c02:	89 2f       	mov	r24, r25
    2c04:	98 2f       	mov	r25, r24
    2c06:	81 e0       	ldi	r24, 0x01	; 1
    2c08:	99 23       	and	r25, r25
    2c0a:	09 f0       	breq	.+2      	; 0x2c0e <main+0x1a4>
    2c0c:	80 e0       	ldi	r24, 0x00	; 0
    2c0e:	88 23       	and	r24, r24
    2c10:	c9 f0       	breq	.+50     	; 0x2c44 <main+0x1da>
				if (currentTime.getHours()%12 == 0){
    2c12:	82 ea       	ldi	r24, 0xA2	; 162
    2c14:	91 e0       	ldi	r25, 0x01	; 1
    2c16:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    2c1a:	9c e0       	ldi	r25, 0x0C	; 12
    2c1c:	69 2f       	mov	r22, r25
    2c1e:	0e 94 57 1b 	call	0x36ae	; 0x36ae <__udivmodqi4>
    2c22:	89 2f       	mov	r24, r25
    2c24:	98 2f       	mov	r25, r24
    2c26:	81 e0       	ldi	r24, 0x01	; 1
    2c28:	99 23       	and	r25, r25
    2c2a:	09 f0       	breq	.+2      	; 0x2c2e <main+0x1c4>
    2c2c:	80 e0       	ldi	r24, 0x00	; 0
    2c2e:	88 23       	and	r24, r24
    2c30:	29 f0       	breq	.+10     	; 0x2c3c <main+0x1d2>
					saveDateTime_eeprom(fTrue,fTrue);
    2c32:	81 e0       	ldi	r24, 0x01	; 1
    2c34:	61 e0       	ldi	r22, 0x01	; 1
    2c36:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    2c3a:	04 c0       	rjmp	.+8      	; 0x2c44 <main+0x1da>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    2c3c:	81 e0       	ldi	r24, 0x01	; 1
    2c3e:	60 e0       	ldi	r22, 0x00	; 0
    2c40:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}//end time capture/save
		
		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode && counter < 3){
    2c44:	80 91 cb 01 	lds	r24, 0x01CB
    2c48:	88 23       	and	r24, r24
    2c4a:	61 f1       	breq	.+88     	; 0x2ca4 <main+0x23a>
    2c4c:	89 81       	ldd	r24, Y+1	; 0x01
    2c4e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c50:	83 30       	cpi	r24, 0x03	; 3
    2c52:	91 05       	cpc	r25, r1
    2c54:	38 f5       	brcc	.+78     	; 0x2ca4 <main+0x23a>
			TakeADC();
    2c56:	0e 94 32 19 	call	0x3264	; 0x3264 <_Z7TakeADCv>
			GetTemp();
    2c5a:	0e 94 08 1a 	call	0x3410	; 0x3410 <_Z7GetTempv>
			counter++;
    2c5e:	89 81       	ldd	r24, Y+1	; 0x01
    2c60:	9a 81       	ldd	r25, Y+2	; 0x02
    2c62:	01 96       	adiw	r24, 0x01	; 1
    2c64:	9a 83       	std	Y+2, r25	; 0x02
    2c66:	89 83       	std	Y+1, r24	; 0x01
			
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    2c68:	80 91 d7 01 	lds	r24, 0x01D7
    2c6c:	88 23       	and	r24, r24
    2c6e:	71 f0       	breq	.+28     	; 0x2c8c <main+0x222>
    2c70:	80 91 d6 01 	lds	r24, 0x01D6
    2c74:	88 23       	and	r24, r24
    2c76:	51 f0       	breq	.+20     	; 0x2c8c <main+0x222>
				if(flagShutdown){restart = fTrue; flagShutdown=fFalse;}
    2c78:	80 91 d5 01 	lds	r24, 0x01D5
    2c7c:	88 23       	and	r24, r24
    2c7e:	89 f0       	breq	.+34     	; 0x2ca2 <main+0x238>
    2c80:	81 e0       	ldi	r24, 0x01	; 1
    2c82:	80 93 d8 01 	sts	0x01D8, r24
    2c86:	10 92 d5 01 	sts	0x01D5, r1
    2c8a:	0b c0       	rjmp	.+22     	; 0x2ca2 <main+0x238>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (!flagShutdown){
    2c8c:	80 91 d5 01 	lds	r24, 0x01D5
    2c90:	88 23       	and	r24, r24
    2c92:	d1 f4       	brne	.+52     	; 0x2cc8 <main+0x25e>
					flagNewShutdown = fTrue;
    2c94:	81 e0       	ldi	r24, 0x01	; 1
    2c96:	80 93 d4 01 	sts	0x01D4, r24
					flagShutdown=fTrue;
    2c9a:	81 e0       	ldi	r24, 0x01	; 1
    2c9c:	80 93 d5 01 	sts	0x01D5, r24
			TakeADC();
			GetTemp();
			counter++;
			
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    2ca0:	13 c0       	rjmp	.+38     	; 0x2cc8 <main+0x25e>
    2ca2:	12 c0       	rjmp	.+36     	; 0x2cc8 <main+0x25e>
					flagNewShutdown = fTrue;
					flagShutdown=fTrue;
				}
			}
		}//end normal mode Check Analog Signals		
		else if (counter >=3 && flagNormalMode){counter=0; flagNewShutdown=fTrue; flagShutdown=fTrue;}		//forces a shutdown for at least one cycle, see how the thing reacts.
    2ca4:	89 81       	ldd	r24, Y+1	; 0x01
    2ca6:	9a 81       	ldd	r25, Y+2	; 0x02
    2ca8:	83 30       	cpi	r24, 0x03	; 3
    2caa:	91 05       	cpc	r25, r1
    2cac:	70 f0       	brcs	.+28     	; 0x2cca <main+0x260>
    2cae:	80 91 cb 01 	lds	r24, 0x01CB
    2cb2:	88 23       	and	r24, r24
    2cb4:	51 f0       	breq	.+20     	; 0x2cca <main+0x260>
    2cb6:	1a 82       	std	Y+2, r1	; 0x02
    2cb8:	19 82       	std	Y+1, r1	; 0x01
    2cba:	81 e0       	ldi	r24, 0x01	; 1
    2cbc:	80 93 d4 01 	sts	0x01D4, r24
    2cc0:	81 e0       	ldi	r24, 0x01	; 1
    2cc2:	80 93 d5 01 	sts	0x01D5, r24
    2cc6:	01 c0       	rjmp	.+2      	; 0x2cca <main+0x260>
			TakeADC();
			GetTemp();
			counter++;
			
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    2cc8:	00 00       	nop
			}
		}//end normal mode Check Analog Signals		
		else if (counter >=3 && flagNormalMode){counter=0; flagNewShutdown=fTrue; flagShutdown=fTrue;}		//forces a shutdown for at least one cycle, see how the thing reacts.
		
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    2cca:	80 91 d4 01 	lds	r24, 0x01D4
    2cce:	88 23       	and	r24, r24
    2cd0:	b9 f0       	breq	.+46     	; 0x2d00 <main+0x296>
			//Make sure nothing messes with the routine that we care about
			__killCommINT();
    2cd2:	8d e3       	ldi	r24, 0x3D	; 61
    2cd4:	90 e0       	ldi	r25, 0x00	; 0
    2cd6:	fc 01       	movw	r30, r24
    2cd8:	10 82       	st	Z, r1
    2cda:	8d e6       	ldi	r24, 0x6D	; 109
    2cdc:	90 e0       	ldi	r25, 0x00	; 0
    2cde:	fc 01       	movw	r30, r24
    2ce0:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    2ce2:	81 e0       	ldi	r24, 0x01	; 1
    2ce4:	80 93 81 01 	sts	0x0181, r24
			flagReceivingBone = fFalse;
    2ce8:	10 92 ca 01 	sts	0x01CA, r1
			flagUserClock=fFalse;						//reset this so next boot is correct. Done in restart case as well for redundancy
    2cec:	10 92 d0 01 	sts	0x01D0, r1
			saveDateTime_eeprom(fTrue,fTrue);
    2cf0:	81 e0       	ldi	r24, 0x01	; 1
    2cf2:	61 e0       	ldi	r22, 0x01	; 1
    2cf4:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
			
			//Kill power--Alert comes in that function
			PowerDown();
    2cf8:	0e 94 dd 1a 	call	0x35ba	; 0x35ba <_Z9PowerDownv>
			flagNewShutdown = fFalse;
    2cfc:	10 92 d4 01 	sts	0x01D4, r1
		}//end new shutdown
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    2d00:	80 91 d8 01 	lds	r24, 0x01D8
    2d04:	88 23       	and	r24, r24
    2d06:	b1 f0       	breq	.+44     	; 0x2d34 <main+0x2ca>
			//Enable COmmunication protocols and then power up. Power up specifies the timing for it to happen	
			PowerUp(POWER_UP_INTERVAL);
    2d08:	83 e0       	ldi	r24, 0x03	; 3
    2d0a:	90 e0       	ldi	r25, 0x00	; 0
    2d0c:	0e 94 87 1a 	call	0x350e	; 0x350e <_Z7PowerUpj>
			__enableCommINT();
    2d10:	8d e3       	ldi	r24, 0x3D	; 61
    2d12:	90 e0       	ldi	r25, 0x00	; 0
    2d14:	2d e3       	ldi	r18, 0x3D	; 61
    2d16:	30 e0       	ldi	r19, 0x00	; 0
    2d18:	f9 01       	movw	r30, r18
    2d1a:	20 81       	ld	r18, Z
    2d1c:	24 60       	ori	r18, 0x04	; 4
    2d1e:	fc 01       	movw	r30, r24
    2d20:	20 83       	st	Z, r18
    2d22:	8d e6       	ldi	r24, 0x6D	; 109
    2d24:	90 e0       	ldi	r25, 0x00	; 0
    2d26:	22 e0       	ldi	r18, 0x02	; 2
    2d28:	fc 01       	movw	r30, r24
    2d2a:	20 83       	st	Z, r18
			//Update the GAVRClock since it's a restart, we have the correct date and time. If BeagleBone sends GPS data, use that to back it up.
			//flagUpdateGAVRClock=fTrue;
			flagUserClock=fFalse;	
    2d2c:	10 92 d0 01 	sts	0x01D0, r1
			restart=fFalse;	
    2d30:	10 92 d8 01 	sts	0x01D8, r1
		}//end restart		
		
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep){GoToSleep(flagShutdown);}
    2d34:	80 91 81 01 	lds	r24, 0x0181
    2d38:	88 23       	and	r24, r24
    2d3a:	21 f0       	breq	.+8      	; 0x2d44 <main+0x2da>
    2d3c:	80 91 d5 01 	lds	r24, 0x01D5
    2d40:	0e 94 d9 18 	call	0x31b2	; 0x31b2 <_Z9GoToSleeph>
		
		//Add logic for an invalid date and time somehow getting in here
		if (flagInvalidDateTime && !flagShutdown){
    2d44:	80 91 d1 01 	lds	r24, 0x01D1
    2d48:	88 23       	and	r24, r24
    2d4a:	09 f4       	brne	.+2      	; 0x2d4e <main+0x2e4>
    2d4c:	eb ce       	rjmp	.-554    	; 0x2b24 <main+0xba>
    2d4e:	80 91 d5 01 	lds	r24, 0x01D5
    2d52:	88 23       	and	r24, r24
    2d54:	09 f0       	breq	.+2      	; 0x2d58 <main+0x2ee>
    2d56:	e6 ce       	rjmp	.-564    	; 0x2b24 <main+0xba>
			flagInvalidDateTime=fFalse;
    2d58:	10 92 d1 01 	sts	0x01D1, r1
			flagUserClock=fTrue;
    2d5c:	81 e0       	ldi	r24, 0x01	; 1
    2d5e:	80 93 d0 01 	sts	0x01D0, r24
			flagUpdateGAVRClock=fFalse;
    2d62:	10 92 ce 01 	sts	0x01CE, r1
	PrintBone("Hello BeagleBone.");	
	printTimeDate(fTrue,fTrue);
	prtSTATUSled |= (1 << bnSTATUSled);
	//main programming loop
	unsigned int counter=0;
	while(fTrue)
    2d66:	de ce       	rjmp	.-580    	; 0x2b24 <main+0xba>

00002d68 <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    2d68:	cf 93       	push	r28
    2d6a:	df 93       	push	r29
    2d6c:	cd b7       	in	r28, 0x3d	; 61
    2d6e:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    2d70:	81 e2       	ldi	r24, 0x21	; 33
    2d72:	90 e0       	ldi	r25, 0x00	; 0
    2d74:	fc 01       	movw	r30, r24
    2d76:	10 82       	st	Z, r1
	DDRB = 0;
    2d78:	84 e2       	ldi	r24, 0x24	; 36
    2d7a:	90 e0       	ldi	r25, 0x00	; 0
    2d7c:	fc 01       	movw	r30, r24
    2d7e:	10 82       	st	Z, r1
	DDRC = 0;
    2d80:	87 e2       	ldi	r24, 0x27	; 39
    2d82:	90 e0       	ldi	r25, 0x00	; 0
    2d84:	fc 01       	movw	r30, r24
    2d86:	10 82       	st	Z, r1
	DDRD = 0;
    2d88:	8a e2       	ldi	r24, 0x2A	; 42
    2d8a:	90 e0       	ldi	r25, 0x00	; 0
    2d8c:	fc 01       	movw	r30, r24
    2d8e:	10 82       	st	Z, r1
	//ddrMAINen |= (1 << bnMAINen);
	
	PORTA = 0;
    2d90:	82 e2       	ldi	r24, 0x22	; 34
    2d92:	90 e0       	ldi	r25, 0x00	; 0
    2d94:	fc 01       	movw	r30, r24
    2d96:	10 82       	st	Z, r1
	PORTB = 0;
    2d98:	85 e2       	ldi	r24, 0x25	; 37
    2d9a:	90 e0       	ldi	r25, 0x00	; 0
    2d9c:	fc 01       	movw	r30, r24
    2d9e:	10 82       	st	Z, r1
	PORTC = 0;
    2da0:	88 e2       	ldi	r24, 0x28	; 40
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	fc 01       	movw	r30, r24
    2da6:	10 82       	st	Z, r1
	PORTD = 0;
    2da8:	8b e2       	ldi	r24, 0x2B	; 43
    2daa:	90 e0       	ldi	r25, 0x00	; 0
    2dac:	fc 01       	movw	r30, r24
    2dae:	10 82       	st	Z, r1
	//__enableMain();
}
    2db0:	df 91       	pop	r29
    2db2:	cf 91       	pop	r28
    2db4:	08 95       	ret

00002db6 <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    2db6:	cf 93       	push	r28
    2db8:	df 93       	push	r29
    2dba:	00 d0       	rcall	.+0      	; 0x2dbc <_Z7AppInitj+0x6>
    2dbc:	cd b7       	in	r28, 0x3d	; 61
    2dbe:	de b7       	in	r29, 0x3e	; 62
    2dc0:	9a 83       	std	Y+2, r25	; 0x02
    2dc2:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    2dc4:	84 ec       	ldi	r24, 0xC4	; 196
    2dc6:	90 e0       	ldi	r25, 0x00	; 0
    2dc8:	29 81       	ldd	r18, Y+1	; 0x01
    2dca:	fc 01       	movw	r30, r24
    2dcc:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    2dce:	85 ec       	ldi	r24, 0xC5	; 197
    2dd0:	90 e0       	ldi	r25, 0x00	; 0
    2dd2:	29 81       	ldd	r18, Y+1	; 0x01
    2dd4:	3a 81       	ldd	r19, Y+2	; 0x02
    2dd6:	23 2f       	mov	r18, r19
    2dd8:	33 27       	eor	r19, r19
    2dda:	fc 01       	movw	r30, r24
    2ddc:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    2dde:	81 ec       	ldi	r24, 0xC1	; 193
    2de0:	90 e0       	ldi	r25, 0x00	; 0
    2de2:	28 e1       	ldi	r18, 0x18	; 24
    2de4:	fc 01       	movw	r30, r24
    2de6:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    2de8:	82 ec       	ldi	r24, 0xC2	; 194
    2dea:	90 e0       	ldi	r25, 0x00	; 0
    2dec:	26 e0       	ldi	r18, 0x06	; 6
    2dee:	fc 01       	movw	r30, r24
    2df0:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Set BAUD for UART1
	UBRR1L = ubrr;
    2df2:	8c ec       	ldi	r24, 0xCC	; 204
    2df4:	90 e0       	ldi	r25, 0x00	; 0
    2df6:	29 81       	ldd	r18, Y+1	; 0x01
    2df8:	fc 01       	movw	r30, r24
    2dfa:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);
    2dfc:	85 ec       	ldi	r24, 0xC5	; 197
    2dfe:	90 e0       	ldi	r25, 0x00	; 0
    2e00:	29 81       	ldd	r18, Y+1	; 0x01
    2e02:	3a 81       	ldd	r19, Y+2	; 0x02
    2e04:	23 2f       	mov	r18, r19
    2e06:	33 27       	eor	r19, r19
    2e08:	fc 01       	movw	r30, r24
    2e0a:	20 83       	st	Z, r18
	//UCSR1A |= (1 << U2X1);
	
	//Enable UART_TX1 and UART_RX1
	UCSR1B = (1 << TXEN1)|(1 << RXEN1);
    2e0c:	89 ec       	ldi	r24, 0xC9	; 201
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
    2e10:	28 e1       	ldi	r18, 0x18	; 24
    2e12:	fc 01       	movw	r30, r24
    2e14:	20 83       	st	Z, r18
	UCSR1C = (1 << UCSZ11)|(1 << UCSZ10);
    2e16:	8a ec       	ldi	r24, 0xCA	; 202
    2e18:	90 e0       	ldi	r25, 0x00	; 0
    2e1a:	26 e0       	ldi	r18, 0x06	; 6
    2e1c:	fc 01       	movw	r30, r24
    2e1e:	20 83       	st	Z, r18
	//UCSR1B |= (1 << RXCIE1);
	__killUARTrec();
    2e20:	81 ec       	ldi	r24, 0xC1	; 193
    2e22:	90 e0       	ldi	r25, 0x00	; 0
    2e24:	21 ec       	ldi	r18, 0xC1	; 193
    2e26:	30 e0       	ldi	r19, 0x00	; 0
    2e28:	f9 01       	movw	r30, r18
    2e2a:	20 81       	ld	r18, Z
    2e2c:	20 68       	ori	r18, 0x80	; 128
    2e2e:	fc 01       	movw	r30, r24
    2e30:	20 83       	st	Z, r18
    2e32:	89 ec       	ldi	r24, 0xC9	; 201
    2e34:	90 e0       	ldi	r25, 0x00	; 0
    2e36:	29 ec       	ldi	r18, 0xC9	; 201
    2e38:	30 e0       	ldi	r19, 0x00	; 0
    2e3a:	f9 01       	movw	r30, r18
    2e3c:	20 81       	ld	r18, Z
    2e3e:	20 68       	ori	r18, 0x80	; 128
    2e40:	fc 01       	movw	r30, r24
    2e42:	20 83       	st	Z, r18
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM0)|(1 << PRUSART1)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    2e44:	84 e6       	ldi	r24, 0x64	; 100
    2e46:	90 e0       	ldi	r25, 0x00	; 0
    2e48:	24 e6       	ldi	r18, 0x64	; 100
    2e4a:	30 e0       	ldi	r19, 0x00	; 0
    2e4c:	f9 01       	movw	r30, r18
    2e4e:	20 81       	ld	r18, Z
    2e50:	2d 6b       	ori	r18, 0xBD	; 189
    2e52:	fc 01       	movw	r30, r24
    2e54:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    2e56:	8a e2       	ldi	r24, 0x2A	; 42
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	2a e2       	ldi	r18, 0x2A	; 42
    2e5c:	30 e0       	ldi	r19, 0x00	; 0
    2e5e:	f9 01       	movw	r30, r18
    2e60:	20 81       	ld	r18, Z
    2e62:	20 68       	ori	r18, 0x80	; 128
    2e64:	fc 01       	movw	r30, r24
    2e66:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    2e68:	87 e2       	ldi	r24, 0x27	; 39
    2e6a:	90 e0       	ldi	r25, 0x00	; 0
    2e6c:	27 e2       	ldi	r18, 0x27	; 39
    2e6e:	30 e0       	ldi	r19, 0x00	; 0
    2e70:	f9 01       	movw	r30, r18
    2e72:	20 81       	ld	r18, Z
    2e74:	24 60       	ori	r18, 0x04	; 4
    2e76:	fc 01       	movw	r30, r24
    2e78:	20 83       	st	Z, r18
	prtSLEEPled |= (1 << bnSLEEPled);	//turn off initially
    2e7a:	8b e2       	ldi	r24, 0x2B	; 43
    2e7c:	90 e0       	ldi	r25, 0x00	; 0
    2e7e:	2b e2       	ldi	r18, 0x2B	; 43
    2e80:	30 e0       	ldi	r19, 0x00	; 0
    2e82:	f9 01       	movw	r30, r18
    2e84:	20 81       	ld	r18, Z
    2e86:	20 68       	ori	r18, 0x80	; 128
    2e88:	fc 01       	movw	r30, r24
    2e8a:	20 83       	st	Z, r18
	prtSTATUSled &= ~(1 << bnSTATUSled);	//turn on initially
    2e8c:	88 e2       	ldi	r24, 0x28	; 40
    2e8e:	90 e0       	ldi	r25, 0x00	; 0
    2e90:	28 e2       	ldi	r18, 0x28	; 40
    2e92:	30 e0       	ldi	r19, 0x00	; 0
    2e94:	f9 01       	movw	r30, r18
    2e96:	20 81       	ld	r18, Z
    2e98:	2b 7f       	andi	r18, 0xFB	; 251
    2e9a:	fc 01       	movw	r30, r24
    2e9c:	20 83       	st	Z, r18
	
	//Enable BB and GAVR interrupts for COMMUNICATION
	ddrBONEINT |= (1 << bnBONEINT);
    2e9e:	81 e2       	ldi	r24, 0x21	; 33
    2ea0:	90 e0       	ldi	r25, 0x00	; 0
    2ea2:	21 e2       	ldi	r18, 0x21	; 33
    2ea4:	30 e0       	ldi	r19, 0x00	; 0
    2ea6:	f9 01       	movw	r30, r18
    2ea8:	20 81       	ld	r18, Z
    2eaa:	22 60       	ori	r18, 0x02	; 2
    2eac:	fc 01       	movw	r30, r24
    2eae:	20 83       	st	Z, r18
	ddrGAVRINT |= (1 << bnGAVRINT);
    2eb0:	84 e2       	ldi	r24, 0x24	; 36
    2eb2:	90 e0       	ldi	r25, 0x00	; 0
    2eb4:	24 e2       	ldi	r18, 0x24	; 36
    2eb6:	30 e0       	ldi	r19, 0x00	; 0
    2eb8:	f9 01       	movw	r30, r18
    2eba:	20 81       	ld	r18, Z
    2ebc:	28 60       	ori	r18, 0x08	; 8
    2ebe:	fc 01       	movw	r30, r24
    2ec0:	20 83       	st	Z, r18
	prtBONEINT &= ~(1 << bnBONEINT);
    2ec2:	82 e2       	ldi	r24, 0x22	; 34
    2ec4:	90 e0       	ldi	r25, 0x00	; 0
    2ec6:	22 e2       	ldi	r18, 0x22	; 34
    2ec8:	30 e0       	ldi	r19, 0x00	; 0
    2eca:	f9 01       	movw	r30, r18
    2ecc:	20 81       	ld	r18, Z
    2ece:	2d 7f       	andi	r18, 0xFD	; 253
    2ed0:	fc 01       	movw	r30, r24
    2ed2:	20 83       	st	Z, r18
	prtGAVRINT &= ~(1 << bnGAVRINT);
    2ed4:	85 e2       	ldi	r24, 0x25	; 37
    2ed6:	90 e0       	ldi	r25, 0x00	; 0
    2ed8:	25 e2       	ldi	r18, 0x25	; 37
    2eda:	30 e0       	ldi	r19, 0x00	; 0
    2edc:	f9 01       	movw	r30, r18
    2ede:	20 81       	ld	r18, Z
    2ee0:	27 7f       	andi	r18, 0xF7	; 247
    2ee2:	fc 01       	movw	r30, r24
    2ee4:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrInterrupts |= (1 << bnGAVRint)|(1 << bnBBint);
    2ee6:	81 e2       	ldi	r24, 0x21	; 33
    2ee8:	90 e0       	ldi	r25, 0x00	; 0
    2eea:	21 e2       	ldi	r18, 0x21	; 33
    2eec:	30 e0       	ldi	r19, 0x00	; 0
    2eee:	f9 01       	movw	r30, r18
    2ef0:	20 81       	ld	r18, Z
    2ef2:	2c 60       	ori	r18, 0x0C	; 12
    2ef4:	fc 01       	movw	r30, r24
    2ef6:	20 83       	st	Z, r18
	prtInterrupts &= ~((1 << bnGAVRint)|(1 << bnBBint));
    2ef8:	82 e2       	ldi	r24, 0x22	; 34
    2efa:	90 e0       	ldi	r25, 0x00	; 0
    2efc:	22 e2       	ldi	r18, 0x22	; 34
    2efe:	30 e0       	ldi	r19, 0x00	; 0
    2f00:	f9 01       	movw	r30, r18
    2f02:	20 81       	ld	r18, Z
    2f04:	23 7f       	andi	r18, 0xF3	; 243
    2f06:	fc 01       	movw	r30, r24
    2f08:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen)|(1 << bnBBen);
    2f0a:	81 e2       	ldi	r24, 0x21	; 33
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
    2f0e:	21 e2       	ldi	r18, 0x21	; 33
    2f10:	30 e0       	ldi	r19, 0x00	; 0
    2f12:	f9 01       	movw	r30, r18
    2f14:	20 81       	ld	r18, Z
    2f16:	20 6f       	ori	r18, 0xF0	; 240
    2f18:	fc 01       	movw	r30, r24
    2f1a:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    2f1c:	84 e2       	ldi	r24, 0x24	; 36
    2f1e:	90 e0       	ldi	r25, 0x00	; 0
    2f20:	24 e2       	ldi	r18, 0x24	; 36
    2f22:	30 e0       	ldi	r19, 0x00	; 0
    2f24:	f9 01       	movw	r30, r18
    2f26:	20 81       	ld	r18, Z
    2f28:	21 60       	ori	r18, 0x01	; 1
    2f2a:	fc 01       	movw	r30, r24
    2f2c:	20 83       	st	Z, r18
	ddrMAINen |= (1 << bnMAINen);
    2f2e:	87 e2       	ldi	r24, 0x27	; 39
    2f30:	90 e0       	ldi	r25, 0x00	; 0
    2f32:	27 e2       	ldi	r18, 0x27	; 39
    2f34:	30 e0       	ldi	r19, 0x00	; 0
    2f36:	f9 01       	movw	r30, r18
    2f38:	20 81       	ld	r18, Z
    2f3a:	21 60       	ori	r18, 0x01	; 1
    2f3c:	fc 01       	movw	r30, r24
    2f3e:	20 83       	st	Z, r18
	__killMain();
    2f40:	88 e2       	ldi	r24, 0x28	; 40
    2f42:	90 e0       	ldi	r25, 0x00	; 0
    2f44:	28 e2       	ldi	r18, 0x28	; 40
    2f46:	30 e0       	ldi	r19, 0x00	; 0
    2f48:	f9 01       	movw	r30, r18
    2f4a:	20 81       	ld	r18, Z
    2f4c:	2e 7f       	andi	r18, 0xFE	; 254
    2f4e:	fc 01       	movw	r30, r24
    2f50:	20 83       	st	Z, r18
	__killBeagleBone();
    2f52:	82 e2       	ldi	r24, 0x22	; 34
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	22 e2       	ldi	r18, 0x22	; 34
    2f58:	30 e0       	ldi	r19, 0x00	; 0
    2f5a:	f9 01       	movw	r30, r18
    2f5c:	20 81       	ld	r18, Z
    2f5e:	2f 7e       	andi	r18, 0xEF	; 239
    2f60:	fc 01       	movw	r30, r24
    2f62:	20 83       	st	Z, r18
	__enableTemp();
    2f64:	85 e2       	ldi	r24, 0x25	; 37
    2f66:	90 e0       	ldi	r25, 0x00	; 0
    2f68:	25 e2       	ldi	r18, 0x25	; 37
    2f6a:	30 e0       	ldi	r19, 0x00	; 0
    2f6c:	f9 01       	movw	r30, r18
    2f6e:	20 81       	ld	r18, Z
    2f70:	21 60       	ori	r18, 0x01	; 1
    2f72:	fc 01       	movw	r30, r24
    2f74:	20 83       	st	Z, r18
	__killLCD();
    2f76:	82 e2       	ldi	r24, 0x22	; 34
    2f78:	90 e0       	ldi	r25, 0x00	; 0
    2f7a:	22 e2       	ldi	r18, 0x22	; 34
    2f7c:	30 e0       	ldi	r19, 0x00	; 0
    2f7e:	f9 01       	movw	r30, r18
    2f80:	20 81       	ld	r18, Z
    2f82:	2f 7d       	andi	r18, 0xDF	; 223
    2f84:	fc 01       	movw	r30, r24
    2f86:	20 83       	st	Z, r18
	__killGPSandGAVR();
    2f88:	82 e2       	ldi	r24, 0x22	; 34
    2f8a:	90 e0       	ldi	r25, 0x00	; 0
    2f8c:	22 e2       	ldi	r18, 0x22	; 34
    2f8e:	30 e0       	ldi	r19, 0x00	; 0
    2f90:	f9 01       	movw	r30, r18
    2f92:	20 81       	ld	r18, Z
    2f94:	2f 73       	andi	r18, 0x3F	; 63
    2f96:	fc 01       	movw	r30, r24
    2f98:	20 83       	st	Z, r18

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	__killCommINT();
    2f9a:	8d e3       	ldi	r24, 0x3D	; 61
    2f9c:	90 e0       	ldi	r25, 0x00	; 0
    2f9e:	fc 01       	movw	r30, r24
    2fa0:	10 82       	st	Z, r1
    2fa2:	8d e6       	ldi	r24, 0x6D	; 109
    2fa4:	90 e0       	ldi	r25, 0x00	; 0
    2fa6:	fc 01       	movw	r30, r24
    2fa8:	10 82       	st	Z, r1
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    2faa:	89 e6       	ldi	r24, 0x69	; 105
    2fac:	90 e0       	ldi	r25, 0x00	; 0
    2fae:	20 e3       	ldi	r18, 0x30	; 48
    2fb0:	fc 01       	movw	r30, r24
    2fb2:	20 83       	st	Z, r18
	//Enable PCINT17
	PCICR |= (1 << PCIE0);
    2fb4:	88 e6       	ldi	r24, 0x68	; 104
    2fb6:	90 e0       	ldi	r25, 0x00	; 0
    2fb8:	28 e6       	ldi	r18, 0x68	; 104
    2fba:	30 e0       	ldi	r19, 0x00	; 0
    2fbc:	f9 01       	movw	r30, r18
    2fbe:	20 81       	ld	r18, Z
    2fc0:	21 60       	ori	r18, 0x01	; 1
    2fc2:	fc 01       	movw	r30, r24
    2fc4:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    2fc6:	84 e2       	ldi	r24, 0x24	; 36
    2fc8:	90 e0       	ldi	r25, 0x00	; 0
    2fca:	24 e2       	ldi	r18, 0x24	; 36
    2fcc:	30 e0       	ldi	r19, 0x00	; 0
    2fce:	f9 01       	movw	r30, r18
    2fd0:	20 81       	ld	r18, Z
    2fd2:	20 6b       	ori	r18, 0xB0	; 176
    2fd4:	fc 01       	movw	r30, r24
    2fd6:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    2fd8:	84 e2       	ldi	r24, 0x24	; 36
    2fda:	90 e0       	ldi	r25, 0x00	; 0
    2fdc:	24 e2       	ldi	r18, 0x24	; 36
    2fde:	30 e0       	ldi	r19, 0x00	; 0
    2fe0:	f9 01       	movw	r30, r18
    2fe2:	20 81       	ld	r18, Z
    2fe4:	2f 7b       	andi	r18, 0xBF	; 191
    2fe6:	fc 01       	movw	r30, r24
    2fe8:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    2fea:	85 e2       	ldi	r24, 0x25	; 37
    2fec:	90 e0       	ldi	r25, 0x00	; 0
    2fee:	25 e2       	ldi	r18, 0x25	; 37
    2ff0:	30 e0       	ldi	r19, 0x00	; 0
    2ff2:	f9 01       	movw	r30, r18
    2ff4:	20 81       	ld	r18, Z
    2ff6:	20 69       	ori	r18, 0x90	; 144
    2ff8:	fc 01       	movw	r30, r24
    2ffa:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    2ffc:	85 e2       	ldi	r24, 0x25	; 37
    2ffe:	90 e0       	ldi	r25, 0x00	; 0
    3000:	25 e2       	ldi	r18, 0x25	; 37
    3002:	30 e0       	ldi	r19, 0x00	; 0
    3004:	f9 01       	movw	r30, r18
    3006:	20 81       	ld	r18, Z
    3008:	2f 7d       	andi	r18, 0xDF	; 223
    300a:	fc 01       	movw	r30, r24
    300c:	20 83       	st	Z, r18
	
}
    300e:	0f 90       	pop	r0
    3010:	0f 90       	pop	r0
    3012:	df 91       	pop	r29
    3014:	cf 91       	pop	r28
    3016:	08 95       	ret

00003018 <_Z9InitBoolsv>:
/*************************************************************************************************************/
void InitBools(){
    3018:	cf 93       	push	r28
    301a:	df 93       	push	r29
    301c:	cd b7       	in	r28, 0x3d	; 61
    301e:	de b7       	in	r29, 0x3e	; 62
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    3020:	81 e0       	ldi	r24, 0x01	; 1
    3022:	80 93 81 01 	sts	0x0181, r24
	flagReceivingBone = fFalse;
    3026:	10 92 ca 01 	sts	0x01CA, r1
	flagNormalMode=fTrue;
    302a:	81 e0       	ldi	r24, 0x01	; 1
    302c:	80 93 cb 01 	sts	0x01CB, r24
	flagReceivingGAVR=fFalse;
    3030:	10 92 cc 01 	sts	0x01CC, r1
	flagWaitingForReceiveGAVR=fFalse;
    3034:	10 92 cd 01 	sts	0x01CD, r1

	flagUpdateGAVRClock=fFalse;
    3038:	10 92 ce 01 	sts	0x01CE, r1
	flagSendingGAVR=fFalse;
    303c:	10 92 cf 01 	sts	0x01CF, r1
	flagUserClock=fFalse;
    3040:	10 92 d0 01 	sts	0x01D0, r1
	flagInvalidDateTime=fFalse;
    3044:	10 92 d1 01 	sts	0x01D1, r1
	flagWaitingToSendGAVR=fFalse;
    3048:	10 92 d2 01 	sts	0x01D2, r1
	flagGPSTime=fFalse;
    304c:	10 92 d3 01 	sts	0x01D3, r1
	
	restart=fFalse;
    3050:	10 92 d8 01 	sts	0x01D8, r1
	//flagNewShutdown=fFalse;
	flagShutdown=fFalse;		//Initialized in startup procedure in beginning of "main"
    3054:	10 92 d5 01 	sts	0x01D5, r1
	flagGoodVolts=fFalse;
    3058:	10 92 d7 01 	sts	0x01D7, r1
	flagGoodTemp=fFalse;
    305c:	10 92 d6 01 	sts	0x01D6, r1
	//flagFreshStart=fTrue;		//Initialized in startup procedure in beginning of "main"
}
    3060:	df 91       	pop	r29
    3062:	cf 91       	pop	r28
    3064:	08 95       	ret

00003066 <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    3066:	cf 93       	push	r28
    3068:	df 93       	push	r29
    306a:	cd b7       	in	r28, 0x3d	; 61
    306c:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    306e:	84 e6       	ldi	r24, 0x64	; 100
    3070:	90 e0       	ldi	r25, 0x00	; 0
    3072:	24 e6       	ldi	r18, 0x64	; 100
    3074:	30 e0       	ldi	r19, 0x00	; 0
    3076:	f9 01       	movw	r30, r18
    3078:	20 81       	ld	r18, Z
    307a:	2f 7b       	andi	r18, 0xBF	; 191
    307c:	fc 01       	movw	r30, r24
    307e:	20 83       	st	Z, r18
	Wait_ms(5);	//give it time to power on
    3080:	85 e0       	ldi	r24, 0x05	; 5
    3082:	90 e0       	ldi	r25, 0x00	; 0
    3084:	0e 94 71 18 	call	0x30e2	; 0x30e2 <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    3088:	86 eb       	ldi	r24, 0xB6	; 182
    308a:	90 e0       	ldi	r25, 0x00	; 0
    308c:	26 eb       	ldi	r18, 0xB6	; 182
    308e:	30 e0       	ldi	r19, 0x00	; 0
    3090:	f9 01       	movw	r30, r18
    3092:	20 81       	ld	r18, Z
    3094:	20 62       	ori	r18, 0x20	; 32
    3096:	fc 01       	movw	r30, r24
    3098:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    309a:	81 eb       	ldi	r24, 0xB1	; 177
    309c:	90 e0       	ldi	r25, 0x00	; 0
    309e:	21 eb       	ldi	r18, 0xB1	; 177
    30a0:	30 e0       	ldi	r19, 0x00	; 0
    30a2:	f9 01       	movw	r30, r18
    30a4:	20 81       	ld	r18, Z
    30a6:	25 60       	ori	r18, 0x05	; 5
    30a8:	fc 01       	movw	r30, r24
    30aa:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    30ac:	86 eb       	ldi	r24, 0xB6	; 182
    30ae:	90 e0       	ldi	r25, 0x00	; 0
    30b0:	fc 01       	movw	r30, r24
    30b2:	80 81       	ld	r24, Z
    30b4:	88 2f       	mov	r24, r24
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	81 71       	andi	r24, 0x11	; 17
    30ba:	90 70       	andi	r25, 0x00	; 0
    30bc:	21 e0       	ldi	r18, 0x01	; 1
    30be:	00 97       	sbiw	r24, 0x00	; 0
    30c0:	09 f4       	brne	.+2      	; 0x30c4 <_Z14EnableRTCTimerv+0x5e>
    30c2:	20 e0       	ldi	r18, 0x00	; 0
    30c4:	22 23       	and	r18, r18
    30c6:	91 f7       	brne	.-28     	; 0x30ac <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    30c8:	87 e3       	ldi	r24, 0x37	; 55
    30ca:	90 e0       	ldi	r25, 0x00	; 0
    30cc:	21 e0       	ldi	r18, 0x01	; 1
    30ce:	fc 01       	movw	r30, r24
    30d0:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    30d2:	80 e7       	ldi	r24, 0x70	; 112
    30d4:	90 e0       	ldi	r25, 0x00	; 0
    30d6:	21 e0       	ldi	r18, 0x01	; 1
    30d8:	fc 01       	movw	r30, r24
    30da:	20 83       	st	Z, r18
	
	//Away we go
}
    30dc:	df 91       	pop	r29
    30de:	cf 91       	pop	r28
    30e0:	08 95       	ret

000030e2 <_Z7Wait_msi>:
/*************************************************************************************************************/
void Wait_ms(int delay)
{
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	00 d0       	rcall	.+0      	; 0x30e8 <_Z7Wait_msi+0x6>
    30e8:	00 d0       	rcall	.+0      	; 0x30ea <_Z7Wait_msi+0x8>
    30ea:	cd b7       	in	r28, 0x3d	; 61
    30ec:	de b7       	in	r29, 0x3e	; 62
    30ee:	9c 83       	std	Y+4, r25	; 0x04
    30f0:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    30f2:	17 c0       	rjmp	.+46     	; 0x3122 <_Z7Wait_msi+0x40>
		for(i = 0; i < 200; i++){
    30f4:	1a 82       	std	Y+2, r1	; 0x02
    30f6:	19 82       	std	Y+1, r1	; 0x01
    30f8:	06 c0       	rjmp	.+12     	; 0x3106 <_Z7Wait_msi+0x24>
			asm volatile("nop");
    30fa:	00 00       	nop
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 200; i++){
    30fc:	89 81       	ldd	r24, Y+1	; 0x01
    30fe:	9a 81       	ldd	r25, Y+2	; 0x02
    3100:	01 96       	adiw	r24, 0x01	; 1
    3102:	9a 83       	std	Y+2, r25	; 0x02
    3104:	89 83       	std	Y+1, r24	; 0x01
    3106:	89 81       	ldd	r24, Y+1	; 0x01
    3108:	9a 81       	ldd	r25, Y+2	; 0x02
    310a:	21 e0       	ldi	r18, 0x01	; 1
    310c:	88 3c       	cpi	r24, 0xC8	; 200
    310e:	91 05       	cpc	r25, r1
    3110:	0c f0       	brlt	.+2      	; 0x3114 <_Z7Wait_msi+0x32>
    3112:	20 e0       	ldi	r18, 0x00	; 0
    3114:	22 23       	and	r18, r18
    3116:	89 f7       	brne	.-30     	; 0x30fa <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    3118:	8b 81       	ldd	r24, Y+3	; 0x03
    311a:	9c 81       	ldd	r25, Y+4	; 0x04
    311c:	01 97       	sbiw	r24, 0x01	; 1
    311e:	9c 83       	std	Y+4, r25	; 0x04
    3120:	8b 83       	std	Y+3, r24	; 0x03
/*************************************************************************************************************/
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
    3122:	21 e0       	ldi	r18, 0x01	; 1
    3124:	8b 81       	ldd	r24, Y+3	; 0x03
    3126:	9c 81       	ldd	r25, Y+4	; 0x04
    3128:	18 16       	cp	r1, r24
    312a:	19 06       	cpc	r1, r25
    312c:	0c f0       	brlt	.+2      	; 0x3130 <_Z7Wait_msi+0x4e>
    312e:	20 e0       	ldi	r18, 0x00	; 0
    3130:	22 23       	and	r18, r18
    3132:	01 f7       	brne	.-64     	; 0x30f4 <_Z7Wait_msi+0x12>
		for(i = 0; i < 200; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    3134:	0f 90       	pop	r0
    3136:	0f 90       	pop	r0
    3138:	0f 90       	pop	r0
    313a:	0f 90       	pop	r0
    313c:	df 91       	pop	r29
    313e:	cf 91       	pop	r28
    3140:	08 95       	ret

00003142 <_Z8Wait_seci>:
/************************************************************************************************************/
void Wait_sec(int sec){
    3142:	cf 93       	push	r28
    3144:	df 93       	push	r29
    3146:	00 d0       	rcall	.+0      	; 0x3148 <_Z8Wait_seci+0x6>
    3148:	00 d0       	rcall	.+0      	; 0x314a <_Z8Wait_seci+0x8>
    314a:	00 d0       	rcall	.+0      	; 0x314c <_Z8Wait_seci+0xa>
    314c:	cd b7       	in	r28, 0x3d	; 61
    314e:	de b7       	in	r29, 0x3e	; 62
    3150:	9e 83       	std	Y+6, r25	; 0x06
    3152:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    3154:	82 ea       	ldi	r24, 0xA2	; 162
    3156:	91 e0       	ldi	r25, 0x01	; 1
    3158:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    315c:	88 2f       	mov	r24, r24
    315e:	90 e0       	ldi	r25, 0x00	; 0
    3160:	9a 83       	std	Y+2, r25	; 0x02
    3162:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    3164:	29 81       	ldd	r18, Y+1	; 0x01
    3166:	3a 81       	ldd	r19, Y+2	; 0x02
    3168:	8d 81       	ldd	r24, Y+5	; 0x05
    316a:	9e 81       	ldd	r25, Y+6	; 0x06
    316c:	82 0f       	add	r24, r18
    316e:	93 1f       	adc	r25, r19
    3170:	2c e3       	ldi	r18, 0x3C	; 60
    3172:	30 e0       	ldi	r19, 0x00	; 0
    3174:	b9 01       	movw	r22, r18
    3176:	0e 94 63 1b 	call	0x36c6	; 0x36c6 <__divmodhi4>
    317a:	9c 83       	std	Y+4, r25	; 0x04
    317c:	8b 83       	std	Y+3, r24	; 0x03
	while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    317e:	01 c0       	rjmp	.+2      	; 0x3182 <_Z8Wait_seci+0x40>
    3180:	00 00       	nop
    3182:	82 ea       	ldi	r24, 0xA2	; 162
    3184:	91 e0       	ldi	r25, 0x01	; 1
    3186:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    318a:	28 2f       	mov	r18, r24
    318c:	30 e0       	ldi	r19, 0x00	; 0
    318e:	8b 81       	ldd	r24, Y+3	; 0x03
    3190:	9c 81       	ldd	r25, Y+4	; 0x04
    3192:	41 e0       	ldi	r20, 0x01	; 1
    3194:	28 17       	cp	r18, r24
    3196:	39 07       	cpc	r19, r25
    3198:	09 f4       	brne	.+2      	; 0x319c <_Z8Wait_seci+0x5a>
    319a:	40 e0       	ldi	r20, 0x00	; 0
    319c:	44 23       	and	r20, r20
    319e:	81 f7       	brne	.-32     	; 0x3180 <_Z8Wait_seci+0x3e>
}
    31a0:	26 96       	adiw	r28, 0x06	; 6
    31a2:	0f b6       	in	r0, 0x3f	; 63
    31a4:	f8 94       	cli
    31a6:	de bf       	out	0x3e, r29	; 62
    31a8:	0f be       	out	0x3f, r0	; 63
    31aa:	cd bf       	out	0x3d, r28	; 61
    31ac:	df 91       	pop	r29
    31ae:	cf 91       	pop	r28
    31b0:	08 95       	ret

000031b2 <_Z9GoToSleeph>:

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    31b2:	cf 93       	push	r28
    31b4:	df 93       	push	r29
    31b6:	00 d0       	rcall	.+0      	; 0x31b8 <_Z9GoToSleeph+0x6>
    31b8:	00 d0       	rcall	.+0      	; 0x31ba <_Z9GoToSleeph+0x8>
    31ba:	0f 92       	push	r0
    31bc:	cd b7       	in	r28, 0x3d	; 61
    31be:	de b7       	in	r29, 0x3e	; 62
    31c0:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    31c2:	78 94       	sei
		int sleepTime, sleepTicks = 0;
    31c4:	1c 82       	std	Y+4, r1	; 0x04
    31c6:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong){
    31c8:	8d 81       	ldd	r24, Y+5	; 0x05
    31ca:	88 23       	and	r24, r24
    31cc:	29 f0       	breq	.+10     	; 0x31d8 <_Z9GoToSleeph+0x26>
			sleepTime = SLEEP_TICKS_LOWV;
    31ce:	8c e0       	ldi	r24, 0x0C	; 12
    31d0:	90 e0       	ldi	r25, 0x00	; 0
    31d2:	9a 83       	std	Y+2, r25	; 0x02
    31d4:	89 83       	std	Y+1, r24	; 0x01
    31d6:	04 c0       	rjmp	.+8      	; 0x31e0 <_Z9GoToSleeph+0x2e>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    31d8:	8a e0       	ldi	r24, 0x0A	; 10
    31da:	90 e0       	ldi	r25, 0x00	; 0
    31dc:	9a 83       	std	Y+2, r25	; 0x02
    31de:	89 83       	std	Y+1, r24	; 0x01
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    31e0:	88 e2       	ldi	r24, 0x28	; 40
    31e2:	90 e0       	ldi	r25, 0x00	; 0
    31e4:	28 e2       	ldi	r18, 0x28	; 40
    31e6:	30 e0       	ldi	r19, 0x00	; 0
    31e8:	f9 01       	movw	r30, r18
    31ea:	20 81       	ld	r18, Z
    31ec:	2b 7f       	andi	r18, 0xFB	; 251
    31ee:	fc 01       	movw	r30, r24
    31f0:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    31f2:	83 e5       	ldi	r24, 0x53	; 83
    31f4:	90 e0       	ldi	r25, 0x00	; 0
    31f6:	26 e0       	ldi	r18, 0x06	; 6
    31f8:	fc 01       	movw	r30, r24
    31fa:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    31fc:	83 e5       	ldi	r24, 0x53	; 83
    31fe:	90 e0       	ldi	r25, 0x00	; 0
    3200:	23 e5       	ldi	r18, 0x53	; 83
    3202:	30 e0       	ldi	r19, 0x00	; 0
    3204:	f9 01       	movw	r30, r18
    3206:	20 81       	ld	r18, Z
    3208:	21 60       	ori	r18, 0x01	; 1
    320a:	fc 01       	movw	r30, r24
    320c:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    320e:	81 e0       	ldi	r24, 0x01	; 1
    3210:	90 e0       	ldi	r25, 0x00	; 0
    3212:	0e 94 71 18 	call	0x30e2	; 0x30e2 <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime){
    3216:	06 c0       	rjmp	.+12     	; 0x3224 <_Z9GoToSleeph+0x72>
			asm volatile("SLEEP");
    3218:	88 95       	sleep
			sleepTicks++;
    321a:	8b 81       	ldd	r24, Y+3	; 0x03
    321c:	9c 81       	ldd	r25, Y+4	; 0x04
    321e:	01 96       	adiw	r24, 0x01	; 1
    3220:	9c 83       	std	Y+4, r25	; 0x04
    3222:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime){
    3224:	41 e0       	ldi	r20, 0x01	; 1
    3226:	2b 81       	ldd	r18, Y+3	; 0x03
    3228:	3c 81       	ldd	r19, Y+4	; 0x04
    322a:	89 81       	ldd	r24, Y+1	; 0x01
    322c:	9a 81       	ldd	r25, Y+2	; 0x02
    322e:	28 17       	cp	r18, r24
    3230:	39 07       	cpc	r19, r25
    3232:	0c f0       	brlt	.+2      	; 0x3236 <_Z9GoToSleeph+0x84>
    3234:	40 e0       	ldi	r20, 0x00	; 0
    3236:	44 23       	and	r20, r20
    3238:	79 f7       	brne	.-34     	; 0x3218 <_Z9GoToSleeph+0x66>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(1);
    323a:	81 e0       	ldi	r24, 0x01	; 1
    323c:	90 e0       	ldi	r25, 0x00	; 0
    323e:	0e 94 71 18 	call	0x30e2	; 0x30e2 <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSTATUSled |= (1 << bnSTATUSled);
    3242:	88 e2       	ldi	r24, 0x28	; 40
    3244:	90 e0       	ldi	r25, 0x00	; 0
    3246:	28 e2       	ldi	r18, 0x28	; 40
    3248:	30 e0       	ldi	r19, 0x00	; 0
    324a:	f9 01       	movw	r30, r18
    324c:	20 81       	ld	r18, Z
    324e:	24 60       	ori	r18, 0x04	; 4
    3250:	fc 01       	movw	r30, r24
    3252:	20 83       	st	Z, r18
}
    3254:	0f 90       	pop	r0
    3256:	0f 90       	pop	r0
    3258:	0f 90       	pop	r0
    325a:	0f 90       	pop	r0
    325c:	0f 90       	pop	r0
    325e:	df 91       	pop	r29
    3260:	cf 91       	pop	r28
    3262:	08 95       	ret

00003264 <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    3264:	cf 93       	push	r28
    3266:	df 93       	push	r29
    3268:	cd b7       	in	r28, 0x3d	; 61
    326a:	de b7       	in	r29, 0x3e	; 62
    326c:	2e 97       	sbiw	r28, 0x0e	; 14
    326e:	0f b6       	in	r0, 0x3f	; 63
    3270:	f8 94       	cli
    3272:	de bf       	out	0x3e, r29	; 62
    3274:	0f be       	out	0x3f, r0	; 63
    3276:	cd bf       	out	0x3d, r28	; 61
	WORD adcReading = 0;
    3278:	1c 82       	std	Y+4, r1	; 0x04
    327a:	1b 82       	std	Y+3, r1	; 0x03
	
	prtInterrupts |= (1 << bnBBint);
    327c:	82 e2       	ldi	r24, 0x22	; 34
    327e:	90 e0       	ldi	r25, 0x00	; 0
    3280:	22 e2       	ldi	r18, 0x22	; 34
    3282:	30 e0       	ldi	r19, 0x00	; 0
    3284:	f9 01       	movw	r30, r18
    3286:	20 81       	ld	r18, Z
    3288:	24 60       	ori	r18, 0x04	; 4
    328a:	fc 01       	movw	r30, r24
    328c:	20 83       	st	Z, r18
	
	__killCommINT();
    328e:	8d e3       	ldi	r24, 0x3D	; 61
    3290:	90 e0       	ldi	r25, 0x00	; 0
    3292:	fc 01       	movw	r30, r24
    3294:	10 82       	st	Z, r1
    3296:	8d e6       	ldi	r24, 0x6D	; 109
    3298:	90 e0       	ldi	r25, 0x00	; 0
    329a:	fc 01       	movw	r30, r24
    329c:	10 82       	st	Z, r1
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    329e:	84 e6       	ldi	r24, 0x64	; 100
    32a0:	90 e0       	ldi	r25, 0x00	; 0
    32a2:	24 e6       	ldi	r18, 0x64	; 100
    32a4:	30 e0       	ldi	r19, 0x00	; 0
    32a6:	f9 01       	movw	r30, r18
    32a8:	20 81       	ld	r18, Z
    32aa:	2e 7f       	andi	r18, 0xFE	; 254
    32ac:	fc 01       	movw	r30, r24
    32ae:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    32b0:	8c e7       	ldi	r24, 0x7C	; 124
    32b2:	90 e0       	ldi	r25, 0x00	; 0
    32b4:	2c e7       	ldi	r18, 0x7C	; 124
    32b6:	30 e0       	ldi	r19, 0x00	; 0
    32b8:	f9 01       	movw	r30, r18
    32ba:	20 81       	ld	r18, Z
    32bc:	20 68       	ori	r18, 0x80	; 128
    32be:	fc 01       	movw	r30, r24
    32c0:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    32c2:	8a e7       	ldi	r24, 0x7A	; 122
    32c4:	90 e0       	ldi	r25, 0x00	; 0
    32c6:	2a e7       	ldi	r18, 0x7A	; 122
    32c8:	30 e0       	ldi	r19, 0x00	; 0
    32ca:	f9 01       	movw	r30, r18
    32cc:	20 81       	ld	r18, Z
    32ce:	24 68       	ori	r18, 0x84	; 132
    32d0:	fc 01       	movw	r30, r24
    32d2:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    32d4:	8e e7       	ldi	r24, 0x7E	; 126
    32d6:	90 e0       	ldi	r25, 0x00	; 0
    32d8:	2e ef       	ldi	r18, 0xFE	; 254
    32da:	fc 01       	movw	r30, r24
    32dc:	20 83       	st	Z, r18
	Wait_ms(100);									//Tim for registers to setup
    32de:	84 e6       	ldi	r24, 0x64	; 100
    32e0:	90 e0       	ldi	r25, 0x00	; 0
    32e2:	0e 94 71 18 	call	0x30e2	; 0x30e2 <_Z7Wait_msi>
	
	//cli();
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    32e6:	1a 82       	std	Y+2, r1	; 0x02
    32e8:	19 82       	std	Y+1, r1	; 0x01
    32ea:	1c c0       	rjmp	.+56     	; 0x3324 <_Z7TakeADCv+0xc0>
    32ec:	8a e7       	ldi	r24, 0x7A	; 122
    32ee:	90 e0       	ldi	r25, 0x00	; 0
    32f0:	2a e7       	ldi	r18, 0x7A	; 122
    32f2:	30 e0       	ldi	r19, 0x00	; 0
    32f4:	f9 01       	movw	r30, r18
    32f6:	20 81       	ld	r18, Z
    32f8:	20 64       	ori	r18, 0x40	; 64
    32fa:	fc 01       	movw	r30, r24
    32fc:	20 83       	st	Z, r18
    32fe:	8a e7       	ldi	r24, 0x7A	; 122
    3300:	90 e0       	ldi	r25, 0x00	; 0
    3302:	fc 01       	movw	r30, r24
    3304:	80 81       	ld	r24, Z
    3306:	88 2f       	mov	r24, r24
    3308:	90 e0       	ldi	r25, 0x00	; 0
    330a:	80 74       	andi	r24, 0x40	; 64
    330c:	90 70       	andi	r25, 0x00	; 0
    330e:	21 e0       	ldi	r18, 0x01	; 1
    3310:	00 97       	sbiw	r24, 0x00	; 0
    3312:	09 f4       	brne	.+2      	; 0x3316 <_Z7TakeADCv+0xb2>
    3314:	20 e0       	ldi	r18, 0x00	; 0
    3316:	22 23       	and	r18, r18
    3318:	91 f7       	brne	.-28     	; 0x32fe <_Z7TakeADCv+0x9a>
    331a:	89 81       	ldd	r24, Y+1	; 0x01
    331c:	9a 81       	ldd	r25, Y+2	; 0x02
    331e:	01 96       	adiw	r24, 0x01	; 1
    3320:	9a 83       	std	Y+2, r25	; 0x02
    3322:	89 83       	std	Y+1, r24	; 0x01
    3324:	21 e0       	ldi	r18, 0x01	; 1
    3326:	89 81       	ldd	r24, Y+1	; 0x01
    3328:	9a 81       	ldd	r25, Y+2	; 0x02
    332a:	82 30       	cpi	r24, 0x02	; 2
    332c:	91 05       	cpc	r25, r1
    332e:	0c f0       	brlt	.+2      	; 0x3332 <_Z7TakeADCv+0xce>
    3330:	20 e0       	ldi	r18, 0x00	; 0
    3332:	22 23       	and	r18, r18
    3334:	d9 f6       	brne	.-74     	; 0x32ec <_Z7TakeADCv+0x88>
	
	//Re-enable interrupts	
	//sei();
	
	//Put conversion into buffer
	adcReading = ADCL;
    3336:	88 e7       	ldi	r24, 0x78	; 120
    3338:	90 e0       	ldi	r25, 0x00	; 0
    333a:	fc 01       	movw	r30, r24
    333c:	80 81       	ld	r24, Z
    333e:	88 2f       	mov	r24, r24
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	9c 83       	std	Y+4, r25	; 0x04
    3344:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    3346:	89 e7       	ldi	r24, 0x79	; 121
    3348:	90 e0       	ldi	r25, 0x00	; 0
    334a:	fc 01       	movw	r30, r24
    334c:	80 81       	ld	r24, Z
    334e:	88 2f       	mov	r24, r24
    3350:	90 e0       	ldi	r25, 0x00	; 0
    3352:	98 2f       	mov	r25, r24
    3354:	88 27       	eor	r24, r24
    3356:	2b 81       	ldd	r18, Y+3	; 0x03
    3358:	3c 81       	ldd	r19, Y+4	; 0x04
    335a:	82 2b       	or	r24, r18
    335c:	93 2b       	or	r25, r19
    335e:	9c 83       	std	Y+4, r25	; 0x04
    3360:	8b 83       	std	Y+3, r24	; 0x03
		
	//Assign global reading and set flag
	globalADC=adcReading;
    3362:	8b 81       	ldd	r24, Y+3	; 0x03
    3364:	9c 81       	ldd	r25, Y+4	; 0x04
    3366:	90 93 9f 01 	sts	0x019F, r25
    336a:	80 93 9e 01 	sts	0x019E, r24
	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    336e:	21 e0       	ldi	r18, 0x01	; 1
    3370:	8b 81       	ldd	r24, Y+3	; 0x03
    3372:	9c 81       	ldd	r25, Y+4	; 0x04
    3374:	f2 e0       	ldi	r31, 0x02	; 2
    3376:	8c 3b       	cpi	r24, 0xBC	; 188
    3378:	9f 07       	cpc	r25, r31
    337a:	08 f4       	brcc	.+2      	; 0x337e <_Z7TakeADCv+0x11a>
    337c:	20 e0       	ldi	r18, 0x00	; 0
    337e:	20 93 d7 01 	sts	0x01D7, r18
		
	//Disable ADC hardware/registers
	ADCSRA = 0;
    3382:	8a e7       	ldi	r24, 0x7A	; 122
    3384:	90 e0       	ldi	r25, 0x00	; 0
    3386:	fc 01       	movw	r30, r24
    3388:	10 82       	st	Z, r1
	ADMUX = 0;
    338a:	8c e7       	ldi	r24, 0x7C	; 124
    338c:	90 e0       	ldi	r25, 0x00	; 0
    338e:	fc 01       	movw	r30, r24
    3390:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    3392:	8e e7       	ldi	r24, 0x7E	; 126
    3394:	90 e0       	ldi	r25, 0x00	; 0
    3396:	2e e7       	ldi	r18, 0x7E	; 126
    3398:	30 e0       	ldi	r19, 0x00	; 0
    339a:	f9 01       	movw	r30, r18
    339c:	20 81       	ld	r18, Z
    339e:	21 60       	ori	r18, 0x01	; 1
    33a0:	fc 01       	movw	r30, r24
    33a2:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    33a4:	84 e6       	ldi	r24, 0x64	; 100
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	24 e6       	ldi	r18, 0x64	; 100
    33aa:	30 e0       	ldi	r19, 0x00	; 0
    33ac:	f9 01       	movw	r30, r18
    33ae:	20 81       	ld	r18, Z
    33b0:	21 60       	ori	r18, 0x01	; 1
    33b2:	fc 01       	movw	r30, r24
    33b4:	20 83       	st	Z, r18

	char tempString[10];
	itoa(globalADC,tempString,10);
    33b6:	80 91 9e 01 	lds	r24, 0x019E
    33ba:	90 91 9f 01 	lds	r25, 0x019F
    33be:	9e 01       	movw	r18, r28
    33c0:	2b 5f       	subi	r18, 0xFB	; 251
    33c2:	3f 4f       	sbci	r19, 0xFF	; 255
    33c4:	b9 01       	movw	r22, r18
    33c6:	4a e0       	ldi	r20, 0x0A	; 10
    33c8:	50 e0       	ldi	r21, 0x00	; 0
    33ca:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <itoa>
	tempString[9]='\0';
    33ce:	1e 86       	std	Y+14, r1	; 0x0e
	//PrintBone("ADC: ");
	//PrintBone(tempString);
	prtInterrupts &= ~(1 << bnBBint);
    33d0:	82 e2       	ldi	r24, 0x22	; 34
    33d2:	90 e0       	ldi	r25, 0x00	; 0
    33d4:	22 e2       	ldi	r18, 0x22	; 34
    33d6:	30 e0       	ldi	r19, 0x00	; 0
    33d8:	f9 01       	movw	r30, r18
    33da:	20 81       	ld	r18, Z
    33dc:	2b 7f       	andi	r18, 0xFB	; 251
    33de:	fc 01       	movw	r30, r24
    33e0:	20 83       	st	Z, r18
	__enableCommINT();
    33e2:	8d e3       	ldi	r24, 0x3D	; 61
    33e4:	90 e0       	ldi	r25, 0x00	; 0
    33e6:	2d e3       	ldi	r18, 0x3D	; 61
    33e8:	30 e0       	ldi	r19, 0x00	; 0
    33ea:	f9 01       	movw	r30, r18
    33ec:	20 81       	ld	r18, Z
    33ee:	24 60       	ori	r18, 0x04	; 4
    33f0:	fc 01       	movw	r30, r24
    33f2:	20 83       	st	Z, r18
    33f4:	8d e6       	ldi	r24, 0x6D	; 109
    33f6:	90 e0       	ldi	r25, 0x00	; 0
    33f8:	22 e0       	ldi	r18, 0x02	; 2
    33fa:	fc 01       	movw	r30, r24
    33fc:	20 83       	st	Z, r18
}
    33fe:	2e 96       	adiw	r28, 0x0e	; 14
    3400:	0f b6       	in	r0, 0x3f	; 63
    3402:	f8 94       	cli
    3404:	de bf       	out	0x3e, r29	; 62
    3406:	0f be       	out	0x3f, r0	; 63
    3408:	cd bf       	out	0x3d, r28	; 61
    340a:	df 91       	pop	r29
    340c:	cf 91       	pop	r28
    340e:	08 95       	ret

00003410 <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    3410:	cf 93       	push	r28
    3412:	df 93       	push	r29
    3414:	cd b7       	in	r28, 0x3d	; 61
    3416:	de b7       	in	r29, 0x3e	; 62
    3418:	2b 97       	sbiw	r28, 0x0b	; 11
    341a:	0f b6       	in	r0, 0x3f	; 63
    341c:	f8 94       	cli
    341e:	de bf       	out	0x3e, r29	; 62
    3420:	0f be       	out	0x3f, r0	; 63
    3422:	cd bf       	out	0x3d, r28	; 61
	WORD rawTemp = 0;
    3424:	1a 82       	std	Y+2, r1	; 0x02
    3426:	19 82       	std	Y+1, r1	; 0x01
	
	//Power on temp monitor, let it settle
	//__enableTemp();
	PRR0 &= ~(1 << PRSPI);	
    3428:	84 e6       	ldi	r24, 0x64	; 100
    342a:	90 e0       	ldi	r25, 0x00	; 0
    342c:	24 e6       	ldi	r18, 0x64	; 100
    342e:	30 e0       	ldi	r19, 0x00	; 0
    3430:	f9 01       	movw	r30, r18
    3432:	20 81       	ld	r18, Z
    3434:	2b 7f       	andi	r18, 0xFB	; 251
    3436:	fc 01       	movw	r30, r24
    3438:	20 83       	st	Z, r18
	SPCR |= (1 << MSTR)|(1 << SPE)|(1 << SPR0);			//enables SPI, master, fck/64
    343a:	8c e4       	ldi	r24, 0x4C	; 76
    343c:	90 e0       	ldi	r25, 0x00	; 0
    343e:	2c e4       	ldi	r18, 0x4C	; 76
    3440:	30 e0       	ldi	r19, 0x00	; 0
    3442:	f9 01       	movw	r30, r18
    3444:	20 81       	ld	r18, Z
    3446:	21 65       	ori	r18, 0x51	; 81
    3448:	fc 01       	movw	r30, r24
    344a:	20 83       	st	Z, r18
	Wait_sec(2);
    344c:	82 e0       	ldi	r24, 0x02	; 2
    344e:	90 e0       	ldi	r25, 0x00	; 0
    3450:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    3454:	85 e2       	ldi	r24, 0x25	; 37
    3456:	90 e0       	ldi	r25, 0x00	; 0
    3458:	25 e2       	ldi	r18, 0x25	; 37
    345a:	30 e0       	ldi	r19, 0x00	; 0
    345c:	f9 01       	movw	r30, r18
    345e:	20 81       	ld	r18, Z
    3460:	2f 76       	andi	r18, 0x6F	; 111
    3462:	fc 01       	movw	r30, r24
    3464:	20 83       	st	Z, r18
	
	cli();
    3466:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR = 0x00;
    3468:	8e e4       	ldi	r24, 0x4E	; 78
    346a:	90 e0       	ldi	r25, 0x00	; 0
    346c:	fc 01       	movw	r30, r24
    346e:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR & (1 << SPIF)));
    3470:	00 00       	nop
    3472:	8d e4       	ldi	r24, 0x4D	; 77
    3474:	90 e0       	ldi	r25, 0x00	; 0
    3476:	fc 01       	movw	r30, r24
    3478:	80 81       	ld	r24, Z
    347a:	80 95       	com	r24
    347c:	88 1f       	adc	r24, r24
    347e:	88 27       	eor	r24, r24
    3480:	88 1f       	adc	r24, r24
    3482:	88 23       	and	r24, r24
    3484:	b1 f7       	brne	.-20     	; 0x3472 <_Z7GetTempv+0x62>
	rawTemp = (SPDR0 << 8);
    3486:	1a 82       	std	Y+2, r1	; 0x02
    3488:	19 82       	std	Y+1, r1	; 0x01
	SPDR = 0x00;
    348a:	8e e4       	ldi	r24, 0x4E	; 78
    348c:	90 e0       	ldi	r25, 0x00	; 0
    348e:	fc 01       	movw	r30, r24
    3490:	10 82       	st	Z, r1
	while (!(SPSR & (1 << SPIF)));
    3492:	00 00       	nop
    3494:	8d e4       	ldi	r24, 0x4D	; 77
    3496:	90 e0       	ldi	r25, 0x00	; 0
    3498:	fc 01       	movw	r30, r24
    349a:	80 81       	ld	r24, Z
    349c:	80 95       	com	r24
    349e:	88 1f       	adc	r24, r24
    34a0:	88 27       	eor	r24, r24
    34a2:	88 1f       	adc	r24, r24
    34a4:	88 23       	and	r24, r24
    34a6:	b1 f7       	brne	.-20     	; 0x3494 <_Z7GetTempv+0x84>
	rawTemp |= SPDR0;
	
	//Set flag to correct value, update global value
	//flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
	globalTemp=rawTemp;
    34a8:	89 81       	ldd	r24, Y+1	; 0x01
    34aa:	9a 81       	ldd	r25, Y+2	; 0x02
    34ac:	90 93 a1 01 	sts	0x01A1, r25
    34b0:	80 93 a0 01 	sts	0x01A0, r24
	
	//re enable interrupts
	sei();
    34b4:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    34b6:	85 e2       	ldi	r24, 0x25	; 37
    34b8:	90 e0       	ldi	r25, 0x00	; 0
    34ba:	25 e2       	ldi	r18, 0x25	; 37
    34bc:	30 e0       	ldi	r19, 0x00	; 0
    34be:	f9 01       	movw	r30, r18
    34c0:	20 81       	ld	r18, Z
    34c2:	20 69       	ori	r18, 0x90	; 144
    34c4:	fc 01       	movw	r30, r24
    34c6:	20 83       	st	Z, r18
	SPCR=0x00;	
    34c8:	8c e4       	ldi	r24, 0x4C	; 76
    34ca:	90 e0       	ldi	r25, 0x00	; 0
    34cc:	fc 01       	movw	r30, r24
    34ce:	10 82       	st	Z, r1
	//__killTemp();
	PRR0 |= (1 << PRSPI);
    34d0:	84 e6       	ldi	r24, 0x64	; 100
    34d2:	90 e0       	ldi	r25, 0x00	; 0
    34d4:	24 e6       	ldi	r18, 0x64	; 100
    34d6:	30 e0       	ldi	r19, 0x00	; 0
    34d8:	f9 01       	movw	r30, r18
    34da:	20 81       	ld	r18, Z
    34dc:	24 60       	ori	r18, 0x04	; 4
    34de:	fc 01       	movw	r30, r24
    34e0:	20 83       	st	Z, r18
	
	char tempString[9];
	itoa(globalTemp,tempString,10);
    34e2:	80 91 a0 01 	lds	r24, 0x01A0
    34e6:	90 91 a1 01 	lds	r25, 0x01A1
    34ea:	9e 01       	movw	r18, r28
    34ec:	2d 5f       	subi	r18, 0xFD	; 253
    34ee:	3f 4f       	sbci	r19, 0xFF	; 255
    34f0:	b9 01       	movw	r22, r18
    34f2:	4a e0       	ldi	r20, 0x0A	; 10
    34f4:	50 e0       	ldi	r21, 0x00	; 0
    34f6:	0e 94 d7 1b 	call	0x37ae	; 0x37ae <itoa>
	tempString[8]='\0';
    34fa:	1b 86       	std	Y+11, r1	; 0x0b
	//PrintBone("TEMP:");
	//PrintBone(tempString);
}
    34fc:	2b 96       	adiw	r28, 0x0b	; 11
    34fe:	0f b6       	in	r0, 0x3f	; 63
    3500:	f8 94       	cli
    3502:	de bf       	out	0x3e, r29	; 62
    3504:	0f be       	out	0x3f, r0	; 63
    3506:	cd bf       	out	0x3d, r28	; 61
    3508:	df 91       	pop	r29
    350a:	cf 91       	pop	r28
    350c:	08 95       	ret

0000350e <_Z7PowerUpj>:
/*************************************************************************************************************/
void PowerUp(WORD interval){
    350e:	cf 93       	push	r28
    3510:	df 93       	push	r29
    3512:	00 d0       	rcall	.+0      	; 0x3514 <_Z7PowerUpj+0x6>
    3514:	cd b7       	in	r28, 0x3d	; 61
    3516:	de b7       	in	r29, 0x3e	; 62
    3518:	9a 83       	std	Y+2, r25	; 0x02
    351a:	89 83       	std	Y+1, r24	; 0x01
	__killCommINT();
    351c:	8d e3       	ldi	r24, 0x3D	; 61
    351e:	90 e0       	ldi	r25, 0x00	; 0
    3520:	fc 01       	movw	r30, r24
    3522:	10 82       	st	Z, r1
    3524:	8d e6       	ldi	r24, 0x6D	; 109
    3526:	90 e0       	ldi	r25, 0x00	; 0
    3528:	fc 01       	movw	r30, r24
    352a:	10 82       	st	Z, r1
	
	//First power on main regulator
	__enableMain();
    352c:	88 e2       	ldi	r24, 0x28	; 40
    352e:	90 e0       	ldi	r25, 0x00	; 0
    3530:	28 e2       	ldi	r18, 0x28	; 40
    3532:	30 e0       	ldi	r19, 0x00	; 0
    3534:	f9 01       	movw	r30, r18
    3536:	20 81       	ld	r18, Z
    3538:	21 60       	ori	r18, 0x01	; 1
    353a:	fc 01       	movw	r30, r24
    353c:	20 83       	st	Z, r18
	Wait_sec(interval);
    353e:	89 81       	ldd	r24, Y+1	; 0x01
    3540:	9a 81       	ldd	r25, Y+2	; 0x02
    3542:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
	
	//Power on BeagleBone next, takes longer time.
	__enableBeagleBone();
    3546:	82 e2       	ldi	r24, 0x22	; 34
    3548:	90 e0       	ldi	r25, 0x00	; 0
    354a:	22 e2       	ldi	r18, 0x22	; 34
    354c:	30 e0       	ldi	r19, 0x00	; 0
    354e:	f9 01       	movw	r30, r18
    3550:	20 81       	ld	r18, Z
    3552:	20 61       	ori	r18, 0x10	; 16
    3554:	fc 01       	movw	r30, r24
    3556:	20 83       	st	Z, r18
	Wait_sec(interval);
    3558:	89 81       	ldd	r24, Y+1	; 0x01
    355a:	9a 81       	ldd	r25, Y+2	; 0x02
    355c:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
	//while (!(pinBBio & (1 << bnW0B9)));	//Wait for GPIO line to go high
	
	//Power on GAVR and Enable GPS
	__enableGPSandGAVR();
    3560:	82 e2       	ldi	r24, 0x22	; 34
    3562:	90 e0       	ldi	r25, 0x00	; 0
    3564:	22 e2       	ldi	r18, 0x22	; 34
    3566:	30 e0       	ldi	r19, 0x00	; 0
    3568:	f9 01       	movw	r30, r18
    356a:	20 81       	ld	r18, Z
    356c:	20 6c       	ori	r18, 0xC0	; 192
    356e:	fc 01       	movw	r30, r24
    3570:	20 83       	st	Z, r18
	Wait_sec(interval);
    3572:	89 81       	ldd	r24, Y+1	; 0x01
    3574:	9a 81       	ldd	r25, Y+2	; 0x02
    3576:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
	//while (!(pinGAVRio & (1 << bnW3G0)));	//Wait for GPIO line to go high signifying correct boot
	
	//Power on LCD
	__enableLCD();
    357a:	82 e2       	ldi	r24, 0x22	; 34
    357c:	90 e0       	ldi	r25, 0x00	; 0
    357e:	22 e2       	ldi	r18, 0x22	; 34
    3580:	30 e0       	ldi	r19, 0x00	; 0
    3582:	f9 01       	movw	r30, r18
    3584:	20 81       	ld	r18, Z
    3586:	20 62       	ori	r18, 0x20	; 32
    3588:	fc 01       	movw	r30, r24
    358a:	20 83       	st	Z, r18
	Wait_sec(interval);
    358c:	89 81       	ldd	r24, Y+1	; 0x01
    358e:	9a 81       	ldd	r25, Y+2	; 0x02
    3590:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
	
	__enableCommINT();
    3594:	8d e3       	ldi	r24, 0x3D	; 61
    3596:	90 e0       	ldi	r25, 0x00	; 0
    3598:	2d e3       	ldi	r18, 0x3D	; 61
    359a:	30 e0       	ldi	r19, 0x00	; 0
    359c:	f9 01       	movw	r30, r18
    359e:	20 81       	ld	r18, Z
    35a0:	24 60       	ori	r18, 0x04	; 4
    35a2:	fc 01       	movw	r30, r24
    35a4:	20 83       	st	Z, r18
    35a6:	8d e6       	ldi	r24, 0x6D	; 109
    35a8:	90 e0       	ldi	r25, 0x00	; 0
    35aa:	22 e0       	ldi	r18, 0x02	; 2
    35ac:	fc 01       	movw	r30, r24
    35ae:	20 83       	st	Z, r18
	
}
    35b0:	0f 90       	pop	r0
    35b2:	0f 90       	pop	r0
    35b4:	df 91       	pop	r29
    35b6:	cf 91       	pop	r28
    35b8:	08 95       	ret

000035ba <_Z9PowerDownv>:
/*************************************************************************************************************/
void PowerDown(){
    35ba:	cf 93       	push	r28
    35bc:	df 93       	push	r29
    35be:	cd b7       	in	r28, 0x3d	; 61
    35c0:	de b7       	in	r29, 0x3e	; 62
	__killCommINT();
    35c2:	8d e3       	ldi	r24, 0x3D	; 61
    35c4:	90 e0       	ldi	r25, 0x00	; 0
    35c6:	fc 01       	movw	r30, r24
    35c8:	10 82       	st	Z, r1
    35ca:	8d e6       	ldi	r24, 0x6D	; 109
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	fc 01       	movw	r30, r24
    35d0:	10 82       	st	Z, r1

	//Signify interrupts, wait 6 seconds for all processing to stop.
	prtInterrupts |= (1 << bnBBint)|(1 << bnGAVRint);
    35d2:	82 e2       	ldi	r24, 0x22	; 34
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	22 e2       	ldi	r18, 0x22	; 34
    35d8:	30 e0       	ldi	r19, 0x00	; 0
    35da:	f9 01       	movw	r30, r18
    35dc:	20 81       	ld	r18, Z
    35de:	2c 60       	ori	r18, 0x0C	; 12
    35e0:	fc 01       	movw	r30, r24
    35e2:	20 83       	st	Z, r18
	Wait_sec(6);
    35e4:	86 e0       	ldi	r24, 0x06	; 6
    35e6:	90 e0       	ldi	r25, 0x00	; 0
    35e8:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
	prtInterrupts &= ~((1 << bnBBint)|(1 << bnGAVRint));
    35ec:	82 e2       	ldi	r24, 0x22	; 34
    35ee:	90 e0       	ldi	r25, 0x00	; 0
    35f0:	22 e2       	ldi	r18, 0x22	; 34
    35f2:	30 e0       	ldi	r19, 0x00	; 0
    35f4:	f9 01       	movw	r30, r18
    35f6:	20 81       	ld	r18, Z
    35f8:	23 7f       	andi	r18, 0xF3	; 243
    35fa:	fc 01       	movw	r30, r24
    35fc:	20 83       	st	Z, r18
	__killLCD();
    35fe:	82 e2       	ldi	r24, 0x22	; 34
    3600:	90 e0       	ldi	r25, 0x00	; 0
    3602:	22 e2       	ldi	r18, 0x22	; 34
    3604:	30 e0       	ldi	r19, 0x00	; 0
    3606:	f9 01       	movw	r30, r18
    3608:	20 81       	ld	r18, Z
    360a:	2f 7d       	andi	r18, 0xDF	; 223
    360c:	fc 01       	movw	r30, r24
    360e:	20 83       	st	Z, r18
	__killGPSandGAVR();
    3610:	82 e2       	ldi	r24, 0x22	; 34
    3612:	90 e0       	ldi	r25, 0x00	; 0
    3614:	22 e2       	ldi	r18, 0x22	; 34
    3616:	30 e0       	ldi	r19, 0x00	; 0
    3618:	f9 01       	movw	r30, r18
    361a:	20 81       	ld	r18, Z
    361c:	2f 73       	andi	r18, 0x3F	; 63
    361e:	fc 01       	movw	r30, r24
    3620:	20 83       	st	Z, r18
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
    3622:	86 e0       	ldi	r24, 0x06	; 6
    3624:	90 e0       	ldi	r25, 0x00	; 0
    3626:	0e 94 a1 18 	call	0x3142	; 0x3142 <_Z8Wait_seci>
	__killBeagleBone();
    362a:	82 e2       	ldi	r24, 0x22	; 34
    362c:	90 e0       	ldi	r25, 0x00	; 0
    362e:	22 e2       	ldi	r18, 0x22	; 34
    3630:	30 e0       	ldi	r19, 0x00	; 0
    3632:	f9 01       	movw	r30, r18
    3634:	20 81       	ld	r18, Z
    3636:	2f 7e       	andi	r18, 0xEF	; 239
    3638:	fc 01       	movw	r30, r24
    363a:	20 83       	st	Z, r18
	__killMain();
    363c:	88 e2       	ldi	r24, 0x28	; 40
    363e:	90 e0       	ldi	r25, 0x00	; 0
    3640:	28 e2       	ldi	r18, 0x28	; 40
    3642:	30 e0       	ldi	r19, 0x00	; 0
    3644:	f9 01       	movw	r30, r18
    3646:	20 81       	ld	r18, Z
    3648:	2e 7f       	andi	r18, 0xFE	; 254
    364a:	fc 01       	movw	r30, r24
    364c:	20 83       	st	Z, r18
}
    364e:	df 91       	pop	r29
    3650:	cf 91       	pop	r28
    3652:	08 95       	ret

00003654 <_Z41__static_initialization_and_destruction_0ii>:
    3654:	cf 93       	push	r28
    3656:	df 93       	push	r29
    3658:	00 d0       	rcall	.+0      	; 0x365a <_Z41__static_initialization_and_destruction_0ii+0x6>
    365a:	00 d0       	rcall	.+0      	; 0x365c <_Z41__static_initialization_and_destruction_0ii+0x8>
    365c:	cd b7       	in	r28, 0x3d	; 61
    365e:	de b7       	in	r29, 0x3e	; 62
    3660:	9a 83       	std	Y+2, r25	; 0x02
    3662:	89 83       	std	Y+1, r24	; 0x01
    3664:	7c 83       	std	Y+4, r23	; 0x04
    3666:	6b 83       	std	Y+3, r22	; 0x03
    3668:	89 81       	ldd	r24, Y+1	; 0x01
    366a:	9a 81       	ldd	r25, Y+2	; 0x02
    366c:	81 30       	cpi	r24, 0x01	; 1
    366e:	91 05       	cpc	r25, r1
    3670:	51 f4       	brne	.+20     	; 0x3686 <_Z41__static_initialization_and_destruction_0ii+0x32>
    3672:	8b 81       	ldd	r24, Y+3	; 0x03
    3674:	9c 81       	ldd	r25, Y+4	; 0x04
    3676:	2f ef       	ldi	r18, 0xFF	; 255
    3678:	8f 3f       	cpi	r24, 0xFF	; 255
    367a:	92 07       	cpc	r25, r18
    367c:	21 f4       	brne	.+8      	; 0x3686 <_Z41__static_initialization_and_destruction_0ii+0x32>

/*********************************************GLOBAL VARIABLES***************************************************/
/****************************************************************************************************************/
WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    367e:	82 ea       	ldi	r24, 0xA2	; 162
    3680:	91 e0       	ldi	r25, 0x01	; 1
    3682:	0e 94 10 04 	call	0x820	; 0x820 <_ZN6myTimeC1Ev>
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
	__killBeagleBone();
	__killMain();
}
    3686:	0f 90       	pop	r0
    3688:	0f 90       	pop	r0
    368a:	0f 90       	pop	r0
    368c:	0f 90       	pop	r0
    368e:	df 91       	pop	r29
    3690:	cf 91       	pop	r28
    3692:	08 95       	ret

00003694 <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    3694:	cf 93       	push	r28
    3696:	df 93       	push	r29
    3698:	cd b7       	in	r28, 0x3d	; 61
    369a:	de b7       	in	r29, 0x3e	; 62
    369c:	81 e0       	ldi	r24, 0x01	; 1
    369e:	90 e0       	ldi	r25, 0x00	; 0
    36a0:	6f ef       	ldi	r22, 0xFF	; 255
    36a2:	7f ef       	ldi	r23, 0xFF	; 255
    36a4:	0e 94 2a 1b 	call	0x3654	; 0x3654 <_Z41__static_initialization_and_destruction_0ii>
    36a8:	df 91       	pop	r29
    36aa:	cf 91       	pop	r28
    36ac:	08 95       	ret

000036ae <__udivmodqi4>:
    36ae:	99 1b       	sub	r25, r25
    36b0:	79 e0       	ldi	r23, 0x09	; 9
    36b2:	04 c0       	rjmp	.+8      	; 0x36bc <__udivmodqi4_ep>

000036b4 <__udivmodqi4_loop>:
    36b4:	99 1f       	adc	r25, r25
    36b6:	96 17       	cp	r25, r22
    36b8:	08 f0       	brcs	.+2      	; 0x36bc <__udivmodqi4_ep>
    36ba:	96 1b       	sub	r25, r22

000036bc <__udivmodqi4_ep>:
    36bc:	88 1f       	adc	r24, r24
    36be:	7a 95       	dec	r23
    36c0:	c9 f7       	brne	.-14     	; 0x36b4 <__udivmodqi4_loop>
    36c2:	80 95       	com	r24
    36c4:	08 95       	ret

000036c6 <__divmodhi4>:
    36c6:	97 fb       	bst	r25, 7
    36c8:	09 2e       	mov	r0, r25
    36ca:	07 26       	eor	r0, r23
    36cc:	0a d0       	rcall	.+20     	; 0x36e2 <__divmodhi4_neg1>
    36ce:	77 fd       	sbrc	r23, 7
    36d0:	04 d0       	rcall	.+8      	; 0x36da <__divmodhi4_neg2>
    36d2:	0c d0       	rcall	.+24     	; 0x36ec <__udivmodhi4>
    36d4:	06 d0       	rcall	.+12     	; 0x36e2 <__divmodhi4_neg1>
    36d6:	00 20       	and	r0, r0
    36d8:	1a f4       	brpl	.+6      	; 0x36e0 <__divmodhi4_exit>

000036da <__divmodhi4_neg2>:
    36da:	70 95       	com	r23
    36dc:	61 95       	neg	r22
    36de:	7f 4f       	sbci	r23, 0xFF	; 255

000036e0 <__divmodhi4_exit>:
    36e0:	08 95       	ret

000036e2 <__divmodhi4_neg1>:
    36e2:	f6 f7       	brtc	.-4      	; 0x36e0 <__divmodhi4_exit>
    36e4:	90 95       	com	r25
    36e6:	81 95       	neg	r24
    36e8:	9f 4f       	sbci	r25, 0xFF	; 255
    36ea:	08 95       	ret

000036ec <__udivmodhi4>:
    36ec:	aa 1b       	sub	r26, r26
    36ee:	bb 1b       	sub	r27, r27
    36f0:	51 e1       	ldi	r21, 0x11	; 17
    36f2:	07 c0       	rjmp	.+14     	; 0x3702 <__udivmodhi4_ep>

000036f4 <__udivmodhi4_loop>:
    36f4:	aa 1f       	adc	r26, r26
    36f6:	bb 1f       	adc	r27, r27
    36f8:	a6 17       	cp	r26, r22
    36fa:	b7 07       	cpc	r27, r23
    36fc:	10 f0       	brcs	.+4      	; 0x3702 <__udivmodhi4_ep>
    36fe:	a6 1b       	sub	r26, r22
    3700:	b7 0b       	sbc	r27, r23

00003702 <__udivmodhi4_ep>:
    3702:	88 1f       	adc	r24, r24
    3704:	99 1f       	adc	r25, r25
    3706:	5a 95       	dec	r21
    3708:	a9 f7       	brne	.-22     	; 0x36f4 <__udivmodhi4_loop>
    370a:	80 95       	com	r24
    370c:	90 95       	com	r25
    370e:	bc 01       	movw	r22, r24
    3710:	cd 01       	movw	r24, r26
    3712:	08 95       	ret

00003714 <__tablejump2__>:
    3714:	ee 0f       	add	r30, r30
    3716:	ff 1f       	adc	r31, r31

00003718 <__tablejump__>:
    3718:	05 90       	lpm	r0, Z+
    371a:	f4 91       	lpm	r31, Z
    371c:	e0 2d       	mov	r30, r0
    371e:	09 94       	ijmp

00003720 <atoi>:
    3720:	fc 01       	movw	r30, r24
    3722:	88 27       	eor	r24, r24
    3724:	99 27       	eor	r25, r25
    3726:	e8 94       	clt
    3728:	21 91       	ld	r18, Z+
    372a:	20 32       	cpi	r18, 0x20	; 32
    372c:	e9 f3       	breq	.-6      	; 0x3728 <atoi+0x8>
    372e:	29 30       	cpi	r18, 0x09	; 9
    3730:	10 f0       	brcs	.+4      	; 0x3736 <atoi+0x16>
    3732:	2e 30       	cpi	r18, 0x0E	; 14
    3734:	c8 f3       	brcs	.-14     	; 0x3728 <atoi+0x8>
    3736:	2b 32       	cpi	r18, 0x2B	; 43
    3738:	41 f0       	breq	.+16     	; 0x374a <atoi+0x2a>
    373a:	2d 32       	cpi	r18, 0x2D	; 45
    373c:	39 f4       	brne	.+14     	; 0x374c <atoi+0x2c>
    373e:	68 94       	set
    3740:	04 c0       	rjmp	.+8      	; 0x374a <atoi+0x2a>
    3742:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <__mulhi_const_10>
    3746:	82 0f       	add	r24, r18
    3748:	91 1d       	adc	r25, r1
    374a:	21 91       	ld	r18, Z+
    374c:	20 53       	subi	r18, 0x30	; 48
    374e:	2a 30       	cpi	r18, 0x0A	; 10
    3750:	c0 f3       	brcs	.-16     	; 0x3742 <atoi+0x22>
    3752:	1e f4       	brtc	.+6      	; 0x375a <atoi+0x3a>
    3754:	90 95       	com	r25
    3756:	81 95       	neg	r24
    3758:	9f 4f       	sbci	r25, 0xFF	; 255
    375a:	08 95       	ret

0000375c <strcat>:
    375c:	fb 01       	movw	r30, r22
    375e:	dc 01       	movw	r26, r24
    3760:	0d 90       	ld	r0, X+
    3762:	00 20       	and	r0, r0
    3764:	e9 f7       	brne	.-6      	; 0x3760 <strcat+0x4>
    3766:	11 97       	sbiw	r26, 0x01	; 1
    3768:	01 90       	ld	r0, Z+
    376a:	0d 92       	st	X+, r0
    376c:	00 20       	and	r0, r0
    376e:	e1 f7       	brne	.-8      	; 0x3768 <strcat+0xc>
    3770:	08 95       	ret

00003772 <strcmp>:
    3772:	fb 01       	movw	r30, r22
    3774:	dc 01       	movw	r26, r24
    3776:	8d 91       	ld	r24, X+
    3778:	01 90       	ld	r0, Z+
    377a:	80 19       	sub	r24, r0
    377c:	01 10       	cpse	r0, r1
    377e:	d9 f3       	breq	.-10     	; 0x3776 <strcmp+0x4>
    3780:	99 0b       	sbc	r25, r25
    3782:	08 95       	ret

00003784 <strcpy>:
    3784:	fb 01       	movw	r30, r22
    3786:	dc 01       	movw	r26, r24
    3788:	01 90       	ld	r0, Z+
    378a:	0d 92       	st	X+, r0
    378c:	00 20       	and	r0, r0
    378e:	e1 f7       	brne	.-8      	; 0x3788 <strcpy+0x4>
    3790:	08 95       	ret

00003792 <strncmp>:
    3792:	fb 01       	movw	r30, r22
    3794:	dc 01       	movw	r26, r24
    3796:	41 50       	subi	r20, 0x01	; 1
    3798:	50 40       	sbci	r21, 0x00	; 0
    379a:	30 f0       	brcs	.+12     	; 0x37a8 <strncmp+0x16>
    379c:	8d 91       	ld	r24, X+
    379e:	01 90       	ld	r0, Z+
    37a0:	80 19       	sub	r24, r0
    37a2:	19 f4       	brne	.+6      	; 0x37aa <strncmp+0x18>
    37a4:	00 20       	and	r0, r0
    37a6:	b9 f7       	brne	.-18     	; 0x3796 <strncmp+0x4>
    37a8:	88 1b       	sub	r24, r24
    37aa:	99 0b       	sbc	r25, r25
    37ac:	08 95       	ret

000037ae <itoa>:
    37ae:	fb 01       	movw	r30, r22
    37b0:	9f 01       	movw	r18, r30
    37b2:	e8 94       	clt
    37b4:	42 30       	cpi	r20, 0x02	; 2
    37b6:	c4 f0       	brlt	.+48     	; 0x37e8 <itoa+0x3a>
    37b8:	45 32       	cpi	r20, 0x25	; 37
    37ba:	b4 f4       	brge	.+44     	; 0x37e8 <itoa+0x3a>
    37bc:	4a 30       	cpi	r20, 0x0A	; 10
    37be:	29 f4       	brne	.+10     	; 0x37ca <itoa+0x1c>
    37c0:	97 fb       	bst	r25, 7
    37c2:	1e f4       	brtc	.+6      	; 0x37ca <itoa+0x1c>
    37c4:	90 95       	com	r25
    37c6:	81 95       	neg	r24
    37c8:	9f 4f       	sbci	r25, 0xFF	; 255
    37ca:	64 2f       	mov	r22, r20
    37cc:	77 27       	eor	r23, r23
    37ce:	0e 94 76 1b 	call	0x36ec	; 0x36ec <__udivmodhi4>
    37d2:	80 5d       	subi	r24, 0xD0	; 208
    37d4:	8a 33       	cpi	r24, 0x3A	; 58
    37d6:	0c f0       	brlt	.+2      	; 0x37da <itoa+0x2c>
    37d8:	89 5d       	subi	r24, 0xD9	; 217
    37da:	81 93       	st	Z+, r24
    37dc:	cb 01       	movw	r24, r22
    37de:	00 97       	sbiw	r24, 0x00	; 0
    37e0:	a1 f7       	brne	.-24     	; 0x37ca <itoa+0x1c>
    37e2:	16 f4       	brtc	.+4      	; 0x37e8 <itoa+0x3a>
    37e4:	5d e2       	ldi	r21, 0x2D	; 45
    37e6:	51 93       	st	Z+, r21
    37e8:	10 82       	st	Z, r1
    37ea:	c9 01       	movw	r24, r18
    37ec:	0c 94 37 1c 	jmp	0x386e	; 0x386e <strrev>

000037f0 <__mulhi_const_10>:
    37f0:	7a e0       	ldi	r23, 0x0A	; 10
    37f2:	97 9f       	mul	r25, r23
    37f4:	90 2d       	mov	r25, r0
    37f6:	87 9f       	mul	r24, r23
    37f8:	80 2d       	mov	r24, r0
    37fa:	91 0d       	add	r25, r1
    37fc:	11 24       	eor	r1, r1
    37fe:	08 95       	ret

00003800 <utoa>:
    3800:	fb 01       	movw	r30, r22
    3802:	9f 01       	movw	r18, r30
    3804:	42 30       	cpi	r20, 0x02	; 2
    3806:	74 f0       	brlt	.+28     	; 0x3824 <utoa+0x24>
    3808:	45 32       	cpi	r20, 0x25	; 37
    380a:	64 f4       	brge	.+24     	; 0x3824 <utoa+0x24>
    380c:	64 2f       	mov	r22, r20
    380e:	77 27       	eor	r23, r23
    3810:	0e 94 76 1b 	call	0x36ec	; 0x36ec <__udivmodhi4>
    3814:	80 5d       	subi	r24, 0xD0	; 208
    3816:	8a 33       	cpi	r24, 0x3A	; 58
    3818:	0c f0       	brlt	.+2      	; 0x381c <utoa+0x1c>
    381a:	89 5d       	subi	r24, 0xD9	; 217
    381c:	81 93       	st	Z+, r24
    381e:	cb 01       	movw	r24, r22
    3820:	00 97       	sbiw	r24, 0x00	; 0
    3822:	a1 f7       	brne	.-24     	; 0x380c <utoa+0xc>
    3824:	10 82       	st	Z, r1
    3826:	c9 01       	movw	r24, r18
    3828:	0c 94 37 1c 	jmp	0x386e	; 0x386e <strrev>

0000382c <__eerd_byte_m644pa>:
    382c:	f9 99       	sbic	0x1f, 1	; 31
    382e:	fe cf       	rjmp	.-4      	; 0x382c <__eerd_byte_m644pa>
    3830:	92 bd       	out	0x22, r25	; 34
    3832:	81 bd       	out	0x21, r24	; 33
    3834:	f8 9a       	sbi	0x1f, 0	; 31
    3836:	99 27       	eor	r25, r25
    3838:	80 b5       	in	r24, 0x20	; 32
    383a:	08 95       	ret

0000383c <__eerd_word_m644pa>:
    383c:	a8 e1       	ldi	r26, 0x18	; 24
    383e:	b0 e0       	ldi	r27, 0x00	; 0
    3840:	42 e0       	ldi	r20, 0x02	; 2
    3842:	50 e0       	ldi	r21, 0x00	; 0
    3844:	0c 94 49 1c 	jmp	0x3892	; 0x3892 <__eerd_blraw_m644pa>

00003848 <__eewr_byte_m644pa>:
    3848:	26 2f       	mov	r18, r22

0000384a <__eewr_r18_m644pa>:
    384a:	f9 99       	sbic	0x1f, 1	; 31
    384c:	fe cf       	rjmp	.-4      	; 0x384a <__eewr_r18_m644pa>
    384e:	1f ba       	out	0x1f, r1	; 31
    3850:	92 bd       	out	0x22, r25	; 34
    3852:	81 bd       	out	0x21, r24	; 33
    3854:	20 bd       	out	0x20, r18	; 32
    3856:	0f b6       	in	r0, 0x3f	; 63
    3858:	f8 94       	cli
    385a:	fa 9a       	sbi	0x1f, 2	; 31
    385c:	f9 9a       	sbi	0x1f, 1	; 31
    385e:	0f be       	out	0x3f, r0	; 63
    3860:	01 96       	adiw	r24, 0x01	; 1
    3862:	08 95       	ret

00003864 <__eewr_word_m644pa>:
    3864:	0e 94 24 1c 	call	0x3848	; 0x3848 <__eewr_byte_m644pa>
    3868:	27 2f       	mov	r18, r23
    386a:	0c 94 25 1c 	jmp	0x384a	; 0x384a <__eewr_r18_m644pa>

0000386e <strrev>:
    386e:	dc 01       	movw	r26, r24
    3870:	fc 01       	movw	r30, r24
    3872:	67 2f       	mov	r22, r23
    3874:	71 91       	ld	r23, Z+
    3876:	77 23       	and	r23, r23
    3878:	e1 f7       	brne	.-8      	; 0x3872 <strrev+0x4>
    387a:	32 97       	sbiw	r30, 0x02	; 2
    387c:	04 c0       	rjmp	.+8      	; 0x3886 <strrev+0x18>
    387e:	7c 91       	ld	r23, X
    3880:	6d 93       	st	X+, r22
    3882:	70 83       	st	Z, r23
    3884:	62 91       	ld	r22, -Z
    3886:	ae 17       	cp	r26, r30
    3888:	bf 07       	cpc	r27, r31
    388a:	c8 f3       	brcs	.-14     	; 0x387e <strrev+0x10>
    388c:	08 95       	ret

0000388e <__eerd_block_m644pa>:
    388e:	dc 01       	movw	r26, r24
    3890:	cb 01       	movw	r24, r22

00003892 <__eerd_blraw_m644pa>:
    3892:	fc 01       	movw	r30, r24
    3894:	f9 99       	sbic	0x1f, 1	; 31
    3896:	fe cf       	rjmp	.-4      	; 0x3894 <__eerd_blraw_m644pa+0x2>
    3898:	06 c0       	rjmp	.+12     	; 0x38a6 <__eerd_blraw_m644pa+0x14>
    389a:	f2 bd       	out	0x22, r31	; 34
    389c:	e1 bd       	out	0x21, r30	; 33
    389e:	f8 9a       	sbi	0x1f, 0	; 31
    38a0:	31 96       	adiw	r30, 0x01	; 1
    38a2:	00 b4       	in	r0, 0x20	; 32
    38a4:	0d 92       	st	X+, r0
    38a6:	41 50       	subi	r20, 0x01	; 1
    38a8:	50 40       	sbci	r21, 0x00	; 0
    38aa:	b8 f7       	brcc	.-18     	; 0x389a <__eerd_blraw_m644pa+0x8>
    38ac:	08 95       	ret

000038ae <_exit>:
    38ae:	f8 94       	cli

000038b0 <__stop_program>:
    38b0:	ff cf       	rjmp	.-2      	; 0x38b0 <__stop_program>
