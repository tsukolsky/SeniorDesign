
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000de  00800100  00003b40  00003bf4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003b40  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000049  008001de  008001de  00003cd2  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  00003cd2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000011f4  00000000  00000000  00003cdc  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000005eb  00000000  00000000  00004ed0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  000054c0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000022c1  00000000  00000000  000055e0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000393  00000000  00000000  000078a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000fec  00000000  00000000  00007c34  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008cc  00000000  00000000  00008c20  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b4b  00000000  00000000  000094ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001290  00000000  00000000  0000a037  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000030  00000000  00000000  0000b2c7  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 37 14 	jmp	0x286e	; 0x286e <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 e3 13 	jmp	0x27c6	; 0x27c6 <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 e7 14 	jmp	0x29ce	; 0x29ce <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 81 14 	jmp	0x2902	; 0x2902 <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 b4 14 	jmp	0x2968	; 0x2968 <__vector_28>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	91 1c       	adc	r9, r1

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d0 e1       	ldi	r29, 0x10	; 16
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	e0 e4       	ldi	r30, 0x40	; 64
      92:	fb e3       	ldi	r31, 0x3B	; 59
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	ae 3d       	cpi	r26, 0xDE	; 222
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	12 e0       	ldi	r17, 0x02	; 2
      a2:	ae ed       	ldi	r26, 0xDE	; 222
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	a7 32       	cpi	r26, 0x27	; 39
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 b5 16 	call	0x2d6a	; 0x2d6a <main>
      ca:	0c 94 9e 1d 	jmp	0x3b3c	; 0x3b3c <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate17checkValidityDateEv>:

BOOL myDate::checkValidityDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	00 d0       	rcall	.+0      	; 0x60a <_ZN6myDate17checkValidityDateEv+0x6>
     60a:	0f 92       	push	r0
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	9b 83       	std	Y+3, r25	; 0x03
     612:	8a 83       	std	Y+2, r24	; 0x02
	BOOL checkYear=fFalse;
     614:	19 82       	std	Y+1, r1	; 0x01
	if (month/13==0){
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	9b 81       	ldd	r25, Y+3	; 0x03
     61a:	fc 01       	movw	r30, r24
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	0c 96       	adiw	r24, 0x0c	; 12
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	89 31       	cpi	r24, 0x19	; 25
     626:	91 05       	cpc	r25, r1
     628:	08 f0       	brcs	.+2      	; 0x62c <_ZN6myDate17checkValidityDateEv+0x28>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	22 23       	and	r18, r18
     62e:	09 f4       	brne	.+2      	; 0x632 <_ZN6myDate17checkValidityDateEv+0x2e>
     630:	66 c0       	rjmp	.+204    	; 0x6fe <_ZN6myDate17checkValidityDateEv+0xfa>
			if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	89 30       	cpi	r24, 0x09	; 9
     63e:	91 05       	cpc	r25, r1
     640:	81 f0       	breq	.+32     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     642:	8a 81       	ldd	r24, Y+2	; 0x02
     644:	9b 81       	ldd	r25, Y+3	; 0x03
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
     64a:	91 81       	ldd	r25, Z+1	; 0x01
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	91 05       	cpc	r25, r1
     650:	41 f0       	breq	.+16     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	9b 81       	ldd	r25, Y+3	; 0x03
     656:	fc 01       	movw	r30, r24
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	86 30       	cpi	r24, 0x06	; 6
     65e:	91 05       	cpc	r25, r1
     660:	59 f4       	brne	.+22     	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	4e 96       	adiw	r24, 0x1e	; 30
     66e:	8d 33       	cpi	r24, 0x3D	; 61
     670:	91 05       	cpc	r25, r1
     672:	10 f4       	brcc	.+4      	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	01 c0       	rjmp	.+2      	; 0x67a <_ZN6myDate17checkValidityDateEv+0x76>
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	88 23       	and	r24, r24
     67c:	19 f0       	breq	.+6      	; 0x684 <_ZN6myDate17checkValidityDateEv+0x80>
				checkYear=fTrue;
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	89 83       	std	Y+1, r24	; 0x01
     682:	28 c0       	rjmp	.+80     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else if (month == 2 && day/29 == 0){
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	fc 01       	movw	r30, r24
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	91 05       	cpc	r25, r1
     692:	59 f4       	brne	.+22     	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     694:	8a 81       	ldd	r24, Y+2	; 0x02
     696:	9b 81       	ldd	r25, Y+3	; 0x03
     698:	fc 01       	movw	r30, r24
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	4c 96       	adiw	r24, 0x1c	; 28
     6a0:	89 33       	cpi	r24, 0x39	; 57
     6a2:	91 05       	cpc	r25, r1
     6a4:	10 f4       	brcc	.+4      	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_ZN6myDate17checkValidityDateEv+0xa8>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	88 23       	and	r24, r24
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_ZN6myDate17checkValidityDateEv+0xb2>
				checkYear=fTrue;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	89 83       	std	Y+1, r24	; 0x01
     6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else{
				if (day/32 == 0){
     6b6:	8a 81       	ldd	r24, Y+2	; 0x02
     6b8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ba:	fc 01       	movw	r30, r24
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	4f 96       	adiw	r24, 0x1f	; 31
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	8f 33       	cpi	r24, 0x3F	; 63
     6c6:	91 05       	cpc	r25, r1
     6c8:	08 f0       	brcs	.+2      	; 0x6cc <_ZN6myDate17checkValidityDateEv+0xc8>
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	22 23       	and	r18, r18
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
					checkYear=fTrue;
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
			
			//Check year
			if (checkYear && year>=2013){return fTrue;}
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	88 23       	and	r24, r24
     6d8:	59 f0       	breq	.+22     	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	84 81       	ldd	r24, Z+4	; 0x04
     6e2:	95 81       	ldd	r25, Z+5	; 0x05
     6e4:	f7 e0       	ldi	r31, 0x07	; 7
     6e6:	8d 3d       	cpi	r24, 0xDD	; 221
     6e8:	9f 07       	cpc	r25, r31
     6ea:	14 f0       	brlt	.+4      	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <_ZN6myDate17checkValidityDateEv+0xee>
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	88 23       	and	r24, r24
     6f4:	11 f0       	breq	.+4      	; 0x6fa <_ZN6myDate17checkValidityDateEv+0xf6>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	03 c0       	rjmp	.+6      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
			else {return fFalse;}
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
	} else {return fFalse;}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	cd b7       	in	r28, 0x3d	; 61
     712:	de b7       	in	r29, 0x3e	; 62
     714:	2d 97       	sbiw	r28, 0x0d	; 13
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	9d 87       	std	Y+13, r25	; 0x0d
     722:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     724:	8c 85       	ldd	r24, Y+12	; 0x0c
     726:	9d 85       	ldd	r25, Y+13	; 0x0d
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	91 81       	ldd	r25, Z+1	; 0x01
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <itoa>
	itoa(day,dayString,10);
     73e:	8c 85       	ldd	r24, Y+12	; 0x0c
     740:	9d 85       	ldd	r25, Y+13	; 0x0d
     742:	fc 01       	movw	r30, r24
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9e 01       	movw	r18, r28
     74a:	2c 5f       	subi	r18, 0xFC	; 252
     74c:	3f 4f       	sbci	r19, 0xFF	; 255
     74e:	b9 01       	movw	r22, r18
     750:	4a e0       	ldi	r20, 0x0A	; 10
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <itoa>
	itoa(year,yearString,10);
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	fc 01       	movw	r30, r24
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9e 01       	movw	r18, r28
     764:	29 5f       	subi	r18, 0xF9	; 249
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	4a e0       	ldi	r20, 0x0A	; 10
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <itoa>
	strcpy(dateString,monthString);
     772:	8c 85       	ldd	r24, Y+12	; 0x0c
     774:	9d 85       	ldd	r25, Y+13	; 0x0d
     776:	06 96       	adiw	r24, 0x06	; 6
     778:	9e 01       	movw	r18, r28
     77a:	2f 5f       	subi	r18, 0xFF	; 255
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <strcpy>
	strcat(dateString,",");
     784:	8c 85       	ldd	r24, Y+12	; 0x0c
     786:	9d 85       	ldd	r25, Y+13	; 0x0d
     788:	9c 01       	movw	r18, r24
     78a:	2a 5f       	subi	r18, 0xFA	; 250
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	c9 01       	movw	r24, r18
     790:	ac 01       	movw	r20, r24
     792:	fa 01       	movw	r30, r20
     794:	01 90       	ld	r0, Z+
     796:	00 20       	and	r0, r0
     798:	e9 f7       	brne	.-6      	; 0x794 <_ZN6myDate7getDateEv+0x88>
     79a:	cf 01       	movw	r24, r30
     79c:	01 97       	sbiw	r24, 0x01	; 1
     79e:	84 1b       	sub	r24, r20
     7a0:	95 0b       	sbc	r25, r21
     7a2:	82 0f       	add	r24, r18
     7a4:	93 1f       	adc	r25, r19
     7a6:	2c e2       	ldi	r18, 0x2C	; 44
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	fc 01       	movw	r30, r24
     7ac:	31 83       	std	Z+1, r19	; 0x01
     7ae:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     7b0:	8c 85       	ldd	r24, Y+12	; 0x0c
     7b2:	9d 85       	ldd	r25, Y+13	; 0x0d
     7b4:	06 96       	adiw	r24, 0x06	; 6
     7b6:	9e 01       	movw	r18, r28
     7b8:	2c 5f       	subi	r18, 0xFC	; 252
     7ba:	3f 4f       	sbci	r19, 0xFF	; 255
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <strcat>
	strcat(dateString,",");
     7c2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7c4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7c6:	9c 01       	movw	r18, r24
     7c8:	2a 5f       	subi	r18, 0xFA	; 250
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	c9 01       	movw	r24, r18
     7ce:	ac 01       	movw	r20, r24
     7d0:	fa 01       	movw	r30, r20
     7d2:	01 90       	ld	r0, Z+
     7d4:	00 20       	and	r0, r0
     7d6:	e9 f7       	brne	.-6      	; 0x7d2 <_ZN6myDate7getDateEv+0xc6>
     7d8:	cf 01       	movw	r24, r30
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	84 1b       	sub	r24, r20
     7de:	95 0b       	sbc	r25, r21
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	2c e2       	ldi	r18, 0x2C	; 44
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	fc 01       	movw	r30, r24
     7ea:	31 83       	std	Z+1, r19	; 0x01
     7ec:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     7ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     7f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f2:	06 96       	adiw	r24, 0x06	; 6
     7f4:	9e 01       	movw	r18, r28
     7f6:	29 5f       	subi	r18, 0xF9	; 249
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <strcat>
	dateString[16] = '\0';
     800:	8c 85       	ldd	r24, Y+12	; 0x0c
     802:	9d 85       	ldd	r25, Y+13	; 0x0d
     804:	fc 01       	movw	r30, r24
     806:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     808:	8c 85       	ldd	r24, Y+12	; 0x0c
     80a:	9d 85       	ldd	r25, Y+13	; 0x0d
     80c:	06 96       	adiw	r24, 0x06	; 6
     80e:	2d 96       	adiw	r28, 0x0d	; 13
     810:	0f b6       	in	r0, 0x3f	; 63
     812:	f8 94       	cli
     814:	de bf       	out	0x3e, r29	; 62
     816:	0f be       	out	0x3f, r0	; 63
     818:	cd bf       	out	0x3d, r28	; 61
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	08 95       	ret

00000820 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	00 d0       	rcall	.+0      	; 0x826 <_ZN6myTimeC1Ev+0x6>
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	9a 83       	std	Y+2, r25	; 0x02
     82c:	89 83       	std	Y+1, r24	; 0x01
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     836:	89 81       	ldd	r24, Y+1	; 0x01
     838:	9a 81       	ldd	r25, Y+2	; 0x02
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	40 e0       	ldi	r20, 0x00	; 0
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	08 95       	ret

00000854 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	28 97       	sbiw	r28, 0x08	; 8
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 83       	std	Y+2, r25	; 0x02
     86a:	89 83       	std	Y+1, r24	; 0x01
     86c:	7c 83       	std	Y+4, r23	; 0x04
     86e:	6b 83       	std	Y+3, r22	; 0x03
     870:	5e 83       	std	Y+6, r21	; 0x06
     872:	4d 83       	std	Y+5, r20	; 0x05
     874:	38 87       	std	Y+8, r19	; 0x08
     876:	2f 83       	std	Y+7, r18	; 0x07
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	9a 81       	ldd	r25, Y+2	; 0x02
     87c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	9a 81       	ldd	r25, Y+2	; 0x02
     884:	6b 81       	ldd	r22, Y+3	; 0x03
     886:	7c 81       	ldd	r23, Y+4	; 0x04
     888:	4d 81       	ldd	r20, Y+5	; 0x05
     88a:	5e 81       	ldd	r21, Y+6	; 0x06
     88c:	2f 81       	ldd	r18, Y+7	; 0x07
     88e:	38 85       	ldd	r19, Y+8	; 0x08
     890:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     894:	28 96       	adiw	r28, 0x08	; 8
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	de bf       	out	0x3e, r29	; 62
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	cd bf       	out	0x3d, r28	; 61
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	08 95       	ret

000008a6 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     8a6:	cf 92       	push	r12
     8a8:	df 92       	push	r13
     8aa:	ef 92       	push	r14
     8ac:	ff 92       	push	r15
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
     8ba:	2e 97       	sbiw	r28, 0x0e	; 14
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	f8 94       	cli
     8c0:	de bf       	out	0x3e, r29	; 62
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	cd bf       	out	0x3d, r28	; 61
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01
     8ca:	7c 83       	std	Y+4, r23	; 0x04
     8cc:	6b 83       	std	Y+3, r22	; 0x03
     8ce:	5e 83       	std	Y+6, r21	; 0x06
     8d0:	4d 83       	std	Y+5, r20	; 0x05
     8d2:	38 87       	std	Y+8, r19	; 0x08
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	1a 87       	std	Y+10, r17	; 0x0a
     8d8:	09 87       	std	Y+9, r16	; 0x09
     8da:	fc 86       	std	Y+12, r15	; 0x0c
     8dc:	eb 86       	std	Y+11, r14	; 0x0b
     8de:	de 86       	std	Y+14, r13	; 0x0e
     8e0:	cd 86       	std	Y+13, r12	; 0x0d
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	69 85       	ldd	r22, Y+9	; 0x09
     8e8:	7a 85       	ldd	r23, Y+10	; 0x0a
     8ea:	4b 85       	ldd	r20, Y+11	; 0x0b
     8ec:	5c 85       	ldd	r21, Y+12	; 0x0c
     8ee:	2d 85       	ldd	r18, Y+13	; 0x0d
     8f0:	3e 85       	ldd	r19, Y+14	; 0x0e
     8f2:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	9a 81       	ldd	r25, Y+2	; 0x02
     8fa:	6b 81       	ldd	r22, Y+3	; 0x03
     8fc:	7c 81       	ldd	r23, Y+4	; 0x04
     8fe:	4d 81       	ldd	r20, Y+5	; 0x05
     900:	5e 81       	ldd	r21, Y+6	; 0x06
     902:	2f 81       	ldd	r18, Y+7	; 0x07
     904:	38 85       	ldd	r19, Y+8	; 0x08
     906:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     90a:	2e 96       	adiw	r28, 0x0e	; 14
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	de bf       	out	0x3e, r29	; 62
     912:	0f be       	out	0x3f, r0	; 63
     914:	cd bf       	out	0x3d, r28	; 61
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	08 95       	ret

00000928 <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	00 d0       	rcall	.+0      	; 0x92e <_ZN6myTime10getSecondsEv+0x6>
     92e:	cd b7       	in	r28, 0x3d	; 61
     930:	de b7       	in	r29, 0x3e	; 62
     932:	9a 83       	std	Y+2, r25	; 0x02
     934:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     936:	89 81       	ldd	r24, Y+1	; 0x01
     938:	9a 81       	ldd	r25, Y+2	; 0x02
     93a:	fc 01       	movw	r30, r24
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	00 d0       	rcall	.+0      	; 0x950 <_ZN6myTime10getMinutesEv+0x6>
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	9a 83       	std	Y+2, r25	; 0x02
     956:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	9a 81       	ldd	r25, Y+2	; 0x02
     95c:	fc 01       	movw	r30, r24
     95e:	81 8d       	ldd	r24, Z+25	; 0x19
     960:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	00 d0       	rcall	.+0      	; 0x972 <_ZN6myTime8getHoursEv+0x6>
     972:	cd b7       	in	r28, 0x3d	; 61
     974:	de b7       	in	r29, 0x3e	; 62
     976:	9a 83       	std	Y+2, r25	; 0x02
     978:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	87 89       	ldd	r24, Z+23	; 0x17
     982:	90 8d       	ldd	r25, Z+24	; 0x18
}
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
     996:	a2 97       	sbiw	r28, 0x22	; 34
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	f8 94       	cli
     99c:	de bf       	out	0x3e, r29	; 62
     99e:	0f be       	out	0x3f, r0	; 63
     9a0:	cd bf       	out	0x3d, r28	; 61
     9a2:	98 a3       	lds	r25, 0x58
     9a4:	8f 8f       	std	Y+31, r24	; 0x1f
     9a6:	7a a3       	lds	r23, 0x5a
     9a8:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     9aa:	ce 01       	movw	r24, r28
     9ac:	0b 96       	adiw	r24, 0x0b	; 11
     9ae:	29 a1       	lds	r18, 0x49
     9b0:	3a a1       	lds	r19, 0x4a
     9b2:	b9 01       	movw	r22, r18
     9b4:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <strcpy>
	for (int j=0; j<3; j++){
     9b8:	1a 82       	std	Y+2, r1	; 0x02
     9ba:	19 82       	std	Y+1, r1	; 0x01
     9bc:	43 c0       	rjmp	.+134    	; 0xa44 <_ZN6myTime7setTimeEPc+0xb6>
		for (int i=0; i<2; i++){
     9be:	1c 82       	std	Y+4, r1	; 0x04
     9c0:	1b 82       	std	Y+3, r1	; 0x03
     9c2:	20 c0       	rjmp	.+64     	; 0xa04 <_ZN6myTime7setTimeEPc+0x76>
				tempString[i]=currentString[i+j*3];
     9c4:	29 81       	ldd	r18, Y+1	; 0x01
     9c6:	3a 81       	ldd	r19, Y+2	; 0x02
     9c8:	c9 01       	movw	r24, r18
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	28 0f       	add	r18, r24
     9d0:	39 1f       	adc	r19, r25
     9d2:	8b 81       	ldd	r24, Y+3	; 0x03
     9d4:	9c 81       	ldd	r25, Y+4	; 0x04
     9d6:	82 0f       	add	r24, r18
     9d8:	93 1f       	adc	r25, r19
     9da:	9e 01       	movw	r18, r28
     9dc:	25 5f       	subi	r18, 0xF5	; 245
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	fc 01       	movw	r30, r24
     9e6:	40 81       	ld	r20, Z
     9e8:	9e 01       	movw	r18, r28
     9ea:	2b 5e       	subi	r18, 0xEB	; 235
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	8b 81       	ldd	r24, Y+3	; 0x03
     9f0:	9c 81       	ldd	r25, Y+4	; 0x04
     9f2:	82 0f       	add	r24, r18
     9f4:	93 1f       	adc	r25, r19
     9f6:	fc 01       	movw	r30, r24
     9f8:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
     9fc:	9c 81       	ldd	r25, Y+4	; 0x04
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	9c 83       	std	Y+4, r25	; 0x04
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	21 e0       	ldi	r18, 0x01	; 1
     a06:	8b 81       	ldd	r24, Y+3	; 0x03
     a08:	9c 81       	ldd	r25, Y+4	; 0x04
     a0a:	82 30       	cpi	r24, 0x02	; 2
     a0c:	91 05       	cpc	r25, r1
     a0e:	0c f0       	brlt	.+2      	; 0xa12 <_ZN6myTime7setTimeEPc+0x84>
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	22 23       	and	r18, r18
     a14:	b9 f6       	brne	.-82     	; 0x9c4 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     a16:	ce 01       	movw	r24, r28
     a18:	45 96       	adiw	r24, 0x15	; 21
     a1a:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
     a1e:	9c 01       	movw	r18, r24
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	ae 01       	movw	r20, r28
     a2a:	4f 5f       	subi	r20, 0xFF	; 255
     a2c:	5f 4f       	sbci	r21, 0xFF	; 255
     a2e:	84 0f       	add	r24, r20
     a30:	95 1f       	adc	r25, r21
     a32:	04 96       	adiw	r24, 0x04	; 4
     a34:	fc 01       	movw	r30, r24
     a36:	31 83       	std	Z+1, r19	; 0x01
     a38:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	9a 81       	ldd	r25, Y+2	; 0x02
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	9a 83       	std	Y+2, r25	; 0x02
     a42:	89 83       	std	Y+1, r24	; 0x01
     a44:	21 e0       	ldi	r18, 0x01	; 1
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	9a 81       	ldd	r25, Y+2	; 0x02
     a4a:	83 30       	cpi	r24, 0x03	; 3
     a4c:	91 05       	cpc	r25, r1
     a4e:	0c f0       	brlt	.+2      	; 0xa52 <_ZN6myTime7setTimeEPc+0xc4>
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	22 23       	and	r18, r18
     a54:	09 f0       	breq	.+2      	; 0xa58 <_ZN6myTime7setTimeEPc+0xca>
     a56:	b3 cf       	rjmp	.-154    	; 0x9be <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	9e 81       	ldd	r25, Y+6	; 0x06
     a5c:	47 96       	adiw	r24, 0x17	; 23
     a5e:	8f 32       	cpi	r24, 0x2F	; 47
     a60:	91 05       	cpc	r25, r1
     a62:	c0 f4       	brcc	.+48     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a64:	8f 81       	ldd	r24, Y+7	; 0x07
     a66:	98 85       	ldd	r25, Y+8	; 0x08
     a68:	cb 96       	adiw	r24, 0x3b	; 59
     a6a:	87 37       	cpi	r24, 0x77	; 119
     a6c:	91 05       	cpc	r25, r1
     a6e:	90 f4       	brcc	.+36     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a70:	89 85       	ldd	r24, Y+9	; 0x09
     a72:	9a 85       	ldd	r25, Y+10	; 0x0a
     a74:	cb 96       	adiw	r24, 0x3b	; 59
     a76:	87 37       	cpi	r24, 0x77	; 119
     a78:	91 05       	cpc	r25, r1
     a7a:	60 f4       	brcc	.+24     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     a7c:	6d 81       	ldd	r22, Y+5	; 0x05
     a7e:	7e 81       	ldd	r23, Y+6	; 0x06
     a80:	4f 81       	ldd	r20, Y+7	; 0x07
     a82:	58 85       	ldd	r21, Y+8	; 0x08
     a84:	29 85       	ldd	r18, Y+9	; 0x09
     a86:	3a 85       	ldd	r19, Y+10	; 0x0a
     a88:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a8a:	98 a1       	lds	r25, 0x48
     a8c:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
		return fTrue;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	01 c0       	rjmp	.+2      	; 0xa96 <_ZN6myTime7setTimeEPc+0x108>
	} 
	return fFalse;
     a94:	80 e0       	ldi	r24, 0x00	; 0
}
     a96:	a2 96       	adiw	r28, 0x22	; 34
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	cd bf       	out	0x3d, r28	; 61
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	cd b7       	in	r28, 0x3d	; 61
     aae:	de b7       	in	r29, 0x3e	; 62
     ab0:	28 97       	sbiw	r28, 0x08	; 8
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	9a 83       	std	Y+2, r25	; 0x02
     abe:	89 83       	std	Y+1, r24	; 0x01
     ac0:	7c 83       	std	Y+4, r23	; 0x04
     ac2:	6b 83       	std	Y+3, r22	; 0x03
     ac4:	5e 83       	std	Y+6, r21	; 0x06
     ac6:	4d 83       	std	Y+5, r20	; 0x05
     ac8:	38 87       	std	Y+8, r19	; 0x08
     aca:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
     ad0:	2b 81       	ldd	r18, Y+3	; 0x03
     ad2:	3c 81       	ldd	r19, Y+4	; 0x04
     ad4:	b9 01       	movw	r22, r18
     ad6:	0e 94 84 05 	call	0xb08	; 0xb08 <_ZN6myTime7setHourEi>
	setMinute(minute);
     ada:	89 81       	ldd	r24, Y+1	; 0x01
     adc:	9a 81       	ldd	r25, Y+2	; 0x02
     ade:	2d 81       	ldd	r18, Y+5	; 0x05
     ae0:	3e 81       	ldd	r19, Y+6	; 0x06
     ae2:	b9 01       	movw	r22, r18
     ae4:	0e 94 a2 05 	call	0xb44	; 0xb44 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     ae8:	89 81       	ldd	r24, Y+1	; 0x01
     aea:	9a 81       	ldd	r25, Y+2	; 0x02
     aec:	2f 81       	ldd	r18, Y+7	; 0x07
     aee:	38 85       	ldd	r19, Y+8	; 0x08
     af0:	b9 01       	movw	r22, r18
     af2:	0e 94 c0 05 	call	0xb80	; 0xb80 <_ZN6myTime9setSecondEi>
}
     af6:	28 96       	adiw	r28, 0x08	; 8
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	de bf       	out	0x3e, r29	; 62
     afe:	0f be       	out	0x3f, r0	; 63
     b00:	cd bf       	out	0x3d, r28	; 61
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     b08:	cf 93       	push	r28
     b0a:	df 93       	push	r29
     b0c:	00 d0       	rcall	.+0      	; 0xb0e <_ZN6myTime7setHourEi+0x6>
     b0e:	00 d0       	rcall	.+0      	; 0xb10 <_ZN6myTime7setHourEi+0x8>
     b10:	cd b7       	in	r28, 0x3d	; 61
     b12:	de b7       	in	r29, 0x3e	; 62
     b14:	9a 83       	std	Y+2, r25	; 0x02
     b16:	89 83       	std	Y+1, r24	; 0x01
     b18:	7c 83       	std	Y+4, r23	; 0x04
     b1a:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     b1c:	8b 81       	ldd	r24, Y+3	; 0x03
     b1e:	9c 81       	ldd	r25, Y+4	; 0x04
     b20:	47 96       	adiw	r24, 0x17	; 23
     b22:	8f 32       	cpi	r24, 0x2F	; 47
     b24:	91 05       	cpc	r25, r1
     b26:	38 f4       	brcc	.+14     	; 0xb36 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     b28:	89 81       	ldd	r24, Y+1	; 0x01
     b2a:	9a 81       	ldd	r25, Y+2	; 0x02
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	3c 81       	ldd	r19, Y+4	; 0x04
     b30:	fc 01       	movw	r30, r24
     b32:	30 8f       	std	Z+24, r19	; 0x18
     b34:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	0f 90       	pop	r0
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <_ZN6myTime9setMinuteEi+0x6>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <_ZN6myTime9setMinuteEi+0x8>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01
     b54:	7c 83       	std	Y+4, r23	; 0x04
     b56:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	cb 96       	adiw	r24, 0x3b	; 59
     b5e:	87 37       	cpi	r24, 0x77	; 119
     b60:	91 05       	cpc	r25, r1
     b62:	38 f4       	brcc	.+14     	; 0xb72 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	2b 81       	ldd	r18, Y+3	; 0x03
     b6a:	3c 81       	ldd	r19, Y+4	; 0x04
     b6c:	fc 01       	movw	r30, r24
     b6e:	32 8f       	std	Z+26, r19	; 0x1a
     b70:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     b72:	0f 90       	pop	r0
     b74:	0f 90       	pop	r0
     b76:	0f 90       	pop	r0
     b78:	0f 90       	pop	r0
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	00 d0       	rcall	.+0      	; 0xb86 <_ZN6myTime9setSecondEi+0x6>
     b86:	00 d0       	rcall	.+0      	; 0xb88 <_ZN6myTime9setSecondEi+0x8>
     b88:	cd b7       	in	r28, 0x3d	; 61
     b8a:	de b7       	in	r29, 0x3e	; 62
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
     b90:	7c 83       	std	Y+4, r23	; 0x04
     b92:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	cb 96       	adiw	r24, 0x3b	; 59
     b9a:	87 37       	cpi	r24, 0x77	; 119
     b9c:	91 05       	cpc	r25, r1
     b9e:	38 f4       	brcc	.+14     	; 0xbae <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	9a 81       	ldd	r25, Y+2	; 0x02
     ba4:	2b 81       	ldd	r18, Y+3	; 0x03
     ba6:	3c 81       	ldd	r19, Y+4	; 0x04
     ba8:	fc 01       	movw	r30, r24
     baa:	34 8f       	std	Z+28, r19	; 0x1c
     bac:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	28 97       	sbiw	r28, 0x08	; 8
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	de bf       	out	0x3e, r29	; 62
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	cd bf       	out	0x3d, r28	; 61
     bd0:	9e 83       	std	Y+6, r25	; 0x06
     bd2:	8d 83       	std	Y+5, r24	; 0x05
     bd4:	78 87       	std	Y+8, r23	; 0x08
     bd6:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     bd8:	8d 81       	ldd	r24, Y+5	; 0x05
     bda:	9e 81       	ldd	r25, Y+6	; 0x06
     bdc:	fc 01       	movw	r30, r24
     bde:	27 89       	ldd	r18, Z+23	; 0x17
     be0:	30 8d       	ldd	r19, Z+24	; 0x18
     be2:	8f 81       	ldd	r24, Y+7	; 0x07
     be4:	98 85       	ldd	r25, Y+8	; 0x08
     be6:	82 0f       	add	r24, r18
     be8:	93 1f       	adc	r25, r19
     bea:	9a 83       	std	Y+2, r25	; 0x02
     bec:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	9a 81       	ldd	r25, Y+2	; 0x02
     bf2:	28 e1       	ldi	r18, 0x18	; 24
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	b9 01       	movw	r22, r18
     bf8:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     bfc:	9c 01       	movw	r18, r24
     bfe:	8d 81       	ldd	r24, Y+5	; 0x05
     c00:	9e 81       	ldd	r25, Y+6	; 0x06
     c02:	fc 01       	movw	r30, r24
     c04:	30 8f       	std	Z+24, r19	; 0x18
     c06:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a 81       	ldd	r25, Y+2	; 0x02
     c0c:	21 e0       	ldi	r18, 0x01	; 1
     c0e:	88 31       	cpi	r24, 0x18	; 24
     c10:	91 05       	cpc	r25, r1
     c12:	0c f4       	brge	.+2      	; 0xc16 <_ZN6myTime8addHoursEi+0x5a>
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	22 23       	and	r18, r18
     c18:	91 f0       	breq	.+36     	; 0xc3e <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	28 e1       	ldi	r18, 0x18	; 24
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	b9 01       	movw	r22, r18
     c24:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     c28:	9b 01       	movw	r18, r22
     c2a:	c9 01       	movw	r24, r18
     c2c:	9c 83       	std	Y+4, r25	; 0x04
     c2e:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     c30:	8d 81       	ldd	r24, Y+5	; 0x05
     c32:	9e 81       	ldd	r25, Y+6	; 0x06
     c34:	2b 81       	ldd	r18, Y+3	; 0x03
     c36:	3c 81       	ldd	r19, Y+4	; 0x04
     c38:	b9 01       	movw	r22, r18
     c3a:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     c3e:	28 96       	adiw	r28, 0x08	; 8
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	08 95       	ret

00000c50 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
     c58:	28 97       	sbiw	r28, 0x08	; 8
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	9e 83       	std	Y+6, r25	; 0x06
     c66:	8d 83       	std	Y+5, r24	; 0x05
     c68:	78 87       	std	Y+8, r23	; 0x08
     c6a:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     c6c:	8d 81       	ldd	r24, Y+5	; 0x05
     c6e:	9e 81       	ldd	r25, Y+6	; 0x06
     c70:	fc 01       	movw	r30, r24
     c72:	21 8d       	ldd	r18, Z+25	; 0x19
     c74:	32 8d       	ldd	r19, Z+26	; 0x1a
     c76:	8f 81       	ldd	r24, Y+7	; 0x07
     c78:	98 85       	ldd	r25, Y+8	; 0x08
     c7a:	82 0f       	add	r24, r18
     c7c:	93 1f       	adc	r25, r19
     c7e:	9a 83       	std	Y+2, r25	; 0x02
     c80:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	9a 81       	ldd	r25, Y+2	; 0x02
     c86:	2c e3       	ldi	r18, 0x3C	; 60
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	b9 01       	movw	r22, r18
     c8c:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     c90:	9c 01       	movw	r18, r24
     c92:	8d 81       	ldd	r24, Y+5	; 0x05
     c94:	9e 81       	ldd	r25, Y+6	; 0x06
     c96:	fc 01       	movw	r30, r24
     c98:	32 8f       	std	Z+26, r19	; 0x1a
     c9a:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ca0:	21 e0       	ldi	r18, 0x01	; 1
     ca2:	8c 33       	cpi	r24, 0x3C	; 60
     ca4:	91 05       	cpc	r25, r1
     ca6:	0c f4       	brge	.+2      	; 0xcaa <_ZN6myTime10addMinutesEi+0x5a>
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	22 23       	and	r18, r18
     cac:	91 f0       	breq	.+36     	; 0xcd2 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	2c e3       	ldi	r18, 0x3C	; 60
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	b9 01       	movw	r22, r18
     cb8:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     cbc:	9b 01       	movw	r18, r22
     cbe:	c9 01       	movw	r24, r18
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     cc4:	2b 81       	ldd	r18, Y+3	; 0x03
     cc6:	3c 81       	ldd	r19, Y+4	; 0x04
     cc8:	8d 81       	ldd	r24, Y+5	; 0x05
     cca:	9e 81       	ldd	r25, Y+6	; 0x06
     ccc:	b9 01       	movw	r22, r18
     cce:	0e 94 de 05 	call	0xbbc	; 0xbbc <_ZN6myTime8addHoursEi>
	}
}
     cd2:	28 96       	adiw	r28, 0x08	; 8
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	cd b7       	in	r28, 0x3d	; 61
     cea:	de b7       	in	r29, 0x3e	; 62
     cec:	28 97       	sbiw	r28, 0x08	; 8
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	de bf       	out	0x3e, r29	; 62
     cf4:	0f be       	out	0x3f, r0	; 63
     cf6:	cd bf       	out	0x3d, r28	; 61
     cf8:	9e 83       	std	Y+6, r25	; 0x06
     cfa:	8d 83       	std	Y+5, r24	; 0x05
     cfc:	78 87       	std	Y+8, r23	; 0x08
     cfe:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	9e 81       	ldd	r25, Y+6	; 0x06
     d04:	fc 01       	movw	r30, r24
     d06:	23 8d       	ldd	r18, Z+27	; 0x1b
     d08:	34 8d       	ldd	r19, Z+28	; 0x1c
     d0a:	8f 81       	ldd	r24, Y+7	; 0x07
     d0c:	98 85       	ldd	r25, Y+8	; 0x08
     d0e:	82 0f       	add	r24, r18
     d10:	93 1f       	adc	r25, r19
     d12:	9a 83       	std	Y+2, r25	; 0x02
     d14:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     d16:	89 81       	ldd	r24, Y+1	; 0x01
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	2c e3       	ldi	r18, 0x3C	; 60
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	b9 01       	movw	r22, r18
     d20:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     d24:	9c 01       	movw	r18, r24
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	fc 01       	movw	r30, r24
     d2c:	34 8f       	std	Z+28, r19	; 0x1c
     d2e:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	9a 81       	ldd	r25, Y+2	; 0x02
     d34:	21 e0       	ldi	r18, 0x01	; 1
     d36:	8c 33       	cpi	r24, 0x3C	; 60
     d38:	91 05       	cpc	r25, r1
     d3a:	0c f4       	brge	.+2      	; 0xd3e <_ZN6myTime10addSecondsEi+0x5a>
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	22 23       	and	r18, r18
     d40:	91 f0       	breq	.+36     	; 0xd66 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     d42:	89 81       	ldd	r24, Y+1	; 0x01
     d44:	9a 81       	ldd	r25, Y+2	; 0x02
     d46:	2c e3       	ldi	r18, 0x3C	; 60
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	b9 01       	movw	r22, r18
     d4c:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
     d50:	9b 01       	movw	r18, r22
     d52:	c9 01       	movw	r24, r18
     d54:	9c 83       	std	Y+4, r25	; 0x04
     d56:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     d58:	2b 81       	ldd	r18, Y+3	; 0x03
     d5a:	3c 81       	ldd	r19, Y+4	; 0x04
     d5c:	8d 81       	ldd	r24, Y+5	; 0x05
     d5e:	9e 81       	ldd	r25, Y+6	; 0x06
     d60:	b9 01       	movw	r22, r18
     d62:	0e 94 28 06 	call	0xc50	; 0xc50 <_ZN6myTime10addMinutesEi>
	}
}
     d66:	28 96       	adiw	r28, 0x08	; 8
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	08 95       	ret

00000d78 <_ZN6myTime13checkValidityEv>:

BOOL myTime::checkValidity(){
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	00 d0       	rcall	.+0      	; 0xd7e <_ZN6myTime13checkValidityEv+0x6>
     d7e:	0f 92       	push	r0
     d80:	cd b7       	in	r28, 0x3d	; 61
     d82:	de b7       	in	r29, 0x3e	; 62
     d84:	9b 83       	std	Y+3, r25	; 0x03
     d86:	8a 83       	std	Y+2, r24	; 0x02
	BOOL stillValid=fTrue;
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	89 83       	std	Y+1, r24	; 0x01
	if (second/60==0 && minute/60==0 && hour/24==0){
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	fc 01       	movw	r30, r24
     d92:	83 8d       	ldd	r24, Z+27	; 0x1b
     d94:	94 8d       	ldd	r25, Z+28	; 0x1c
     d96:	cb 96       	adiw	r24, 0x3b	; 59
     d98:	87 37       	cpi	r24, 0x77	; 119
     d9a:	91 05       	cpc	r25, r1
     d9c:	a0 f4       	brcc	.+40     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	fc 01       	movw	r30, r24
     da4:	81 8d       	ldd	r24, Z+25	; 0x19
     da6:	92 8d       	ldd	r25, Z+26	; 0x1a
     da8:	cb 96       	adiw	r24, 0x3b	; 59
     daa:	87 37       	cpi	r24, 0x77	; 119
     dac:	91 05       	cpc	r25, r1
     dae:	58 f4       	brcc	.+22     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	9b 81       	ldd	r25, Y+3	; 0x03
     db4:	fc 01       	movw	r30, r24
     db6:	87 89       	ldd	r24, Z+23	; 0x17
     db8:	90 8d       	ldd	r25, Z+24	; 0x18
     dba:	47 96       	adiw	r24, 0x17	; 23
     dbc:	8f 32       	cpi	r24, 0x2F	; 47
     dbe:	91 05       	cpc	r25, r1
     dc0:	10 f4       	brcc	.+4      	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <_ZN6myTime13checkValidityEv+0x50>
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	88 23       	and	r24, r24
     dca:	69 f0       	breq	.+26     	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
		if (checkValidityDate()){return fTrue;}
     dcc:	8a 81       	ldd	r24, Y+2	; 0x02
     dce:	9b 81       	ldd	r25, Y+3	; 0x03
     dd0:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate17checkValidityDateEv>
     dd4:	98 2f       	mov	r25, r24
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	99 23       	and	r25, r25
     dda:	09 f4       	brne	.+2      	; 0xdde <_ZN6myTime13checkValidityEv+0x66>
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	88 23       	and	r24, r24
     de0:	11 f0       	breq	.+4      	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	01 c0       	rjmp	.+2      	; 0xde8 <_ZN6myTime13checkValidityEv+0x70>
	}
	return fFalse;
     de6:	80 e0       	ldi	r24, 0x00	; 0
}
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	cd b7       	in	r28, 0x3d	; 61
     dfa:	de b7       	in	r29, 0x3e	; 62
     dfc:	2b 97       	sbiw	r28, 0x0b	; 11
     dfe:	0f b6       	in	r0, 0x3f	; 63
     e00:	f8 94       	cli
     e02:	de bf       	out	0x3e, r29	; 62
     e04:	0f be       	out	0x3f, r0	; 63
     e06:	cd bf       	out	0x3d, r28	; 61
     e08:	9b 87       	std	Y+11, r25	; 0x0b
     e0a:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e10:	fc 01       	movw	r30, r24
     e12:	87 89       	ldd	r24, Z+23	; 0x17
     e14:	90 8d       	ldd	r25, Z+24	; 0x18
     e16:	9e 01       	movw	r18, r28
     e18:	2f 5f       	subi	r18, 0xFF	; 255
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	b9 01       	movw	r22, r18
     e1e:	4a e0       	ldi	r20, 0x0A	; 10
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <itoa>
	itoa(minute,minuteString,10);
     e26:	8a 85       	ldd	r24, Y+10	; 0x0a
     e28:	9b 85       	ldd	r25, Y+11	; 0x0b
     e2a:	fc 01       	movw	r30, r24
     e2c:	81 8d       	ldd	r24, Z+25	; 0x19
     e2e:	92 8d       	ldd	r25, Z+26	; 0x1a
     e30:	9e 01       	movw	r18, r28
     e32:	2c 5f       	subi	r18, 0xFC	; 252
     e34:	3f 4f       	sbci	r19, 0xFF	; 255
     e36:	b9 01       	movw	r22, r18
     e38:	4a e0       	ldi	r20, 0x0A	; 10
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <itoa>
	itoa(second,secondString,10);
     e40:	8a 85       	ldd	r24, Y+10	; 0x0a
     e42:	9b 85       	ldd	r25, Y+11	; 0x0b
     e44:	fc 01       	movw	r30, r24
     e46:	83 8d       	ldd	r24, Z+27	; 0x1b
     e48:	94 8d       	ldd	r25, Z+28	; 0x1c
     e4a:	9e 01       	movw	r18, r28
     e4c:	29 5f       	subi	r18, 0xF9	; 249
     e4e:	3f 4f       	sbci	r19, 0xFF	; 255
     e50:	b9 01       	movw	r22, r18
     e52:	4a e0       	ldi	r20, 0x0A	; 10
     e54:	50 e0       	ldi	r21, 0x00	; 0
     e56:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <itoa>
	strcpy(timeString,hourString);
     e5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e5e:	4d 96       	adiw	r24, 0x1d	; 29
     e60:	9e 01       	movw	r18, r28
     e62:	2f 5f       	subi	r18, 0xFF	; 255
     e64:	3f 4f       	sbci	r19, 0xFF	; 255
     e66:	b9 01       	movw	r22, r18
     e68:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <strcpy>
	strcat(timeString,":");
     e6c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e6e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e70:	9c 01       	movw	r18, r24
     e72:	23 5e       	subi	r18, 0xE3	; 227
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	c9 01       	movw	r24, r18
     e78:	ac 01       	movw	r20, r24
     e7a:	fa 01       	movw	r30, r20
     e7c:	01 90       	ld	r0, Z+
     e7e:	00 20       	and	r0, r0
     e80:	e9 f7       	brne	.-6      	; 0xe7c <_ZN6myTime7getTimeEv+0x88>
     e82:	cf 01       	movw	r24, r30
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	84 1b       	sub	r24, r20
     e88:	95 0b       	sbc	r25, r21
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	2a e3       	ldi	r18, 0x3A	; 58
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	fc 01       	movw	r30, r24
     e94:	31 83       	std	Z+1, r19	; 0x01
     e96:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     e98:	8a 85       	ldd	r24, Y+10	; 0x0a
     e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9c:	4d 96       	adiw	r24, 0x1d	; 29
     e9e:	9e 01       	movw	r18, r28
     ea0:	2c 5f       	subi	r18, 0xFC	; 252
     ea2:	3f 4f       	sbci	r19, 0xFF	; 255
     ea4:	b9 01       	movw	r22, r18
     ea6:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <strcat>
	strcat(timeString,":");
     eaa:	8a 85       	ldd	r24, Y+10	; 0x0a
     eac:	9b 85       	ldd	r25, Y+11	; 0x0b
     eae:	9c 01       	movw	r18, r24
     eb0:	23 5e       	subi	r18, 0xE3	; 227
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	c9 01       	movw	r24, r18
     eb6:	ac 01       	movw	r20, r24
     eb8:	fa 01       	movw	r30, r20
     eba:	01 90       	ld	r0, Z+
     ebc:	00 20       	and	r0, r0
     ebe:	e9 f7       	brne	.-6      	; 0xeba <_ZN6myTime7getTimeEv+0xc6>
     ec0:	cf 01       	movw	r24, r30
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	84 1b       	sub	r24, r20
     ec6:	95 0b       	sbc	r25, r21
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	2a e3       	ldi	r18, 0x3A	; 58
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	fc 01       	movw	r30, r24
     ed2:	31 83       	std	Z+1, r19	; 0x01
     ed4:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
     eda:	4d 96       	adiw	r24, 0x1d	; 29
     edc:	9e 01       	movw	r18, r28
     ede:	29 5f       	subi	r18, 0xF9	; 249
     ee0:	3f 4f       	sbci	r19, 0xFF	; 255
     ee2:	b9 01       	movw	r22, r18
     ee4:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <strcat>
	timeString[11] = '\0';
     ee8:	8a 85       	ldd	r24, Y+10	; 0x0a
     eea:	9b 85       	ldd	r25, Y+11	; 0x0b
     eec:	fc 01       	movw	r30, r24
     eee:	10 a6       	lds	r17, 0xb0
	return timeString;
     ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ef4:	4d 96       	adiw	r24, 0x1d	; 29
     ef6:	2b 96       	adiw	r28, 0x0b	; 11
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 8;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	2f 97       	sbiw	r28, 0x0f	; 15
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	8e 87       	std	Y+14, r24	; 0x0e
     f1e:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     f20:	f8 94       	cli
	if (gTime){
     f22:	8e 85       	ldd	r24, Y+14	; 0x0e
     f24:	88 23       	and	r24, r24
     f26:	09 f4       	brne	.+2      	; 0xf2a <_Z18getDateTime_eepromhh+0x22>
     f28:	4b c0       	rjmp	.+150    	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     f2a:	1a 82       	std	Y+2, r1	; 0x02
     f2c:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     f32:	2c c0       	rjmp	.+88     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__eerd_byte_m644pa>
     f3c:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__eerd_byte_m644pa>
     f46:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__eerd_byte_m644pa>
     f50:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     f52:	8f 81       	ldd	r24, Y+7	; 0x07
     f54:	8c 33       	cpi	r24, 0x3C	; 60
     f56:	a8 f4       	brcc	.+42     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f58:	88 85       	ldd	r24, Y+8	; 0x08
     f5a:	8c 33       	cpi	r24, 0x3C	; 60
     f5c:	90 f4       	brcc	.+36     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f5e:	89 85       	ldd	r24, Y+9	; 0x09
     f60:	88 31       	cpi	r24, 0x18	; 24
     f62:	78 f4       	brcc	.+30     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	68 2f       	mov	r22, r24
     f68:	70 e0       	ldi	r23, 0x00	; 0
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	48 2f       	mov	r20, r24
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	8f 81       	ldd	r24, Y+7	; 0x07
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	82 ee       	ldi	r24, 0xE2	; 226
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
     f7e:	1b 82       	std	Y+3, r1	; 0x03
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	9a 81       	ldd	r25, Y+2	; 0x02
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     f8c:	8b 81       	ldd	r24, Y+3	; 0x03
     f8e:	88 23       	and	r24, r24
     f90:	39 f0       	breq	.+14     	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	9a 81       	ldd	r25, Y+2	; 0x02
     f96:	83 30       	cpi	r24, 0x03	; 3
     f98:	91 05       	cpc	r25, r1
     f9a:	14 f4       	brge	.+4      	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <_Z18getDateTime_eepromhh+0x9a>
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	88 23       	and	r24, r24
     fa4:	39 f6       	brne	.-114    	; 0xf34 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     fa6:	8b 81       	ldd	r24, Y+3	; 0x03
     fa8:	88 23       	and	r24, r24
     faa:	51 f0       	breq	.+20     	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
     fac:	82 ee       	ldi	r24, 0xE2	; 226
     fae:	91 e0       	ldi	r25, 0x01	; 1
     fb0:	61 e0       	ldi	r22, 0x01	; 1
     fb2:	70 e0       	ldi	r23, 0x00	; 0
     fb4:	41 e0       	ldi	r20, 0x01	; 1
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	21 e0       	ldi	r18, 0x01	; 1
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
     fc2:	88 23       	and	r24, r24
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <_Z18getDateTime_eepromhh+0xc0>
     fc6:	4e c0       	rjmp	.+156    	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     fc8:	1d 82       	std	Y+5, r1	; 0x05
     fca:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     fcc:	81 e0       	ldi	r24, 0x01	; 1
     fce:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     fd0:	2f c0       	rjmp	.+94     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     fd2:	84 e0       	ldi	r24, 0x04	; 4
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__eerd_byte_m644pa>
     fda:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <__eerd_byte_m644pa>
     fe4:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     fe6:	85 e0       	ldi	r24, 0x05	; 5
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	0e 94 65 1d 	call	0x3aca	; 0x3aca <__eerd_word_m644pa>
     fee:	9d 87       	std	Y+13, r25	; 0x0d
     ff0:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     ff2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff4:	8f 31       	cpi	r24, 0x1F	; 31
     ff6:	b8 f4       	brcc	.+46     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ff8:	8b 85       	ldd	r24, Y+11	; 0x0b
     ffa:	8d 30       	cpi	r24, 0x0D	; 13
     ffc:	a0 f4       	brcc	.+40     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ffe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1000:	9d 85       	ldd	r25, Y+13	; 0x0d
    1002:	27 e2       	ldi	r18, 0x27	; 39
    1004:	80 31       	cpi	r24, 0x10	; 16
    1006:	92 07       	cpc	r25, r18
    1008:	70 f4       	brcc	.+28     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
    100a:	8b 85       	ldd	r24, Y+11	; 0x0b
    100c:	68 2f       	mov	r22, r24
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	8a 85       	ldd	r24, Y+10	; 0x0a
    1012:	48 2f       	mov	r20, r24
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	2c 85       	ldd	r18, Y+12	; 0x0c
    1018:	3d 85       	ldd	r19, Y+13	; 0x0d
    101a:	82 ee       	ldi	r24, 0xE2	; 226
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
    1022:	1e 82       	std	Y+6, r1	; 0x06
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
    1026:	8c 81       	ldd	r24, Y+4	; 0x04
    1028:	9d 81       	ldd	r25, Y+5	; 0x05
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	9d 83       	std	Y+5, r25	; 0x05
    102e:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
    1030:	8e 81       	ldd	r24, Y+6	; 0x06
    1032:	88 23       	and	r24, r24
    1034:	39 f0       	breq	.+14     	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	9d 81       	ldd	r25, Y+5	; 0x05
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	91 05       	cpc	r25, r1
    103e:	14 f4       	brge	.+4      	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <_Z18getDateTime_eepromhh+0x13e>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	88 23       	and	r24, r24
    1048:	21 f6       	brne	.-120    	; 0xfd2 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	88 23       	and	r24, r24
    104e:	51 f0       	breq	.+20     	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
    1050:	82 ee       	ldi	r24, 0xE2	; 226
    1052:	91 e0       	ldi	r25, 0x01	; 1
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	70 e0       	ldi	r23, 0x00	; 0
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	21 ed       	ldi	r18, 0xD1	; 209
    105e:	37 e0       	ldi	r19, 0x07	; 7
    1060:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
    1064:	78 94       	sei
}
    1066:	2f 96       	adiw	r28, 0x0f	; 15
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	29 97       	sbiw	r28, 0x09	; 9
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	88 87       	std	Y+8, r24	; 0x08
    108e:	69 87       	std	Y+9, r22	; 0x09
	cli();
    1090:	f8 94       	cli
	if (sTime){
    1092:	88 85       	ldd	r24, Y+8	; 0x08
    1094:	88 23       	and	r24, r24
    1096:	f1 f0       	breq	.+60     	; 0x10d4 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
    1098:	82 ee       	ldi	r24, 0xE2	; 226
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    10a0:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
    10a2:	82 ee       	ldi	r24, 0xE2	; 226
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    10aa:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
    10ac:	82 ee       	ldi	r24, 0xE2	; 226
    10ae:	91 e0       	ldi	r25, 0x01	; 1
    10b0:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    10b4:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	6b 81       	ldd	r22, Y+3	; 0x03
    10bc:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeMinute,tempMin);
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	6a 81       	ldd	r22, Y+2	; 0x02
    10c6:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeHour,tempHour);
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	69 81       	ldd	r22, Y+1	; 0x01
    10d0:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__eewr_byte_m644pa>
	}
	if (sDate){
    10d4:	89 85       	ldd	r24, Y+9	; 0x09
    10d6:	88 23       	and	r24, r24
    10d8:	09 f1       	breq	.+66     	; 0x111c <__stack+0x1d>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
    10da:	82 ee       	ldi	r24, 0xE2	; 226
    10dc:	91 e0       	ldi	r25, 0x01	; 1
    10de:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
    10e2:	9d 83       	std	Y+5, r25	; 0x05
    10e4:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
    10e6:	82 ee       	ldi	r24, 0xE2	; 226
    10e8:	91 e0       	ldi	r25, 0x01	; 1
    10ea:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
    10ee:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
    10f0:	82 ee       	ldi	r24, 0xE2	; 226
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
    10f8:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
    10fa:	85 e0       	ldi	r24, 0x05	; 5
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1100:	3d 81       	ldd	r19, Y+5	; 0x05
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 79 1d 	call	0x3af2	; 0x3af2 <__eewr_word_m644pa>
		eeprom_write_byte(&eeMonth,tempMonth);
    1108:	83 e0       	ldi	r24, 0x03	; 3
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	6e 81       	ldd	r22, Y+6	; 0x06
    110e:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeDay,tempDay);
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	6f 81       	ldd	r22, Y+7	; 0x07
    1118:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__eewr_byte_m644pa>
	}
	sei();
    111c:	78 94       	sei
}
    111e:	29 96       	adiw	r28, 0x09	; 9
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	cd bf       	out	0x3d, r28	; 61
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	08 95       	ret

00001130 <_Z8Wait_seci>:
extern WORD globalADC, globalTemp;
extern myTime currentTime;


/************************************************************************************************************/
void Wait_sec(int sec){
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	00 d0       	rcall	.+0      	; 0x1136 <_Z8Wait_seci+0x6>
    1136:	00 d0       	rcall	.+0      	; 0x1138 <_Z8Wait_seci+0x8>
    1138:	00 d0       	rcall	.+0      	; 0x113a <_Z8Wait_seci+0xa>
    113a:	cd b7       	in	r28, 0x3d	; 61
    113c:	de b7       	in	r29, 0x3e	; 62
    113e:	9e 83       	std	Y+6, r25	; 0x06
    1140:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    1142:	82 ee       	ldi	r24, 0xE2	; 226
    1144:	91 e0       	ldi	r25, 0x01	; 1
    1146:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    114a:	88 2f       	mov	r24, r24
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	9a 83       	std	Y+2, r25	; 0x02
    1150:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    1152:	29 81       	ldd	r18, Y+1	; 0x01
    1154:	3a 81       	ldd	r19, Y+2	; 0x02
    1156:	8d 81       	ldd	r24, Y+5	; 0x05
    1158:	9e 81       	ldd	r25, Y+6	; 0x06
    115a:	82 0f       	add	r24, r18
    115c:	93 1f       	adc	r25, r19
    115e:	2c e3       	ldi	r18, 0x3C	; 60
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	b9 01       	movw	r22, r18
    1164:	0e 94 aa 1c 	call	0x3954	; 0x3954 <__divmodhi4>
    1168:	9c 83       	std	Y+4, r25	; 0x04
    116a:	8b 83       	std	Y+3, r24	; 0x03
while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    116c:	01 c0       	rjmp	.+2      	; 0x1170 <_Z8Wait_seci+0x40>
    116e:	00 00       	nop
    1170:	82 ee       	ldi	r24, 0xE2	; 226
    1172:	91 e0       	ldi	r25, 0x01	; 1
    1174:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    1178:	28 2f       	mov	r18, r24
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	8b 81       	ldd	r24, Y+3	; 0x03
    117e:	9c 81       	ldd	r25, Y+4	; 0x04
    1180:	41 e0       	ldi	r20, 0x01	; 1
    1182:	28 17       	cp	r18, r24
    1184:	39 07       	cpc	r19, r25
    1186:	09 f4       	brne	.+2      	; 0x118a <_Z8Wait_seci+0x5a>
    1188:	40 e0       	ldi	r20, 0x00	; 0
    118a:	44 23       	and	r20, r20
    118c:	81 f7       	brne	.-32     	; 0x116e <_Z8Wait_seci+0x3e>
}
    118e:	26 96       	adiw	r28, 0x06	; 6
    1190:	0f b6       	in	r0, 0x3f	; 63
    1192:	f8 94       	cli
    1194:	de bf       	out	0x3e, r29	; 62
    1196:	0f be       	out	0x3f, r0	; 63
    1198:	cd bf       	out	0x3d, r28	; 61
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	08 95       	ret

000011a0 <_Z7Wait_msi>:
/************************************************************************************************************/
void Wait_ms(int delay)
{
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	00 d0       	rcall	.+0      	; 0x11a6 <_Z7Wait_msi+0x6>
    11a6:	00 d0       	rcall	.+0      	; 0x11a8 <_Z7Wait_msi+0x8>
    11a8:	cd b7       	in	r28, 0x3d	; 61
    11aa:	de b7       	in	r29, 0x3e	; 62
    11ac:	9c 83       	std	Y+4, r25	; 0x04
    11ae:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    11b0:	17 c0       	rjmp	.+46     	; 0x11e0 <_Z7Wait_msi+0x40>
		for(i = 0; i < 200; i++){
    11b2:	1a 82       	std	Y+2, r1	; 0x02
    11b4:	19 82       	std	Y+1, r1	; 0x01
    11b6:	06 c0       	rjmp	.+12     	; 0x11c4 <_Z7Wait_msi+0x24>
			asm volatile("nop");
    11b8:	00 00       	nop
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 200; i++){
    11ba:	89 81       	ldd	r24, Y+1	; 0x01
    11bc:	9a 81       	ldd	r25, Y+2	; 0x02
    11be:	01 96       	adiw	r24, 0x01	; 1
    11c0:	9a 83       	std	Y+2, r25	; 0x02
    11c2:	89 83       	std	Y+1, r24	; 0x01
    11c4:	89 81       	ldd	r24, Y+1	; 0x01
    11c6:	9a 81       	ldd	r25, Y+2	; 0x02
    11c8:	21 e0       	ldi	r18, 0x01	; 1
    11ca:	88 3c       	cpi	r24, 0xC8	; 200
    11cc:	91 05       	cpc	r25, r1
    11ce:	0c f0       	brlt	.+2      	; 0x11d2 <_Z7Wait_msi+0x32>
    11d0:	20 e0       	ldi	r18, 0x00	; 0
    11d2:	22 23       	and	r18, r18
    11d4:	89 f7       	brne	.-30     	; 0x11b8 <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    11d6:	8b 81       	ldd	r24, Y+3	; 0x03
    11d8:	9c 81       	ldd	r25, Y+4	; 0x04
    11da:	01 97       	sbiw	r24, 0x01	; 1
    11dc:	9c 83       	std	Y+4, r25	; 0x04
    11de:	8b 83       	std	Y+3, r24	; 0x03
/************************************************************************************************************/
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
    11e0:	21 e0       	ldi	r18, 0x01	; 1
    11e2:	8b 81       	ldd	r24, Y+3	; 0x03
    11e4:	9c 81       	ldd	r25, Y+4	; 0x04
    11e6:	18 16       	cp	r1, r24
    11e8:	19 06       	cpc	r1, r25
    11ea:	0c f0       	brlt	.+2      	; 0x11ee <_Z7Wait_msi+0x4e>
    11ec:	20 e0       	ldi	r18, 0x00	; 0
    11ee:	22 23       	and	r18, r18
    11f0:	01 f7       	brne	.-64     	; 0x11b2 <_Z7Wait_msi+0x12>
		for(i = 0; i < 200; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	0f 90       	pop	r0
    11f8:	0f 90       	pop	r0
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
    11fe:	08 95       	ret

00001200 <_Z17SendInterruptGAVRv>:
/************************************************************************************************************/
void SendInterruptGAVR(){
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	00 d0       	rcall	.+0      	; 0x1206 <_Z17SendInterruptGAVRv+0x6>
    1206:	cd b7       	in	r28, 0x3d	; 61
    1208:	de b7       	in	r29, 0x3e	; 62
	//Raise interrupts to GAVR for three ish clock cycles. Tried waiting....didn't work.
	prtGAVRINT |= (1 << bnGAVRINT);
    120a:	85 e2       	ldi	r24, 0x25	; 37
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	25 e2       	ldi	r18, 0x25	; 37
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	f9 01       	movw	r30, r18
    1214:	20 81       	ld	r18, Z
    1216:	28 60       	ori	r18, 0x08	; 8
    1218:	fc 01       	movw	r30, r24
    121a:	20 83       	st	Z, r18
	for (int i=0; i<2; i++){asm ("nop");}
    121c:	1a 82       	std	Y+2, r1	; 0x02
    121e:	19 82       	std	Y+1, r1	; 0x01
    1220:	06 c0       	rjmp	.+12     	; 0x122e <_Z17SendInterruptGAVRv+0x2e>
    1222:	00 00       	nop
    1224:	89 81       	ldd	r24, Y+1	; 0x01
    1226:	9a 81       	ldd	r25, Y+2	; 0x02
    1228:	01 96       	adiw	r24, 0x01	; 1
    122a:	9a 83       	std	Y+2, r25	; 0x02
    122c:	89 83       	std	Y+1, r24	; 0x01
    122e:	21 e0       	ldi	r18, 0x01	; 1
    1230:	89 81       	ldd	r24, Y+1	; 0x01
    1232:	9a 81       	ldd	r25, Y+2	; 0x02
    1234:	82 30       	cpi	r24, 0x02	; 2
    1236:	91 05       	cpc	r25, r1
    1238:	0c f0       	brlt	.+2      	; 0x123c <_Z17SendInterruptGAVRv+0x3c>
    123a:	20 e0       	ldi	r18, 0x00	; 0
    123c:	22 23       	and	r18, r18
    123e:	89 f7       	brne	.-30     	; 0x1222 <_Z17SendInterruptGAVRv+0x22>
	prtGAVRINT &= ~(1 << bnGAVRINT);
    1240:	85 e2       	ldi	r24, 0x25	; 37
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	25 e2       	ldi	r18, 0x25	; 37
    1246:	30 e0       	ldi	r19, 0x00	; 0
    1248:	f9 01       	movw	r30, r18
    124a:	20 81       	ld	r18, Z
    124c:	27 7f       	andi	r18, 0xF7	; 247
    124e:	fc 01       	movw	r30, r24
    1250:	20 83       	st	Z, r18
}
    1252:	0f 90       	pop	r0
    1254:	0f 90       	pop	r0
    1256:	df 91       	pop	r29
    1258:	cf 91       	pop	r28
    125a:	08 95       	ret

0000125c <_Z13PutUartChBonec>:

/**************************************************************************************************************/
void PutUartChBone(char ch){
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	0f 92       	push	r0
    1262:	cd b7       	in	r28, 0x3d	; 61
    1264:	de b7       	in	r29, 0x3e	; 62
    1266:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
    1268:	00 00       	nop
    126a:	80 ec       	ldi	r24, 0xC0	; 192
    126c:	90 e0       	ldi	r25, 0x00	; 0
    126e:	fc 01       	movw	r30, r24
    1270:	80 81       	ld	r24, Z
    1272:	88 2f       	mov	r24, r24
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	80 72       	andi	r24, 0x20	; 32
    1278:	90 70       	andi	r25, 0x00	; 0
    127a:	21 e0       	ldi	r18, 0x01	; 1
    127c:	00 97       	sbiw	r24, 0x00	; 0
    127e:	09 f0       	breq	.+2      	; 0x1282 <_Z13PutUartChBonec+0x26>
    1280:	20 e0       	ldi	r18, 0x00	; 0
    1282:	22 23       	and	r18, r18
    1284:	91 f7       	brne	.-28     	; 0x126a <_Z13PutUartChBonec+0xe>
	UDR0=ch;
    1286:	86 ec       	ldi	r24, 0xC6	; 198
    1288:	90 e0       	ldi	r25, 0x00	; 0
    128a:	29 81       	ldd	r18, Y+1	; 0x01
    128c:	fc 01       	movw	r30, r24
    128e:	20 83       	st	Z, r18
}
    1290:	0f 90       	pop	r0
    1292:	df 91       	pop	r29
    1294:	cf 91       	pop	r28
    1296:	08 95       	ret

00001298 <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
    1298:	cf 93       	push	r28
    129a:	df 93       	push	r29
    129c:	00 d0       	rcall	.+0      	; 0x129e <_Z9PrintBonePc+0x6>
    129e:	0f 92       	push	r0
    12a0:	cd b7       	in	r28, 0x3d	; 61
    12a2:	de b7       	in	r29, 0x3e	; 62
    12a4:	9b 83       	std	Y+3, r25	; 0x03
    12a6:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    12a8:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    12aa:	0e c0       	rjmp	.+28     	; 0x12c8 <_Z9PrintBonePc+0x30>
		PutUartChBone(string[i++]);
    12ac:	89 81       	ldd	r24, Y+1	; 0x01
    12ae:	88 2f       	mov	r24, r24
    12b0:	90 e0       	ldi	r25, 0x00	; 0
    12b2:	2a 81       	ldd	r18, Y+2	; 0x02
    12b4:	3b 81       	ldd	r19, Y+3	; 0x03
    12b6:	82 0f       	add	r24, r18
    12b8:	93 1f       	adc	r25, r19
    12ba:	fc 01       	movw	r30, r24
    12bc:	80 81       	ld	r24, Z
    12be:	99 81       	ldd	r25, Y+1	; 0x01
    12c0:	9f 5f       	subi	r25, 0xFF	; 255
    12c2:	99 83       	std	Y+1, r25	; 0x01
    12c4:	0e 94 2e 09 	call	0x125c	; 0x125c <_Z13PutUartChBonec>
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    12c8:	89 81       	ldd	r24, Y+1	; 0x01
    12ca:	88 2f       	mov	r24, r24
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	2a 81       	ldd	r18, Y+2	; 0x02
    12d0:	3b 81       	ldd	r19, Y+3	; 0x03
    12d2:	82 0f       	add	r24, r18
    12d4:	93 1f       	adc	r25, r19
    12d6:	fc 01       	movw	r30, r24
    12d8:	90 81       	ld	r25, Z
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	99 23       	and	r25, r25
    12de:	09 f4       	brne	.+2      	; 0x12e2 <_Z9PrintBonePc+0x4a>
    12e0:	80 e0       	ldi	r24, 0x00	; 0
    12e2:	88 23       	and	r24, r24
    12e4:	19 f7       	brne	.-58     	; 0x12ac <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i++]);
	}
}
    12e6:	0f 90       	pop	r0
    12e8:	0f 90       	pop	r0
    12ea:	0f 90       	pop	r0
    12ec:	df 91       	pop	r29
    12ee:	cf 91       	pop	r28
    12f0:	08 95       	ret

000012f2 <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    12f2:	cf 93       	push	r28
    12f4:	df 93       	push	r29
    12f6:	0f 92       	push	r0
    12f8:	cd b7       	in	r28, 0x3d	; 61
    12fa:	de b7       	in	r29, 0x3e	; 62
    12fc:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    12fe:	00 00       	nop
    1300:	88 ec       	ldi	r24, 0xC8	; 200
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	fc 01       	movw	r30, r24
    1306:	80 81       	ld	r24, Z
    1308:	88 2f       	mov	r24, r24
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	80 72       	andi	r24, 0x20	; 32
    130e:	90 70       	andi	r25, 0x00	; 0
    1310:	21 e0       	ldi	r18, 0x01	; 1
    1312:	00 97       	sbiw	r24, 0x00	; 0
    1314:	09 f0       	breq	.+2      	; 0x1318 <_Z13PutUartChGAVRc+0x26>
    1316:	20 e0       	ldi	r18, 0x00	; 0
    1318:	22 23       	and	r18, r18
    131a:	91 f7       	brne	.-28     	; 0x1300 <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    131c:	8e ec       	ldi	r24, 0xCE	; 206
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	29 81       	ldd	r18, Y+1	; 0x01
    1322:	fc 01       	movw	r30, r24
    1324:	20 83       	st	Z, r18
}
    1326:	0f 90       	pop	r0
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	08 95       	ret

0000132e <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    132e:	cf 93       	push	r28
    1330:	df 93       	push	r29
    1332:	00 d0       	rcall	.+0      	; 0x1334 <_Z9PrintGAVRPc+0x6>
    1334:	0f 92       	push	r0
    1336:	cd b7       	in	r28, 0x3d	; 61
    1338:	de b7       	in	r29, 0x3e	; 62
    133a:	9b 83       	std	Y+3, r25	; 0x03
    133c:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    133e:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    1340:	12 c0       	rjmp	.+36     	; 0x1366 <_Z9PrintGAVRPc+0x38>
		Wait_ms(350);
    1342:	8e e5       	ldi	r24, 0x5E	; 94
    1344:	91 e0       	ldi	r25, 0x01	; 1
    1346:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		PutUartChGAVR(string[i++]);
    134a:	89 81       	ldd	r24, Y+1	; 0x01
    134c:	88 2f       	mov	r24, r24
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	2a 81       	ldd	r18, Y+2	; 0x02
    1352:	3b 81       	ldd	r19, Y+3	; 0x03
    1354:	82 0f       	add	r24, r18
    1356:	93 1f       	adc	r25, r19
    1358:	fc 01       	movw	r30, r24
    135a:	80 81       	ld	r24, Z
    135c:	99 81       	ldd	r25, Y+1	; 0x01
    135e:	9f 5f       	subi	r25, 0xFF	; 255
    1360:	99 83       	std	Y+1, r25	; 0x01
    1362:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    1366:	89 81       	ldd	r24, Y+1	; 0x01
    1368:	88 2f       	mov	r24, r24
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	2a 81       	ldd	r18, Y+2	; 0x02
    136e:	3b 81       	ldd	r19, Y+3	; 0x03
    1370:	82 0f       	add	r24, r18
    1372:	93 1f       	adc	r25, r19
    1374:	fc 01       	movw	r30, r24
    1376:	90 81       	ld	r25, Z
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	99 23       	and	r25, r25
    137c:	09 f4       	brne	.+2      	; 0x1380 <_Z9PrintGAVRPc+0x52>
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	88 23       	and	r24, r24
    1382:	f9 f6       	brne	.-66     	; 0x1342 <_Z9PrintGAVRPc+0x14>
		Wait_ms(350);
		PutUartChGAVR(string[i++]);
	}
}
    1384:	0f 90       	pop	r0
    1386:	0f 90       	pop	r0
    1388:	0f 90       	pop	r0
    138a:	df 91       	pop	r29
    138c:	cf 91       	pop	r28
    138e:	08 95       	ret

00001390 <_Z8sendGAVRv>:
/*************************************************************************************************************/
void sendGAVR(){
    1390:	cf 93       	push	r28
    1392:	df 93       	push	r29
    1394:	cd b7       	in	r28, 0x3d	; 61
    1396:	de b7       	in	r29, 0x3e	; 62
    1398:	cb 55       	subi	r28, 0x5B	; 91
    139a:	d0 40       	sbci	r29, 0x00	; 0
    139c:	0f b6       	in	r0, 0x3f	; 63
    139e:	f8 94       	cli
    13a0:	de bf       	out	0x3e, r29	; 62
    13a2:	0f be       	out	0x3f, r0	; 63
    13a4:	cd bf       	out	0x3d, r28	; 61
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	8b 87       	std	Y+11, r24	; 0x0b
	char recChar, recString[40], sentString[40];
	unsigned int strLoc=0;
    13aa:	1a 82       	std	Y+2, r1	; 0x02
    13ac:	19 82       	std	Y+1, r1	; 0x01
	
	//Set sending flag
	flagSendingGAVR=fTrue;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	80 93 12 02 	sts	0x0212, r24
	
	//Transmission protocol
	while (flagSendingGAVR){
    13b4:	0a c2       	rjmp	.+1044   	; 0x17ca <_Z8sendGAVRv+0x43a>
		/* State 5: Successful transmission and reception. Kill sending flag, reset state, exit.					 */
		/* State 6: ACKBAD received, check to see if we have an invalid date/time in our clock or it was just noisy  */
		/*			and had error in transmission/reception. If valid, go to waiting state. Else exit and set flag.	 */
		/* State 7: Got the wrong ack for something, set a flag to let the WAVR do its thing then try again.		 */
		/*************************************************************************************************************/
		switch (state){
    13b6:	80 91 25 02 	lds	r24, 0x0225
    13ba:	90 91 26 02 	lds	r25, 0x0226
    13be:	83 30       	cpi	r24, 0x03	; 3
    13c0:	91 05       	cpc	r25, r1
    13c2:	09 f4       	brne	.+2      	; 0x13c6 <_Z8sendGAVRv+0x36>
    13c4:	ee c0       	rjmp	.+476    	; 0x15a2 <_Z8sendGAVRv+0x212>
    13c6:	84 30       	cpi	r24, 0x04	; 4
    13c8:	91 05       	cpc	r25, r1
    13ca:	48 f4       	brcc	.+18     	; 0x13de <_Z8sendGAVRv+0x4e>
    13cc:	81 30       	cpi	r24, 0x01	; 1
    13ce:	91 05       	cpc	r25, r1
    13d0:	09 f4       	brne	.+2      	; 0x13d4 <_Z8sendGAVRv+0x44>
    13d2:	78 c0       	rjmp	.+240    	; 0x14c4 <_Z8sendGAVRv+0x134>
    13d4:	82 30       	cpi	r24, 0x02	; 2
    13d6:	91 05       	cpc	r25, r1
    13d8:	08 f0       	brcs	.+2      	; 0x13dc <_Z8sendGAVRv+0x4c>
    13da:	82 c0       	rjmp	.+260    	; 0x14e0 <_Z8sendGAVRv+0x150>
    13dc:	0d c0       	rjmp	.+26     	; 0x13f8 <_Z8sendGAVRv+0x68>
    13de:	86 30       	cpi	r24, 0x06	; 6
    13e0:	91 05       	cpc	r25, r1
    13e2:	09 f4       	brne	.+2      	; 0x13e6 <_Z8sendGAVRv+0x56>
    13e4:	aa c1       	rjmp	.+852    	; 0x173a <_Z8sendGAVRv+0x3aa>
    13e6:	87 30       	cpi	r24, 0x07	; 7
    13e8:	91 05       	cpc	r25, r1
    13ea:	09 f4       	brne	.+2      	; 0x13ee <_Z8sendGAVRv+0x5e>
    13ec:	bf c1       	rjmp	.+894    	; 0x176c <_Z8sendGAVRv+0x3dc>
    13ee:	85 30       	cpi	r24, 0x05	; 5
    13f0:	91 05       	cpc	r25, r1
    13f2:	09 f4       	brne	.+2      	; 0x13f6 <_Z8sendGAVRv+0x66>
    13f4:	79 c1       	rjmp	.+754    	; 0x16e8 <_Z8sendGAVRv+0x358>
    13f6:	e1 c1       	rjmp	.+962    	; 0x17ba <_Z8sendGAVRv+0x42a>
			case 0: {
				SendInterruptGAVR();
    13f8:	0e 94 00 09 	call	0x1200	; 0x1200 <_Z17SendInterruptGAVRv>
				state=1;
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	90 93 26 02 	sts	0x0226, r25
    1404:	80 93 25 02 	sts	0x0225, r24
				break;
    1408:	e0 c1       	rjmp	.+960    	; 0x17ca <_Z8sendGAVRv+0x43a>
			}//end case 0
			case 1: {
				//Wait for connection to set and something to come in.			
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					Wait_ms(50);				//wait for the register to start to load.
    140a:	82 e3       	ldi	r24, 0x32	; 50
    140c:	90 e0       	ldi	r25, 0x00	; 0
    140e:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
    1412:	00 00       	nop
    1414:	88 ec       	ldi	r24, 0xC8	; 200
    1416:	90 e0       	ldi	r25, 0x00	; 0
    1418:	fc 01       	movw	r30, r24
    141a:	80 81       	ld	r24, Z
    141c:	88 23       	and	r24, r24
    141e:	34 f0       	brlt	.+12     	; 0x142c <_Z8sendGAVRv+0x9c>
    1420:	80 91 12 02 	lds	r24, 0x0212
    1424:	88 23       	and	r24, r24
    1426:	11 f0       	breq	.+4      	; 0x142c <_Z8sendGAVRv+0x9c>
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	01 c0       	rjmp	.+2      	; 0x142e <_Z8sendGAVRv+0x9e>
    142c:	80 e0       	ldi	r24, 0x00	; 0
    142e:	88 23       	and	r24, r24
    1430:	89 f7       	brne	.-30     	; 0x1414 <_Z8sendGAVRv+0x84>
					if (!flagSendingGAVR){PrintBone("TimeoutSend");PrintBone(recString); break;}		//if timeout is why we broke, just exit
    1432:	80 91 12 02 	lds	r24, 0x0212
    1436:	88 23       	and	r24, r24
    1438:	51 f4       	brne	.+20     	; 0x144e <_Z8sendGAVRv+0xbe>
    143a:	80 e0       	ldi	r24, 0x00	; 0
    143c:	91 e0       	ldi	r25, 0x01	; 1
    143e:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1442:	ce 01       	movw	r24, r28
    1444:	c4 96       	adiw	r24, 0x34	; 52
    1446:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    144a:	00 00       	nop
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    144c:	be c1       	rjmp	.+892    	; 0x17ca <_Z8sendGAVRv+0x43a>
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					Wait_ms(50);				//wait for the register to start to load.
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
					if (!flagSendingGAVR){PrintBone("TimeoutSend");PrintBone(recString); break;}		//if timeout is why we broke, just exit
					recChar=UDR1;
    144e:	8e ec       	ldi	r24, 0xCE	; 206
    1450:	90 e0       	ldi	r25, 0x00	; 0
    1452:	fc 01       	movw	r30, r24
    1454:	80 81       	ld	r24, Z
    1456:	89 87       	std	Y+9, r24	; 0x09
					recString[strLoc++]=recChar;
    1458:	9e 01       	movw	r18, r28
    145a:	2c 5c       	subi	r18, 0xCC	; 204
    145c:	3f 4f       	sbci	r19, 0xFF	; 255
    145e:	89 81       	ldd	r24, Y+1	; 0x01
    1460:	9a 81       	ldd	r25, Y+2	; 0x02
    1462:	82 0f       	add	r24, r18
    1464:	93 1f       	adc	r25, r19
    1466:	29 85       	ldd	r18, Y+9	; 0x09
    1468:	fc 01       	movw	r30, r24
    146a:	20 83       	st	Z, r18
    146c:	89 81       	ldd	r24, Y+1	; 0x01
    146e:	9a 81       	ldd	r25, Y+2	; 0x02
    1470:	01 96       	adiw	r24, 0x01	; 1
    1472:	9a 83       	std	Y+2, r25	; 0x02
    1474:	89 83       	std	Y+1, r24	; 0x01
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
    1476:	89 85       	ldd	r24, Y+9	; 0x09
    1478:	8e 32       	cpi	r24, 0x2E	; 46
    147a:	b1 f4       	brne	.+44     	; 0x14a8 <_Z8sendGAVRv+0x118>
    147c:	9e 01       	movw	r18, r28
    147e:	2c 5c       	subi	r18, 0xCC	; 204
    1480:	3f 4f       	sbci	r19, 0xFF	; 255
    1482:	89 81       	ldd	r24, Y+1	; 0x01
    1484:	9a 81       	ldd	r25, Y+2	; 0x02
    1486:	82 0f       	add	r24, r18
    1488:	93 1f       	adc	r25, r19
    148a:	fc 01       	movw	r30, r24
    148c:	10 82       	st	Z, r1
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	9a 81       	ldd	r25, Y+2	; 0x02
    1492:	01 96       	adiw	r24, 0x01	; 1
    1494:	9a 83       	std	Y+2, r25	; 0x02
    1496:	89 83       	std	Y+1, r24	; 0x01
    1498:	82 e0       	ldi	r24, 0x02	; 2
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	90 93 26 02 	sts	0x0226, r25
    14a0:	80 93 25 02 	sts	0x0225, r24
    14a4:	1b 86       	std	Y+11, r1	; 0x0b
    14a6:	0e c0       	rjmp	.+28     	; 0x14c4 <_Z8sendGAVRv+0x134>
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
    14a8:	89 81       	ldd	r24, Y+1	; 0x01
    14aa:	9a 81       	ldd	r25, Y+2	; 0x02
    14ac:	87 32       	cpi	r24, 0x27	; 39
    14ae:	91 05       	cpc	r25, r1
    14b0:	48 f0       	brcs	.+18     	; 0x14c4 <_Z8sendGAVRv+0x134>
    14b2:	1a 82       	std	Y+2, r1	; 0x02
    14b4:	19 82       	std	Y+1, r1	; 0x01
    14b6:	1b 86       	std	Y+11, r1	; 0x0b
    14b8:	87 e0       	ldi	r24, 0x07	; 7
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	90 93 26 02 	sts	0x0226, r25
    14c0:	80 93 25 02 	sts	0x0225, r24
				break;
			}//end case 0
			case 1: {
				//Wait for connection to set and something to come in.			
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    14c4:	8b 85       	ldd	r24, Y+11	; 0x0b
    14c6:	88 23       	and	r24, r24
    14c8:	31 f0       	breq	.+12     	; 0x14d6 <_Z8sendGAVRv+0x146>
    14ca:	80 91 12 02 	lds	r24, 0x0212
    14ce:	88 23       	and	r24, r24
    14d0:	11 f0       	breq	.+4      	; 0x14d6 <_Z8sendGAVRv+0x146>
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	01 c0       	rjmp	.+2      	; 0x14d8 <_Z8sendGAVRv+0x148>
    14d6:	80 e0       	ldi	r24, 0x00	; 0
    14d8:	88 23       	and	r24, r24
    14da:	09 f0       	breq	.+2      	; 0x14de <_Z8sendGAVRv+0x14e>
    14dc:	96 cf       	rjmp	.-212    	; 0x140a <_Z8sendGAVRv+0x7a>
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    14de:	75 c1       	rjmp	.+746    	; 0x17ca <_Z8sendGAVRv+0x43a>
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
    14e0:	ce 01       	movw	r24, r28
    14e2:	c4 96       	adiw	r24, 0x34	; 52
    14e4:	2c e0       	ldi	r18, 0x0C	; 12
    14e6:	31 e0       	ldi	r19, 0x01	; 1
    14e8:	b9 01       	movw	r22, r18
    14ea:	42 e0       	ldi	r20, 0x02	; 2
    14ec:	50 e0       	ldi	r21, 0x00	; 0
    14ee:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    14f2:	00 97       	sbiw	r24, 0x00	; 0
    14f4:	39 f4       	brne	.+14     	; 0x1504 <_Z8sendGAVRv+0x174>
    14f6:	83 e0       	ldi	r24, 0x03	; 3
    14f8:	90 e0       	ldi	r25, 0x00	; 0
    14fa:	90 93 26 02 	sts	0x0226, r25
    14fe:	80 93 25 02 	sts	0x0225, r24
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    1502:	63 c1       	rjmp	.+710    	; 0x17ca <_Z8sendGAVRv+0x43a>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
    1504:	ce 01       	movw	r24, r28
    1506:	c4 96       	adiw	r24, 0x34	; 52
    1508:	2f e0       	ldi	r18, 0x0F	; 15
    150a:	31 e0       	ldi	r19, 0x01	; 1
    150c:	b9 01       	movw	r22, r18
    150e:	42 e0       	ldi	r20, 0x02	; 2
    1510:	50 e0       	ldi	r21, 0x00	; 0
    1512:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    1516:	00 97       	sbiw	r24, 0x00	; 0
    1518:	51 f4       	brne	.+20     	; 0x152e <_Z8sendGAVRv+0x19e>
    151a:	85 e0       	ldi	r24, 0x05	; 5
    151c:	90 e0       	ldi	r25, 0x00	; 0
    151e:	90 93 26 02 	sts	0x0226, r25
    1522:	80 93 25 02 	sts	0x0225, r24
    1526:	81 e0       	ldi	r24, 0x01	; 1
    1528:	80 93 0e 02 	sts	0x020E, r24
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    152c:	4e c1       	rjmp	.+668    	; 0x17ca <_Z8sendGAVRv+0x43a>
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
    152e:	ce 01       	movw	r24, r28
    1530:	c4 96       	adiw	r24, 0x34	; 52
    1532:	22 e1       	ldi	r18, 0x12	; 18
    1534:	31 e0       	ldi	r19, 0x01	; 1
    1536:	b9 01       	movw	r22, r18
    1538:	42 e0       	ldi	r20, 0x02	; 2
    153a:	50 e0       	ldi	r21, 0x00	; 0
    153c:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    1540:	00 97       	sbiw	r24, 0x00	; 0
    1542:	39 f4       	brne	.+14     	; 0x1552 <_Z8sendGAVRv+0x1c2>
    1544:	86 e0       	ldi	r24, 0x06	; 6
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	90 93 26 02 	sts	0x0226, r25
    154c:	80 93 25 02 	sts	0x0225, r24
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    1550:	3c c1       	rjmp	.+632    	; 0x17ca <_Z8sendGAVRv+0x43a>
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
    1552:	80 91 11 02 	lds	r24, 0x0211
    1556:	88 23       	and	r24, r24
    1558:	a9 f0       	breq	.+42     	; 0x1584 <_Z8sendGAVRv+0x1f4>
    155a:	ce 01       	movw	r24, r28
    155c:	c4 96       	adiw	r24, 0x34	; 52
    155e:	9e 01       	movw	r18, r28
    1560:	24 5f       	subi	r18, 0xF4	; 244
    1562:	3f 4f       	sbci	r19, 0xFF	; 255
    1564:	b9 01       	movw	r22, r18
    1566:	0e 94 00 1d 	call	0x3a00	; 0x3a00 <strcmp>
    156a:	00 97       	sbiw	r24, 0x00	; 0
    156c:	59 f4       	brne	.+22     	; 0x1584 <_Z8sendGAVRv+0x1f4>
    156e:	85 e1       	ldi	r24, 0x15	; 21
    1570:	91 e0       	ldi	r25, 0x01	; 1
    1572:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1576:	85 e0       	ldi	r24, 0x05	; 5
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	90 93 26 02 	sts	0x0226, r25
    157e:	80 93 25 02 	sts	0x0225, r24
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    1582:	23 c1       	rjmp	.+582    	; 0x17ca <_Z8sendGAVRv+0x43a>
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
    1584:	83 e2       	ldi	r24, 0x23	; 35
    1586:	91 e0       	ldi	r25, 0x01	; 1
    1588:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    158c:	ce 01       	movw	r24, r28
    158e:	c4 96       	adiw	r24, 0x34	; 52
    1590:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1594:	87 e0       	ldi	r24, 0x07	; 7
    1596:	90 e0       	ldi	r25, 0x00	; 0
    1598:	90 93 26 02 	sts	0x0226, r25
    159c:	80 93 25 02 	sts	0x0225, r24
				break;
    15a0:	14 c1       	rjmp	.+552    	; 0x17ca <_Z8sendGAVRv+0x43a>
				}//end case 2
			case 3:{
				Wait_ms(100);
    15a2:	84 e6       	ldi	r24, 0x64	; 100
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
				if (flagUserClock && !flagUpdateGAVRClock){
    15aa:	80 91 13 02 	lds	r24, 0x0213
    15ae:	88 23       	and	r24, r24
    15b0:	69 f0       	breq	.+26     	; 0x15cc <_Z8sendGAVRv+0x23c>
    15b2:	80 91 11 02 	lds	r24, 0x0211
    15b6:	88 23       	and	r24, r24
    15b8:	49 f4       	brne	.+18     	; 0x15cc <_Z8sendGAVRv+0x23c>
					PrintGAVR("G.");				
    15ba:	8f e0       	ldi	r24, 0x0F	; 15
    15bc:	91 e0       	ldi	r25, 0x01	; 1
    15be:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
					PrintBone("GetTime.");
    15c2:	8e e2       	ldi	r24, 0x2E	; 46
    15c4:	91 e0       	ldi	r25, 0x01	; 1
    15c6:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    15ca:	67 c0       	rjmp	.+206    	; 0x169a <_Z8sendGAVRv+0x30a>
				//If we are updating the gavr, send the time and date together regardless. preface with SYN
				} else if (flagUpdateGAVRClock && !flagUserClock){
    15cc:	80 91 11 02 	lds	r24, 0x0211
    15d0:	88 23       	and	r24, r24
    15d2:	09 f4       	brne	.+2      	; 0x15d6 <_Z8sendGAVRv+0x246>
    15d4:	57 c0       	rjmp	.+174    	; 0x1684 <_Z8sendGAVRv+0x2f4>
    15d6:	80 91 13 02 	lds	r24, 0x0213
    15da:	88 23       	and	r24, r24
    15dc:	09 f0       	breq	.+2      	; 0x15e0 <_Z8sendGAVRv+0x250>
    15de:	52 c0       	rjmp	.+164    	; 0x1684 <_Z8sendGAVRv+0x2f4>
					strcpy(sentString,"A");			//this is a syn, not ack to save logic in GAVR code. Can change if we want.
    15e0:	ce 01       	movw	r24, r28
    15e2:	0c 96       	adiw	r24, 0x0c	; 12
    15e4:	21 e4       	ldi	r18, 0x41	; 65
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	fc 01       	movw	r30, r24
    15ea:	31 83       	std	Z+1, r19	; 0x01
    15ec:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getTime());
    15ee:	82 ee       	ldi	r24, 0xE2	; 226
    15f0:	91 e0       	ldi	r25, 0x01	; 1
    15f2:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    15f6:	9c 01       	movw	r18, r24
    15f8:	ce 01       	movw	r24, r28
    15fa:	0c 96       	adiw	r24, 0x0c	; 12
    15fc:	b9 01       	movw	r22, r18
    15fe:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <strcat>
					strcat(sentString,"/");	//add delimiter.
    1602:	ce 01       	movw	r24, r28
    1604:	0c 96       	adiw	r24, 0x0c	; 12
    1606:	9c 01       	movw	r18, r24
    1608:	f9 01       	movw	r30, r18
    160a:	01 90       	ld	r0, Z+
    160c:	00 20       	and	r0, r0
    160e:	e9 f7       	brne	.-6      	; 0x160a <_Z8sendGAVRv+0x27a>
    1610:	cf 01       	movw	r24, r30
    1612:	01 97       	sbiw	r24, 0x01	; 1
    1614:	82 1b       	sub	r24, r18
    1616:	93 0b       	sbc	r25, r19
    1618:	9e 01       	movw	r18, r28
    161a:	24 5f       	subi	r18, 0xF4	; 244
    161c:	3f 4f       	sbci	r19, 0xFF	; 255
    161e:	82 0f       	add	r24, r18
    1620:	93 1f       	adc	r25, r19
    1622:	2f e2       	ldi	r18, 0x2F	; 47
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	fc 01       	movw	r30, r24
    1628:	31 83       	std	Z+1, r19	; 0x01
    162a:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getDate());
    162c:	82 ee       	ldi	r24, 0xE2	; 226
    162e:	91 e0       	ldi	r25, 0x01	; 1
    1630:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    1634:	9c 01       	movw	r18, r24
    1636:	ce 01       	movw	r24, r28
    1638:	0c 96       	adiw	r24, 0x0c	; 12
    163a:	b9 01       	movw	r22, r18
    163c:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <strcat>
					strcat(sentString,".\0");
    1640:	ce 01       	movw	r24, r28
    1642:	0c 96       	adiw	r24, 0x0c	; 12
    1644:	9c 01       	movw	r18, r24
    1646:	f9 01       	movw	r30, r18
    1648:	01 90       	ld	r0, Z+
    164a:	00 20       	and	r0, r0
    164c:	e9 f7       	brne	.-6      	; 0x1648 <_Z8sendGAVRv+0x2b8>
    164e:	cf 01       	movw	r24, r30
    1650:	01 97       	sbiw	r24, 0x01	; 1
    1652:	82 1b       	sub	r24, r18
    1654:	93 0b       	sbc	r25, r19
    1656:	9e 01       	movw	r18, r28
    1658:	24 5f       	subi	r18, 0xF4	; 244
    165a:	3f 4f       	sbci	r19, 0xFF	; 255
    165c:	82 0f       	add	r24, r18
    165e:	93 1f       	adc	r25, r19
    1660:	2e e2       	ldi	r18, 0x2E	; 46
    1662:	30 e0       	ldi	r19, 0x00	; 0
    1664:	fc 01       	movw	r30, r24
    1666:	31 83       	std	Z+1, r19	; 0x01
    1668:	20 83       	st	Z, r18
					PutUartChGAVR('S');
    166a:	83 e5       	ldi	r24, 0x53	; 83
    166c:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
    1670:	80 e0       	ldi	r24, 0x00	; 0
    1672:	61 e0       	ldi	r22, 0x01	; 1
    1674:	41 e0       	ldi	r20, 0x01	; 1
    1676:	0e 94 79 13 	call	0x26f2	; 0x26f2 <_Z13printTimeDatehhh>
					PrintBone("Sending time.");
    167a:	87 e3       	ldi	r24, 0x37	; 55
    167c:	91 e0       	ldi	r25, 0x01	; 1
    167e:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1682:	0b c0       	rjmp	.+22     	; 0x169a <_Z8sendGAVRv+0x30a>
				} else {PrintBone("noflags.");state=7; break;}	//end if-else (what we are doing).
    1684:	85 e4       	ldi	r24, 0x45	; 69
    1686:	91 e0       	ldi	r25, 0x01	; 1
    1688:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    168c:	87 e0       	ldi	r24, 0x07	; 7
    168e:	90 e0       	ldi	r25, 0x00	; 0
    1690:	90 93 26 02 	sts	0x0226, r25
    1694:	80 93 25 02 	sts	0x0225, r24
    1698:	98 c0       	rjmp	.+304    	; 0x17ca <_Z8sendGAVRv+0x43a>
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    169a:	1c 82       	std	Y+4, r1	; 0x04
    169c:	1b 82       	std	Y+3, r1	; 0x03
    169e:	0e c0       	rjmp	.+28     	; 0x16bc <_Z8sendGAVRv+0x32c>
    16a0:	9e 01       	movw	r18, r28
    16a2:	2c 5c       	subi	r18, 0xCC	; 204
    16a4:	3f 4f       	sbci	r19, 0xFF	; 255
    16a6:	8b 81       	ldd	r24, Y+3	; 0x03
    16a8:	9c 81       	ldd	r25, Y+4	; 0x04
    16aa:	82 0f       	add	r24, r18
    16ac:	93 1f       	adc	r25, r19
    16ae:	fc 01       	movw	r30, r24
    16b0:	10 82       	st	Z, r1
    16b2:	8b 81       	ldd	r24, Y+3	; 0x03
    16b4:	9c 81       	ldd	r25, Y+4	; 0x04
    16b6:	01 96       	adiw	r24, 0x01	; 1
    16b8:	9c 83       	std	Y+4, r25	; 0x04
    16ba:	8b 83       	std	Y+3, r24	; 0x03
    16bc:	2b 81       	ldd	r18, Y+3	; 0x03
    16be:	3c 81       	ldd	r19, Y+4	; 0x04
    16c0:	41 e0       	ldi	r20, 0x01	; 1
    16c2:	89 81       	ldd	r24, Y+1	; 0x01
    16c4:	9a 81       	ldd	r25, Y+2	; 0x02
    16c6:	28 17       	cp	r18, r24
    16c8:	39 07       	cpc	r19, r25
    16ca:	08 f0       	brcs	.+2      	; 0x16ce <_Z8sendGAVRv+0x33e>
    16cc:	40 e0       	ldi	r20, 0x00	; 0
    16ce:	44 23       	and	r20, r20
    16d0:	39 f7       	brne	.-50     	; 0x16a0 <_Z8sendGAVRv+0x310>
					
				//Reset the carriage feature, string location and go back to the receiving state.
				noCarriage=fTrue;
    16d2:	81 e0       	ldi	r24, 0x01	; 1
    16d4:	8b 87       	std	Y+11, r24	; 0x0b
				strLoc=0;
    16d6:	1a 82       	std	Y+2, r1	; 0x02
    16d8:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	90 93 26 02 	sts	0x0226, r25
    16e2:	80 93 25 02 	sts	0x0225, r24
				break;
    16e6:	71 c0       	rjmp	.+226    	; 0x17ca <_Z8sendGAVRv+0x43a>
				}//end case 3
			case 5:{
				//Successful communications overall
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    16e8:	1e 82       	std	Y+6, r1	; 0x06
    16ea:	1d 82       	std	Y+5, r1	; 0x05
    16ec:	0e c0       	rjmp	.+28     	; 0x170a <_Z8sendGAVRv+0x37a>
    16ee:	9e 01       	movw	r18, r28
    16f0:	2c 5c       	subi	r18, 0xCC	; 204
    16f2:	3f 4f       	sbci	r19, 0xFF	; 255
    16f4:	8d 81       	ldd	r24, Y+5	; 0x05
    16f6:	9e 81       	ldd	r25, Y+6	; 0x06
    16f8:	82 0f       	add	r24, r18
    16fa:	93 1f       	adc	r25, r19
    16fc:	fc 01       	movw	r30, r24
    16fe:	10 82       	st	Z, r1
    1700:	8d 81       	ldd	r24, Y+5	; 0x05
    1702:	9e 81       	ldd	r25, Y+6	; 0x06
    1704:	01 96       	adiw	r24, 0x01	; 1
    1706:	9e 83       	std	Y+6, r25	; 0x06
    1708:	8d 83       	std	Y+5, r24	; 0x05
    170a:	2d 81       	ldd	r18, Y+5	; 0x05
    170c:	3e 81       	ldd	r19, Y+6	; 0x06
    170e:	41 e0       	ldi	r20, 0x01	; 1
    1710:	89 81       	ldd	r24, Y+1	; 0x01
    1712:	9a 81       	ldd	r25, Y+2	; 0x02
    1714:	28 17       	cp	r18, r24
    1716:	39 07       	cpc	r19, r25
    1718:	08 f0       	brcs	.+2      	; 0x171c <_Z8sendGAVRv+0x38c>
    171a:	40 e0       	ldi	r20, 0x00	; 0
    171c:	44 23       	and	r20, r20
    171e:	39 f7       	brne	.-50     	; 0x16ee <_Z8sendGAVRv+0x35e>
				PrintBone("Success.");
    1720:	8e e4       	ldi	r24, 0x4E	; 78
    1722:	91 e0       	ldi	r25, 0x01	; 1
    1724:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
				flagSendingGAVR=fFalse;
    1728:	10 92 12 02 	sts	0x0212, r1
				flagUpdateGAVRClock=fFalse;							//Always true if we get here.
    172c:	10 92 11 02 	sts	0x0211, r1
				state=0;
    1730:	10 92 26 02 	sts	0x0226, r1
    1734:	10 92 25 02 	sts	0x0225, r1
				break;
    1738:	48 c0       	rjmp	.+144    	; 0x17ca <_Z8sendGAVRv+0x43a>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
    173a:	82 ee       	ldi	r24, 0xE2	; 226
    173c:	91 e0       	ldi	r25, 0x01	; 1
    173e:	0e 94 bc 06 	call	0xd78	; 0xd78 <_ZN6myTime13checkValidityEv>
    1742:	8a 87       	std	Y+10, r24	; 0x0a
				if (dateOK){state=7;}
    1744:	8a 85       	ldd	r24, Y+10	; 0x0a
    1746:	88 23       	and	r24, r24
    1748:	39 f0       	breq	.+14     	; 0x1758 <_Z8sendGAVRv+0x3c8>
    174a:	87 e0       	ldi	r24, 0x07	; 7
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	90 93 26 02 	sts	0x0226, r25
    1752:	80 93 25 02 	sts	0x0225, r24
				else {state=7; flagInvalidDateTime=fTrue;}
				break;
    1756:	39 c0       	rjmp	.+114    	; 0x17ca <_Z8sendGAVRv+0x43a>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
				if (dateOK){state=7;}
				else {state=7; flagInvalidDateTime=fTrue;}
    1758:	87 e0       	ldi	r24, 0x07	; 7
    175a:	90 e0       	ldi	r25, 0x00	; 0
    175c:	90 93 26 02 	sts	0x0226, r25
    1760:	80 93 25 02 	sts	0x0225, r24
    1764:	81 e0       	ldi	r24, 0x01	; 1
    1766:	80 93 14 02 	sts	0x0214, r24
				break;
    176a:	2f c0       	rjmp	.+94     	; 0x17ca <_Z8sendGAVRv+0x43a>
				}//end case 6
			case 7:{
				//Got the wrong ACK back, or invalid ACK. Wait for next cycle then resend. Keep all the flags the same
				PrintBone("ErrorS.");
    176c:	87 e5       	ldi	r24, 0x57	; 87
    176e:	91 e0       	ldi	r25, 0x01	; 1
    1770:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
				flagSendingGAVR=fFalse;
    1774:	10 92 12 02 	sts	0x0212, r1
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1778:	18 86       	std	Y+8, r1	; 0x08
    177a:	1f 82       	std	Y+7, r1	; 0x07
    177c:	0e c0       	rjmp	.+28     	; 0x179a <_Z8sendGAVRv+0x40a>
    177e:	9e 01       	movw	r18, r28
    1780:	2c 5c       	subi	r18, 0xCC	; 204
    1782:	3f 4f       	sbci	r19, 0xFF	; 255
    1784:	8f 81       	ldd	r24, Y+7	; 0x07
    1786:	98 85       	ldd	r25, Y+8	; 0x08
    1788:	82 0f       	add	r24, r18
    178a:	93 1f       	adc	r25, r19
    178c:	fc 01       	movw	r30, r24
    178e:	10 82       	st	Z, r1
    1790:	8f 81       	ldd	r24, Y+7	; 0x07
    1792:	98 85       	ldd	r25, Y+8	; 0x08
    1794:	01 96       	adiw	r24, 0x01	; 1
    1796:	98 87       	std	Y+8, r25	; 0x08
    1798:	8f 83       	std	Y+7, r24	; 0x07
    179a:	2f 81       	ldd	r18, Y+7	; 0x07
    179c:	38 85       	ldd	r19, Y+8	; 0x08
    179e:	41 e0       	ldi	r20, 0x01	; 1
    17a0:	89 81       	ldd	r24, Y+1	; 0x01
    17a2:	9a 81       	ldd	r25, Y+2	; 0x02
    17a4:	28 17       	cp	r18, r24
    17a6:	39 07       	cpc	r19, r25
    17a8:	08 f0       	brcs	.+2      	; 0x17ac <_Z8sendGAVRv+0x41c>
    17aa:	40 e0       	ldi	r20, 0x00	; 0
    17ac:	44 23       	and	r20, r20
    17ae:	39 f7       	brne	.-50     	; 0x177e <_Z8sendGAVRv+0x3ee>
				state=0;
    17b0:	10 92 26 02 	sts	0x0226, r1
    17b4:	10 92 25 02 	sts	0x0225, r1
				break;
    17b8:	08 c0       	rjmp	.+16     	; 0x17ca <_Z8sendGAVRv+0x43a>
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; break;}
    17ba:	10 92 26 02 	sts	0x0226, r1
    17be:	10 92 25 02 	sts	0x0225, r1
    17c2:	10 92 12 02 	sts	0x0212, r1
    17c6:	1b 86       	std	Y+11, r1	; 0x0b
    17c8:	00 00       	nop
	
	//Set sending flag
	flagSendingGAVR=fTrue;
	
	//Transmission protocol
	while (flagSendingGAVR){
    17ca:	90 91 12 02 	lds	r25, 0x0212
    17ce:	81 e0       	ldi	r24, 0x01	; 1
    17d0:	99 23       	and	r25, r25
    17d2:	09 f4       	brne	.+2      	; 0x17d6 <_Z8sendGAVRv+0x446>
    17d4:	80 e0       	ldi	r24, 0x00	; 0
    17d6:	88 23       	and	r24, r24
    17d8:	09 f0       	breq	.+2      	; 0x17dc <_Z8sendGAVRv+0x44c>
    17da:	ed cd       	rjmp	.-1062   	; 0x13b6 <_Z8sendGAVRv+0x26>
				break;
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; break;}
		}//end switch
	}//end while
}//end function 	
    17dc:	c5 5a       	subi	r28, 0xA5	; 165
    17de:	df 4f       	sbci	r29, 0xFF	; 255
    17e0:	0f b6       	in	r0, 0x3f	; 63
    17e2:	f8 94       	cli
    17e4:	de bf       	out	0x3e, r29	; 62
    17e6:	0f be       	out	0x3f, r0	; 63
    17e8:	cd bf       	out	0x3d, r28	; 61
    17ea:	df 91       	pop	r29
    17ec:	cf 91       	pop	r28
    17ee:	08 95       	ret

000017f0 <_Z11ReceiveGAVRv>:

/*************************************************************************************************************/
void ReceiveGAVR(){
    17f0:	cf 93       	push	r28
    17f2:	df 93       	push	r29
    17f4:	cd b7       	in	r28, 0x3d	; 61
    17f6:	de b7       	in	r29, 0x3e	; 62
    17f8:	c1 55       	subi	r28, 0x51	; 81
    17fa:	d0 40       	sbci	r29, 0x00	; 0
    17fc:	0f b6       	in	r0, 0x3f	; 63
    17fe:	f8 94       	cli
    1800:	de bf       	out	0x3e, r29	; 62
    1802:	0f be       	out	0x3f, r0	; 63
    1804:	cd bf       	out	0x3d, r28	; 61
	unsigned int state=0;
    1806:	1a 82       	std	Y+2, r1	; 0x02
    1808:	19 82       	std	Y+1, r1	; 0x01
	char recChar, recString[40];
	unsigned int strLoc=0;
    180a:	1c 82       	std	Y+4, r1	; 0x04
    180c:	1b 82       	std	Y+3, r1	; 0x03
	BOOL noCarriage=fTrue;
    180e:	81 e0       	ldi	r24, 0x01	; 1
    1810:	8d 83       	std	Y+5, r24	; 0x05
	
	//While Loop
	while (flagReceivingGAVR){
    1812:	43 c3       	rjmp	.+1670   	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
		/** State 5: Exit case. Lower "flagReceivingGAVR" which causes and exit.													   **/
		/** State 6: ACKERROR state. Send "ACKERROR", then exit through state 5.													   **/
		/** State 7: Successful acquire of time/date.																				   **/
		/** Default: Set state to 0, doesn't really matter though. Exit signalling timeout to sender.								   **/
		/********************************************************************************************************************************/
		switch(state){
    1814:	89 81       	ldd	r24, Y+1	; 0x01
    1816:	9a 81       	ldd	r25, Y+2	; 0x02
    1818:	83 30       	cpi	r24, 0x03	; 3
    181a:	91 05       	cpc	r25, r1
    181c:	09 f4       	brne	.+2      	; 0x1820 <_Z11ReceiveGAVRv+0x30>
    181e:	cd c0       	rjmp	.+410    	; 0x19ba <_Z11ReceiveGAVRv+0x1ca>
    1820:	84 30       	cpi	r24, 0x04	; 4
    1822:	91 05       	cpc	r25, r1
    1824:	48 f4       	brcc	.+18     	; 0x1838 <_Z11ReceiveGAVRv+0x48>
    1826:	81 30       	cpi	r24, 0x01	; 1
    1828:	91 05       	cpc	r25, r1
    182a:	09 f4       	brne	.+2      	; 0x182e <_Z11ReceiveGAVRv+0x3e>
    182c:	8d c0       	rjmp	.+282    	; 0x1948 <_Z11ReceiveGAVRv+0x158>
    182e:	82 30       	cpi	r24, 0x02	; 2
    1830:	91 05       	cpc	r25, r1
    1832:	08 f0       	brcs	.+2      	; 0x1836 <_Z11ReceiveGAVRv+0x46>
    1834:	97 c0       	rjmp	.+302    	; 0x1964 <_Z11ReceiveGAVRv+0x174>
    1836:	11 c0       	rjmp	.+34     	; 0x185a <_Z11ReceiveGAVRv+0x6a>
    1838:	85 30       	cpi	r24, 0x05	; 5
    183a:	91 05       	cpc	r25, r1
    183c:	09 f4       	brne	.+2      	; 0x1840 <_Z11ReceiveGAVRv+0x50>
    183e:	df c2       	rjmp	.+1470   	; 0x1dfe <_Z11ReceiveGAVRv+0x60e>
    1840:	85 30       	cpi	r24, 0x05	; 5
    1842:	91 05       	cpc	r25, r1
    1844:	08 f4       	brcc	.+2      	; 0x1848 <_Z11ReceiveGAVRv+0x58>
    1846:	ba c2       	rjmp	.+1396   	; 0x1dbc <_Z11ReceiveGAVRv+0x5cc>
    1848:	86 30       	cpi	r24, 0x06	; 6
    184a:	91 05       	cpc	r25, r1
    184c:	09 f4       	brne	.+2      	; 0x1850 <_Z11ReceiveGAVRv+0x60>
    184e:	fa c2       	rjmp	.+1524   	; 0x1e44 <_Z11ReceiveGAVRv+0x654>
    1850:	87 30       	cpi	r24, 0x07	; 7
    1852:	91 05       	cpc	r25, r1
    1854:	09 f4       	brne	.+2      	; 0x1858 <_Z11ReceiveGAVRv+0x68>
    1856:	07 c3       	rjmp	.+1550   	; 0x1e66 <_Z11ReceiveGAVRv+0x676>
    1858:	19 c3       	rjmp	.+1586   	; 0x1e8c <_Z11ReceiveGAVRv+0x69c>
				case 0:{
					//Beginning case
					strLoc=0;
    185a:	1c 82       	std	Y+4, r1	; 0x04
    185c:	1b 82       	std	Y+3, r1	; 0x03
					recChar = UDR1;
    185e:	8e ec       	ldi	r24, 0xCE	; 206
    1860:	90 e0       	ldi	r25, 0x00	; 0
    1862:	fc 01       	movw	r30, r24
    1864:	80 81       	ld	r24, Z
    1866:	8e 8b       	std	Y+22, r24	; 0x16
					if (recChar=='.'){
    1868:	8e 89       	ldd	r24, Y+22	; 0x16
    186a:	8e 32       	cpi	r24, 0x2E	; 46
    186c:	29 f4       	brne	.+10     	; 0x1878 <_Z11ReceiveGAVRv+0x88>
						state=6;															//Go to error state.
    186e:	86 e0       	ldi	r24, 0x06	; 6
    1870:	90 e0       	ldi	r25, 0x00	; 0
    1872:	9a 83       	std	Y+2, r25	; 0x02
    1874:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
    1876:	11 c3       	rjmp	.+1570   	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
					//Beginning case
					strLoc=0;
					recChar = UDR1;
					if (recChar=='.'){
						state=6;															//Go to error state.
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
    1878:	9e 01       	movw	r18, r28
    187a:	26 5d       	subi	r18, 0xD6	; 214
    187c:	3f 4f       	sbci	r19, 0xFF	; 255
    187e:	8b 81       	ldd	r24, Y+3	; 0x03
    1880:	9c 81       	ldd	r25, Y+4	; 0x04
    1882:	82 0f       	add	r24, r18
    1884:	93 1f       	adc	r25, r19
    1886:	2e 89       	ldd	r18, Y+22	; 0x16
    1888:	fc 01       	movw	r30, r24
    188a:	20 83       	st	Z, r18
    188c:	8b 81       	ldd	r24, Y+3	; 0x03
    188e:	9c 81       	ldd	r25, Y+4	; 0x04
    1890:	01 96       	adiw	r24, 0x01	; 1
    1892:	9c 83       	std	Y+4, r25	; 0x04
    1894:	8b 83       	std	Y+3, r24	; 0x03
    1896:	81 e0       	ldi	r24, 0x01	; 1
    1898:	90 e0       	ldi	r25, 0x00	; 0
    189a:	9a 83       	std	Y+2, r25	; 0x02
    189c:	89 83       	std	Y+1, r24	; 0x01
					break;
    189e:	fd c2       	rjmp	.+1530   	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						Wait_ms(50);
    18a0:	82 e3       	ldi	r24, 0x32	; 50
    18a2:	90 e0       	ldi	r25, 0x00	; 0
    18a4:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
    18a8:	00 00       	nop
    18aa:	88 ec       	ldi	r24, 0xC8	; 200
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	fc 01       	movw	r30, r24
    18b0:	80 81       	ld	r24, Z
    18b2:	88 23       	and	r24, r24
    18b4:	34 f0       	brlt	.+12     	; 0x18c2 <_Z11ReceiveGAVRv+0xd2>
    18b6:	80 91 0d 02 	lds	r24, 0x020D
    18ba:	88 23       	and	r24, r24
    18bc:	11 f0       	breq	.+4      	; 0x18c2 <_Z11ReceiveGAVRv+0xd2>
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	01 c0       	rjmp	.+2      	; 0x18c4 <_Z11ReceiveGAVRv+0xd4>
    18c2:	80 e0       	ldi	r24, 0x00	; 0
    18c4:	88 23       	and	r24, r24
    18c6:	89 f7       	brne	.-30     	; 0x18aa <_Z11ReceiveGAVRv+0xba>
						if (!flagReceivingGAVR){state=0; PrintBone("Timeout-RG");PrintBone(recString);break;}							//if there was a timeout, break out and reset state
    18c8:	80 91 0d 02 	lds	r24, 0x020D
    18cc:	88 23       	and	r24, r24
    18ce:	61 f4       	brne	.+24     	; 0x18e8 <_Z11ReceiveGAVRv+0xf8>
    18d0:	1a 82       	std	Y+2, r1	; 0x02
    18d2:	19 82       	std	Y+1, r1	; 0x01
    18d4:	8f e5       	ldi	r24, 0x5F	; 95
    18d6:	91 e0       	ldi	r25, 0x01	; 1
    18d8:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    18dc:	ce 01       	movw	r24, r28
    18de:	8a 96       	adiw	r24, 0x2a	; 42
    18e0:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    18e4:	00 00       	nop
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    18e6:	d9 c2       	rjmp	.+1458   	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						Wait_ms(50);
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
						if (!flagReceivingGAVR){state=0; PrintBone("Timeout-RG");PrintBone(recString);break;}							//if there was a timeout, break out and reset state
						recChar=UDR1;
    18e8:	8e ec       	ldi	r24, 0xCE	; 206
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	fc 01       	movw	r30, r24
    18ee:	80 81       	ld	r24, Z
    18f0:	8e 8b       	std	Y+22, r24	; 0x16
						recString[strLoc++]=recChar;										//'.' always included into recString
    18f2:	9e 01       	movw	r18, r28
    18f4:	26 5d       	subi	r18, 0xD6	; 214
    18f6:	3f 4f       	sbci	r19, 0xFF	; 255
    18f8:	8b 81       	ldd	r24, Y+3	; 0x03
    18fa:	9c 81       	ldd	r25, Y+4	; 0x04
    18fc:	82 0f       	add	r24, r18
    18fe:	93 1f       	adc	r25, r19
    1900:	2e 89       	ldd	r18, Y+22	; 0x16
    1902:	fc 01       	movw	r30, r24
    1904:	20 83       	st	Z, r18
    1906:	8b 81       	ldd	r24, Y+3	; 0x03
    1908:	9c 81       	ldd	r25, Y+4	; 0x04
    190a:	01 96       	adiw	r24, 0x01	; 1
    190c:	9c 83       	std	Y+4, r25	; 0x04
    190e:	8b 83       	std	Y+3, r24	; 0x03
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1910:	8e 89       	ldd	r24, Y+22	; 0x16
    1912:	8e 32       	cpi	r24, 0x2E	; 46
    1914:	79 f4       	brne	.+30     	; 0x1934 <_Z11ReceiveGAVRv+0x144>
    1916:	9e 01       	movw	r18, r28
    1918:	26 5d       	subi	r18, 0xD6	; 214
    191a:	3f 4f       	sbci	r19, 0xFF	; 255
    191c:	8b 81       	ldd	r24, Y+3	; 0x03
    191e:	9c 81       	ldd	r25, Y+4	; 0x04
    1920:	82 0f       	add	r24, r18
    1922:	93 1f       	adc	r25, r19
    1924:	fc 01       	movw	r30, r24
    1926:	10 82       	st	Z, r1
    1928:	1d 82       	std	Y+5, r1	; 0x05
    192a:	82 e0       	ldi	r24, 0x02	; 2
    192c:	90 e0       	ldi	r25, 0x00	; 0
    192e:	9a 83       	std	Y+2, r25	; 0x02
    1930:	89 83       	std	Y+1, r24	; 0x01
    1932:	0a c0       	rjmp	.+20     	; 0x1948 <_Z11ReceiveGAVRv+0x158>
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
    1934:	8b 81       	ldd	r24, Y+3	; 0x03
    1936:	9c 81       	ldd	r25, Y+4	; 0x04
    1938:	87 32       	cpi	r24, 0x27	; 39
    193a:	91 05       	cpc	r25, r1
    193c:	28 f0       	brcs	.+10     	; 0x1948 <_Z11ReceiveGAVRv+0x158>
    193e:	86 e0       	ldi	r24, 0x06	; 6
    1940:	90 e0       	ldi	r25, 0x00	; 0
    1942:	9a 83       	std	Y+2, r25	; 0x02
    1944:	89 83       	std	Y+1, r24	; 0x01
    1946:	1d 82       	std	Y+5, r1	; 0x05
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
    1948:	8d 81       	ldd	r24, Y+5	; 0x05
    194a:	88 23       	and	r24, r24
    194c:	31 f0       	breq	.+12     	; 0x195a <_Z11ReceiveGAVRv+0x16a>
    194e:	80 91 0d 02 	lds	r24, 0x020D
    1952:	88 23       	and	r24, r24
    1954:	11 f0       	breq	.+4      	; 0x195a <_Z11ReceiveGAVRv+0x16a>
    1956:	81 e0       	ldi	r24, 0x01	; 1
    1958:	01 c0       	rjmp	.+2      	; 0x195c <_Z11ReceiveGAVRv+0x16c>
    195a:	80 e0       	ldi	r24, 0x00	; 0
    195c:	88 23       	and	r24, r24
    195e:	09 f0       	breq	.+2      	; 0x1962 <_Z11ReceiveGAVRv+0x172>
    1960:	9f cf       	rjmp	.-194    	; 0x18a0 <_Z11ReceiveGAVRv+0xb0>
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    1962:	9b c2       	rjmp	.+1334   	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
    1964:	ce 01       	movw	r24, r28
    1966:	8a 96       	adiw	r24, 0x2a	; 42
    1968:	2a e6       	ldi	r18, 0x6A	; 106
    196a:	31 e0       	ldi	r19, 0x01	; 1
    196c:	b9 01       	movw	r22, r18
    196e:	48 e0       	ldi	r20, 0x08	; 8
    1970:	50 e0       	ldi	r21, 0x00	; 0
    1972:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    1976:	00 97       	sbiw	r24, 0x00	; 0
    1978:	29 f4       	brne	.+10     	; 0x1984 <_Z11ReceiveGAVRv+0x194>
    197a:	84 e0       	ldi	r24, 0x04	; 4
    197c:	90 e0       	ldi	r25, 0x00	; 0
    197e:	9a 83       	std	Y+2, r25	; 0x02
    1980:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
					break;
    1982:	8b c2       	rjmp	.+1302   	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
					break;
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
    1984:	8c a5       	lds	r24, 0x6c
    1986:	91 e0       	ldi	r25, 0x01	; 1
    1988:	8a 33       	cpi	r24, 0x3A	; 58
    198a:	09 f0       	breq	.+2      	; 0x198e <_Z11ReceiveGAVRv+0x19e>
    198c:	90 e0       	ldi	r25, 0x00	; 0
    198e:	2d a5       	lds	r18, 0x6d
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	2a 33       	cpi	r18, 0x3A	; 58
    1994:	09 f0       	breq	.+2      	; 0x1998 <_Z11ReceiveGAVRv+0x1a8>
    1996:	80 e0       	ldi	r24, 0x00	; 0
    1998:	89 27       	eor	r24, r25
    199a:	88 23       	and	r24, r24
    199c:	49 f0       	breq	.+18     	; 0x19b0 <_Z11ReceiveGAVRv+0x1c0>
    199e:	83 e0       	ldi	r24, 0x03	; 3
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	9a 83       	std	Y+2, r25	; 0x02
    19a4:	89 83       	std	Y+1, r24	; 0x01
    19a6:	8d e6       	ldi	r24, 0x6D	; 109
    19a8:	91 e0       	ldi	r25, 0x01	; 1
    19aa:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					else {state=6;}
					break;
    19ae:	75 c2       	rjmp	.+1258   	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
    19b0:	86 e0       	ldi	r24, 0x06	; 6
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	9a 83       	std	Y+2, r25	; 0x02
    19b6:	89 83       	std	Y+1, r24	; 0x01
					break;
    19b8:	70 c2       	rjmp	.+1248   	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
				}//end case 2
				case 3:{
					//Parse for date/time case
					if (flagUserClock){
    19ba:	80 91 13 02 	lds	r24, 0x0213
    19be:	88 23       	and	r24, r24
    19c0:	09 f4       	brne	.+2      	; 0x19c4 <_Z11ReceiveGAVRv+0x1d4>
    19c2:	f3 c1       	rjmp	.+998    	; 0x1daa <_Z11ReceiveGAVRv+0x5ba>
						//Go through the string and parse for the time. Must go through the time to get the date.
						BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    19c4:	1f 8a       	std	Y+23, r1	; 0x17
    19c6:	18 8e       	std	Y+24, r1	; 0x18
						int counter=1;
    19c8:	81 e0       	ldi	r24, 0x01	; 1
    19ca:	90 e0       	ldi	r25, 0x00	; 0
    19cc:	9f 83       	std	Y+7, r25	; 0x07
    19ce:	8e 83       	std	Y+6, r24	; 0x06
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    19d0:	1a 8e       	std	Y+26, r1	; 0x1a
    19d2:	19 8e       	std	Y+25, r1	; 0x19
    19d4:	1c 8e       	std	Y+28, r1	; 0x1c
    19d6:	1b 8e       	std	Y+27, r1	; 0x1b
    19d8:	1e 8e       	std	Y+30, r1	; 0x1e
    19da:	1d 8e       	std	Y+29, r1	; 0x1d
    19dc:	18 a2       	lds	r17, 0x98
    19de:	1f 8e       	std	Y+31, r1	; 0x1f
    19e0:	1a a2       	lds	r17, 0x9a
    19e2:	19 a2       	lds	r17, 0x99
    19e4:	1c a2       	lds	r17, 0x9c
    19e6:	1b a2       	lds	r17, 0x9b
    19e8:	19 86       	std	Y+9, r1	; 0x09
    19ea:	18 86       	std	Y+8, r1	; 0x08
    19ec:	1b 86       	std	Y+11, r1	; 0x0b
    19ee:	1a 86       	std	Y+10, r1	; 0x0a
    19f0:	1d 86       	std	Y+13, r1	; 0x0d
    19f2:	1c 86       	std	Y+12, r1	; 0x0c
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    19f4:	73 c0       	rjmp	.+230    	; 0x1adc <_Z11ReceiveGAVRv+0x2ec>
							//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
							if (recString[counter]!=':' && hms<3){
    19f6:	9e 01       	movw	r18, r28
    19f8:	26 5d       	subi	r18, 0xD6	; 214
    19fa:	3f 4f       	sbci	r19, 0xFF	; 255
    19fc:	8e 81       	ldd	r24, Y+6	; 0x06
    19fe:	9f 81       	ldd	r25, Y+7	; 0x07
    1a00:	82 0f       	add	r24, r18
    1a02:	93 1f       	adc	r25, r19
    1a04:	fc 01       	movw	r30, r24
    1a06:	80 81       	ld	r24, Z
    1a08:	8a 33       	cpi	r24, 0x3A	; 58
    1a0a:	e9 f0       	breq	.+58     	; 0x1a46 <_Z11ReceiveGAVRv+0x256>
    1a0c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a0e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a10:	83 30       	cpi	r24, 0x03	; 3
    1a12:	91 05       	cpc	r25, r1
    1a14:	c4 f4       	brge	.+48     	; 0x1a46 <_Z11ReceiveGAVRv+0x256>
								tempStringNum[placement++]=recString[counter];
    1a16:	9e 01       	movw	r18, r28
    1a18:	26 5d       	subi	r18, 0xD6	; 214
    1a1a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a1c:	8e 81       	ldd	r24, Y+6	; 0x06
    1a1e:	9f 81       	ldd	r25, Y+7	; 0x07
    1a20:	82 0f       	add	r24, r18
    1a22:	93 1f       	adc	r25, r19
    1a24:	fc 01       	movw	r30, r24
    1a26:	40 81       	ld	r20, Z
    1a28:	9e 01       	movw	r18, r28
    1a2a:	2b 5d       	subi	r18, 0xDB	; 219
    1a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a2e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a30:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a32:	82 0f       	add	r24, r18
    1a34:	93 1f       	adc	r25, r19
    1a36:	fc 01       	movw	r30, r24
    1a38:	40 83       	st	Z, r20
    1a3a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a3c:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a3e:	01 96       	adiw	r24, 0x01	; 1
    1a40:	9d 87       	std	Y+13, r25	; 0x0d
    1a42:	8c 87       	std	Y+12, r24	; 0x0c
    1a44:	46 c0       	rjmp	.+140    	; 0x1ad2 <_Z11ReceiveGAVRv+0x2e2>
							//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
							} else if (hms<2 && recString[counter] == ':') {
    1a46:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a48:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a4a:	82 30       	cpi	r24, 0x02	; 2
    1a4c:	91 05       	cpc	r25, r1
    1a4e:	0c f0       	brlt	.+2      	; 0x1a52 <_Z11ReceiveGAVRv+0x262>
    1a50:	40 c0       	rjmp	.+128    	; 0x1ad2 <_Z11ReceiveGAVRv+0x2e2>
    1a52:	9e 01       	movw	r18, r28
    1a54:	26 5d       	subi	r18, 0xD6	; 214
    1a56:	3f 4f       	sbci	r19, 0xFF	; 255
    1a58:	8e 81       	ldd	r24, Y+6	; 0x06
    1a5a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a5c:	82 0f       	add	r24, r18
    1a5e:	93 1f       	adc	r25, r19
    1a60:	fc 01       	movw	r30, r24
    1a62:	80 81       	ld	r24, Z
    1a64:	8a 33       	cpi	r24, 0x3A	; 58
    1a66:	a9 f5       	brne	.+106    	; 0x1ad2 <_Z11ReceiveGAVRv+0x2e2>
								tempNum[hms++] = atoi(tempStringNum);
    1a68:	ce 01       	movw	r24, r28
    1a6a:	85 96       	adiw	r24, 0x25	; 37
    1a6c:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
    1a70:	9c 01       	movw	r18, r24
    1a72:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a74:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a76:	88 0f       	add	r24, r24
    1a78:	99 1f       	adc	r25, r25
    1a7a:	ae 01       	movw	r20, r28
    1a7c:	4f 5f       	subi	r20, 0xFF	; 255
    1a7e:	5f 4f       	sbci	r21, 0xFF	; 255
    1a80:	84 0f       	add	r24, r20
    1a82:	95 1f       	adc	r25, r21
    1a84:	48 96       	adiw	r24, 0x18	; 24
    1a86:	fc 01       	movw	r30, r24
    1a88:	31 83       	std	Z+1, r19	; 0x01
    1a8a:	20 83       	st	Z, r18
    1a8c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a8e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a90:	01 96       	adiw	r24, 0x01	; 1
    1a92:	9b 87       	std	Y+11, r25	; 0x0b
    1a94:	8a 87       	std	Y+10, r24	; 0x0a
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1a96:	1f 86       	std	Y+15, r1	; 0x0f
    1a98:	1e 86       	std	Y+14, r1	; 0x0e
    1a9a:	0e c0       	rjmp	.+28     	; 0x1ab8 <_Z11ReceiveGAVRv+0x2c8>
    1a9c:	9e 01       	movw	r18, r28
    1a9e:	2b 5d       	subi	r18, 0xDB	; 219
    1aa0:	3f 4f       	sbci	r19, 0xFF	; 255
    1aa2:	8e 85       	ldd	r24, Y+14	; 0x0e
    1aa4:	9f 85       	ldd	r25, Y+15	; 0x0f
    1aa6:	82 0f       	add	r24, r18
    1aa8:	93 1f       	adc	r25, r19
    1aaa:	fc 01       	movw	r30, r24
    1aac:	10 82       	st	Z, r1
    1aae:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ab0:	9f 85       	ldd	r25, Y+15	; 0x0f
    1ab2:	01 96       	adiw	r24, 0x01	; 1
    1ab4:	9f 87       	std	Y+15, r25	; 0x0f
    1ab6:	8e 87       	std	Y+14, r24	; 0x0e
    1ab8:	41 e0       	ldi	r20, 0x01	; 1
    1aba:	2e 85       	ldd	r18, Y+14	; 0x0e
    1abc:	3f 85       	ldd	r19, Y+15	; 0x0f
    1abe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1ac0:	9d 85       	ldd	r25, Y+13	; 0x0d
    1ac2:	82 17       	cp	r24, r18
    1ac4:	93 07       	cpc	r25, r19
    1ac6:	0c f4       	brge	.+2      	; 0x1aca <_Z11ReceiveGAVRv+0x2da>
    1ac8:	40 e0       	ldi	r20, 0x00	; 0
    1aca:	44 23       	and	r20, r20
    1acc:	39 f7       	brne	.-50     	; 0x1a9c <_Z11ReceiveGAVRv+0x2ac>
								placement=0;												//reset placement
    1ace:	1d 86       	std	Y+13, r1	; 0x0d
    1ad0:	1c 86       	std	Y+12, r1	; 0x0c
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
    1ad2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ad4:	9f 81       	ldd	r25, Y+7	; 0x07
    1ad6:	01 96       	adiw	r24, 0x01	; 1
    1ad8:	9f 83       	std	Y+7, r25	; 0x07
    1ada:	8e 83       	std	Y+6, r24	; 0x06
						int counter=1;
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    1adc:	9e 01       	movw	r18, r28
    1ade:	26 5d       	subi	r18, 0xD6	; 214
    1ae0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ae2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ae4:	9f 81       	ldd	r25, Y+7	; 0x07
    1ae6:	82 0f       	add	r24, r18
    1ae8:	93 1f       	adc	r25, r19
    1aea:	fc 01       	movw	r30, r24
    1aec:	80 81       	ld	r24, Z
    1aee:	8f 32       	cpi	r24, 0x2F	; 47
    1af0:	69 f0       	breq	.+26     	; 0x1b0c <_Z11ReceiveGAVRv+0x31c>
    1af2:	9e 01       	movw	r18, r28
    1af4:	26 5d       	subi	r18, 0xD6	; 214
    1af6:	3f 4f       	sbci	r19, 0xFF	; 255
    1af8:	8e 81       	ldd	r24, Y+6	; 0x06
    1afa:	9f 81       	ldd	r25, Y+7	; 0x07
    1afc:	82 0f       	add	r24, r18
    1afe:	93 1f       	adc	r25, r19
    1b00:	fc 01       	movw	r30, r24
    1b02:	80 81       	ld	r24, Z
    1b04:	88 23       	and	r24, r24
    1b06:	11 f0       	breq	.+4      	; 0x1b0c <_Z11ReceiveGAVRv+0x31c>
    1b08:	81 e0       	ldi	r24, 0x01	; 1
    1b0a:	01 c0       	rjmp	.+2      	; 0x1b0e <_Z11ReceiveGAVRv+0x31e>
    1b0c:	80 e0       	ldi	r24, 0x00	; 0
    1b0e:	88 23       	and	r24, r24
    1b10:	09 f0       	breq	.+2      	; 0x1b14 <_Z11ReceiveGAVRv+0x324>
    1b12:	71 cf       	rjmp	.-286    	; 0x19f6 <_Z11ReceiveGAVRv+0x206>
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
						}//end while
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
    1b14:	9e 01       	movw	r18, r28
    1b16:	26 5d       	subi	r18, 0xD6	; 214
    1b18:	3f 4f       	sbci	r19, 0xFF	; 255
    1b1a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b1c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b1e:	82 0f       	add	r24, r18
    1b20:	93 1f       	adc	r25, r19
    1b22:	fc 01       	movw	r30, r24
    1b24:	80 81       	ld	r24, Z
    1b26:	8f 32       	cpi	r24, 0x2F	; 47
    1b28:	b9 f4       	brne	.+46     	; 0x1b58 <_Z11ReceiveGAVRv+0x368>
							tempNum[hms] = atoi(tempStringNum);
    1b2a:	ce 01       	movw	r24, r28
    1b2c:	85 96       	adiw	r24, 0x25	; 37
    1b2e:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
    1b32:	9c 01       	movw	r18, r24
    1b34:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b36:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b38:	88 0f       	add	r24, r24
    1b3a:	99 1f       	adc	r25, r25
    1b3c:	ae 01       	movw	r20, r28
    1b3e:	4f 5f       	subi	r20, 0xFF	; 255
    1b40:	5f 4f       	sbci	r21, 0xFF	; 255
    1b42:	84 0f       	add	r24, r20
    1b44:	95 1f       	adc	r25, r21
    1b46:	48 96       	adiw	r24, 0x18	; 24
    1b48:	fc 01       	movw	r30, r24
    1b4a:	31 83       	std	Z+1, r19	; 0x01
    1b4c:	20 83       	st	Z, r18
							successTime=fTrue;
    1b4e:	81 e0       	ldi	r24, 0x01	; 1
    1b50:	8f 8b       	std	Y+23, r24	; 0x17
							break;
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1b52:	19 8a       	std	Y+17, r1	; 0x11
    1b54:	18 8a       	std	Y+16, r1	; 0x10
    1b56:	17 c0       	rjmp	.+46     	; 0x1b86 <_Z11ReceiveGAVRv+0x396>
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
							tempNum[hms] = atoi(tempStringNum);
							successTime=fTrue;
						} else {
							state=5;
    1b58:	85 e0       	ldi	r24, 0x05	; 5
    1b5a:	90 e0       	ldi	r25, 0x00	; 0
    1b5c:	9a 83       	std	Y+2, r25	; 0x02
    1b5e:	89 83       	std	Y+1, r24	; 0x01
							PrintGAVR("B.");
    1b60:	82 e1       	ldi	r24, 0x12	; 18
    1b62:	91 e0       	ldi	r25, 0x01	; 1
    1b64:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
							break;
    1b68:	98 c1       	rjmp	.+816    	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1b6a:	9e 01       	movw	r18, r28
    1b6c:	2b 5d       	subi	r18, 0xDB	; 219
    1b6e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b70:	88 89       	ldd	r24, Y+16	; 0x10
    1b72:	99 89       	ldd	r25, Y+17	; 0x11
    1b74:	82 0f       	add	r24, r18
    1b76:	93 1f       	adc	r25, r19
    1b78:	fc 01       	movw	r30, r24
    1b7a:	10 82       	st	Z, r1
    1b7c:	88 89       	ldd	r24, Y+16	; 0x10
    1b7e:	99 89       	ldd	r25, Y+17	; 0x11
    1b80:	01 96       	adiw	r24, 0x01	; 1
    1b82:	99 8b       	std	Y+17, r25	; 0x11
    1b84:	88 8b       	std	Y+16, r24	; 0x10
    1b86:	41 e0       	ldi	r20, 0x01	; 1
    1b88:	28 89       	ldd	r18, Y+16	; 0x10
    1b8a:	39 89       	ldd	r19, Y+17	; 0x11
    1b8c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b8e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b90:	82 17       	cp	r24, r18
    1b92:	93 07       	cpc	r25, r19
    1b94:	0c f4       	brge	.+2      	; 0x1b98 <_Z11ReceiveGAVRv+0x3a8>
    1b96:	40 e0       	ldi	r20, 0x00	; 0
    1b98:	44 23       	and	r20, r20
    1b9a:	39 f7       	brne	.-50     	; 0x1b6a <_Z11ReceiveGAVRv+0x37a>
						placement=0;
    1b9c:	1d 86       	std	Y+13, r1	; 0x0d
    1b9e:	1c 86       	std	Y+12, r1	; 0x0c
						counter++;	//get past the '/'
    1ba0:	8e 81       	ldd	r24, Y+6	; 0x06
    1ba2:	9f 81       	ldd	r25, Y+7	; 0x07
    1ba4:	01 96       	adiw	r24, 0x01	; 1
    1ba6:	9f 83       	std	Y+7, r25	; 0x07
    1ba8:	8e 83       	std	Y+6, r24	; 0x06
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1baa:	73 c0       	rjmp	.+230    	; 0x1c92 <_Z11ReceiveGAVRv+0x4a2>
							//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
							if  (recString[counter] != ',' && dmy < 3){
    1bac:	9e 01       	movw	r18, r28
    1bae:	26 5d       	subi	r18, 0xD6	; 214
    1bb0:	3f 4f       	sbci	r19, 0xFF	; 255
    1bb2:	8e 81       	ldd	r24, Y+6	; 0x06
    1bb4:	9f 81       	ldd	r25, Y+7	; 0x07
    1bb6:	82 0f       	add	r24, r18
    1bb8:	93 1f       	adc	r25, r19
    1bba:	fc 01       	movw	r30, r24
    1bbc:	80 81       	ld	r24, Z
    1bbe:	8c 32       	cpi	r24, 0x2C	; 44
    1bc0:	e9 f0       	breq	.+58     	; 0x1bfc <_Z11ReceiveGAVRv+0x40c>
    1bc2:	88 85       	ldd	r24, Y+8	; 0x08
    1bc4:	99 85       	ldd	r25, Y+9	; 0x09
    1bc6:	83 30       	cpi	r24, 0x03	; 3
    1bc8:	91 05       	cpc	r25, r1
    1bca:	c4 f4       	brge	.+48     	; 0x1bfc <_Z11ReceiveGAVRv+0x40c>
								tempStringNum[placement++]=recString[counter];
    1bcc:	9e 01       	movw	r18, r28
    1bce:	26 5d       	subi	r18, 0xD6	; 214
    1bd0:	3f 4f       	sbci	r19, 0xFF	; 255
    1bd2:	8e 81       	ldd	r24, Y+6	; 0x06
    1bd4:	9f 81       	ldd	r25, Y+7	; 0x07
    1bd6:	82 0f       	add	r24, r18
    1bd8:	93 1f       	adc	r25, r19
    1bda:	fc 01       	movw	r30, r24
    1bdc:	40 81       	ld	r20, Z
    1bde:	9e 01       	movw	r18, r28
    1be0:	2b 5d       	subi	r18, 0xDB	; 219
    1be2:	3f 4f       	sbci	r19, 0xFF	; 255
    1be4:	8c 85       	ldd	r24, Y+12	; 0x0c
    1be6:	9d 85       	ldd	r25, Y+13	; 0x0d
    1be8:	82 0f       	add	r24, r18
    1bea:	93 1f       	adc	r25, r19
    1bec:	fc 01       	movw	r30, r24
    1bee:	40 83       	st	Z, r20
    1bf0:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bf2:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bf4:	01 96       	adiw	r24, 0x01	; 1
    1bf6:	9d 87       	std	Y+13, r25	; 0x0d
    1bf8:	8c 87       	std	Y+12, r24	; 0x0c
    1bfa:	46 c0       	rjmp	.+140    	; 0x1c88 <_Z11ReceiveGAVRv+0x498>
							//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
							} else if (dmy<2 && recString[counter]==','){
    1bfc:	88 85       	ldd	r24, Y+8	; 0x08
    1bfe:	99 85       	ldd	r25, Y+9	; 0x09
    1c00:	82 30       	cpi	r24, 0x02	; 2
    1c02:	91 05       	cpc	r25, r1
    1c04:	0c f0       	brlt	.+2      	; 0x1c08 <_Z11ReceiveGAVRv+0x418>
    1c06:	40 c0       	rjmp	.+128    	; 0x1c88 <_Z11ReceiveGAVRv+0x498>
    1c08:	9e 01       	movw	r18, r28
    1c0a:	26 5d       	subi	r18, 0xD6	; 214
    1c0c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c0e:	8e 81       	ldd	r24, Y+6	; 0x06
    1c10:	9f 81       	ldd	r25, Y+7	; 0x07
    1c12:	82 0f       	add	r24, r18
    1c14:	93 1f       	adc	r25, r19
    1c16:	fc 01       	movw	r30, r24
    1c18:	80 81       	ld	r24, Z
    1c1a:	8c 32       	cpi	r24, 0x2C	; 44
    1c1c:	a9 f5       	brne	.+106    	; 0x1c88 <_Z11ReceiveGAVRv+0x498>
								tempNum1[dmy++] = atoi(tempStringNum);
    1c1e:	ce 01       	movw	r24, r28
    1c20:	85 96       	adiw	r24, 0x25	; 37
    1c22:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
    1c26:	9c 01       	movw	r18, r24
    1c28:	88 85       	ldd	r24, Y+8	; 0x08
    1c2a:	99 85       	ldd	r25, Y+9	; 0x09
    1c2c:	88 0f       	add	r24, r24
    1c2e:	99 1f       	adc	r25, r25
    1c30:	ae 01       	movw	r20, r28
    1c32:	4f 5f       	subi	r20, 0xFF	; 255
    1c34:	5f 4f       	sbci	r21, 0xFF	; 255
    1c36:	84 0f       	add	r24, r20
    1c38:	95 1f       	adc	r25, r21
    1c3a:	4e 96       	adiw	r24, 0x1e	; 30
    1c3c:	fc 01       	movw	r30, r24
    1c3e:	31 83       	std	Z+1, r19	; 0x01
    1c40:	20 83       	st	Z, r18
    1c42:	88 85       	ldd	r24, Y+8	; 0x08
    1c44:	99 85       	ldd	r25, Y+9	; 0x09
    1c46:	01 96       	adiw	r24, 0x01	; 1
    1c48:	99 87       	std	Y+9, r25	; 0x09
    1c4a:	88 87       	std	Y+8, r24	; 0x08
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    1c4c:	1b 8a       	std	Y+19, r1	; 0x13
    1c4e:	1a 8a       	std	Y+18, r1	; 0x12
    1c50:	0e c0       	rjmp	.+28     	; 0x1c6e <_Z11ReceiveGAVRv+0x47e>
    1c52:	9e 01       	movw	r18, r28
    1c54:	2b 5d       	subi	r18, 0xDB	; 219
    1c56:	3f 4f       	sbci	r19, 0xFF	; 255
    1c58:	8a 89       	ldd	r24, Y+18	; 0x12
    1c5a:	9b 89       	ldd	r25, Y+19	; 0x13
    1c5c:	82 0f       	add	r24, r18
    1c5e:	93 1f       	adc	r25, r19
    1c60:	fc 01       	movw	r30, r24
    1c62:	10 82       	st	Z, r1
    1c64:	8a 89       	ldd	r24, Y+18	; 0x12
    1c66:	9b 89       	ldd	r25, Y+19	; 0x13
    1c68:	01 96       	adiw	r24, 0x01	; 1
    1c6a:	9b 8b       	std	Y+19, r25	; 0x13
    1c6c:	8a 8b       	std	Y+18, r24	; 0x12
    1c6e:	41 e0       	ldi	r20, 0x01	; 1
    1c70:	2a 89       	ldd	r18, Y+18	; 0x12
    1c72:	3b 89       	ldd	r19, Y+19	; 0x13
    1c74:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c76:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c78:	82 17       	cp	r24, r18
    1c7a:	93 07       	cpc	r25, r19
    1c7c:	0c f4       	brge	.+2      	; 0x1c80 <_Z11ReceiveGAVRv+0x490>
    1c7e:	40 e0       	ldi	r20, 0x00	; 0
    1c80:	44 23       	and	r20, r20
    1c82:	39 f7       	brne	.-50     	; 0x1c52 <_Z11ReceiveGAVRv+0x462>
								placement=0;
    1c84:	1d 86       	std	Y+13, r1	; 0x0d
    1c86:	1c 86       	std	Y+12, r1	; 0x0c
							} else;
							counter++;							
    1c88:	8e 81       	ldd	r24, Y+6	; 0x06
    1c8a:	9f 81       	ldd	r25, Y+7	; 0x07
    1c8c:	01 96       	adiw	r24, 0x01	; 1
    1c8e:	9f 83       	std	Y+7, r25	; 0x07
    1c90:	8e 83       	std	Y+6, r24	; 0x06
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
						placement=0;
						counter++;	//get past the '/'
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1c92:	9e 01       	movw	r18, r28
    1c94:	26 5d       	subi	r18, 0xD6	; 214
    1c96:	3f 4f       	sbci	r19, 0xFF	; 255
    1c98:	8e 81       	ldd	r24, Y+6	; 0x06
    1c9a:	9f 81       	ldd	r25, Y+7	; 0x07
    1c9c:	82 0f       	add	r24, r18
    1c9e:	93 1f       	adc	r25, r19
    1ca0:	fc 01       	movw	r30, r24
    1ca2:	80 81       	ld	r24, Z
    1ca4:	8e 32       	cpi	r24, 0x2E	; 46
    1ca6:	a1 f0       	breq	.+40     	; 0x1cd0 <_Z11ReceiveGAVRv+0x4e0>
    1ca8:	9e 01       	movw	r18, r28
    1caa:	26 5d       	subi	r18, 0xD6	; 214
    1cac:	3f 4f       	sbci	r19, 0xFF	; 255
    1cae:	8e 81       	ldd	r24, Y+6	; 0x06
    1cb0:	9f 81       	ldd	r25, Y+7	; 0x07
    1cb2:	82 0f       	add	r24, r18
    1cb4:	93 1f       	adc	r25, r19
    1cb6:	fc 01       	movw	r30, r24
    1cb8:	80 81       	ld	r24, Z
    1cba:	88 23       	and	r24, r24
    1cbc:	49 f0       	breq	.+18     	; 0x1cd0 <_Z11ReceiveGAVRv+0x4e0>
    1cbe:	2e 81       	ldd	r18, Y+6	; 0x06
    1cc0:	3f 81       	ldd	r19, Y+7	; 0x07
    1cc2:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc4:	9c 81       	ldd	r25, Y+4	; 0x04
    1cc6:	28 17       	cp	r18, r24
    1cc8:	39 07       	cpc	r19, r25
    1cca:	11 f0       	breq	.+4      	; 0x1cd0 <_Z11ReceiveGAVRv+0x4e0>
    1ccc:	81 e0       	ldi	r24, 0x01	; 1
    1cce:	01 c0       	rjmp	.+2      	; 0x1cd2 <_Z11ReceiveGAVRv+0x4e2>
    1cd0:	80 e0       	ldi	r24, 0x00	; 0
    1cd2:	88 23       	and	r24, r24
    1cd4:	09 f0       	breq	.+2      	; 0x1cd8 <_Z11ReceiveGAVRv+0x4e8>
    1cd6:	6a cf       	rjmp	.-300    	; 0x1bac <_Z11ReceiveGAVRv+0x3bc>
								placement=0;
							} else;
							counter++;							
						}//end while
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
    1cd8:	9e 01       	movw	r18, r28
    1cda:	26 5d       	subi	r18, 0xD6	; 214
    1cdc:	3f 4f       	sbci	r19, 0xFF	; 255
    1cde:	8e 81       	ldd	r24, Y+6	; 0x06
    1ce0:	9f 81       	ldd	r25, Y+7	; 0x07
    1ce2:	82 0f       	add	r24, r18
    1ce4:	93 1f       	adc	r25, r19
    1ce6:	fc 01       	movw	r30, r24
    1ce8:	80 81       	ld	r24, Z
    1cea:	8e 32       	cpi	r24, 0x2E	; 46
    1cec:	c1 f4       	brne	.+48     	; 0x1d1e <_Z11ReceiveGAVRv+0x52e>
							tempNum1[dmy] = atoi(tempStringNum);
    1cee:	ce 01       	movw	r24, r28
    1cf0:	85 96       	adiw	r24, 0x25	; 37
    1cf2:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
    1cf6:	9c 01       	movw	r18, r24
    1cf8:	88 85       	ldd	r24, Y+8	; 0x08
    1cfa:	99 85       	ldd	r25, Y+9	; 0x09
    1cfc:	88 0f       	add	r24, r24
    1cfe:	99 1f       	adc	r25, r25
    1d00:	ae 01       	movw	r20, r28
    1d02:	4f 5f       	subi	r20, 0xFF	; 255
    1d04:	5f 4f       	sbci	r21, 0xFF	; 255
    1d06:	84 0f       	add	r24, r20
    1d08:	95 1f       	adc	r25, r21
    1d0a:	4e 96       	adiw	r24, 0x1e	; 30
    1d0c:	fc 01       	movw	r30, r24
    1d0e:	31 83       	std	Z+1, r19	; 0x01
    1d10:	20 83       	st	Z, r18
							successDate=fTrue;
    1d12:	81 e0       	ldi	r24, 0x01	; 1
    1d14:	88 8f       	std	Y+24, r24	; 0x18
							state=5;
							break;
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (successDate && successTime){
    1d16:	88 8d       	ldd	r24, Y+24	; 0x18
    1d18:	88 23       	and	r24, r24
    1d1a:	51 f4       	brne	.+20     	; 0x1d30 <_Z11ReceiveGAVRv+0x540>
    1d1c:	37 c0       	rjmp	.+110    	; 0x1d8c <_Z11ReceiveGAVRv+0x59c>
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
							tempNum1[dmy] = atoi(tempStringNum);
							successDate=fTrue;
						} else {//something in the string was wrong, ACKBAD and then exit
							PrintGAVR("B.");
    1d1e:	82 e1       	ldi	r24, 0x12	; 18
    1d20:	91 e0       	ldi	r25, 0x01	; 1
    1d22:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
							state=5;
    1d26:	85 e0       	ldi	r24, 0x05	; 5
    1d28:	90 e0       	ldi	r25, 0x00	; 0
    1d2a:	9a 83       	std	Y+2, r25	; 0x02
    1d2c:	89 83       	std	Y+1, r24	; 0x01
							break;
    1d2e:	b5 c0       	rjmp	.+362    	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (successDate && successTime){
    1d30:	8f 89       	ldd	r24, Y+23	; 0x17
    1d32:	88 23       	and	r24, r24
    1d34:	59 f1       	breq	.+86     	; 0x1d8c <_Z11ReceiveGAVRv+0x59c>
							currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    1d36:	69 8d       	ldd	r22, Y+25	; 0x19
    1d38:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1d3a:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1d3c:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1d3e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1d40:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1d42:	82 ee       	ldi	r24, 0xE2	; 226
    1d44:	91 e0       	ldi	r25, 0x01	; 1
    1d46:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
							currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    1d4a:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1d4c:	78 a1       	lds	r23, 0x48
    1d4e:	49 a1       	lds	r20, 0x49
    1d50:	5a a1       	lds	r21, 0x4a
    1d52:	2b a1       	lds	r18, 0x4b
    1d54:	3c a1       	lds	r19, 0x4c
    1d56:	82 ee       	ldi	r24, 0xE2	; 226
    1d58:	91 e0       	ldi	r25, 0x01	; 1
    1d5a:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
							saveDateTime_eeprom(fTrue,fTrue);
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	61 e0       	ldi	r22, 0x01	; 1
    1d62:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
							flagUserClock=fFalse;
    1d66:	10 92 13 02 	sts	0x0213, r1
							flagWaitingForReceiveGAVR=fFalse;			
    1d6a:	10 92 0e 02 	sts	0x020E, r1
							//send ACK
							recString[0]='A';
    1d6e:	81 e4       	ldi	r24, 0x41	; 65
    1d70:	8a a7       	lds	r24, 0x7a
							PrintGAVR(recString);
    1d72:	ce 01       	movw	r24, r28
    1d74:	8a 96       	adiw	r24, 0x2a	; 42
    1d76:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
							PrintBone("Set my time.");
    1d7a:	89 e7       	ldi	r24, 0x79	; 121
    1d7c:	91 e0       	ldi	r25, 0x01	; 1
    1d7e:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
							state=7;
    1d82:	87 e0       	ldi	r24, 0x07	; 7
    1d84:	90 e0       	ldi	r25, 0x00	; 0
    1d86:	9a 83       	std	Y+2, r25	; 0x02
    1d88:	89 83       	std	Y+1, r24	; 0x01
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("NO.");
						state=5;
					}// end if-else (flagUserClock)					
					//Exit
					break;
    1d8a:	87 c0       	rjmp	.+270    	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
							PrintGAVR(recString);
							PrintBone("Set my time.");
							state=7;
						} else {			//If one was unsucessful, we need to keep waiting for the date
							//Here is a choice: Do we watn  to user to indicate the time is wrong, or just make them set it? Doesn't really matter.
							flagUserClock=fTrue;
    1d8c:	81 e0       	ldi	r24, 0x01	; 1
    1d8e:	80 93 13 02 	sts	0x0213, r24
							flagWaitingForReceiveGAVR=fTrue;
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	80 93 0e 02 	sts	0x020E, r24
							PrintBone("Bad time.");
    1d98:	86 e8       	ldi	r24, 0x86	; 134
    1d9a:	91 e0       	ldi	r25, 0x01	; 1
    1d9c:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
							state=5;						
    1da0:	85 e0       	ldi	r24, 0x05	; 5
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	9a 83       	std	Y+2, r25	; 0x02
    1da6:	89 83       	std	Y+1, r24	; 0x01
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("NO.");
						state=5;
					}// end if-else (flagUserClock)					
					//Exit
					break;
    1da8:	78 c0       	rjmp	.+240    	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
							PrintBone("Bad time.");
							state=5;						
						}//end if-else flagUserTime && successDate/Time
																																	
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("NO.");
    1daa:	80 e9       	ldi	r24, 0x90	; 144
    1dac:	91 e0       	ldi	r25, 0x01	; 1
    1dae:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
						state=5;
    1db2:	85 e0       	ldi	r24, 0x05	; 5
    1db4:	90 e0       	ldi	r25, 0x00	; 0
    1db6:	9a 83       	std	Y+2, r25	; 0x02
    1db8:	89 83       	std	Y+1, r24	; 0x01
					}// end if-else (flagUserClock)					
					//Exit
					break;
    1dba:	6f c0       	rjmp	.+222    	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
					}//end case 3				
				case 4:{
					Wait_ms(100);
    1dbc:	84 e6       	ldi	r24, 0x64	; 100
    1dbe:	90 e0       	ldi	r25, 0x00	; 0
    1dc0:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					//Successful SYNNEED case.
					if (!flagUserClock){	//If we don't need the date or time, update with what we have.
    1dc4:	80 91 13 02 	lds	r24, 0x0213
    1dc8:	88 23       	and	r24, r24
    1dca:	61 f4       	brne	.+24     	; 0x1de4 <_Z11ReceiveGAVRv+0x5f4>
						flagUpdateGAVRClock=fTrue;
    1dcc:	81 e0       	ldi	r24, 0x01	; 1
    1dce:	80 93 11 02 	sts	0x0211, r24
						PrintGAVR("N.");				//respond with correct ack
    1dd2:	8a e6       	ldi	r24, 0x6A	; 106
    1dd4:	91 e0       	ldi	r25, 0x01	; 1
    1dd6:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
						PrintBone("GAVR Needs.");
    1dda:	84 e9       	ldi	r24, 0x94	; 148
    1ddc:	91 e0       	ldi	r25, 0x01	; 1
    1dde:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1de2:	08 c0       	rjmp	.+16     	; 0x1df4 <_Z11ReceiveGAVRv+0x604>
					} else {
						PrintBone("NO.");
    1de4:	80 e9       	ldi	r24, 0x90	; 144
    1de6:	91 e0       	ldi	r25, 0x01	; 1
    1de8:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
						PrintGAVR("NO.");	//say we can't give you anything, ask the user.
    1dec:	80 e9       	ldi	r24, 0x90	; 144
    1dee:	91 e0       	ldi	r25, 0x01	; 1
    1df0:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
						//Should be expecting something from the GAVR with user date and time, this reminds the GAVR.
					} //end if-else
					state=5;
    1df4:	85 e0       	ldi	r24, 0x05	; 5
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	9a 83       	std	Y+2, r25	; 0x02
    1dfa:	89 83       	std	Y+1, r24	; 0x01
					break;					
    1dfc:	4e c0       	rjmp	.+156    	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
				}//end case 4
				case 5:{
					//Exit case
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1dfe:	1d 8a       	std	Y+21, r1	; 0x15
    1e00:	1c 8a       	std	Y+20, r1	; 0x14
    1e02:	0e c0       	rjmp	.+28     	; 0x1e20 <_Z11ReceiveGAVRv+0x630>
    1e04:	9e 01       	movw	r18, r28
    1e06:	26 5d       	subi	r18, 0xD6	; 214
    1e08:	3f 4f       	sbci	r19, 0xFF	; 255
    1e0a:	8c 89       	ldd	r24, Y+20	; 0x14
    1e0c:	9d 89       	ldd	r25, Y+21	; 0x15
    1e0e:	82 0f       	add	r24, r18
    1e10:	93 1f       	adc	r25, r19
    1e12:	fc 01       	movw	r30, r24
    1e14:	10 82       	st	Z, r1
    1e16:	8c 89       	ldd	r24, Y+20	; 0x14
    1e18:	9d 89       	ldd	r25, Y+21	; 0x15
    1e1a:	01 96       	adiw	r24, 0x01	; 1
    1e1c:	9d 8b       	std	Y+21, r25	; 0x15
    1e1e:	8c 8b       	std	Y+20, r24	; 0x14
    1e20:	2c 89       	ldd	r18, Y+20	; 0x14
    1e22:	3d 89       	ldd	r19, Y+21	; 0x15
    1e24:	41 e0       	ldi	r20, 0x01	; 1
    1e26:	8b 81       	ldd	r24, Y+3	; 0x03
    1e28:	9c 81       	ldd	r25, Y+4	; 0x04
    1e2a:	28 17       	cp	r18, r24
    1e2c:	39 07       	cpc	r19, r25
    1e2e:	08 f0       	brcs	.+2      	; 0x1e32 <_Z11ReceiveGAVRv+0x642>
    1e30:	40 e0       	ldi	r20, 0x00	; 0
    1e32:	44 23       	and	r20, r20
    1e34:	39 f7       	brne	.-50     	; 0x1e04 <_Z11ReceiveGAVRv+0x614>
					flagReceivingGAVR=fFalse;
    1e36:	10 92 0d 02 	sts	0x020D, r1
					flagWaitingForReceiveGAVR=fFalse;
    1e3a:	10 92 0e 02 	sts	0x020E, r1
					state=0;		//just in case
    1e3e:	1a 82       	std	Y+2, r1	; 0x02
    1e40:	19 82       	std	Y+1, r1	; 0x01
					break;
    1e42:	2b c0       	rjmp	.+86     	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
				}//end case 5
				case 6:{
					//Error in ACK case
					Wait_ms(150);
    1e44:	86 e9       	ldi	r24, 0x96	; 150
    1e46:	90 e0       	ldi	r25, 0x00	; 0
    1e48:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					PrintGAVR("E.");
    1e4c:	80 ea       	ldi	r24, 0xA0	; 160
    1e4e:	91 e0       	ldi	r25, 0x01	; 1
    1e50:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
					PrintBone("ErrorR.");
    1e54:	83 ea       	ldi	r24, 0xA3	; 163
    1e56:	91 e0       	ldi	r25, 0x01	; 1
    1e58:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					state=5;
    1e5c:	85 e0       	ldi	r24, 0x05	; 5
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	9a 83       	std	Y+2, r25	; 0x02
    1e62:	89 83       	std	Y+1, r24	; 0x01
					break;
    1e64:	1a c0       	rjmp	.+52     	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
				}//end case 6
				case 7:{
					Wait_ms(150);
    1e66:	86 e9       	ldi	r24, 0x96	; 150
    1e68:	90 e0       	ldi	r25, 0x00	; 0
    1e6a:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					//Successful grab of date/time case
					recString[0]='A';
    1e6e:	81 e4       	ldi	r24, 0x41	; 65
    1e70:	8a a7       	lds	r24, 0x7a
					PrintGAVR(recString);
    1e72:	ce 01       	movw	r24, r28
    1e74:	8a 96       	adiw	r24, 0x2a	; 42
    1e76:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
					state=5;
    1e7a:	85 e0       	ldi	r24, 0x05	; 5
    1e7c:	90 e0       	ldi	r25, 0x00	; 0
    1e7e:	9a 83       	std	Y+2, r25	; 0x02
    1e80:	89 83       	std	Y+1, r24	; 0x01
					PrintBone("Success.");
    1e82:	8e e4       	ldi	r24, 0x4E	; 78
    1e84:	91 e0       	ldi	r25, 0x01	; 1
    1e86:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					break;		
    1e8a:	07 c0       	rjmp	.+14     	; 0x1e9a <_Z11ReceiveGAVRv+0x6aa>
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
    1e8c:	1a 82       	std	Y+2, r1	; 0x02
    1e8e:	19 82       	std	Y+1, r1	; 0x01
    1e90:	1c 82       	std	Y+4, r1	; 0x04
    1e92:	1b 82       	std	Y+3, r1	; 0x03
    1e94:	10 92 0d 02 	sts	0x020D, r1
    1e98:	00 00       	nop
	char recChar, recString[40];
	unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	//While Loop
	while (flagReceivingGAVR){
    1e9a:	90 91 0d 02 	lds	r25, 0x020D
    1e9e:	81 e0       	ldi	r24, 0x01	; 1
    1ea0:	99 23       	and	r25, r25
    1ea2:	09 f4       	brne	.+2      	; 0x1ea6 <_Z11ReceiveGAVRv+0x6b6>
    1ea4:	80 e0       	ldi	r24, 0x00	; 0
    1ea6:	88 23       	and	r24, r24
    1ea8:	09 f0       	breq	.+2      	; 0x1eac <_Z11ReceiveGAVRv+0x6bc>
    1eaa:	b4 cc       	rjmp	.-1688   	; 0x1814 <_Z11ReceiveGAVRv+0x24>
					break;		
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
			}//end switch	
		}//end while flagReceivingGAVR	
}	
    1eac:	cf 5a       	subi	r28, 0xAF	; 175
    1eae:	df 4f       	sbci	r29, 0xFF	; 255
    1eb0:	0f b6       	in	r0, 0x3f	; 63
    1eb2:	f8 94       	cli
    1eb4:	de bf       	out	0x3e, r29	; 62
    1eb6:	0f be       	out	0x3f, r0	; 63
    1eb8:	cd bf       	out	0x3d, r28	; 61
    1eba:	df 91       	pop	r29
    1ebc:	cf 91       	pop	r28
    1ebe:	08 95       	ret

00001ec0 <_Z11ReceiveBonev>:
/*************************************************************************************************************/
void ReceiveBone(){
    1ec0:	cf 93       	push	r28
    1ec2:	df 93       	push	r29
    1ec4:	cd b7       	in	r28, 0x3d	; 61
    1ec6:	de b7       	in	r29, 0x3e	; 62
    1ec8:	c5 56       	subi	r28, 0x65	; 101
    1eca:	d0 40       	sbci	r29, 0x00	; 0
    1ecc:	0f b6       	in	r0, 0x3f	; 63
    1ece:	f8 94       	cli
    1ed0:	de bf       	out	0x3e, r29	; 62
    1ed2:	0f be       	out	0x3f, r0	; 63
    1ed4:	cd bf       	out	0x3d, r28	; 61
	BYTE state=0,strLoc=0;
    1ed6:	19 82       	std	Y+1, r1	; 0x01
    1ed8:	1a 82       	std	Y+2, r1	; 0x02
	char recChar, recString[40];
	BOOL noCarriage=fTrue;
    1eda:	81 e0       	ldi	r24, 0x01	; 1
    1edc:	8b 83       	std	Y+3, r24	; 0x03
	while (flagReceivingBone){
    1ede:	f6 c3       	rjmp	.+2028   	; 0x26cc <_Z11ReceiveBonev+0x80c>
			/* State 6: Graceful exit. Exit from a command like adc or temp.																*/
			/* State 7: Parse the input string for the time and date. Should be time(:)'/'date(,) where : and , are the delimiters. Term by */
			/*			'.'																													*/
			/********************************************************************************************************************************/
			
			switch(state){
    1ee0:	89 81       	ldd	r24, Y+1	; 0x01
    1ee2:	88 2f       	mov	r24, r24
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	83 30       	cpi	r24, 0x03	; 3
    1ee8:	91 05       	cpc	r25, r1
    1eea:	09 f4       	brne	.+2      	; 0x1eee <_Z11ReceiveBonev+0x2e>
    1eec:	48 c1       	rjmp	.+656    	; 0x217e <_Z11ReceiveBonev+0x2be>
    1eee:	84 30       	cpi	r24, 0x04	; 4
    1ef0:	91 05       	cpc	r25, r1
    1ef2:	5c f4       	brge	.+22     	; 0x1f0a <_Z11ReceiveBonev+0x4a>
    1ef4:	81 30       	cpi	r24, 0x01	; 1
    1ef6:	91 05       	cpc	r25, r1
    1ef8:	09 f4       	brne	.+2      	; 0x1efc <_Z11ReceiveBonev+0x3c>
    1efa:	77 c0       	rjmp	.+238    	; 0x1fea <_Z11ReceiveBonev+0x12a>
    1efc:	82 30       	cpi	r24, 0x02	; 2
    1efe:	91 05       	cpc	r25, r1
    1f00:	0c f0       	brlt	.+2      	; 0x1f04 <_Z11ReceiveBonev+0x44>
    1f02:	83 c0       	rjmp	.+262    	; 0x200a <_Z11ReceiveBonev+0x14a>
    1f04:	00 97       	sbiw	r24, 0x00	; 0
    1f06:	91 f0       	breq	.+36     	; 0x1f2c <_Z11ReceiveBonev+0x6c>
    1f08:	dd c3       	rjmp	.+1978   	; 0x26c4 <_Z11ReceiveBonev+0x804>
    1f0a:	85 30       	cpi	r24, 0x05	; 5
    1f0c:	91 05       	cpc	r25, r1
    1f0e:	09 f4       	brne	.+2      	; 0x1f12 <_Z11ReceiveBonev+0x52>
    1f10:	82 c1       	rjmp	.+772    	; 0x2216 <_Z11ReceiveBonev+0x356>
    1f12:	85 30       	cpi	r24, 0x05	; 5
    1f14:	91 05       	cpc	r25, r1
    1f16:	0c f4       	brge	.+2      	; 0x1f1a <_Z11ReceiveBonev+0x5a>
    1f18:	59 c1       	rjmp	.+690    	; 0x21cc <_Z11ReceiveBonev+0x30c>
    1f1a:	86 30       	cpi	r24, 0x06	; 6
    1f1c:	91 05       	cpc	r25, r1
    1f1e:	09 f4       	brne	.+2      	; 0x1f22 <_Z11ReceiveBonev+0x62>
    1f20:	a3 c1       	rjmp	.+838    	; 0x2268 <_Z11ReceiveBonev+0x3a8>
    1f22:	87 30       	cpi	r24, 0x07	; 7
    1f24:	91 05       	cpc	r25, r1
    1f26:	09 f4       	brne	.+2      	; 0x1f2a <_Z11ReceiveBonev+0x6a>
    1f28:	c0 c1       	rjmp	.+896    	; 0x22aa <_Z11ReceiveBonev+0x3ea>
    1f2a:	cc c3       	rjmp	.+1944   	; 0x26c4 <_Z11ReceiveBonev+0x804>
				case 0:{
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
    1f2c:	1a 82       	std	Y+2, r1	; 0x02
					recChar = UDR0;
    1f2e:	86 ec       	ldi	r24, 0xC6	; 198
    1f30:	90 e0       	ldi	r25, 0x00	; 0
    1f32:	fc 01       	movw	r30, r24
    1f34:	80 81       	ld	r24, Z
    1f36:	8c 8f       	std	Y+28, r24	; 0x1c
					if (recChar=='.'){
    1f38:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1f3a:	8e 32       	cpi	r24, 0x2E	; 46
    1f3c:	19 f4       	brne	.+6      	; 0x1f44 <_Z11ReceiveBonev+0x84>
						state=5;
    1f3e:	85 e0       	ldi	r24, 0x05	; 5
    1f40:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
    1f42:	c4 c3       	rjmp	.+1928   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
					recChar = UDR0;
					if (recChar=='.'){
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
    1f44:	8a 81       	ldd	r24, Y+2	; 0x02
    1f46:	88 2f       	mov	r24, r24
    1f48:	90 e0       	ldi	r25, 0x00	; 0
    1f4a:	9e 01       	movw	r18, r28
    1f4c:	22 5c       	subi	r18, 0xC2	; 194
    1f4e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f50:	82 0f       	add	r24, r18
    1f52:	93 1f       	adc	r25, r19
    1f54:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1f56:	fc 01       	movw	r30, r24
    1f58:	20 83       	st	Z, r18
    1f5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1f5c:	8f 5f       	subi	r24, 0xFF	; 255
    1f5e:	8a 83       	std	Y+2, r24	; 0x02
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	89 83       	std	Y+1, r24	; 0x01
					break;				
    1f64:	b3 c3       	rjmp	.+1894   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						Wait_ms(50);
    1f66:	82 e3       	ldi	r24, 0x32	; 50
    1f68:	90 e0       	ldi	r25, 0x00	; 0
    1f6a:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
						while ((!(UCSR0A & (1 << RXC0))) && flagReceivingBone);		//get the next character
    1f6e:	00 00       	nop
    1f70:	80 ec       	ldi	r24, 0xC0	; 192
    1f72:	90 e0       	ldi	r25, 0x00	; 0
    1f74:	fc 01       	movw	r30, r24
    1f76:	80 81       	ld	r24, Z
    1f78:	88 23       	and	r24, r24
    1f7a:	34 f0       	brlt	.+12     	; 0x1f88 <_Z11ReceiveBonev+0xc8>
    1f7c:	80 91 0b 02 	lds	r24, 0x020B
    1f80:	88 23       	and	r24, r24
    1f82:	11 f0       	breq	.+4      	; 0x1f88 <_Z11ReceiveBonev+0xc8>
    1f84:	81 e0       	ldi	r24, 0x01	; 1
    1f86:	01 c0       	rjmp	.+2      	; 0x1f8a <_Z11ReceiveBonev+0xca>
    1f88:	80 e0       	ldi	r24, 0x00	; 0
    1f8a:	88 23       	and	r24, r24
    1f8c:	89 f7       	brne	.-30     	; 0x1f70 <_Z11ReceiveBonev+0xb0>
						if (!flagReceivingBone){break;}					//if there was a timeout, break out and reset state
    1f8e:	80 91 0b 02 	lds	r24, 0x020B
    1f92:	88 23       	and	r24, r24
    1f94:	c1 f1       	breq	.+112    	; 0x2006 <_Z11ReceiveBonev+0x146>
						recChar=UDR0;
    1f96:	86 ec       	ldi	r24, 0xC6	; 198
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	80 81       	ld	r24, Z
    1f9e:	8c 8f       	std	Y+28, r24	; 0x1c
						recString[strLoc++]=recChar;
    1fa0:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa2:	88 2f       	mov	r24, r24
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	9e 01       	movw	r18, r28
    1fa8:	22 5c       	subi	r18, 0xC2	; 194
    1faa:	3f 4f       	sbci	r19, 0xFF	; 255
    1fac:	82 0f       	add	r24, r18
    1fae:	93 1f       	adc	r25, r19
    1fb0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1fb2:	fc 01       	movw	r30, r24
    1fb4:	20 83       	st	Z, r18
    1fb6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fb8:	8f 5f       	subi	r24, 0xFF	; 255
    1fba:	8a 83       	std	Y+2, r24	; 0x02
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1fbc:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1fbe:	8e 32       	cpi	r24, 0x2E	; 46
    1fc0:	71 f4       	brne	.+28     	; 0x1fde <_Z11ReceiveBonev+0x11e>
    1fc2:	8a 81       	ldd	r24, Y+2	; 0x02
    1fc4:	88 2f       	mov	r24, r24
    1fc6:	90 e0       	ldi	r25, 0x00	; 0
    1fc8:	9e 01       	movw	r18, r28
    1fca:	22 5c       	subi	r18, 0xC2	; 194
    1fcc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fce:	82 0f       	add	r24, r18
    1fd0:	93 1f       	adc	r25, r19
    1fd2:	fc 01       	movw	r30, r24
    1fd4:	10 82       	st	Z, r1
    1fd6:	1b 82       	std	Y+3, r1	; 0x03
    1fd8:	82 e0       	ldi	r24, 0x02	; 2
    1fda:	89 83       	std	Y+1, r24	; 0x01
    1fdc:	06 c0       	rjmp	.+12     	; 0x1fea <_Z11ReceiveBonev+0x12a>
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
    1fde:	8a 81       	ldd	r24, Y+2	; 0x02
    1fe0:	87 32       	cpi	r24, 0x27	; 39
    1fe2:	18 f0       	brcs	.+6      	; 0x1fea <_Z11ReceiveBonev+0x12a>
    1fe4:	85 e0       	ldi	r24, 0x05	; 5
    1fe6:	89 83       	std	Y+1, r24	; 0x01
    1fe8:	1b 82       	std	Y+3, r1	; 0x03
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    1fea:	8b 81       	ldd	r24, Y+3	; 0x03
    1fec:	88 23       	and	r24, r24
    1fee:	31 f0       	breq	.+12     	; 0x1ffc <_Z11ReceiveBonev+0x13c>
    1ff0:	80 91 0b 02 	lds	r24, 0x020B
    1ff4:	88 23       	and	r24, r24
    1ff6:	11 f0       	breq	.+4      	; 0x1ffc <_Z11ReceiveBonev+0x13c>
    1ff8:	81 e0       	ldi	r24, 0x01	; 1
    1ffa:	01 c0       	rjmp	.+2      	; 0x1ffe <_Z11ReceiveBonev+0x13e>
    1ffc:	80 e0       	ldi	r24, 0x00	; 0
    1ffe:	88 23       	and	r24, r24
    2000:	09 f0       	breq	.+2      	; 0x2004 <_Z11ReceiveBonev+0x144>
    2002:	b1 cf       	rjmp	.-158    	; 0x1f66 <_Z11ReceiveBonev+0xa6>
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    2004:	63 c3       	rjmp	.+1734   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						Wait_ms(50);
						while ((!(UCSR0A & (1 << RXC0))) && flagReceivingBone);		//get the next character
						if (!flagReceivingBone){break;}					//if there was a timeout, break out and reset state
    2006:	00 00       	nop
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    2008:	61 c3       	rjmp	.+1730   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
    200a:	ce 01       	movw	r24, r28
    200c:	ce 96       	adiw	r24, 0x3e	; 62
    200e:	2b ea       	ldi	r18, 0xAB	; 171
    2010:	31 e0       	ldi	r19, 0x01	; 1
    2012:	b9 01       	movw	r22, r18
    2014:	42 e0       	ldi	r20, 0x02	; 2
    2016:	50 e0       	ldi	r21, 0x00	; 0
    2018:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    201c:	00 97       	sbiw	r24, 0x00	; 0
    201e:	41 f4       	brne	.+16     	; 0x2030 <_Z11ReceiveBonev+0x170>
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	60 e0       	ldi	r22, 0x00	; 0
    2024:	41 e0       	ldi	r20, 0x01	; 1
    2026:	0e 94 79 13 	call	0x26f2	; 0x26f2 <_Z13printTimeDatehhh>
    202a:	86 e0       	ldi	r24, 0x06	; 6
    202c:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    202e:	4e c3       	rjmp	.+1692   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end while
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
    2030:	ce 01       	movw	r24, r28
    2032:	ce 96       	adiw	r24, 0x3e	; 62
    2034:	2e ea       	ldi	r18, 0xAE	; 174
    2036:	31 e0       	ldi	r19, 0x01	; 1
    2038:	b9 01       	movw	r22, r18
    203a:	42 e0       	ldi	r20, 0x02	; 2
    203c:	50 e0       	ldi	r21, 0x00	; 0
    203e:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    2042:	00 97       	sbiw	r24, 0x00	; 0
    2044:	41 f4       	brne	.+16     	; 0x2056 <_Z11ReceiveBonev+0x196>
    2046:	81 e0       	ldi	r24, 0x01	; 1
    2048:	61 e0       	ldi	r22, 0x01	; 1
    204a:	40 e0       	ldi	r20, 0x00	; 0
    204c:	0e 94 79 13 	call	0x26f2	; 0x26f2 <_Z13printTimeDatehhh>
    2050:	86 e0       	ldi	r24, 0x06	; 6
    2052:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    2054:	3b c3       	rjmp	.+1654   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
    2056:	ce 01       	movw	r24, r28
    2058:	ce 96       	adiw	r24, 0x3e	; 62
    205a:	21 eb       	ldi	r18, 0xB1	; 177
    205c:	31 e0       	ldi	r19, 0x01	; 1
    205e:	b9 01       	movw	r22, r18
    2060:	42 e0       	ldi	r20, 0x02	; 2
    2062:	50 e0       	ldi	r21, 0x00	; 0
    2064:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    2068:	00 97       	sbiw	r24, 0x00	; 0
    206a:	41 f4       	brne	.+16     	; 0x207c <_Z11ReceiveBonev+0x1bc>
    206c:	81 e0       	ldi	r24, 0x01	; 1
    206e:	61 e0       	ldi	r22, 0x01	; 1
    2070:	41 e0       	ldi	r20, 0x01	; 1
    2072:	0e 94 79 13 	call	0x26f2	; 0x26f2 <_Z13printTimeDatehhh>
    2076:	86 e0       	ldi	r24, 0x06	; 6
    2078:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    207a:	28 c3       	rjmp	.+1616   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
    207c:	ce 01       	movw	r24, r28
    207e:	ce 96       	adiw	r24, 0x3e	; 62
    2080:	24 eb       	ldi	r18, 0xB4	; 180
    2082:	31 e0       	ldi	r19, 0x01	; 1
    2084:	b9 01       	movw	r22, r18
    2086:	42 e0       	ldi	r20, 0x02	; 2
    2088:	50 e0       	ldi	r21, 0x00	; 0
    208a:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    208e:	00 97       	sbiw	r24, 0x00	; 0
    2090:	59 f4       	brne	.+22     	; 0x20a8 <_Z11ReceiveBonev+0x1e8>
    2092:	81 e0       	ldi	r24, 0x01	; 1
    2094:	60 e0       	ldi	r22, 0x00	; 0
    2096:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    209a:	ce 01       	movw	r24, r28
    209c:	ce 96       	adiw	r24, 0x3e	; 62
    209e:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    20a2:	86 e0       	ldi	r24, 0x06	; 6
    20a4:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    20a6:	12 c3       	rjmp	.+1572   	; 0x26cc <_Z11ReceiveBonev+0x80c>
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    20a8:	ce 01       	movw	r24, r28
    20aa:	ce 96       	adiw	r24, 0x3e	; 62
    20ac:	27 eb       	ldi	r18, 0xB7	; 183
    20ae:	31 e0       	ldi	r19, 0x01	; 1
    20b0:	b9 01       	movw	r22, r18
    20b2:	42 e0       	ldi	r20, 0x02	; 2
    20b4:	50 e0       	ldi	r21, 0x00	; 0
    20b6:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    20ba:	00 97       	sbiw	r24, 0x00	; 0
    20bc:	a1 f4       	brne	.+40     	; 0x20e6 <_Z11ReceiveBonev+0x226>
    20be:	80 91 de 01 	lds	r24, 0x01DE
    20c2:	90 91 df 01 	lds	r25, 0x01DF
    20c6:	9e 01       	movw	r18, r28
    20c8:	23 5e       	subi	r18, 0xE3	; 227
    20ca:	3f 4f       	sbci	r19, 0xFF	; 255
    20cc:	b9 01       	movw	r22, r18
    20ce:	4a e0       	ldi	r20, 0x0A	; 10
    20d0:	50 e0       	ldi	r21, 0x00	; 0
    20d2:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <utoa>
    20d6:	1b a2       	lds	r17, 0x9b
    20d8:	ce 01       	movw	r24, r28
    20da:	4d 96       	adiw	r24, 0x1d	; 29
    20dc:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    20e0:	86 e0       	ldi	r24, 0x06	; 6
    20e2:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    20e4:	f3 c2       	rjmp	.+1510   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    20e6:	ce 01       	movw	r24, r28
    20e8:	ce 96       	adiw	r24, 0x3e	; 62
    20ea:	2a eb       	ldi	r18, 0xBA	; 186
    20ec:	31 e0       	ldi	r19, 0x01	; 1
    20ee:	b9 01       	movw	r22, r18
    20f0:	43 e0       	ldi	r20, 0x03	; 3
    20f2:	50 e0       	ldi	r21, 0x00	; 0
    20f4:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    20f8:	00 97       	sbiw	r24, 0x00	; 0
    20fa:	a1 f4       	brne	.+40     	; 0x2124 <_Z11ReceiveBonev+0x264>
    20fc:	80 91 e0 01 	lds	r24, 0x01E0
    2100:	90 91 e1 01 	lds	r25, 0x01E1
    2104:	9e 01       	movw	r18, r28
    2106:	2c 5d       	subi	r18, 0xDC	; 220
    2108:	3f 4f       	sbci	r19, 0xFF	; 255
    210a:	b9 01       	movw	r22, r18
    210c:	4a e0       	ldi	r20, 0x0A	; 10
    210e:	50 e0       	ldi	r21, 0x00	; 0
    2110:	0e 94 47 1d 	call	0x3a8e	; 0x3a8e <utoa>
    2114:	1a a6       	lds	r17, 0xba
    2116:	ce 01       	movw	r24, r28
    2118:	84 96       	adiw	r24, 0x24	; 36
    211a:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    211e:	86 e0       	ldi	r24, 0x06	; 6
    2120:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    2122:	d4 c2       	rjmp	.+1448   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
    2124:	ce 01       	movw	r24, r28
    2126:	80 5c       	subi	r24, 0xC0	; 192
    2128:	9f 4f       	sbci	r25, 0xFF	; 255
    212a:	fc 01       	movw	r30, r24
    212c:	80 81       	ld	r24, Z
    212e:	21 e0       	ldi	r18, 0x01	; 1
    2130:	8a 33       	cpi	r24, 0x3A	; 58
    2132:	09 f0       	breq	.+2      	; 0x2136 <_Z11ReceiveBonev+0x276>
    2134:	20 e0       	ldi	r18, 0x00	; 0
    2136:	ce 01       	movw	r24, r28
    2138:	8f 5b       	subi	r24, 0xBF	; 191
    213a:	9f 4f       	sbci	r25, 0xFF	; 255
    213c:	fc 01       	movw	r30, r24
    213e:	90 81       	ld	r25, Z
    2140:	81 e0       	ldi	r24, 0x01	; 1
    2142:	9a 33       	cpi	r25, 0x3A	; 58
    2144:	09 f0       	breq	.+2      	; 0x2148 <_Z11ReceiveBonev+0x288>
    2146:	80 e0       	ldi	r24, 0x00	; 0
    2148:	82 27       	eor	r24, r18
    214a:	88 23       	and	r24, r24
    214c:	19 f0       	breq	.+6      	; 0x2154 <_Z11ReceiveBonev+0x294>
						state=7;	
    214e:	87 e0       	ldi	r24, 0x07	; 7
    2150:	89 83       	std	Y+1, r24	; 0x01
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    2152:	bc c2       	rjmp	.+1400   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
    2154:	ce 01       	movw	r24, r28
    2156:	ce 96       	adiw	r24, 0x3e	; 62
    2158:	2a e6       	ldi	r18, 0x6A	; 106
    215a:	31 e0       	ldi	r19, 0x01	; 1
    215c:	b9 01       	movw	r22, r18
    215e:	42 e0       	ldi	r20, 0x02	; 2
    2160:	50 e0       	ldi	r21, 0x00	; 0
    2162:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <strncmp>
    2166:	00 97       	sbiw	r24, 0x00	; 0
    2168:	39 f4       	brne	.+14     	; 0x2178 <_Z11ReceiveBonev+0x2b8>
    216a:	8a e6       	ldi	r24, 0x6A	; 106
    216c:	91 e0       	ldi	r25, 0x01	; 1
    216e:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    2172:	86 e0       	ldi	r24, 0x06	; 6
    2174:	89 83       	std	Y+1, r24	; 0x01
					else {state=5;}						
					break;
    2176:	aa c2       	rjmp	.+1364   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
    2178:	85 e0       	ldi	r24, 0x05	; 5
    217a:	89 83       	std	Y+1, r24	; 0x01
					break;
    217c:	a7 c2       	rjmp	.+1358   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 2
				case 3:{
					//Successful receive state of time, change SYN to ACK, then print what we got.
					recString[0]='A';
    217e:	81 e4       	ldi	r24, 0x41	; 65
    2180:	8e af       	sts	0x7e, r24
					PrintBone(recString);
    2182:	ce 01       	movw	r24, r28
    2184:	ce 96       	adiw	r24, 0x3e	; 62
    2186:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					state=0;
    218a:	19 82       	std	Y+1, r1	; 0x01
					flagReceivingBone=fFalse;
    218c:	10 92 0b 02 	sts	0x020B, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    2190:	1d 82       	std	Y+5, r1	; 0x05
    2192:	1c 82       	std	Y+4, r1	; 0x04
    2194:	0e c0       	rjmp	.+28     	; 0x21b2 <_Z11ReceiveBonev+0x2f2>
    2196:	9e 01       	movw	r18, r28
    2198:	22 5c       	subi	r18, 0xC2	; 194
    219a:	3f 4f       	sbci	r19, 0xFF	; 255
    219c:	8c 81       	ldd	r24, Y+4	; 0x04
    219e:	9d 81       	ldd	r25, Y+5	; 0x05
    21a0:	82 0f       	add	r24, r18
    21a2:	93 1f       	adc	r25, r19
    21a4:	fc 01       	movw	r30, r24
    21a6:	10 82       	st	Z, r1
    21a8:	8c 81       	ldd	r24, Y+4	; 0x04
    21aa:	9d 81       	ldd	r25, Y+5	; 0x05
    21ac:	01 96       	adiw	r24, 0x01	; 1
    21ae:	9d 83       	std	Y+5, r25	; 0x05
    21b0:	8c 83       	std	Y+4, r24	; 0x04
    21b2:	8a 81       	ldd	r24, Y+2	; 0x02
    21b4:	28 2f       	mov	r18, r24
    21b6:	30 e0       	ldi	r19, 0x00	; 0
    21b8:	41 e0       	ldi	r20, 0x01	; 1
    21ba:	8c 81       	ldd	r24, Y+4	; 0x04
    21bc:	9d 81       	ldd	r25, Y+5	; 0x05
    21be:	82 17       	cp	r24, r18
    21c0:	93 07       	cpc	r25, r19
    21c2:	0c f0       	brlt	.+2      	; 0x21c6 <_Z11ReceiveBonev+0x306>
    21c4:	40 e0       	ldi	r20, 0x00	; 0
    21c6:	44 23       	and	r20, r20
    21c8:	31 f7       	brne	.-52     	; 0x2196 <_Z11ReceiveBonev+0x2d6>
					break;
    21ca:	80 c2       	rjmp	.+1280   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 3
				case 4:{
					//Bad time string.
					PrintBone("B.");
    21cc:	82 e1       	ldi	r24, 0x12	; 18
    21ce:	91 e0       	ldi	r25, 0x01	; 1
    21d0:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    21d4:	10 92 0b 02 	sts	0x020B, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    21d8:	1f 82       	std	Y+7, r1	; 0x07
    21da:	1e 82       	std	Y+6, r1	; 0x06
    21dc:	0e c0       	rjmp	.+28     	; 0x21fa <_Z11ReceiveBonev+0x33a>
    21de:	9e 01       	movw	r18, r28
    21e0:	22 5c       	subi	r18, 0xC2	; 194
    21e2:	3f 4f       	sbci	r19, 0xFF	; 255
    21e4:	8e 81       	ldd	r24, Y+6	; 0x06
    21e6:	9f 81       	ldd	r25, Y+7	; 0x07
    21e8:	82 0f       	add	r24, r18
    21ea:	93 1f       	adc	r25, r19
    21ec:	fc 01       	movw	r30, r24
    21ee:	10 82       	st	Z, r1
    21f0:	8e 81       	ldd	r24, Y+6	; 0x06
    21f2:	9f 81       	ldd	r25, Y+7	; 0x07
    21f4:	01 96       	adiw	r24, 0x01	; 1
    21f6:	9f 83       	std	Y+7, r25	; 0x07
    21f8:	8e 83       	std	Y+6, r24	; 0x06
    21fa:	8a 81       	ldd	r24, Y+2	; 0x02
    21fc:	28 2f       	mov	r18, r24
    21fe:	30 e0       	ldi	r19, 0x00	; 0
    2200:	41 e0       	ldi	r20, 0x01	; 1
    2202:	8e 81       	ldd	r24, Y+6	; 0x06
    2204:	9f 81       	ldd	r25, Y+7	; 0x07
    2206:	82 17       	cp	r24, r18
    2208:	93 07       	cpc	r25, r19
    220a:	0c f0       	brlt	.+2      	; 0x220e <_Z11ReceiveBonev+0x34e>
    220c:	40 e0       	ldi	r20, 0x00	; 0
    220e:	44 23       	and	r20, r20
    2210:	31 f7       	brne	.-52     	; 0x21de <_Z11ReceiveBonev+0x31e>
					state=0;
    2212:	19 82       	std	Y+1, r1	; 0x01
					break;
    2214:	5b c2       	rjmp	.+1206   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 4
				case 5:{
					//Didn't get a good ack or there was an error.
					PrintBone("E.");
    2216:	80 ea       	ldi	r24, 0xA0	; 160
    2218:	91 e0       	ldi	r25, 0x01	; 1
    221a:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					PrintBone(recString);
    221e:	ce 01       	movw	r24, r28
    2220:	ce 96       	adiw	r24, 0x3e	; 62
    2222:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    2226:	10 92 0b 02 	sts	0x020B, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    222a:	19 86       	std	Y+9, r1	; 0x09
    222c:	18 86       	std	Y+8, r1	; 0x08
    222e:	0e c0       	rjmp	.+28     	; 0x224c <_Z11ReceiveBonev+0x38c>
    2230:	9e 01       	movw	r18, r28
    2232:	22 5c       	subi	r18, 0xC2	; 194
    2234:	3f 4f       	sbci	r19, 0xFF	; 255
    2236:	88 85       	ldd	r24, Y+8	; 0x08
    2238:	99 85       	ldd	r25, Y+9	; 0x09
    223a:	82 0f       	add	r24, r18
    223c:	93 1f       	adc	r25, r19
    223e:	fc 01       	movw	r30, r24
    2240:	10 82       	st	Z, r1
    2242:	88 85       	ldd	r24, Y+8	; 0x08
    2244:	99 85       	ldd	r25, Y+9	; 0x09
    2246:	01 96       	adiw	r24, 0x01	; 1
    2248:	99 87       	std	Y+9, r25	; 0x09
    224a:	88 87       	std	Y+8, r24	; 0x08
    224c:	8a 81       	ldd	r24, Y+2	; 0x02
    224e:	28 2f       	mov	r18, r24
    2250:	30 e0       	ldi	r19, 0x00	; 0
    2252:	41 e0       	ldi	r20, 0x01	; 1
    2254:	88 85       	ldd	r24, Y+8	; 0x08
    2256:	99 85       	ldd	r25, Y+9	; 0x09
    2258:	82 17       	cp	r24, r18
    225a:	93 07       	cpc	r25, r19
    225c:	0c f0       	brlt	.+2      	; 0x2260 <_Z11ReceiveBonev+0x3a0>
    225e:	40 e0       	ldi	r20, 0x00	; 0
    2260:	44 23       	and	r20, r20
    2262:	31 f7       	brne	.-52     	; 0x2230 <_Z11ReceiveBonev+0x370>
					state=0;
    2264:	19 82       	std	Y+1, r1	; 0x01
					break;
    2266:	32 c2       	rjmp	.+1124   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 5
				case 6:{
					//Graceful exit.
					flagReceivingBone=fFalse;
    2268:	10 92 0b 02 	sts	0x020B, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    226c:	1b 86       	std	Y+11, r1	; 0x0b
    226e:	1a 86       	std	Y+10, r1	; 0x0a
    2270:	0e c0       	rjmp	.+28     	; 0x228e <_Z11ReceiveBonev+0x3ce>
    2272:	9e 01       	movw	r18, r28
    2274:	22 5c       	subi	r18, 0xC2	; 194
    2276:	3f 4f       	sbci	r19, 0xFF	; 255
    2278:	8a 85       	ldd	r24, Y+10	; 0x0a
    227a:	9b 85       	ldd	r25, Y+11	; 0x0b
    227c:	82 0f       	add	r24, r18
    227e:	93 1f       	adc	r25, r19
    2280:	fc 01       	movw	r30, r24
    2282:	10 82       	st	Z, r1
    2284:	8a 85       	ldd	r24, Y+10	; 0x0a
    2286:	9b 85       	ldd	r25, Y+11	; 0x0b
    2288:	01 96       	adiw	r24, 0x01	; 1
    228a:	9b 87       	std	Y+11, r25	; 0x0b
    228c:	8a 87       	std	Y+10, r24	; 0x0a
    228e:	8a 81       	ldd	r24, Y+2	; 0x02
    2290:	28 2f       	mov	r18, r24
    2292:	30 e0       	ldi	r19, 0x00	; 0
    2294:	41 e0       	ldi	r20, 0x01	; 1
    2296:	8a 85       	ldd	r24, Y+10	; 0x0a
    2298:	9b 85       	ldd	r25, Y+11	; 0x0b
    229a:	82 17       	cp	r24, r18
    229c:	93 07       	cpc	r25, r19
    229e:	0c f0       	brlt	.+2      	; 0x22a2 <_Z11ReceiveBonev+0x3e2>
    22a0:	40 e0       	ldi	r20, 0x00	; 0
    22a2:	44 23       	and	r20, r20
    22a4:	31 f7       	brne	.-52     	; 0x2272 <_Z11ReceiveBonev+0x3b2>
					state=0;
    22a6:	19 82       	std	Y+1, r1	; 0x01
					break;
    22a8:	11 c2       	rjmp	.+1058   	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 6
				case 7:{
					//Parse the string
					//Go through the string and parse for the time. Must go through the time to get the date.
					BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    22aa:	1c 86       	std	Y+12, r1	; 0x0c
    22ac:	1d 86       	std	Y+13, r1	; 0x0d
					int counter=1;
    22ae:	81 e0       	ldi	r24, 0x01	; 1
    22b0:	90 e0       	ldi	r25, 0x00	; 0
    22b2:	9f 87       	std	Y+15, r25	; 0x0f
    22b4:	8e 87       	std	Y+14, r24	; 0x0e
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    22b6:	1c a6       	lds	r17, 0xbc
    22b8:	1b a6       	lds	r17, 0xbb
    22ba:	1e a6       	lds	r17, 0xbe
    22bc:	1d a6       	lds	r17, 0xbd
    22be:	18 aa       	sts	0x98, r17
    22c0:	1f a6       	lds	r17, 0xbf
    22c2:	1a aa       	sts	0x9a, r17
    22c4:	19 aa       	sts	0x99, r17
    22c6:	1c aa       	sts	0x9c, r17
    22c8:	1b aa       	sts	0x9b, r17
    22ca:	1e aa       	sts	0x9e, r17
    22cc:	1d aa       	sts	0x9d, r17
    22ce:	19 8a       	std	Y+17, r1	; 0x11
    22d0:	18 8a       	std	Y+16, r1	; 0x10
    22d2:	1b 8a       	std	Y+19, r1	; 0x13
    22d4:	1a 8a       	std	Y+18, r1	; 0x12
    22d6:	1d 8a       	std	Y+21, r1	; 0x15
    22d8:	1c 8a       	std	Y+20, r1	; 0x14
					char tempStringNum[7];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    22da:	73 c0       	rjmp	.+230    	; 0x23c2 <_Z11ReceiveBonev+0x502>
						//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
						if (recString[counter]!=':' && hms<3){
    22dc:	9e 01       	movw	r18, r28
    22de:	22 5c       	subi	r18, 0xC2	; 194
    22e0:	3f 4f       	sbci	r19, 0xFF	; 255
    22e2:	8e 85       	ldd	r24, Y+14	; 0x0e
    22e4:	9f 85       	ldd	r25, Y+15	; 0x0f
    22e6:	82 0f       	add	r24, r18
    22e8:	93 1f       	adc	r25, r19
    22ea:	fc 01       	movw	r30, r24
    22ec:	80 81       	ld	r24, Z
    22ee:	8a 33       	cpi	r24, 0x3A	; 58
    22f0:	e9 f0       	breq	.+58     	; 0x232c <_Z11ReceiveBonev+0x46c>
    22f2:	8a 89       	ldd	r24, Y+18	; 0x12
    22f4:	9b 89       	ldd	r25, Y+19	; 0x13
    22f6:	83 30       	cpi	r24, 0x03	; 3
    22f8:	91 05       	cpc	r25, r1
    22fa:	c4 f4       	brge	.+48     	; 0x232c <_Z11ReceiveBonev+0x46c>
							tempStringNum[placement++]=recString[counter];
    22fc:	9e 01       	movw	r18, r28
    22fe:	22 5c       	subi	r18, 0xC2	; 194
    2300:	3f 4f       	sbci	r19, 0xFF	; 255
    2302:	8e 85       	ldd	r24, Y+14	; 0x0e
    2304:	9f 85       	ldd	r25, Y+15	; 0x0f
    2306:	82 0f       	add	r24, r18
    2308:	93 1f       	adc	r25, r19
    230a:	fc 01       	movw	r30, r24
    230c:	40 81       	ld	r20, Z
    230e:	9e 01       	movw	r18, r28
    2310:	29 5c       	subi	r18, 0xC9	; 201
    2312:	3f 4f       	sbci	r19, 0xFF	; 255
    2314:	8c 89       	ldd	r24, Y+20	; 0x14
    2316:	9d 89       	ldd	r25, Y+21	; 0x15
    2318:	82 0f       	add	r24, r18
    231a:	93 1f       	adc	r25, r19
    231c:	fc 01       	movw	r30, r24
    231e:	40 83       	st	Z, r20
    2320:	8c 89       	ldd	r24, Y+20	; 0x14
    2322:	9d 89       	ldd	r25, Y+21	; 0x15
    2324:	01 96       	adiw	r24, 0x01	; 1
    2326:	9d 8b       	std	Y+21, r25	; 0x15
    2328:	8c 8b       	std	Y+20, r24	; 0x14
    232a:	46 c0       	rjmp	.+140    	; 0x23b8 <_Z11ReceiveBonev+0x4f8>
						//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
						} else if (hms<2 && recString[counter] == ':') {
    232c:	8a 89       	ldd	r24, Y+18	; 0x12
    232e:	9b 89       	ldd	r25, Y+19	; 0x13
    2330:	82 30       	cpi	r24, 0x02	; 2
    2332:	91 05       	cpc	r25, r1
    2334:	0c f0       	brlt	.+2      	; 0x2338 <_Z11ReceiveBonev+0x478>
    2336:	40 c0       	rjmp	.+128    	; 0x23b8 <_Z11ReceiveBonev+0x4f8>
    2338:	9e 01       	movw	r18, r28
    233a:	22 5c       	subi	r18, 0xC2	; 194
    233c:	3f 4f       	sbci	r19, 0xFF	; 255
    233e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2340:	9f 85       	ldd	r25, Y+15	; 0x0f
    2342:	82 0f       	add	r24, r18
    2344:	93 1f       	adc	r25, r19
    2346:	fc 01       	movw	r30, r24
    2348:	80 81       	ld	r24, Z
    234a:	8a 33       	cpi	r24, 0x3A	; 58
    234c:	a9 f5       	brne	.+106    	; 0x23b8 <_Z11ReceiveBonev+0x4f8>
							tempNum[hms++] = atoi(tempStringNum);
    234e:	ce 01       	movw	r24, r28
    2350:	c7 96       	adiw	r24, 0x37	; 55
    2352:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
    2356:	9c 01       	movw	r18, r24
    2358:	8a 89       	ldd	r24, Y+18	; 0x12
    235a:	9b 89       	ldd	r25, Y+19	; 0x13
    235c:	88 0f       	add	r24, r24
    235e:	99 1f       	adc	r25, r25
    2360:	ae 01       	movw	r20, r28
    2362:	4f 5f       	subi	r20, 0xFF	; 255
    2364:	5f 4f       	sbci	r21, 0xFF	; 255
    2366:	84 0f       	add	r24, r20
    2368:	95 1f       	adc	r25, r21
    236a:	8a 96       	adiw	r24, 0x2a	; 42
    236c:	fc 01       	movw	r30, r24
    236e:	31 83       	std	Z+1, r19	; 0x01
    2370:	20 83       	st	Z, r18
    2372:	8a 89       	ldd	r24, Y+18	; 0x12
    2374:	9b 89       	ldd	r25, Y+19	; 0x13
    2376:	01 96       	adiw	r24, 0x01	; 1
    2378:	9b 8b       	std	Y+19, r25	; 0x13
    237a:	8a 8b       	std	Y+18, r24	; 0x12
							for (int j=0; j <= placement; j++){tempStringNum[j]=(char)NULL;}	//reset the string
    237c:	1f 8a       	std	Y+23, r1	; 0x17
    237e:	1e 8a       	std	Y+22, r1	; 0x16
    2380:	0e c0       	rjmp	.+28     	; 0x239e <_Z11ReceiveBonev+0x4de>
    2382:	9e 01       	movw	r18, r28
    2384:	29 5c       	subi	r18, 0xC9	; 201
    2386:	3f 4f       	sbci	r19, 0xFF	; 255
    2388:	8e 89       	ldd	r24, Y+22	; 0x16
    238a:	9f 89       	ldd	r25, Y+23	; 0x17
    238c:	82 0f       	add	r24, r18
    238e:	93 1f       	adc	r25, r19
    2390:	fc 01       	movw	r30, r24
    2392:	10 82       	st	Z, r1
    2394:	8e 89       	ldd	r24, Y+22	; 0x16
    2396:	9f 89       	ldd	r25, Y+23	; 0x17
    2398:	01 96       	adiw	r24, 0x01	; 1
    239a:	9f 8b       	std	Y+23, r25	; 0x17
    239c:	8e 8b       	std	Y+22, r24	; 0x16
    239e:	41 e0       	ldi	r20, 0x01	; 1
    23a0:	2e 89       	ldd	r18, Y+22	; 0x16
    23a2:	3f 89       	ldd	r19, Y+23	; 0x17
    23a4:	8c 89       	ldd	r24, Y+20	; 0x14
    23a6:	9d 89       	ldd	r25, Y+21	; 0x15
    23a8:	82 17       	cp	r24, r18
    23aa:	93 07       	cpc	r25, r19
    23ac:	0c f4       	brge	.+2      	; 0x23b0 <_Z11ReceiveBonev+0x4f0>
    23ae:	40 e0       	ldi	r20, 0x00	; 0
    23b0:	44 23       	and	r20, r20
    23b2:	39 f7       	brne	.-50     	; 0x2382 <_Z11ReceiveBonev+0x4c2>
							placement=0;												//reset placement
    23b4:	1d 8a       	std	Y+21, r1	; 0x15
    23b6:	1c 8a       	std	Y+20, r1	; 0x14
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
    23b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    23ba:	9f 85       	ldd	r25, Y+15	; 0x0f
    23bc:	01 96       	adiw	r24, 0x01	; 1
    23be:	9f 87       	std	Y+15, r25	; 0x0f
    23c0:	8e 87       	std	Y+14, r24	; 0x0e
					int counter=1;
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
					char tempStringNum[7];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    23c2:	9e 01       	movw	r18, r28
    23c4:	22 5c       	subi	r18, 0xC2	; 194
    23c6:	3f 4f       	sbci	r19, 0xFF	; 255
    23c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    23ca:	9f 85       	ldd	r25, Y+15	; 0x0f
    23cc:	82 0f       	add	r24, r18
    23ce:	93 1f       	adc	r25, r19
    23d0:	fc 01       	movw	r30, r24
    23d2:	80 81       	ld	r24, Z
    23d4:	8f 32       	cpi	r24, 0x2F	; 47
    23d6:	69 f0       	breq	.+26     	; 0x23f2 <_Z11ReceiveBonev+0x532>
    23d8:	9e 01       	movw	r18, r28
    23da:	22 5c       	subi	r18, 0xC2	; 194
    23dc:	3f 4f       	sbci	r19, 0xFF	; 255
    23de:	8e 85       	ldd	r24, Y+14	; 0x0e
    23e0:	9f 85       	ldd	r25, Y+15	; 0x0f
    23e2:	82 0f       	add	r24, r18
    23e4:	93 1f       	adc	r25, r19
    23e6:	fc 01       	movw	r30, r24
    23e8:	80 81       	ld	r24, Z
    23ea:	88 23       	and	r24, r24
    23ec:	11 f0       	breq	.+4      	; 0x23f2 <_Z11ReceiveBonev+0x532>
    23ee:	81 e0       	ldi	r24, 0x01	; 1
    23f0:	01 c0       	rjmp	.+2      	; 0x23f4 <_Z11ReceiveBonev+0x534>
    23f2:	80 e0       	ldi	r24, 0x00	; 0
    23f4:	88 23       	and	r24, r24
    23f6:	09 f0       	breq	.+2      	; 0x23fa <_Z11ReceiveBonev+0x53a>
    23f8:	71 cf       	rjmp	.-286    	; 0x22dc <_Z11ReceiveBonev+0x41c>
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
					}//end while
					//Found a '/', assign tempNum otherwise exit with ACKBAD
					if (recString[counter] == '/'){
    23fa:	9e 01       	movw	r18, r28
    23fc:	22 5c       	subi	r18, 0xC2	; 194
    23fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2400:	8e 85       	ldd	r24, Y+14	; 0x0e
    2402:	9f 85       	ldd	r25, Y+15	; 0x0f
    2404:	82 0f       	add	r24, r18
    2406:	93 1f       	adc	r25, r19
    2408:	fc 01       	movw	r30, r24
    240a:	80 81       	ld	r24, Z
    240c:	8f 32       	cpi	r24, 0x2F	; 47
    240e:	a9 f4       	brne	.+42     	; 0x243a <_Z11ReceiveBonev+0x57a>
						tempNum[hms] = atoi(tempStringNum);
    2410:	ce 01       	movw	r24, r28
    2412:	c7 96       	adiw	r24, 0x37	; 55
    2414:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
    2418:	9c 01       	movw	r18, r24
    241a:	8a 89       	ldd	r24, Y+18	; 0x12
    241c:	9b 89       	ldd	r25, Y+19	; 0x13
    241e:	88 0f       	add	r24, r24
    2420:	99 1f       	adc	r25, r25
    2422:	ae 01       	movw	r20, r28
    2424:	4f 5f       	subi	r20, 0xFF	; 255
    2426:	5f 4f       	sbci	r21, 0xFF	; 255
    2428:	84 0f       	add	r24, r20
    242a:	95 1f       	adc	r25, r21
    242c:	8a 96       	adiw	r24, 0x2a	; 42
    242e:	fc 01       	movw	r30, r24
    2430:	31 83       	std	Z+1, r19	; 0x01
    2432:	20 83       	st	Z, r18
						successTime=fTrue;
    2434:	81 e0       	ldi	r24, 0x01	; 1
    2436:	8c 87       	std	Y+12, r24	; 0x0c
    2438:	02 c0       	rjmp	.+4      	; 0x243e <_Z11ReceiveBonev+0x57e>
					} else {
						state=4;
    243a:	84 e0       	ldi	r24, 0x04	; 4
    243c:	89 83       	std	Y+1, r24	; 0x01
					}
					
					//If flag for Date is set, then parse the string and do something with it.
					//Now get the date. have to null the tempStringNum
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    243e:	19 8e       	std	Y+25, r1	; 0x19
    2440:	18 8e       	std	Y+24, r1	; 0x18
    2442:	0e c0       	rjmp	.+28     	; 0x2460 <_Z11ReceiveBonev+0x5a0>
    2444:	9e 01       	movw	r18, r28
    2446:	29 5c       	subi	r18, 0xC9	; 201
    2448:	3f 4f       	sbci	r19, 0xFF	; 255
    244a:	88 8d       	ldd	r24, Y+24	; 0x18
    244c:	99 8d       	ldd	r25, Y+25	; 0x19
    244e:	82 0f       	add	r24, r18
    2450:	93 1f       	adc	r25, r19
    2452:	fc 01       	movw	r30, r24
    2454:	10 82       	st	Z, r1
    2456:	88 8d       	ldd	r24, Y+24	; 0x18
    2458:	99 8d       	ldd	r25, Y+25	; 0x19
    245a:	01 96       	adiw	r24, 0x01	; 1
    245c:	99 8f       	std	Y+25, r25	; 0x19
    245e:	88 8f       	std	Y+24, r24	; 0x18
    2460:	41 e0       	ldi	r20, 0x01	; 1
    2462:	28 8d       	ldd	r18, Y+24	; 0x18
    2464:	39 8d       	ldd	r19, Y+25	; 0x19
    2466:	8c 89       	ldd	r24, Y+20	; 0x14
    2468:	9d 89       	ldd	r25, Y+21	; 0x15
    246a:	82 17       	cp	r24, r18
    246c:	93 07       	cpc	r25, r19
    246e:	0c f4       	brge	.+2      	; 0x2472 <_Z11ReceiveBonev+0x5b2>
    2470:	40 e0       	ldi	r20, 0x00	; 0
    2472:	44 23       	and	r20, r20
    2474:	39 f7       	brne	.-50     	; 0x2444 <_Z11ReceiveBonev+0x584>
					placement=0;
    2476:	1d 8a       	std	Y+21, r1	; 0x15
    2478:	1c 8a       	std	Y+20, r1	; 0x14
					counter++;	//get past the '/'
    247a:	8e 85       	ldd	r24, Y+14	; 0x0e
    247c:	9f 85       	ldd	r25, Y+15	; 0x0f
    247e:	01 96       	adiw	r24, 0x01	; 1
    2480:	9f 87       	std	Y+15, r25	; 0x0f
    2482:	8e 87       	std	Y+14, r24	; 0x0e
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    2484:	73 c0       	rjmp	.+230    	; 0x256c <_Z11ReceiveBonev+0x6ac>
						//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
						if  (recString[counter] != ',' && dmy < 3){
    2486:	9e 01       	movw	r18, r28
    2488:	22 5c       	subi	r18, 0xC2	; 194
    248a:	3f 4f       	sbci	r19, 0xFF	; 255
    248c:	8e 85       	ldd	r24, Y+14	; 0x0e
    248e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2490:	82 0f       	add	r24, r18
    2492:	93 1f       	adc	r25, r19
    2494:	fc 01       	movw	r30, r24
    2496:	80 81       	ld	r24, Z
    2498:	8c 32       	cpi	r24, 0x2C	; 44
    249a:	e9 f0       	breq	.+58     	; 0x24d6 <_Z11ReceiveBonev+0x616>
    249c:	88 89       	ldd	r24, Y+16	; 0x10
    249e:	99 89       	ldd	r25, Y+17	; 0x11
    24a0:	83 30       	cpi	r24, 0x03	; 3
    24a2:	91 05       	cpc	r25, r1
    24a4:	c4 f4       	brge	.+48     	; 0x24d6 <_Z11ReceiveBonev+0x616>
							tempStringNum[placement++]=recString[counter];
    24a6:	9e 01       	movw	r18, r28
    24a8:	22 5c       	subi	r18, 0xC2	; 194
    24aa:	3f 4f       	sbci	r19, 0xFF	; 255
    24ac:	8e 85       	ldd	r24, Y+14	; 0x0e
    24ae:	9f 85       	ldd	r25, Y+15	; 0x0f
    24b0:	82 0f       	add	r24, r18
    24b2:	93 1f       	adc	r25, r19
    24b4:	fc 01       	movw	r30, r24
    24b6:	40 81       	ld	r20, Z
    24b8:	9e 01       	movw	r18, r28
    24ba:	29 5c       	subi	r18, 0xC9	; 201
    24bc:	3f 4f       	sbci	r19, 0xFF	; 255
    24be:	8c 89       	ldd	r24, Y+20	; 0x14
    24c0:	9d 89       	ldd	r25, Y+21	; 0x15
    24c2:	82 0f       	add	r24, r18
    24c4:	93 1f       	adc	r25, r19
    24c6:	fc 01       	movw	r30, r24
    24c8:	40 83       	st	Z, r20
    24ca:	8c 89       	ldd	r24, Y+20	; 0x14
    24cc:	9d 89       	ldd	r25, Y+21	; 0x15
    24ce:	01 96       	adiw	r24, 0x01	; 1
    24d0:	9d 8b       	std	Y+21, r25	; 0x15
    24d2:	8c 8b       	std	Y+20, r24	; 0x14
    24d4:	46 c0       	rjmp	.+140    	; 0x2562 <_Z11ReceiveBonev+0x6a2>
						//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
						} else if (dmy<2 && recString[counter]==','){
    24d6:	88 89       	ldd	r24, Y+16	; 0x10
    24d8:	99 89       	ldd	r25, Y+17	; 0x11
    24da:	82 30       	cpi	r24, 0x02	; 2
    24dc:	91 05       	cpc	r25, r1
    24de:	0c f0       	brlt	.+2      	; 0x24e2 <_Z11ReceiveBonev+0x622>
    24e0:	40 c0       	rjmp	.+128    	; 0x2562 <_Z11ReceiveBonev+0x6a2>
    24e2:	9e 01       	movw	r18, r28
    24e4:	22 5c       	subi	r18, 0xC2	; 194
    24e6:	3f 4f       	sbci	r19, 0xFF	; 255
    24e8:	8e 85       	ldd	r24, Y+14	; 0x0e
    24ea:	9f 85       	ldd	r25, Y+15	; 0x0f
    24ec:	82 0f       	add	r24, r18
    24ee:	93 1f       	adc	r25, r19
    24f0:	fc 01       	movw	r30, r24
    24f2:	80 81       	ld	r24, Z
    24f4:	8c 32       	cpi	r24, 0x2C	; 44
    24f6:	a9 f5       	brne	.+106    	; 0x2562 <_Z11ReceiveBonev+0x6a2>
							tempNum1[dmy++] = atoi(tempStringNum);
    24f8:	ce 01       	movw	r24, r28
    24fa:	c7 96       	adiw	r24, 0x37	; 55
    24fc:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
    2500:	9c 01       	movw	r18, r24
    2502:	88 89       	ldd	r24, Y+16	; 0x10
    2504:	99 89       	ldd	r25, Y+17	; 0x11
    2506:	88 0f       	add	r24, r24
    2508:	99 1f       	adc	r25, r25
    250a:	ae 01       	movw	r20, r28
    250c:	4f 5f       	subi	r20, 0xFF	; 255
    250e:	5f 4f       	sbci	r21, 0xFF	; 255
    2510:	84 0f       	add	r24, r20
    2512:	95 1f       	adc	r25, r21
    2514:	c0 96       	adiw	r24, 0x30	; 48
    2516:	fc 01       	movw	r30, r24
    2518:	31 83       	std	Z+1, r19	; 0x01
    251a:	20 83       	st	Z, r18
    251c:	88 89       	ldd	r24, Y+16	; 0x10
    251e:	99 89       	ldd	r25, Y+17	; 0x11
    2520:	01 96       	adiw	r24, 0x01	; 1
    2522:	99 8b       	std	Y+17, r25	; 0x11
    2524:	88 8b       	std	Y+16, r24	; 0x10
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    2526:	1b 8e       	std	Y+27, r1	; 0x1b
    2528:	1a 8e       	std	Y+26, r1	; 0x1a
    252a:	0e c0       	rjmp	.+28     	; 0x2548 <_Z11ReceiveBonev+0x688>
    252c:	9e 01       	movw	r18, r28
    252e:	29 5c       	subi	r18, 0xC9	; 201
    2530:	3f 4f       	sbci	r19, 0xFF	; 255
    2532:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2534:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2536:	82 0f       	add	r24, r18
    2538:	93 1f       	adc	r25, r19
    253a:	fc 01       	movw	r30, r24
    253c:	10 82       	st	Z, r1
    253e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2540:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2542:	01 96       	adiw	r24, 0x01	; 1
    2544:	9b 8f       	std	Y+27, r25	; 0x1b
    2546:	8a 8f       	std	Y+26, r24	; 0x1a
    2548:	41 e0       	ldi	r20, 0x01	; 1
    254a:	2a 8d       	ldd	r18, Y+26	; 0x1a
    254c:	3b 8d       	ldd	r19, Y+27	; 0x1b
    254e:	8c 89       	ldd	r24, Y+20	; 0x14
    2550:	9d 89       	ldd	r25, Y+21	; 0x15
    2552:	82 17       	cp	r24, r18
    2554:	93 07       	cpc	r25, r19
    2556:	0c f4       	brge	.+2      	; 0x255a <_Z11ReceiveBonev+0x69a>
    2558:	40 e0       	ldi	r20, 0x00	; 0
    255a:	44 23       	and	r20, r20
    255c:	39 f7       	brne	.-50     	; 0x252c <_Z11ReceiveBonev+0x66c>
							placement=0;
    255e:	1d 8a       	std	Y+21, r1	; 0x15
    2560:	1c 8a       	std	Y+20, r1	; 0x14
						} else;
						counter++;							
    2562:	8e 85       	ldd	r24, Y+14	; 0x0e
    2564:	9f 85       	ldd	r25, Y+15	; 0x0f
    2566:	01 96       	adiw	r24, 0x01	; 1
    2568:	9f 87       	std	Y+15, r25	; 0x0f
    256a:	8e 87       	std	Y+14, r24	; 0x0e
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
					placement=0;
					counter++;	//get past the '/'
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    256c:	9e 01       	movw	r18, r28
    256e:	22 5c       	subi	r18, 0xC2	; 194
    2570:	3f 4f       	sbci	r19, 0xFF	; 255
    2572:	8e 85       	ldd	r24, Y+14	; 0x0e
    2574:	9f 85       	ldd	r25, Y+15	; 0x0f
    2576:	82 0f       	add	r24, r18
    2578:	93 1f       	adc	r25, r19
    257a:	fc 01       	movw	r30, r24
    257c:	80 81       	ld	r24, Z
    257e:	8e 32       	cpi	r24, 0x2E	; 46
    2580:	a9 f0       	breq	.+42     	; 0x25ac <_Z11ReceiveBonev+0x6ec>
    2582:	9e 01       	movw	r18, r28
    2584:	22 5c       	subi	r18, 0xC2	; 194
    2586:	3f 4f       	sbci	r19, 0xFF	; 255
    2588:	8e 85       	ldd	r24, Y+14	; 0x0e
    258a:	9f 85       	ldd	r25, Y+15	; 0x0f
    258c:	82 0f       	add	r24, r18
    258e:	93 1f       	adc	r25, r19
    2590:	fc 01       	movw	r30, r24
    2592:	80 81       	ld	r24, Z
    2594:	88 23       	and	r24, r24
    2596:	51 f0       	breq	.+20     	; 0x25ac <_Z11ReceiveBonev+0x6ec>
    2598:	8a 81       	ldd	r24, Y+2	; 0x02
    259a:	28 2f       	mov	r18, r24
    259c:	30 e0       	ldi	r19, 0x00	; 0
    259e:	8e 85       	ldd	r24, Y+14	; 0x0e
    25a0:	9f 85       	ldd	r25, Y+15	; 0x0f
    25a2:	28 17       	cp	r18, r24
    25a4:	39 07       	cpc	r19, r25
    25a6:	11 f0       	breq	.+4      	; 0x25ac <_Z11ReceiveBonev+0x6ec>
    25a8:	81 e0       	ldi	r24, 0x01	; 1
    25aa:	01 c0       	rjmp	.+2      	; 0x25ae <_Z11ReceiveBonev+0x6ee>
    25ac:	80 e0       	ldi	r24, 0x00	; 0
    25ae:	88 23       	and	r24, r24
    25b0:	09 f0       	breq	.+2      	; 0x25b4 <_Z11ReceiveBonev+0x6f4>
    25b2:	69 cf       	rjmp	.-302    	; 0x2486 <_Z11ReceiveBonev+0x5c6>
						} else;
						counter++;							
					}//end while
					
					//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
					if (recString[counter] == '.'){
    25b4:	9e 01       	movw	r18, r28
    25b6:	22 5c       	subi	r18, 0xC2	; 194
    25b8:	3f 4f       	sbci	r19, 0xFF	; 255
    25ba:	8e 85       	ldd	r24, Y+14	; 0x0e
    25bc:	9f 85       	ldd	r25, Y+15	; 0x0f
    25be:	82 0f       	add	r24, r18
    25c0:	93 1f       	adc	r25, r19
    25c2:	fc 01       	movw	r30, r24
    25c4:	80 81       	ld	r24, Z
    25c6:	8e 32       	cpi	r24, 0x2E	; 46
    25c8:	a9 f4       	brne	.+42     	; 0x25f4 <_Z11ReceiveBonev+0x734>
						tempNum1[dmy] = atoi(tempStringNum);
    25ca:	ce 01       	movw	r24, r28
    25cc:	c7 96       	adiw	r24, 0x37	; 55
    25ce:	0e 94 d7 1c 	call	0x39ae	; 0x39ae <atoi>
    25d2:	9c 01       	movw	r18, r24
    25d4:	88 89       	ldd	r24, Y+16	; 0x10
    25d6:	99 89       	ldd	r25, Y+17	; 0x11
    25d8:	88 0f       	add	r24, r24
    25da:	99 1f       	adc	r25, r25
    25dc:	ae 01       	movw	r20, r28
    25de:	4f 5f       	subi	r20, 0xFF	; 255
    25e0:	5f 4f       	sbci	r21, 0xFF	; 255
    25e2:	84 0f       	add	r24, r20
    25e4:	95 1f       	adc	r25, r21
    25e6:	c0 96       	adiw	r24, 0x30	; 48
    25e8:	fc 01       	movw	r30, r24
    25ea:	31 83       	std	Z+1, r19	; 0x01
    25ec:	20 83       	st	Z, r18
						successDate=fTrue;
    25ee:	81 e0       	ldi	r24, 0x01	; 1
    25f0:	8d 87       	std	Y+13, r24	; 0x0d
    25f2:	02 c0       	rjmp	.+4      	; 0x25f8 <_Z11ReceiveBonev+0x738>
					} else {//something in the string was wrong, ACKBAD and then exit
						state=4;
    25f4:	84 e0       	ldi	r24, 0x04	; 4
    25f6:	89 83       	std	Y+1, r24	; 0x01
					}	
					
					//NOw set the time and date, then save it to EEPROM
					if (successDate && successTime){
    25f8:	8d 85       	ldd	r24, Y+13	; 0x0d
    25fa:	88 23       	and	r24, r24
    25fc:	19 f1       	breq	.+70     	; 0x2644 <_Z11ReceiveBonev+0x784>
    25fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    2600:	88 23       	and	r24, r24
    2602:	01 f1       	breq	.+64     	; 0x2644 <_Z11ReceiveBonev+0x784>
						currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    2604:	69 a9       	sts	0x49, r22
    2606:	7a a9       	sts	0x4a, r23
    2608:	4b a9       	sts	0x4b, r20
    260a:	5c a9       	sts	0x4c, r21
    260c:	2d a9       	sts	0x4d, r18
    260e:	3e a9       	sts	0x4e, r19
    2610:	82 ee       	ldi	r24, 0xE2	; 226
    2612:	91 e0       	ldi	r25, 0x01	; 1
    2614:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
						currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    2618:	6b a5       	lds	r22, 0x6b
    261a:	7c a5       	lds	r23, 0x6c
    261c:	4d a5       	lds	r20, 0x6d
    261e:	5e a5       	lds	r21, 0x6e
    2620:	2f a5       	lds	r18, 0x6f
    2622:	38 a9       	sts	0x48, r19
    2624:	82 ee       	ldi	r24, 0xE2	; 226
    2626:	91 e0       	ldi	r25, 0x01	; 1
    2628:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
						saveDateTime_eeprom(fTrue,fTrue);
    262c:	81 e0       	ldi	r24, 0x01	; 1
    262e:	61 e0       	ldi	r22, 0x01	; 1
    2630:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    2634:	81 e0       	ldi	r24, 0x01	; 1
    2636:	80 93 11 02 	sts	0x0211, r24
						//Make sure UserClock flags are down
						flagUserClock=fFalse;
    263a:	10 92 13 02 	sts	0x0213, r1
						state=3;	//Graceful exit
    263e:	83 e0       	ldi	r24, 0x03	; 3
    2640:	89 83       	std	Y+1, r24	; 0x01
    2642:	3b c0       	rjmp	.+118    	; 0x26ba <_Z11ReceiveBonev+0x7fa>
						
					} else if (!(successDate && successTime) && restart){
    2644:	8d 85       	ldd	r24, Y+13	; 0x0d
    2646:	88 23       	and	r24, r24
    2648:	19 f0       	breq	.+6      	; 0x2650 <_Z11ReceiveBonev+0x790>
    264a:	8c 85       	ldd	r24, Y+12	; 0x0c
    264c:	88 23       	and	r24, r24
    264e:	61 f4       	brne	.+24     	; 0x2668 <_Z11ReceiveBonev+0x7a8>
    2650:	80 91 1b 02 	lds	r24, 0x021B
    2654:	88 23       	and	r24, r24
    2656:	41 f0       	breq	.+16     	; 0x2668 <_Z11ReceiveBonev+0x7a8>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    2658:	81 e0       	ldi	r24, 0x01	; 1
    265a:	80 93 11 02 	sts	0x0211, r24
						flagUserClock=fFalse;
    265e:	10 92 13 02 	sts	0x0213, r1
						state=4;	//ACKBAD
    2662:	84 e0       	ldi	r24, 0x04	; 4
    2664:	89 83       	std	Y+1, r24	; 0x01
    2666:	29 c0       	rjmp	.+82     	; 0x26ba <_Z11ReceiveBonev+0x7fa>
					} else if (!(successDate && successTime) && flagFreshStart && !restart){
    2668:	8d 85       	ldd	r24, Y+13	; 0x0d
    266a:	88 23       	and	r24, r24
    266c:	19 f0       	breq	.+6      	; 0x2674 <_Z11ReceiveBonev+0x7b4>
    266e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2670:	88 23       	and	r24, r24
    2672:	81 f4       	brne	.+32     	; 0x2694 <_Z11ReceiveBonev+0x7d4>
    2674:	80 91 1c 02 	lds	r24, 0x021C
    2678:	88 23       	and	r24, r24
    267a:	61 f0       	breq	.+24     	; 0x2694 <_Z11ReceiveBonev+0x7d4>
    267c:	80 91 1b 02 	lds	r24, 0x021B
    2680:	88 23       	and	r24, r24
    2682:	41 f4       	brne	.+16     	; 0x2694 <_Z11ReceiveBonev+0x7d4>
						flagUserClock=fTrue;
    2684:	81 e0       	ldi	r24, 0x01	; 1
    2686:	80 93 13 02 	sts	0x0213, r24
						flagUpdateGAVRClock=fFalse;
    268a:	10 92 11 02 	sts	0x0211, r1
						state=4;	//ACKBAD
    268e:	84 e0       	ldi	r24, 0x04	; 4
    2690:	89 83       	std	Y+1, r24	; 0x01
    2692:	13 c0       	rjmp	.+38     	; 0x26ba <_Z11ReceiveBonev+0x7fa>
					} else if (!(successDate && successTime) && !flagFreshStart && !restart){state=4;}	//Don't change the flags, keep them the correct way
    2694:	8d 85       	ldd	r24, Y+13	; 0x0d
    2696:	88 23       	and	r24, r24
    2698:	19 f0       	breq	.+6      	; 0x26a0 <_Z11ReceiveBonev+0x7e0>
    269a:	8c 85       	ldd	r24, Y+12	; 0x0c
    269c:	88 23       	and	r24, r24
    269e:	59 f4       	brne	.+22     	; 0x26b6 <_Z11ReceiveBonev+0x7f6>
    26a0:	80 91 1c 02 	lds	r24, 0x021C
    26a4:	88 23       	and	r24, r24
    26a6:	39 f4       	brne	.+14     	; 0x26b6 <_Z11ReceiveBonev+0x7f6>
    26a8:	80 91 1b 02 	lds	r24, 0x021B
    26ac:	88 23       	and	r24, r24
    26ae:	19 f4       	brne	.+6      	; 0x26b6 <_Z11ReceiveBonev+0x7f6>
    26b0:	84 e0       	ldi	r24, 0x04	; 4
    26b2:	89 83       	std	Y+1, r24	; 0x01
    26b4:	02 c0       	rjmp	.+4      	; 0x26ba <_Z11ReceiveBonev+0x7fa>
					else {state=4;}
    26b6:	84 e0       	ldi	r24, 0x04	; 4
    26b8:	89 83       	std	Y+1, r24	; 0x01
					//Lower restart flags. Should have parallel case in timer just in case this state doesn't happen.
					flagFreshStart=fFalse;
    26ba:	10 92 1c 02 	sts	0x021C, r1
					restart=fFalse;	
    26be:	10 92 1b 02 	sts	0x021B, r1
					break;
    26c2:	04 c0       	rjmp	.+8      	; 0x26cc <_Z11ReceiveBonev+0x80c>
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
    26c4:	10 92 0b 02 	sts	0x020B, r1
    26c8:	19 82       	std	Y+1, r1	; 0x01
    26ca:	00 00       	nop
/*************************************************************************************************************/
void ReceiveBone(){
	BYTE state=0,strLoc=0;
	char recChar, recString[40];
	BOOL noCarriage=fTrue;
	while (flagReceivingBone){
    26cc:	90 91 0b 02 	lds	r25, 0x020B
    26d0:	81 e0       	ldi	r24, 0x01	; 1
    26d2:	99 23       	and	r25, r25
    26d4:	09 f4       	brne	.+2      	; 0x26d8 <_Z11ReceiveBonev+0x818>
    26d6:	80 e0       	ldi	r24, 0x00	; 0
    26d8:	88 23       	and	r24, r24
    26da:	09 f0       	breq	.+2      	; 0x26de <_Z11ReceiveBonev+0x81e>
    26dc:	01 cc       	rjmp	.-2046   	; 0x1ee0 <_Z11ReceiveBonev+0x20>
					break;
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
			}//end switch
	}//end while(flagUARTbone)	
}//end ReceiveBone()
    26de:	cb 59       	subi	r28, 0x9B	; 155
    26e0:	df 4f       	sbci	r29, 0xFF	; 255
    26e2:	0f b6       	in	r0, 0x3f	; 63
    26e4:	f8 94       	cli
    26e6:	de bf       	out	0x3e, r29	; 62
    26e8:	0f be       	out	0x3f, r0	; 63
    26ea:	cd bf       	out	0x3d, r28	; 61
    26ec:	df 91       	pop	r29
    26ee:	cf 91       	pop	r28
    26f0:	08 95       	ret

000026f2 <_Z13printTimeDatehhh>:

/*************************************************************************************************************/
//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    26f2:	cf 93       	push	r28
    26f4:	df 93       	push	r29
    26f6:	cd b7       	in	r28, 0x3d	; 61
    26f8:	de b7       	in	r29, 0x3e	; 62
    26fa:	eb 97       	sbiw	r28, 0x3b	; 59
    26fc:	0f b6       	in	r0, 0x3f	; 63
    26fe:	f8 94       	cli
    2700:	de bf       	out	0x3e, r29	; 62
    2702:	0f be       	out	0x3f, r0	; 63
    2704:	cd bf       	out	0x3d, r28	; 61
    2706:	89 af       	sts	0x79, r24
    2708:	6a af       	sts	0x7a, r22
    270a:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    270c:	89 ad       	sts	0x69, r24
    270e:	88 23       	and	r24, r24
    2710:	49 f1       	breq	.+82     	; 0x2764 <_Z13printTimeDatehhh+0x72>
		if (pTime){
    2712:	8a ad       	sts	0x6a, r24
    2714:	88 23       	and	r24, r24
    2716:	89 f0       	breq	.+34     	; 0x273a <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    2718:	82 ee       	ldi	r24, 0xE2	; 226
    271a:	91 e0       	ldi	r25, 0x01	; 1
    271c:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    2720:	9c 01       	movw	r18, r24
    2722:	ce 01       	movw	r24, r28
    2724:	01 96       	adiw	r24, 0x01	; 1
    2726:	b9 01       	movw	r22, r18
    2728:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <strcpy>
			PrintBone(tempTime);
    272c:	ce 01       	movw	r24, r28
    272e:	01 96       	adiw	r24, 0x01	; 1
    2730:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
			PutUartChBone('/');
    2734:	8f e2       	ldi	r24, 0x2F	; 47
    2736:	0e 94 2e 09 	call	0x125c	; 0x125c <_Z13PutUartChBonec>
		}
		if (pDate){
    273a:	8b ad       	sts	0x6b, r24
    273c:	88 23       	and	r24, r24
    273e:	d1 f1       	breq	.+116    	; 0x27b4 <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    2740:	82 ee       	ldi	r24, 0xE2	; 226
    2742:	91 e0       	ldi	r25, 0x01	; 1
    2744:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    2748:	9c 01       	movw	r18, r24
    274a:	ce 01       	movw	r24, r28
    274c:	0c 96       	adiw	r24, 0x0c	; 12
    274e:	b9 01       	movw	r22, r18
    2750:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <strcpy>
			PrintBone(tempDate);
    2754:	ce 01       	movw	r24, r28
    2756:	0c 96       	adiw	r24, 0x0c	; 12
    2758:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
			PutUartChGAVR('.');
    275c:	8e e2       	ldi	r24, 0x2E	; 46
    275e:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
    2762:	28 c0       	rjmp	.+80     	; 0x27b4 <_Z13printTimeDatehhh+0xc2>
		}
	} else { //Printing to GAVR
		if (pTime){
    2764:	8a ad       	sts	0x6a, r24
    2766:	88 23       	and	r24, r24
    2768:	89 f0       	breq	.+34     	; 0x278c <_Z13printTimeDatehhh+0x9a>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    276a:	82 ee       	ldi	r24, 0xE2	; 226
    276c:	91 e0       	ldi	r25, 0x01	; 1
    276e:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    2772:	9c 01       	movw	r18, r24
    2774:	ce 01       	movw	r24, r28
    2776:	4d 96       	adiw	r24, 0x1d	; 29
    2778:	b9 01       	movw	r22, r18
    277a:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <strcpy>
			PrintGAVR(tempTime);
    277e:	ce 01       	movw	r24, r28
    2780:	4d 96       	adiw	r24, 0x1d	; 29
    2782:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    2786:	8f e2       	ldi	r24, 0x2F	; 47
    2788:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
		}
		if (pDate){
    278c:	8b ad       	sts	0x6b, r24
    278e:	88 23       	and	r24, r24
    2790:	89 f0       	breq	.+34     	; 0x27b4 <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    2792:	82 ee       	ldi	r24, 0xE2	; 226
    2794:	91 e0       	ldi	r25, 0x01	; 1
    2796:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    279a:	9c 01       	movw	r18, r24
    279c:	ce 01       	movw	r24, r28
    279e:	88 96       	adiw	r24, 0x28	; 40
    27a0:	b9 01       	movw	r22, r18
    27a2:	0e 94 09 1d 	call	0x3a12	; 0x3a12 <strcpy>
			PrintGAVR(tempDate);
    27a6:	ce 01       	movw	r24, r28
    27a8:	88 96       	adiw	r24, 0x28	; 40
    27aa:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
			PutUartChGAVR('.');
    27ae:	8e e2       	ldi	r24, 0x2E	; 46
    27b0:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
		}
	}
}
    27b4:	eb 96       	adiw	r28, 0x3b	; 59
    27b6:	0f b6       	in	r0, 0x3f	; 63
    27b8:	f8 94       	cli
    27ba:	de bf       	out	0x3e, r29	; 62
    27bc:	0f be       	out	0x3f, r0	; 63
    27be:	cd bf       	out	0x3d, r28	; 61
    27c0:	df 91       	pop	r29
    27c2:	cf 91       	pop	r28
    27c4:	08 95       	ret

000027c6 <__vector_6>:
/****************************************************************************************************************/


/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
//PCINT_17: Getting information from the GAVR
ISR(PCINT2_vect){
    27c6:	1f 92       	push	r1
    27c8:	0f 92       	push	r0
    27ca:	0f b6       	in	r0, 0x3f	; 63
    27cc:	0f 92       	push	r0
    27ce:	11 24       	eor	r1, r1
    27d0:	2f 93       	push	r18
    27d2:	3f 93       	push	r19
    27d4:	4f 93       	push	r20
    27d6:	5f 93       	push	r21
    27d8:	6f 93       	push	r22
    27da:	7f 93       	push	r23
    27dc:	8f 93       	push	r24
    27de:	9f 93       	push	r25
    27e0:	af 93       	push	r26
    27e2:	bf 93       	push	r27
    27e4:	ef 93       	push	r30
    27e6:	ff 93       	push	r31
    27e8:	cf 93       	push	r28
    27ea:	df 93       	push	r29
    27ec:	cd b7       	in	r28, 0x3d	; 61
    27ee:	de b7       	in	r29, 0x3e	; 62
	cli();
    27f0:	f8 94       	cli
	if (PINC & (1 << PCINT17)){
    27f2:	86 e2       	ldi	r24, 0x26	; 38
    27f4:	90 e0       	ldi	r25, 0x00	; 0
    27f6:	fc 01       	movw	r30, r24
    27f8:	80 81       	ld	r24, Z
    27fa:	88 2f       	mov	r24, r24
    27fc:	90 e0       	ldi	r25, 0x00	; 0
    27fe:	82 70       	andi	r24, 0x02	; 2
    2800:	90 70       	andi	r25, 0x00	; 0
    2802:	21 e0       	ldi	r18, 0x01	; 1
    2804:	00 97       	sbiw	r24, 0x00	; 0
    2806:	09 f4       	brne	.+2      	; 0x280a <__vector_6+0x44>
    2808:	20 e0       	ldi	r18, 0x00	; 0
    280a:	22 23       	and	r18, r18
    280c:	e1 f0       	breq	.+56     	; 0x2846 <__vector_6+0x80>
		__killCommINT();
    280e:	8d e3       	ldi	r24, 0x3D	; 61
    2810:	90 e0       	ldi	r25, 0x00	; 0
    2812:	fc 01       	movw	r30, r24
    2814:	10 82       	st	Z, r1
    2816:	8d e6       	ldi	r24, 0x6D	; 109
    2818:	90 e0       	ldi	r25, 0x00	; 0
    281a:	fc 01       	movw	r30, r24
    281c:	10 82       	st	Z, r1
		//Do work, correct interrupt
		UCSR1B |= (1 << RXCIE1);
    281e:	89 ec       	ldi	r24, 0xC9	; 201
    2820:	90 e0       	ldi	r25, 0x00	; 0
    2822:	29 ec       	ldi	r18, 0xC9	; 201
    2824:	30 e0       	ldi	r19, 0x00	; 0
    2826:	f9 01       	movw	r30, r18
    2828:	20 81       	ld	r18, Z
    282a:	20 68       	ori	r18, 0x80	; 128
    282c:	fc 01       	movw	r30, r24
    282e:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;
    2830:	10 92 0a 02 	sts	0x020A, r1
		flagNormalMode=fFalse;
    2834:	10 92 0c 02 	sts	0x020C, r1
		flagWaitingForSYNGAVR=fTrue;
    2838:	81 e0       	ldi	r24, 0x01	; 1
    283a:	80 93 0f 02 	sts	0x020F, r24
		//Acknowledge
		PrintGAVR("A.");
    283e:	8c e0       	ldi	r24, 0x0C	; 12
    2840:	91 e0       	ldi	r25, 0x01	; 1
    2842:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
	}
	sei();
    2846:	78 94       	sei
}	
    2848:	df 91       	pop	r29
    284a:	cf 91       	pop	r28
    284c:	ff 91       	pop	r31
    284e:	ef 91       	pop	r30
    2850:	bf 91       	pop	r27
    2852:	af 91       	pop	r26
    2854:	9f 91       	pop	r25
    2856:	8f 91       	pop	r24
    2858:	7f 91       	pop	r23
    285a:	6f 91       	pop	r22
    285c:	5f 91       	pop	r21
    285e:	4f 91       	pop	r20
    2860:	3f 91       	pop	r19
    2862:	2f 91       	pop	r18
    2864:	0f 90       	pop	r0
    2866:	0f be       	out	0x3f, r0	; 63
    2868:	0f 90       	pop	r0
    286a:	1f 90       	pop	r1
    286c:	18 95       	reti

0000286e <__vector_3>:
/********************************************************/
//INT2: Getting information from BeagleBone
ISR(INT2_vect){	//about to get time, get things ready
    286e:	1f 92       	push	r1
    2870:	0f 92       	push	r0
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	0f 92       	push	r0
    2876:	11 24       	eor	r1, r1
    2878:	2f 93       	push	r18
    287a:	3f 93       	push	r19
    287c:	4f 93       	push	r20
    287e:	5f 93       	push	r21
    2880:	6f 93       	push	r22
    2882:	7f 93       	push	r23
    2884:	8f 93       	push	r24
    2886:	9f 93       	push	r25
    2888:	af 93       	push	r26
    288a:	bf 93       	push	r27
    288c:	ef 93       	push	r30
    288e:	ff 93       	push	r31
    2890:	cf 93       	push	r28
    2892:	df 93       	push	r29
    2894:	cd b7       	in	r28, 0x3d	; 61
    2896:	de b7       	in	r29, 0x3e	; 62
	cli();
    2898:	f8 94       	cli
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    289a:	80 91 18 02 	lds	r24, 0x0218
    289e:	88 23       	and	r24, r24
    28a0:	e1 f4       	brne	.+56     	; 0x28da <__vector_3+0x6c>
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    28a2:	10 92 0a 02 	sts	0x020A, r1
		flagNormalMode=fFalse;
    28a6:	10 92 0c 02 	sts	0x020C, r1
		flagWaitingForSYNBone=fTrue;
    28aa:	81 e0       	ldi	r24, 0x01	; 1
    28ac:	80 93 10 02 	sts	0x0210, r24
		__killCommINT();
    28b0:	8d e3       	ldi	r24, 0x3D	; 61
    28b2:	90 e0       	ldi	r25, 0x00	; 0
    28b4:	fc 01       	movw	r30, r24
    28b6:	10 82       	st	Z, r1
    28b8:	8d e6       	ldi	r24, 0x6D	; 109
    28ba:	90 e0       	ldi	r25, 0x00	; 0
    28bc:	fc 01       	movw	r30, r24
    28be:	10 82       	st	Z, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("A.");
    28c0:	8c e0       	ldi	r24, 0x0C	; 12
    28c2:	91 e0       	ldi	r25, 0x01	; 1
    28c4:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
		UCSR0B |= (1 << RXCIE0);
    28c8:	81 ec       	ldi	r24, 0xC1	; 193
    28ca:	90 e0       	ldi	r25, 0x00	; 0
    28cc:	21 ec       	ldi	r18, 0xC1	; 193
    28ce:	30 e0       	ldi	r19, 0x00	; 0
    28d0:	f9 01       	movw	r30, r18
    28d2:	20 81       	ld	r18, Z
    28d4:	20 68       	ori	r18, 0x80	; 128
    28d6:	fc 01       	movw	r30, r24
    28d8:	20 83       	st	Z, r18
	}
	sei();
    28da:	78 94       	sei
}
    28dc:	df 91       	pop	r29
    28de:	cf 91       	pop	r28
    28e0:	ff 91       	pop	r31
    28e2:	ef 91       	pop	r30
    28e4:	bf 91       	pop	r27
    28e6:	af 91       	pop	r26
    28e8:	9f 91       	pop	r25
    28ea:	8f 91       	pop	r24
    28ec:	7f 91       	pop	r23
    28ee:	6f 91       	pop	r22
    28f0:	5f 91       	pop	r21
    28f2:	4f 91       	pop	r20
    28f4:	3f 91       	pop	r19
    28f6:	2f 91       	pop	r18
    28f8:	0f 90       	pop	r0
    28fa:	0f be       	out	0x3f, r0	; 63
    28fc:	0f 90       	pop	r0
    28fe:	1f 90       	pop	r1
    2900:	18 95       	reti

00002902 <__vector_20>:
/********************************************************/
//UART Receive from BeagleBone
ISR(USART0_RX_vect){
    2902:	1f 92       	push	r1
    2904:	0f 92       	push	r0
    2906:	0f b6       	in	r0, 0x3f	; 63
    2908:	0f 92       	push	r0
    290a:	11 24       	eor	r1, r1
    290c:	2f 93       	push	r18
    290e:	3f 93       	push	r19
    2910:	8f 93       	push	r24
    2912:	9f 93       	push	r25
    2914:	ef 93       	push	r30
    2916:	ff 93       	push	r31
    2918:	cf 93       	push	r28
    291a:	df 93       	push	r29
    291c:	cd b7       	in	r28, 0x3d	; 61
    291e:	de b7       	in	r29, 0x3e	; 62
	cli();
    2920:	f8 94       	cli
	if (flagWaitingForSYNBone){
    2922:	80 91 10 02 	lds	r24, 0x0210
    2926:	88 23       	and	r24, r24
    2928:	31 f0       	breq	.+12     	; 0x2936 <__vector_20+0x34>
		flagReceivingBone=fTrue;
    292a:	81 e0       	ldi	r24, 0x01	; 1
    292c:	80 93 0b 02 	sts	0x020B, r24
		flagWaitingForSYNBone=fFalse;
    2930:	10 92 10 02 	sts	0x0210, r1
    2934:	02 c0       	rjmp	.+4      	; 0x293a <__vector_20+0x38>
	} else {
		flagReceivingBone=fFalse;		//there was a timeout between the initial interrupt and when we are getting this.
    2936:	10 92 0b 02 	sts	0x020B, r1
	}	
	UCSR0B &= ~(1 << RXCIE0);
    293a:	81 ec       	ldi	r24, 0xC1	; 193
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	21 ec       	ldi	r18, 0xC1	; 193
    2940:	30 e0       	ldi	r19, 0x00	; 0
    2942:	f9 01       	movw	r30, r18
    2944:	20 81       	ld	r18, Z
    2946:	2f 77       	andi	r18, 0x7F	; 127
    2948:	fc 01       	movw	r30, r24
    294a:	20 83       	st	Z, r18
	sei();
    294c:	78 94       	sei
}
    294e:	df 91       	pop	r29
    2950:	cf 91       	pop	r28
    2952:	ff 91       	pop	r31
    2954:	ef 91       	pop	r30
    2956:	9f 91       	pop	r25
    2958:	8f 91       	pop	r24
    295a:	3f 91       	pop	r19
    295c:	2f 91       	pop	r18
    295e:	0f 90       	pop	r0
    2960:	0f be       	out	0x3f, r0	; 63
    2962:	0f 90       	pop	r0
    2964:	1f 90       	pop	r1
    2966:	18 95       	reti

00002968 <__vector_28>:
/********************************************************/
ISR(USART1_RX_vect){
    2968:	1f 92       	push	r1
    296a:	0f 92       	push	r0
    296c:	0f b6       	in	r0, 0x3f	; 63
    296e:	0f 92       	push	r0
    2970:	11 24       	eor	r1, r1
    2972:	2f 93       	push	r18
    2974:	3f 93       	push	r19
    2976:	8f 93       	push	r24
    2978:	9f 93       	push	r25
    297a:	ef 93       	push	r30
    297c:	ff 93       	push	r31
    297e:	cf 93       	push	r28
    2980:	df 93       	push	r29
    2982:	cd b7       	in	r28, 0x3d	; 61
    2984:	de b7       	in	r29, 0x3e	; 62
	cli();
    2986:	f8 94       	cli
	if (flagWaitingForSYNGAVR){
    2988:	80 91 0f 02 	lds	r24, 0x020F
    298c:	88 23       	and	r24, r24
    298e:	31 f0       	breq	.+12     	; 0x299c <__vector_28+0x34>
		flagReceivingGAVR=fTrue;
    2990:	81 e0       	ldi	r24, 0x01	; 1
    2992:	80 93 0d 02 	sts	0x020D, r24
		flagWaitingForSYNGAVR=fFalse;
    2996:	10 92 0f 02 	sts	0x020F, r1
    299a:	02 c0       	rjmp	.+4      	; 0x29a0 <__vector_28+0x38>
	}else {
		flagReceivingGAVR=fFalse;
    299c:	10 92 0d 02 	sts	0x020D, r1
	}
	UCSR1B &= ~(1 <<RXCIE1);	//disable interrupt
    29a0:	89 ec       	ldi	r24, 0xC9	; 201
    29a2:	90 e0       	ldi	r25, 0x00	; 0
    29a4:	29 ec       	ldi	r18, 0xC9	; 201
    29a6:	30 e0       	ldi	r19, 0x00	; 0
    29a8:	f9 01       	movw	r30, r18
    29aa:	20 81       	ld	r18, Z
    29ac:	2f 77       	andi	r18, 0x7F	; 127
    29ae:	fc 01       	movw	r30, r24
    29b0:	20 83       	st	Z, r18
	sei();
    29b2:	78 94       	sei
}
    29b4:	df 91       	pop	r29
    29b6:	cf 91       	pop	r28
    29b8:	ff 91       	pop	r31
    29ba:	ef 91       	pop	r30
    29bc:	9f 91       	pop	r25
    29be:	8f 91       	pop	r24
    29c0:	3f 91       	pop	r19
    29c2:	2f 91       	pop	r18
    29c4:	0f 90       	pop	r0
    29c6:	0f be       	out	0x3f, r0	; 63
    29c8:	0f 90       	pop	r0
    29ca:	1f 90       	pop	r1
    29cc:	18 95       	reti

000029ce <__vector_11>:

/********************************************************/
//RTC Timer.
ISR(TIMER2_OVF_vect){
    29ce:	1f 92       	push	r1
    29d0:	0f 92       	push	r0
    29d2:	0f b6       	in	r0, 0x3f	; 63
    29d4:	0f 92       	push	r0
    29d6:	11 24       	eor	r1, r1
    29d8:	2f 93       	push	r18
    29da:	3f 93       	push	r19
    29dc:	4f 93       	push	r20
    29de:	5f 93       	push	r21
    29e0:	6f 93       	push	r22
    29e2:	7f 93       	push	r23
    29e4:	8f 93       	push	r24
    29e6:	9f 93       	push	r25
    29e8:	af 93       	push	r26
    29ea:	bf 93       	push	r27
    29ec:	ef 93       	push	r30
    29ee:	ff 93       	push	r31
    29f0:	cf 93       	push	r28
    29f2:	df 93       	push	r29
    29f4:	cd b7       	in	r28, 0x3d	; 61
    29f6:	de b7       	in	r29, 0x3e	; 62
	cli();
    29f8:	f8 94       	cli
	prtSLEEPled ^= (1 << bnSLEEPled);
    29fa:	8b e2       	ldi	r24, 0x2B	; 43
    29fc:	90 e0       	ldi	r25, 0x00	; 0
    29fe:	2b e2       	ldi	r18, 0x2B	; 43
    2a00:	30 e0       	ldi	r19, 0x00	; 0
    2a02:	f9 01       	movw	r30, r18
    2a04:	30 81       	ld	r19, Z
    2a06:	20 e8       	ldi	r18, 0x80	; 128
    2a08:	23 27       	eor	r18, r19
    2a0a:	fc 01       	movw	r30, r24
    2a0c:	20 83       	st	Z, r18
	static unsigned int gavrSendTimeout=0, boneReceiveTimeout=0, gavrReceiveTimeout=0, startupTimeout=0;
	
	currentTime.addSeconds(1);
    2a0e:	82 ee       	ldi	r24, 0xE2	; 226
    2a10:	91 e0       	ldi	r25, 0x01	; 1
    2a12:	61 e0       	ldi	r22, 0x01	; 1
    2a14:	70 e0       	ldi	r23, 0x00	; 0
    2a16:	0e 94 72 06 	call	0xce4	; 0xce4 <_ZN6myTime10addSecondsEi>
	
	//GAVR Transmission Timeout
	if (flagSendingGAVR && gavrSendTimeout <=COMM_TIMEOUT_SEC){gavrSendTimeout++;}
    2a1a:	80 91 12 02 	lds	r24, 0x0212
    2a1e:	88 23       	and	r24, r24
    2a20:	89 f0       	breq	.+34     	; 0x2a44 <__vector_11+0x76>
    2a22:	80 91 1d 02 	lds	r24, 0x021D
    2a26:	90 91 1e 02 	lds	r25, 0x021E
    2a2a:	89 30       	cpi	r24, 0x09	; 9
    2a2c:	91 05       	cpc	r25, r1
    2a2e:	50 f4       	brcc	.+20     	; 0x2a44 <__vector_11+0x76>
    2a30:	80 91 1d 02 	lds	r24, 0x021D
    2a34:	90 91 1e 02 	lds	r25, 0x021E
    2a38:	01 96       	adiw	r24, 0x01	; 1
    2a3a:	90 93 1e 02 	sts	0x021E, r25
    2a3e:	80 93 1d 02 	sts	0x021D, r24
    2a42:	43 c0       	rjmp	.+134    	; 0x2aca <__vector_11+0xfc>
	else if (flagSendingGAVR && gavrSendTimeout > COMM_TIMEOUT_SEC){__killUARTrec();flagSendingGAVR=fFalse;flagGoToSleep=fTrue; gavrSendTimeout=0; __enableCommINT();}
    2a44:	80 91 12 02 	lds	r24, 0x0212
    2a48:	88 23       	and	r24, r24
    2a4a:	89 f1       	breq	.+98     	; 0x2aae <__vector_11+0xe0>
    2a4c:	80 91 1d 02 	lds	r24, 0x021D
    2a50:	90 91 1e 02 	lds	r25, 0x021E
    2a54:	89 30       	cpi	r24, 0x09	; 9
    2a56:	91 05       	cpc	r25, r1
    2a58:	50 f1       	brcs	.+84     	; 0x2aae <__vector_11+0xe0>
    2a5a:	81 ec       	ldi	r24, 0xC1	; 193
    2a5c:	90 e0       	ldi	r25, 0x00	; 0
    2a5e:	21 ec       	ldi	r18, 0xC1	; 193
    2a60:	30 e0       	ldi	r19, 0x00	; 0
    2a62:	f9 01       	movw	r30, r18
    2a64:	20 81       	ld	r18, Z
    2a66:	20 68       	ori	r18, 0x80	; 128
    2a68:	fc 01       	movw	r30, r24
    2a6a:	20 83       	st	Z, r18
    2a6c:	89 ec       	ldi	r24, 0xC9	; 201
    2a6e:	90 e0       	ldi	r25, 0x00	; 0
    2a70:	29 ec       	ldi	r18, 0xC9	; 201
    2a72:	30 e0       	ldi	r19, 0x00	; 0
    2a74:	f9 01       	movw	r30, r18
    2a76:	20 81       	ld	r18, Z
    2a78:	20 68       	ori	r18, 0x80	; 128
    2a7a:	fc 01       	movw	r30, r24
    2a7c:	20 83       	st	Z, r18
    2a7e:	10 92 12 02 	sts	0x0212, r1
    2a82:	81 e0       	ldi	r24, 0x01	; 1
    2a84:	80 93 0a 02 	sts	0x020A, r24
    2a88:	10 92 1e 02 	sts	0x021E, r1
    2a8c:	10 92 1d 02 	sts	0x021D, r1
    2a90:	8d e3       	ldi	r24, 0x3D	; 61
    2a92:	90 e0       	ldi	r25, 0x00	; 0
    2a94:	2d e3       	ldi	r18, 0x3D	; 61
    2a96:	30 e0       	ldi	r19, 0x00	; 0
    2a98:	f9 01       	movw	r30, r18
    2a9a:	20 81       	ld	r18, Z
    2a9c:	24 60       	ori	r18, 0x04	; 4
    2a9e:	fc 01       	movw	r30, r24
    2aa0:	20 83       	st	Z, r18
    2aa2:	8d e6       	ldi	r24, 0x6D	; 109
    2aa4:	90 e0       	ldi	r25, 0x00	; 0
    2aa6:	22 e0       	ldi	r18, 0x02	; 2
    2aa8:	fc 01       	movw	r30, r24
    2aaa:	20 83       	st	Z, r18
    2aac:	0e c0       	rjmp	.+28     	; 0x2aca <__vector_11+0xfc>
	else if (!flagSendingGAVR && gavrSendTimeout > 0){gavrSendTimeout=0;}
    2aae:	80 91 12 02 	lds	r24, 0x0212
    2ab2:	88 23       	and	r24, r24
    2ab4:	51 f4       	brne	.+20     	; 0x2aca <__vector_11+0xfc>
    2ab6:	80 91 1d 02 	lds	r24, 0x021D
    2aba:	90 91 1e 02 	lds	r25, 0x021E
    2abe:	00 97       	sbiw	r24, 0x00	; 0
    2ac0:	21 f0       	breq	.+8      	; 0x2aca <__vector_11+0xfc>
    2ac2:	10 92 1e 02 	sts	0x021E, r1
    2ac6:	10 92 1d 02 	sts	0x021D, r1
	else;
	
	//BeagleBone Reception Timeout
	if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout <=COMM_TIMEOUT_SEC)){boneReceiveTimeout++;}
    2aca:	80 91 0b 02 	lds	r24, 0x020B
    2ace:	88 23       	and	r24, r24
    2ad0:	21 f4       	brne	.+8      	; 0x2ada <__vector_11+0x10c>
    2ad2:	80 91 10 02 	lds	r24, 0x0210
    2ad6:	88 23       	and	r24, r24
    2ad8:	89 f0       	breq	.+34     	; 0x2afc <__vector_11+0x12e>
    2ada:	80 91 1f 02 	lds	r24, 0x021F
    2ade:	90 91 20 02 	lds	r25, 0x0220
    2ae2:	89 30       	cpi	r24, 0x09	; 9
    2ae4:	91 05       	cpc	r25, r1
    2ae6:	50 f4       	brcc	.+20     	; 0x2afc <__vector_11+0x12e>
    2ae8:	80 91 1f 02 	lds	r24, 0x021F
    2aec:	90 91 20 02 	lds	r25, 0x0220
    2af0:	01 96       	adiw	r24, 0x01	; 1
    2af2:	90 93 20 02 	sts	0x0220, r25
    2af6:	80 93 1f 02 	sts	0x021F, r24
    2afa:	50 c0       	rjmp	.+160    	; 0x2b9c <__vector_11+0x1ce>
	else if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout > COMM_TIMEOUT_SEC)){__killUARTrec();flagReceivingBone=fFalse; flagWaitingForSYNBone=fFalse;flagGoToSleep=fTrue; flagNormalMode=fTrue; boneReceiveTimeout=0; __enableCommINT();}
    2afc:	80 91 0b 02 	lds	r24, 0x020B
    2b00:	88 23       	and	r24, r24
    2b02:	21 f4       	brne	.+8      	; 0x2b0c <__vector_11+0x13e>
    2b04:	80 91 10 02 	lds	r24, 0x0210
    2b08:	88 23       	and	r24, r24
    2b0a:	b1 f1       	breq	.+108    	; 0x2b78 <__vector_11+0x1aa>
    2b0c:	80 91 1f 02 	lds	r24, 0x021F
    2b10:	90 91 20 02 	lds	r25, 0x0220
    2b14:	89 30       	cpi	r24, 0x09	; 9
    2b16:	91 05       	cpc	r25, r1
    2b18:	78 f1       	brcs	.+94     	; 0x2b78 <__vector_11+0x1aa>
    2b1a:	81 ec       	ldi	r24, 0xC1	; 193
    2b1c:	90 e0       	ldi	r25, 0x00	; 0
    2b1e:	21 ec       	ldi	r18, 0xC1	; 193
    2b20:	30 e0       	ldi	r19, 0x00	; 0
    2b22:	f9 01       	movw	r30, r18
    2b24:	20 81       	ld	r18, Z
    2b26:	20 68       	ori	r18, 0x80	; 128
    2b28:	fc 01       	movw	r30, r24
    2b2a:	20 83       	st	Z, r18
    2b2c:	89 ec       	ldi	r24, 0xC9	; 201
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	29 ec       	ldi	r18, 0xC9	; 201
    2b32:	30 e0       	ldi	r19, 0x00	; 0
    2b34:	f9 01       	movw	r30, r18
    2b36:	20 81       	ld	r18, Z
    2b38:	20 68       	ori	r18, 0x80	; 128
    2b3a:	fc 01       	movw	r30, r24
    2b3c:	20 83       	st	Z, r18
    2b3e:	10 92 0b 02 	sts	0x020B, r1
    2b42:	10 92 10 02 	sts	0x0210, r1
    2b46:	81 e0       	ldi	r24, 0x01	; 1
    2b48:	80 93 0a 02 	sts	0x020A, r24
    2b4c:	81 e0       	ldi	r24, 0x01	; 1
    2b4e:	80 93 0c 02 	sts	0x020C, r24
    2b52:	10 92 20 02 	sts	0x0220, r1
    2b56:	10 92 1f 02 	sts	0x021F, r1
    2b5a:	8d e3       	ldi	r24, 0x3D	; 61
    2b5c:	90 e0       	ldi	r25, 0x00	; 0
    2b5e:	2d e3       	ldi	r18, 0x3D	; 61
    2b60:	30 e0       	ldi	r19, 0x00	; 0
    2b62:	f9 01       	movw	r30, r18
    2b64:	20 81       	ld	r18, Z
    2b66:	24 60       	ori	r18, 0x04	; 4
    2b68:	fc 01       	movw	r30, r24
    2b6a:	20 83       	st	Z, r18
    2b6c:	8d e6       	ldi	r24, 0x6D	; 109
    2b6e:	90 e0       	ldi	r25, 0x00	; 0
    2b70:	22 e0       	ldi	r18, 0x02	; 2
    2b72:	fc 01       	movw	r30, r24
    2b74:	20 83       	st	Z, r18
    2b76:	12 c0       	rjmp	.+36     	; 0x2b9c <__vector_11+0x1ce>
	else if ((!flagReceivingBone && !flagWaitingForSYNBone) && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    2b78:	80 91 0b 02 	lds	r24, 0x020B
    2b7c:	88 23       	and	r24, r24
    2b7e:	71 f4       	brne	.+28     	; 0x2b9c <__vector_11+0x1ce>
    2b80:	80 91 10 02 	lds	r24, 0x0210
    2b84:	88 23       	and	r24, r24
    2b86:	51 f4       	brne	.+20     	; 0x2b9c <__vector_11+0x1ce>
    2b88:	80 91 1f 02 	lds	r24, 0x021F
    2b8c:	90 91 20 02 	lds	r25, 0x0220
    2b90:	00 97       	sbiw	r24, 0x00	; 0
    2b92:	21 f0       	breq	.+8      	; 0x2b9c <__vector_11+0x1ce>
    2b94:	10 92 20 02 	sts	0x0220, r1
    2b98:	10 92 1f 02 	sts	0x021F, r1
	else;

	//GAVR Reception Timeout
	if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout <= COMM_TIMEOUT_SEC){gavrReceiveTimeout++;}
    2b9c:	80 91 0d 02 	lds	r24, 0x020D
    2ba0:	88 23       	and	r24, r24
    2ba2:	21 f4       	brne	.+8      	; 0x2bac <__vector_11+0x1de>
    2ba4:	80 91 0f 02 	lds	r24, 0x020F
    2ba8:	88 23       	and	r24, r24
    2baa:	89 f0       	breq	.+34     	; 0x2bce <__vector_11+0x200>
    2bac:	80 91 21 02 	lds	r24, 0x0221
    2bb0:	90 91 22 02 	lds	r25, 0x0222
    2bb4:	89 30       	cpi	r24, 0x09	; 9
    2bb6:	91 05       	cpc	r25, r1
    2bb8:	50 f4       	brcc	.+20     	; 0x2bce <__vector_11+0x200>
    2bba:	80 91 21 02 	lds	r24, 0x0221
    2bbe:	90 91 22 02 	lds	r25, 0x0222
    2bc2:	01 96       	adiw	r24, 0x01	; 1
    2bc4:	90 93 22 02 	sts	0x0222, r25
    2bc8:	80 93 21 02 	sts	0x0221, r24
    2bcc:	50 c0       	rjmp	.+160    	; 0x2c6e <__vector_11+0x2a0>
	else if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout > COMM_TIMEOUT_SEC){__killUARTrec(); flagReceivingGAVR=fFalse;flagGoToSleep=fTrue; flagWaitingForSYNGAVR=fFalse;flagNormalMode=fTrue;gavrReceiveTimeout=0; __enableCommINT();}
    2bce:	80 91 0d 02 	lds	r24, 0x020D
    2bd2:	88 23       	and	r24, r24
    2bd4:	21 f4       	brne	.+8      	; 0x2bde <__vector_11+0x210>
    2bd6:	80 91 0f 02 	lds	r24, 0x020F
    2bda:	88 23       	and	r24, r24
    2bdc:	b1 f1       	breq	.+108    	; 0x2c4a <__vector_11+0x27c>
    2bde:	80 91 21 02 	lds	r24, 0x0221
    2be2:	90 91 22 02 	lds	r25, 0x0222
    2be6:	89 30       	cpi	r24, 0x09	; 9
    2be8:	91 05       	cpc	r25, r1
    2bea:	78 f1       	brcs	.+94     	; 0x2c4a <__vector_11+0x27c>
    2bec:	81 ec       	ldi	r24, 0xC1	; 193
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	21 ec       	ldi	r18, 0xC1	; 193
    2bf2:	30 e0       	ldi	r19, 0x00	; 0
    2bf4:	f9 01       	movw	r30, r18
    2bf6:	20 81       	ld	r18, Z
    2bf8:	20 68       	ori	r18, 0x80	; 128
    2bfa:	fc 01       	movw	r30, r24
    2bfc:	20 83       	st	Z, r18
    2bfe:	89 ec       	ldi	r24, 0xC9	; 201
    2c00:	90 e0       	ldi	r25, 0x00	; 0
    2c02:	29 ec       	ldi	r18, 0xC9	; 201
    2c04:	30 e0       	ldi	r19, 0x00	; 0
    2c06:	f9 01       	movw	r30, r18
    2c08:	20 81       	ld	r18, Z
    2c0a:	20 68       	ori	r18, 0x80	; 128
    2c0c:	fc 01       	movw	r30, r24
    2c0e:	20 83       	st	Z, r18
    2c10:	10 92 0d 02 	sts	0x020D, r1
    2c14:	81 e0       	ldi	r24, 0x01	; 1
    2c16:	80 93 0a 02 	sts	0x020A, r24
    2c1a:	10 92 0f 02 	sts	0x020F, r1
    2c1e:	81 e0       	ldi	r24, 0x01	; 1
    2c20:	80 93 0c 02 	sts	0x020C, r24
    2c24:	10 92 22 02 	sts	0x0222, r1
    2c28:	10 92 21 02 	sts	0x0221, r1
    2c2c:	8d e3       	ldi	r24, 0x3D	; 61
    2c2e:	90 e0       	ldi	r25, 0x00	; 0
    2c30:	2d e3       	ldi	r18, 0x3D	; 61
    2c32:	30 e0       	ldi	r19, 0x00	; 0
    2c34:	f9 01       	movw	r30, r18
    2c36:	20 81       	ld	r18, Z
    2c38:	24 60       	ori	r18, 0x04	; 4
    2c3a:	fc 01       	movw	r30, r24
    2c3c:	20 83       	st	Z, r18
    2c3e:	8d e6       	ldi	r24, 0x6D	; 109
    2c40:	90 e0       	ldi	r25, 0x00	; 0
    2c42:	22 e0       	ldi	r18, 0x02	; 2
    2c44:	fc 01       	movw	r30, r24
    2c46:	20 83       	st	Z, r18
    2c48:	12 c0       	rjmp	.+36     	; 0x2c6e <__vector_11+0x2a0>
	else if ((!flagReceivingGAVR && !flagWaitingForSYNGAVR) && gavrReceiveTimeout > 0){gavrReceiveTimeout=0;}
    2c4a:	80 91 0d 02 	lds	r24, 0x020D
    2c4e:	88 23       	and	r24, r24
    2c50:	71 f4       	brne	.+28     	; 0x2c6e <__vector_11+0x2a0>
    2c52:	80 91 0f 02 	lds	r24, 0x020F
    2c56:	88 23       	and	r24, r24
    2c58:	51 f4       	brne	.+20     	; 0x2c6e <__vector_11+0x2a0>
    2c5a:	80 91 21 02 	lds	r24, 0x0221
    2c5e:	90 91 22 02 	lds	r25, 0x0222
    2c62:	00 97       	sbiw	r24, 0x00	; 0
    2c64:	21 f0       	breq	.+8      	; 0x2c6e <__vector_11+0x2a0>
    2c66:	10 92 22 02 	sts	0x0222, r1
    2c6a:	10 92 21 02 	sts	0x0221, r1
	else;
	
	//Startup Tiemout for sending clock to GAVR
	if ((flagFreshStart || restart) && startupTimeout <= STARTUP_TIMEOUT_SEC){startupTimeout++;}
    2c6e:	80 91 1c 02 	lds	r24, 0x021C
    2c72:	88 23       	and	r24, r24
    2c74:	21 f4       	brne	.+8      	; 0x2c7e <__vector_11+0x2b0>
    2c76:	80 91 1b 02 	lds	r24, 0x021B
    2c7a:	88 23       	and	r24, r24
    2c7c:	89 f0       	breq	.+34     	; 0x2ca0 <__vector_11+0x2d2>
    2c7e:	80 91 23 02 	lds	r24, 0x0223
    2c82:	90 91 24 02 	lds	r25, 0x0224
    2c86:	8d 33       	cpi	r24, 0x3D	; 61
    2c88:	91 05       	cpc	r25, r1
    2c8a:	50 f4       	brcc	.+20     	; 0x2ca0 <__vector_11+0x2d2>
    2c8c:	80 91 23 02 	lds	r24, 0x0223
    2c90:	90 91 24 02 	lds	r25, 0x0224
    2c94:	01 96       	adiw	r24, 0x01	; 1
    2c96:	90 93 24 02 	sts	0x0224, r25
    2c9a:	80 93 23 02 	sts	0x0223, r24
    2c9e:	51 c0       	rjmp	.+162    	; 0x2d42 <__vector_11+0x374>
	else if ((flagFreshStart || restart) && startupTimeout > STARTUP_TIMEOUT_SEC){
    2ca0:	80 91 1c 02 	lds	r24, 0x021C
    2ca4:	88 23       	and	r24, r24
    2ca6:	21 f4       	brne	.+8      	; 0x2cb0 <__vector_11+0x2e2>
    2ca8:	80 91 1b 02 	lds	r24, 0x021B
    2cac:	88 23       	and	r24, r24
    2cae:	b9 f1       	breq	.+110    	; 0x2d1e <__vector_11+0x350>
    2cb0:	80 91 23 02 	lds	r24, 0x0223
    2cb4:	90 91 24 02 	lds	r25, 0x0224
    2cb8:	8d 33       	cpi	r24, 0x3D	; 61
    2cba:	91 05       	cpc	r25, r1
    2cbc:	80 f1       	brcs	.+96     	; 0x2d1e <__vector_11+0x350>
		if (flagFreshStart){flagFreshStart=fFalse; flagUserClock=fTrue; flagUpdateGAVRClock=fFalse;}	//The GPS didn't send valid data, get user clock.
    2cbe:	80 91 1c 02 	lds	r24, 0x021C
    2cc2:	88 23       	and	r24, r24
    2cc4:	41 f0       	breq	.+16     	; 0x2cd6 <__vector_11+0x308>
    2cc6:	10 92 1c 02 	sts	0x021C, r1
    2cca:	81 e0       	ldi	r24, 0x01	; 1
    2ccc:	80 93 13 02 	sts	0x0213, r24
    2cd0:	10 92 11 02 	sts	0x0211, r1
    2cd4:	0b c0       	rjmp	.+22     	; 0x2cec <__vector_11+0x31e>
		else if (restart){restart=fFalse; flagUserClock=fFalse; flagUpdateGAVRClock=fTrue;}				//Gps didn't send valid data, we have valid data. This is redundant to the main
    2cd6:	80 91 1b 02 	lds	r24, 0x021B
    2cda:	88 23       	and	r24, r24
    2cdc:	39 f0       	breq	.+14     	; 0x2cec <__vector_11+0x31e>
    2cde:	10 92 1b 02 	sts	0x021B, r1
    2ce2:	10 92 13 02 	sts	0x0213, r1
    2ce6:	81 e0       	ldi	r24, 0x01	; 1
    2ce8:	80 93 11 02 	sts	0x0211, r24
		__enableCommINT();																				//--procedure that depends on "if (restart)"
    2cec:	8d e3       	ldi	r24, 0x3D	; 61
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	2d e3       	ldi	r18, 0x3D	; 61
    2cf2:	30 e0       	ldi	r19, 0x00	; 0
    2cf4:	f9 01       	movw	r30, r18
    2cf6:	20 81       	ld	r18, Z
    2cf8:	24 60       	ori	r18, 0x04	; 4
    2cfa:	fc 01       	movw	r30, r24
    2cfc:	20 83       	st	Z, r18
    2cfe:	8d e6       	ldi	r24, 0x6D	; 109
    2d00:	90 e0       	ldi	r25, 0x00	; 0
    2d02:	22 e0       	ldi	r18, 0x02	; 2
    2d04:	fc 01       	movw	r30, r24
    2d06:	20 83       	st	Z, r18
		startupTimeout=0;
    2d08:	10 92 24 02 	sts	0x0224, r1
    2d0c:	10 92 23 02 	sts	0x0223, r1
		flagGoToSleep=fTrue;
    2d10:	81 e0       	ldi	r24, 0x01	; 1
    2d12:	80 93 0a 02 	sts	0x020A, r24
		flagNormalMode=fTrue;
    2d16:	81 e0       	ldi	r24, 0x01	; 1
    2d18:	80 93 0c 02 	sts	0x020C, r24
    2d1c:	12 c0       	rjmp	.+36     	; 0x2d42 <__vector_11+0x374>
	} else if (!(flagFreshStart || restart) && startupTimeout > 0){startupTimeout=0;}
    2d1e:	80 91 1c 02 	lds	r24, 0x021C
    2d22:	88 23       	and	r24, r24
    2d24:	71 f4       	brne	.+28     	; 0x2d42 <__vector_11+0x374>
    2d26:	80 91 1b 02 	lds	r24, 0x021B
    2d2a:	88 23       	and	r24, r24
    2d2c:	51 f4       	brne	.+20     	; 0x2d42 <__vector_11+0x374>
    2d2e:	80 91 23 02 	lds	r24, 0x0223
    2d32:	90 91 24 02 	lds	r25, 0x0224
    2d36:	00 97       	sbiw	r24, 0x00	; 0
    2d38:	21 f0       	breq	.+8      	; 0x2d42 <__vector_11+0x374>
    2d3a:	10 92 24 02 	sts	0x0224, r1
    2d3e:	10 92 23 02 	sts	0x0223, r1
	else;
	sei();
    2d42:	78 94       	sei
}//End timer 2 overflow.
    2d44:	df 91       	pop	r29
    2d46:	cf 91       	pop	r28
    2d48:	ff 91       	pop	r31
    2d4a:	ef 91       	pop	r30
    2d4c:	bf 91       	pop	r27
    2d4e:	af 91       	pop	r26
    2d50:	9f 91       	pop	r25
    2d52:	8f 91       	pop	r24
    2d54:	7f 91       	pop	r23
    2d56:	6f 91       	pop	r22
    2d58:	5f 91       	pop	r21
    2d5a:	4f 91       	pop	r20
    2d5c:	3f 91       	pop	r19
    2d5e:	2f 91       	pop	r18
    2d60:	0f 90       	pop	r0
    2d62:	0f be       	out	0x3f, r0	; 63
    2d64:	0f 90       	pop	r0
    2d66:	1f 90       	pop	r1
    2d68:	18 95       	reti

00002d6a <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    2d6a:	cf 93       	push	r28
    2d6c:	df 93       	push	r29
    2d6e:	cd b7       	in	r28, 0x3d	; 61
    2d70:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    2d72:	0e 94 46 18 	call	0x308c	; 0x308c <_Z10DeviceInitv>
	AppInit(MYUBRR);
    2d76:	83 e3       	ldi	r24, 0x33	; 51
    2d78:	90 e0       	ldi	r25, 0x00	; 0
    2d7a:	0e 94 6d 18 	call	0x30da	; 0x30da <_Z7AppInitj>
	EnableRTCTimer();
    2d7e:	0e 94 c9 19 	call	0x3392	; 0x3392 <_Z14EnableRTCTimerv>
	InitBools();
    2d82:	0e 94 9e 19 	call	0x333c	; 0x333c <_Z9InitBoolsv>
	getDateTime_eeprom(fTrue,fTrue);
    2d86:	81 e0       	ldi	r24, 0x01	; 1
    2d88:	61 e0       	ldi	r22, 0x01	; 1
    2d8a:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z18getDateTime_eepromhh>
	//Prep/make sure power/temp is good
	Wait_sec(2);
    2d8e:	82 e0       	ldi	r24, 0x02	; 2
    2d90:	90 e0       	ldi	r25, 0x00	; 0
    2d92:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	GetTemp();
    2d96:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_Z7GetTempv>
	TakeADC();
    2d9a:	0e 94 65 1a 	call	0x34ca	; 0x34ca <_Z7TakeADCv>
	flagGoodTemp=fTrue;
    2d9e:	81 e0       	ldi	r24, 0x01	; 1
    2da0:	80 93 19 02 	sts	0x0219, r24
	if (flagGoodVolts && flagGoodTemp){				//Good to power on system
    2da4:	80 91 1a 02 	lds	r24, 0x021A
    2da8:	88 23       	and	r24, r24
    2daa:	e1 f0       	breq	.+56     	; 0x2de4 <main+0x7a>
    2dac:	80 91 19 02 	lds	r24, 0x0219
    2db0:	88 23       	and	r24, r24
    2db2:	c1 f0       	breq	.+48     	; 0x2de4 <main+0x7a>
		PowerUp(POWER_UP_INTERVAL);
    2db4:	83 e0       	ldi	r24, 0x03	; 3
    2db6:	90 e0       	ldi	r25, 0x00	; 0
    2db8:	0e 94 d0 1b 	call	0x37a0	; 0x37a0 <_Z7PowerUpj>
		__enableCommINT();
    2dbc:	8d e3       	ldi	r24, 0x3D	; 61
    2dbe:	90 e0       	ldi	r25, 0x00	; 0
    2dc0:	2d e3       	ldi	r18, 0x3D	; 61
    2dc2:	30 e0       	ldi	r19, 0x00	; 0
    2dc4:	f9 01       	movw	r30, r18
    2dc6:	20 81       	ld	r18, Z
    2dc8:	24 60       	ori	r18, 0x04	; 4
    2dca:	fc 01       	movw	r30, r24
    2dcc:	20 83       	st	Z, r18
    2dce:	8d e6       	ldi	r24, 0x6D	; 109
    2dd0:	90 e0       	ldi	r25, 0x00	; 0
    2dd2:	22 e0       	ldi	r18, 0x02	; 2
    2dd4:	fc 01       	movw	r30, r24
    2dd6:	20 83       	st	Z, r18
		flagFreshStart=fTrue;
    2dd8:	81 e0       	ldi	r24, 0x01	; 1
    2dda:	80 93 1c 02 	sts	0x021C, r24
		flagShutdown=fFalse;
    2dde:	10 92 18 02 	sts	0x0218, r1
    2de2:	0d c0       	rjmp	.+26     	; 0x2dfe <main+0x94>
	} else {										//Something isn't right, don't power on the system.
		__killCommINT();
    2de4:	8d e3       	ldi	r24, 0x3D	; 61
    2de6:	90 e0       	ldi	r25, 0x00	; 0
    2de8:	fc 01       	movw	r30, r24
    2dea:	10 82       	st	Z, r1
    2dec:	8d e6       	ldi	r24, 0x6D	; 109
    2dee:	90 e0       	ldi	r25, 0x00	; 0
    2df0:	fc 01       	movw	r30, r24
    2df2:	10 82       	st	Z, r1
		flagShutdown=fTrue;
    2df4:	81 e0       	ldi	r24, 0x01	; 1
    2df6:	80 93 18 02 	sts	0x0218, r24
		flagFreshStart=fFalse;
    2dfa:	10 92 1c 02 	sts	0x021C, r1
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
    2dfe:	88 e2       	ldi	r24, 0x28	; 40
    2e00:	90 e0       	ldi	r25, 0x00	; 0
    2e02:	28 e2       	ldi	r18, 0x28	; 40
    2e04:	30 e0       	ldi	r19, 0x00	; 0
    2e06:	f9 01       	movw	r30, r18
    2e08:	20 81       	ld	r18, Z
    2e0a:	24 60       	ori	r18, 0x04	; 4
    2e0c:	fc 01       	movw	r30, r24
    2e0e:	20 83       	st	Z, r18
    2e10:	01 c0       	rjmp	.+2      	; 0x2e14 <main+0xaa>
	//main programming loop
	while(fTrue)
    2e12:	00 00       	nop
	{		
		//If receiving UART string, go get rest of it.
		if (flagReceivingBone && !flagReceivingGAVR){
    2e14:	80 91 0b 02 	lds	r24, 0x020B
    2e18:	88 23       	and	r24, r24
    2e1a:	11 f1       	breq	.+68     	; 0x2e60 <main+0xf6>
    2e1c:	80 91 0d 02 	lds	r24, 0x020D
    2e20:	88 23       	and	r24, r24
    2e22:	f1 f4       	brne	.+60     	; 0x2e60 <main+0xf6>
			ReceiveBone();
    2e24:	0e 94 60 0f 	call	0x1ec0	; 0x1ec0 <_Z11ReceiveBonev>
			Wait_sec(4);
    2e28:	84 e0       	ldi	r24, 0x04	; 4
    2e2a:	90 e0       	ldi	r25, 0x00	; 0
    2e2c:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			if (!flagReceivingGAVR){
    2e30:	80 91 0d 02 	lds	r24, 0x020D
    2e34:	88 23       	and	r24, r24
    2e36:	a1 f4       	brne	.+40     	; 0x2e60 <main+0xf6>
				__enableCommINT();
    2e38:	8d e3       	ldi	r24, 0x3D	; 61
    2e3a:	90 e0       	ldi	r25, 0x00	; 0
    2e3c:	2d e3       	ldi	r18, 0x3D	; 61
    2e3e:	30 e0       	ldi	r19, 0x00	; 0
    2e40:	f9 01       	movw	r30, r18
    2e42:	20 81       	ld	r18, Z
    2e44:	24 60       	ori	r18, 0x04	; 4
    2e46:	fc 01       	movw	r30, r24
    2e48:	20 83       	st	Z, r18
    2e4a:	8d e6       	ldi	r24, 0x6D	; 109
    2e4c:	90 e0       	ldi	r25, 0x00	; 0
    2e4e:	22 e0       	ldi	r18, 0x02	; 2
    2e50:	fc 01       	movw	r30, r24
    2e52:	20 83       	st	Z, r18
				flagGoToSleep=fTrue;
    2e54:	81 e0       	ldi	r24, 0x01	; 1
    2e56:	80 93 0a 02 	sts	0x020A, r24
				flagNormalMode=fTrue;
    2e5a:	81 e0       	ldi	r24, 0x01	; 1
    2e5c:	80 93 0c 02 	sts	0x020C, r24
			} //Otherwise, keep the CommInts down...			
		}//end flag Receiving from Bone 
		
		//Receiving Data/Signals from GAVR. GAVR has the priority
		if (flagReceivingGAVR){
    2e60:	80 91 0d 02 	lds	r24, 0x020D
    2e64:	88 23       	and	r24, r24
    2e66:	11 f1       	breq	.+68     	; 0x2eac <main+0x142>
			PrintBone("Receiving from WAVR.");
    2e68:	8e eb       	ldi	r24, 0xBE	; 190
    2e6a:	91 e0       	ldi	r25, 0x01	; 1
    2e6c:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
			ReceiveGAVR();
    2e70:	0e 94 f8 0b 	call	0x17f0	; 0x17f0 <_Z11ReceiveGAVRv>
			Wait_sec(4);	
    2e74:	84 e0       	ldi	r24, 0x04	; 4
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			if (!flagReceivingBone){		
    2e7c:	80 91 0b 02 	lds	r24, 0x020B
    2e80:	88 23       	and	r24, r24
    2e82:	a1 f4       	brne	.+40     	; 0x2eac <main+0x142>
				__enableCommINT();	
    2e84:	8d e3       	ldi	r24, 0x3D	; 61
    2e86:	90 e0       	ldi	r25, 0x00	; 0
    2e88:	2d e3       	ldi	r18, 0x3D	; 61
    2e8a:	30 e0       	ldi	r19, 0x00	; 0
    2e8c:	f9 01       	movw	r30, r18
    2e8e:	20 81       	ld	r18, Z
    2e90:	24 60       	ori	r18, 0x04	; 4
    2e92:	fc 01       	movw	r30, r24
    2e94:	20 83       	st	Z, r18
    2e96:	8d e6       	ldi	r24, 0x6D	; 109
    2e98:	90 e0       	ldi	r25, 0x00	; 0
    2e9a:	22 e0       	ldi	r18, 0x02	; 2
    2e9c:	fc 01       	movw	r30, r24
    2e9e:	20 83       	st	Z, r18
				flagGoToSleep=fTrue;
    2ea0:	81 e0       	ldi	r24, 0x01	; 1
    2ea2:	80 93 0a 02 	sts	0x020A, r24
				flagNormalMode=fTrue;
    2ea6:	81 e0       	ldi	r24, 0x01	; 1
    2ea8:	80 93 0c 02 	sts	0x020C, r24
			}
		}//end flag Receiving from GAVR case
		
		//Communication with GAVR. Either updating the date/time on it or asking for date and time. The internal send machine deals with the flags.
		if ((flagUpdateGAVRClock  || flagUserClock) && !flagWaitingForReceiveGAVR && !flagReceivingBone && !flagReceivingGAVR && !flagWaitingForSYNGAVR && !flagWaitingForSYNBone){
    2eac:	80 91 11 02 	lds	r24, 0x0211
    2eb0:	88 23       	and	r24, r24
    2eb2:	21 f4       	brne	.+8      	; 0x2ebc <main+0x152>
    2eb4:	80 91 13 02 	lds	r24, 0x0213
    2eb8:	88 23       	and	r24, r24
    2eba:	d1 f1       	breq	.+116    	; 0x2f30 <main+0x1c6>
    2ebc:	80 91 0e 02 	lds	r24, 0x020E
    2ec0:	88 23       	and	r24, r24
    2ec2:	b1 f5       	brne	.+108    	; 0x2f30 <main+0x1c6>
    2ec4:	80 91 0b 02 	lds	r24, 0x020B
    2ec8:	88 23       	and	r24, r24
    2eca:	91 f5       	brne	.+100    	; 0x2f30 <main+0x1c6>
    2ecc:	80 91 0d 02 	lds	r24, 0x020D
    2ed0:	88 23       	and	r24, r24
    2ed2:	71 f5       	brne	.+92     	; 0x2f30 <main+0x1c6>
    2ed4:	80 91 0f 02 	lds	r24, 0x020F
    2ed8:	88 23       	and	r24, r24
    2eda:	51 f5       	brne	.+84     	; 0x2f30 <main+0x1c6>
    2edc:	80 91 10 02 	lds	r24, 0x0210
    2ee0:	88 23       	and	r24, r24
    2ee2:	31 f5       	brne	.+76     	; 0x2f30 <main+0x1c6>
			PrintBone("SendingG.");
    2ee4:	83 ed       	ldi	r24, 0xD3	; 211
    2ee6:	91 e0       	ldi	r25, 0x01	; 1
    2ee8:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
			sendGAVR();
    2eec:	0e 94 c8 09 	call	0x1390	; 0x1390 <_Z8sendGAVRv>
			Wait_sec(4);
    2ef0:	84 e0       	ldi	r24, 0x04	; 4
    2ef2:	90 e0       	ldi	r25, 0x00	; 0
    2ef4:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			if (!flagReceivingGAVR && !flagReceivingBone){
    2ef8:	80 91 0d 02 	lds	r24, 0x020D
    2efc:	88 23       	and	r24, r24
    2efe:	c1 f4       	brne	.+48     	; 0x2f30 <main+0x1c6>
    2f00:	80 91 0b 02 	lds	r24, 0x020B
    2f04:	88 23       	and	r24, r24
    2f06:	a1 f4       	brne	.+40     	; 0x2f30 <main+0x1c6>
				__enableCommINT();
    2f08:	8d e3       	ldi	r24, 0x3D	; 61
    2f0a:	90 e0       	ldi	r25, 0x00	; 0
    2f0c:	2d e3       	ldi	r18, 0x3D	; 61
    2f0e:	30 e0       	ldi	r19, 0x00	; 0
    2f10:	f9 01       	movw	r30, r18
    2f12:	20 81       	ld	r18, Z
    2f14:	24 60       	ori	r18, 0x04	; 4
    2f16:	fc 01       	movw	r30, r24
    2f18:	20 83       	st	Z, r18
    2f1a:	8d e6       	ldi	r24, 0x6D	; 109
    2f1c:	90 e0       	ldi	r25, 0x00	; 0
    2f1e:	22 e0       	ldi	r18, 0x02	; 2
    2f20:	fc 01       	movw	r30, r24
    2f22:	20 83       	st	Z, r18
				flagGoToSleep=fTrue;
    2f24:	81 e0       	ldi	r24, 0x01	; 1
    2f26:	80 93 0a 02 	sts	0x020A, r24
				flagNormalMode=fTrue;
    2f2a:	81 e0       	ldi	r24, 0x01	; 1
    2f2c:	80 93 0c 02 	sts	0x020C, r24
			}			
		}//end send to GAVR case

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    2f30:	80 91 0c 02 	lds	r24, 0x020C
    2f34:	88 23       	and	r24, r24
    2f36:	49 f1       	breq	.+82     	; 0x2f8a <main+0x220>
			if (currentTime.getMinutes()%30 == 0){
    2f38:	82 ee       	ldi	r24, 0xE2	; 226
    2f3a:	91 e0       	ldi	r25, 0x01	; 1
    2f3c:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    2f40:	9e e1       	ldi	r25, 0x1E	; 30
    2f42:	69 2f       	mov	r22, r25
    2f44:	0e 94 9e 1c 	call	0x393c	; 0x393c <__udivmodqi4>
    2f48:	89 2f       	mov	r24, r25
    2f4a:	98 2f       	mov	r25, r24
    2f4c:	81 e0       	ldi	r24, 0x01	; 1
    2f4e:	99 23       	and	r25, r25
    2f50:	09 f0       	breq	.+2      	; 0x2f54 <main+0x1ea>
    2f52:	80 e0       	ldi	r24, 0x00	; 0
    2f54:	88 23       	and	r24, r24
    2f56:	c9 f0       	breq	.+50     	; 0x2f8a <main+0x220>
				if (currentTime.getHours()%12 == 0){
    2f58:	82 ee       	ldi	r24, 0xE2	; 226
    2f5a:	91 e0       	ldi	r25, 0x01	; 1
    2f5c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    2f60:	9c e0       	ldi	r25, 0x0C	; 12
    2f62:	69 2f       	mov	r22, r25
    2f64:	0e 94 9e 1c 	call	0x393c	; 0x393c <__udivmodqi4>
    2f68:	89 2f       	mov	r24, r25
    2f6a:	98 2f       	mov	r25, r24
    2f6c:	81 e0       	ldi	r24, 0x01	; 1
    2f6e:	99 23       	and	r25, r25
    2f70:	09 f0       	breq	.+2      	; 0x2f74 <main+0x20a>
    2f72:	80 e0       	ldi	r24, 0x00	; 0
    2f74:	88 23       	and	r24, r24
    2f76:	29 f0       	breq	.+10     	; 0x2f82 <main+0x218>
					saveDateTime_eeprom(fTrue,fTrue);
    2f78:	81 e0       	ldi	r24, 0x01	; 1
    2f7a:	61 e0       	ldi	r22, 0x01	; 1
    2f7c:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    2f80:	04 c0       	rjmp	.+8      	; 0x2f8a <main+0x220>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    2f82:	81 e0       	ldi	r24, 0x01	; 1
    2f84:	60 e0       	ldi	r22, 0x00	; 0
    2f86:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}//end time capture/save

		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    2f8a:	80 91 0c 02 	lds	r24, 0x020C
    2f8e:	88 23       	and	r24, r24
    2f90:	19 f1       	breq	.+70     	; 0x2fd8 <main+0x26e>
			TakeADC();
    2f92:	0e 94 65 1a 	call	0x34ca	; 0x34ca <_Z7TakeADCv>
			GetTemp();
    2f96:	0e 94 3b 1b 	call	0x3676	; 0x3676 <_Z7GetTempv>
			flagGoodTemp=fTrue;
    2f9a:	81 e0       	ldi	r24, 0x01	; 1
    2f9c:	80 93 19 02 	sts	0x0219, r24
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    2fa0:	80 91 1a 02 	lds	r24, 0x021A
    2fa4:	88 23       	and	r24, r24
    2fa6:	71 f0       	breq	.+28     	; 0x2fc4 <main+0x25a>
    2fa8:	80 91 19 02 	lds	r24, 0x0219
    2fac:	88 23       	and	r24, r24
    2fae:	51 f0       	breq	.+20     	; 0x2fc4 <main+0x25a>
				if(flagShutdown){restart = fTrue; flagShutdown=fFalse;}
    2fb0:	80 91 18 02 	lds	r24, 0x0218
    2fb4:	88 23       	and	r24, r24
    2fb6:	81 f0       	breq	.+32     	; 0x2fd8 <main+0x26e>
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	80 93 1b 02 	sts	0x021B, r24
    2fbe:	10 92 18 02 	sts	0x0218, r1
    2fc2:	0a c0       	rjmp	.+20     	; 0x2fd8 <main+0x26e>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (!flagShutdown){
    2fc4:	80 91 18 02 	lds	r24, 0x0218
    2fc8:	88 23       	and	r24, r24
    2fca:	31 f4       	brne	.+12     	; 0x2fd8 <main+0x26e>
					flagNewShutdown = fTrue;
    2fcc:	81 e0       	ldi	r24, 0x01	; 1
    2fce:	80 93 17 02 	sts	0x0217, r24
					flagShutdown=fTrue;
    2fd2:	81 e0       	ldi	r24, 0x01	; 1
    2fd4:	80 93 18 02 	sts	0x0218, r24
				}
			}
		}//end normal mode Check Analog Signals		
		
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    2fd8:	80 91 17 02 	lds	r24, 0x0217
    2fdc:	88 23       	and	r24, r24
    2fde:	b9 f0       	breq	.+46     	; 0x300e <main+0x2a4>
			//Make sure nothing messes with the routine that we care about
			__killCommINT();
    2fe0:	8d e3       	ldi	r24, 0x3D	; 61
    2fe2:	90 e0       	ldi	r25, 0x00	; 0
    2fe4:	fc 01       	movw	r30, r24
    2fe6:	10 82       	st	Z, r1
    2fe8:	8d e6       	ldi	r24, 0x6D	; 109
    2fea:	90 e0       	ldi	r25, 0x00	; 0
    2fec:	fc 01       	movw	r30, r24
    2fee:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    2ff0:	81 e0       	ldi	r24, 0x01	; 1
    2ff2:	80 93 0a 02 	sts	0x020A, r24
			flagReceivingBone = fFalse;
    2ff6:	10 92 0b 02 	sts	0x020B, r1
			flagUserClock=fFalse;						//reset this so next boot is correct. Done in restart case as well for redundancy
    2ffa:	10 92 13 02 	sts	0x0213, r1
			saveDateTime_eeprom(fTrue,fTrue);
    2ffe:	81 e0       	ldi	r24, 0x01	; 1
    3000:	61 e0       	ldi	r22, 0x01	; 1
    3002:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
			
			//Kill power--Alert comes in that function
			PowerDown();
    3006:	0e 94 24 1c 	call	0x3848	; 0x3848 <_Z9PowerDownv>
			flagNewShutdown = fFalse;
    300a:	10 92 17 02 	sts	0x0217, r1
		}//end new shutdown
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    300e:	80 91 1b 02 	lds	r24, 0x021B
    3012:	88 23       	and	r24, r24
    3014:	c9 f0       	breq	.+50     	; 0x3048 <main+0x2de>
			//Enable COmmunication protocols and then power up. Power up specifies the timing for it to happen	
			PowerUp(POWER_UP_INTERVAL);
    3016:	83 e0       	ldi	r24, 0x03	; 3
    3018:	90 e0       	ldi	r25, 0x00	; 0
    301a:	0e 94 d0 1b 	call	0x37a0	; 0x37a0 <_Z7PowerUpj>
			__enableCommINT();
    301e:	8d e3       	ldi	r24, 0x3D	; 61
    3020:	90 e0       	ldi	r25, 0x00	; 0
    3022:	2d e3       	ldi	r18, 0x3D	; 61
    3024:	30 e0       	ldi	r19, 0x00	; 0
    3026:	f9 01       	movw	r30, r18
    3028:	20 81       	ld	r18, Z
    302a:	24 60       	ori	r18, 0x04	; 4
    302c:	fc 01       	movw	r30, r24
    302e:	20 83       	st	Z, r18
    3030:	8d e6       	ldi	r24, 0x6D	; 109
    3032:	90 e0       	ldi	r25, 0x00	; 0
    3034:	22 e0       	ldi	r18, 0x02	; 2
    3036:	fc 01       	movw	r30, r24
    3038:	20 83       	st	Z, r18
			//Update the GAVRClock since it's a restart, we have the correct date and time. If BeagleBone sends GPS data, use that to back it up.
			flagUpdateGAVRClock=fTrue;
    303a:	81 e0       	ldi	r24, 0x01	; 1
    303c:	80 93 11 02 	sts	0x0211, r24
			flagUserClock=fFalse;	
    3040:	10 92 13 02 	sts	0x0213, r1
			restart=fFalse;	
    3044:	10 92 1b 02 	sts	0x021B, r1
		}//end restart		
		
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep && (!flagUserClock || !flagUpdateGAVRClock)){GoToSleep(flagShutdown);}
    3048:	80 91 0a 02 	lds	r24, 0x020A
    304c:	88 23       	and	r24, r24
    304e:	61 f0       	breq	.+24     	; 0x3068 <main+0x2fe>
    3050:	80 91 13 02 	lds	r24, 0x0213
    3054:	88 23       	and	r24, r24
    3056:	21 f0       	breq	.+8      	; 0x3060 <main+0x2f6>
    3058:	80 91 11 02 	lds	r24, 0x0211
    305c:	88 23       	and	r24, r24
    305e:	21 f4       	brne	.+8      	; 0x3068 <main+0x2fe>
    3060:	80 91 18 02 	lds	r24, 0x0218
    3064:	0e 94 07 1a 	call	0x340e	; 0x340e <_Z9GoToSleeph>
		
		//Add logic for an invalid date and time somehow getting in here
		if (flagInvalidDateTime && !flagShutdown){
    3068:	80 91 14 02 	lds	r24, 0x0214
    306c:	88 23       	and	r24, r24
    306e:	09 f4       	brne	.+2      	; 0x3072 <main+0x308>
    3070:	d0 ce       	rjmp	.-608    	; 0x2e12 <main+0xa8>
    3072:	80 91 18 02 	lds	r24, 0x0218
    3076:	88 23       	and	r24, r24
    3078:	09 f0       	breq	.+2      	; 0x307c <main+0x312>
    307a:	cb ce       	rjmp	.-618    	; 0x2e12 <main+0xa8>
			flagInvalidDateTime=fFalse;
    307c:	10 92 14 02 	sts	0x0214, r1
			flagUserClock=fTrue;
    3080:	81 e0       	ldi	r24, 0x01	; 1
    3082:	80 93 13 02 	sts	0x0213, r24
			flagUpdateGAVRClock=fFalse;
    3086:	10 92 11 02 	sts	0x0211, r1
		flagFreshStart=fFalse;
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
	//main programming loop
	while(fTrue)
    308a:	c3 ce       	rjmp	.-634    	; 0x2e12 <main+0xa8>

0000308c <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    308c:	cf 93       	push	r28
    308e:	df 93       	push	r29
    3090:	cd b7       	in	r28, 0x3d	; 61
    3092:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    3094:	81 e2       	ldi	r24, 0x21	; 33
    3096:	90 e0       	ldi	r25, 0x00	; 0
    3098:	fc 01       	movw	r30, r24
    309a:	10 82       	st	Z, r1
	DDRB = 0;
    309c:	84 e2       	ldi	r24, 0x24	; 36
    309e:	90 e0       	ldi	r25, 0x00	; 0
    30a0:	fc 01       	movw	r30, r24
    30a2:	10 82       	st	Z, r1
	DDRC = 0;
    30a4:	87 e2       	ldi	r24, 0x27	; 39
    30a6:	90 e0       	ldi	r25, 0x00	; 0
    30a8:	fc 01       	movw	r30, r24
    30aa:	10 82       	st	Z, r1
	DDRD = 0;
    30ac:	8a e2       	ldi	r24, 0x2A	; 42
    30ae:	90 e0       	ldi	r25, 0x00	; 0
    30b0:	fc 01       	movw	r30, r24
    30b2:	10 82       	st	Z, r1
	
	PORTA = 0;
    30b4:	82 e2       	ldi	r24, 0x22	; 34
    30b6:	90 e0       	ldi	r25, 0x00	; 0
    30b8:	fc 01       	movw	r30, r24
    30ba:	10 82       	st	Z, r1
	PORTB = 0;
    30bc:	85 e2       	ldi	r24, 0x25	; 37
    30be:	90 e0       	ldi	r25, 0x00	; 0
    30c0:	fc 01       	movw	r30, r24
    30c2:	10 82       	st	Z, r1
	PORTC = 0;
    30c4:	88 e2       	ldi	r24, 0x28	; 40
    30c6:	90 e0       	ldi	r25, 0x00	; 0
    30c8:	fc 01       	movw	r30, r24
    30ca:	10 82       	st	Z, r1
	PORTD = 0;
    30cc:	8b e2       	ldi	r24, 0x2B	; 43
    30ce:	90 e0       	ldi	r25, 0x00	; 0
    30d0:	fc 01       	movw	r30, r24
    30d2:	10 82       	st	Z, r1
}
    30d4:	df 91       	pop	r29
    30d6:	cf 91       	pop	r28
    30d8:	08 95       	ret

000030da <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    30da:	cf 93       	push	r28
    30dc:	df 93       	push	r29
    30de:	00 d0       	rcall	.+0      	; 0x30e0 <_Z7AppInitj+0x6>
    30e0:	cd b7       	in	r28, 0x3d	; 61
    30e2:	de b7       	in	r29, 0x3e	; 62
    30e4:	9a 83       	std	Y+2, r25	; 0x02
    30e6:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    30e8:	84 ec       	ldi	r24, 0xC4	; 196
    30ea:	90 e0       	ldi	r25, 0x00	; 0
    30ec:	29 81       	ldd	r18, Y+1	; 0x01
    30ee:	fc 01       	movw	r30, r24
    30f0:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    30f2:	85 ec       	ldi	r24, 0xC5	; 197
    30f4:	90 e0       	ldi	r25, 0x00	; 0
    30f6:	29 81       	ldd	r18, Y+1	; 0x01
    30f8:	3a 81       	ldd	r19, Y+2	; 0x02
    30fa:	23 2f       	mov	r18, r19
    30fc:	33 27       	eor	r19, r19
    30fe:	fc 01       	movw	r30, r24
    3100:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    3102:	81 ec       	ldi	r24, 0xC1	; 193
    3104:	90 e0       	ldi	r25, 0x00	; 0
    3106:	28 e1       	ldi	r18, 0x18	; 24
    3108:	fc 01       	movw	r30, r24
    310a:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    310c:	82 ec       	ldi	r24, 0xC2	; 194
    310e:	90 e0       	ldi	r25, 0x00	; 0
    3110:	26 e0       	ldi	r18, 0x06	; 6
    3112:	fc 01       	movw	r30, r24
    3114:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Set BAUD for UART1
	UBRR1L = ubrr;
    3116:	8c ec       	ldi	r24, 0xCC	; 204
    3118:	90 e0       	ldi	r25, 0x00	; 0
    311a:	29 81       	ldd	r18, Y+1	; 0x01
    311c:	fc 01       	movw	r30, r24
    311e:	20 83       	st	Z, r18
	UBRR1H = (ubrr >> 8);
    3120:	8d ec       	ldi	r24, 0xCD	; 205
    3122:	90 e0       	ldi	r25, 0x00	; 0
    3124:	29 81       	ldd	r18, Y+1	; 0x01
    3126:	3a 81       	ldd	r19, Y+2	; 0x02
    3128:	23 2f       	mov	r18, r19
    312a:	33 27       	eor	r19, r19
    312c:	fc 01       	movw	r30, r24
    312e:	20 83       	st	Z, r18
	//UCSR1A |= (1 << U2X1);
	
	//Enable UART_TX1 and UART_RX1
	UCSR1B = (1 << TXEN1)|(1 << RXEN1);
    3130:	89 ec       	ldi	r24, 0xC9	; 201
    3132:	90 e0       	ldi	r25, 0x00	; 0
    3134:	28 e1       	ldi	r18, 0x18	; 24
    3136:	fc 01       	movw	r30, r24
    3138:	20 83       	st	Z, r18
	UCSR1C = (1 << UCSZ11)|(1 << UCSZ10);
    313a:	8a ec       	ldi	r24, 0xCA	; 202
    313c:	90 e0       	ldi	r25, 0x00	; 0
    313e:	26 e0       	ldi	r18, 0x06	; 6
    3140:	fc 01       	movw	r30, r24
    3142:	20 83       	st	Z, r18
	//UCSR1B |= (1 << RXCIE1);
	__killUARTrec();
    3144:	81 ec       	ldi	r24, 0xC1	; 193
    3146:	90 e0       	ldi	r25, 0x00	; 0
    3148:	21 ec       	ldi	r18, 0xC1	; 193
    314a:	30 e0       	ldi	r19, 0x00	; 0
    314c:	f9 01       	movw	r30, r18
    314e:	20 81       	ld	r18, Z
    3150:	20 68       	ori	r18, 0x80	; 128
    3152:	fc 01       	movw	r30, r24
    3154:	20 83       	st	Z, r18
    3156:	89 ec       	ldi	r24, 0xC9	; 201
    3158:	90 e0       	ldi	r25, 0x00	; 0
    315a:	29 ec       	ldi	r18, 0xC9	; 201
    315c:	30 e0       	ldi	r19, 0x00	; 0
    315e:	f9 01       	movw	r30, r18
    3160:	20 81       	ld	r18, Z
    3162:	20 68       	ori	r18, 0x80	; 128
    3164:	fc 01       	movw	r30, r24
    3166:	20 83       	st	Z, r18
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM0)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    3168:	84 e6       	ldi	r24, 0x64	; 100
    316a:	90 e0       	ldi	r25, 0x00	; 0
    316c:	24 e6       	ldi	r18, 0x64	; 100
    316e:	30 e0       	ldi	r19, 0x00	; 0
    3170:	f9 01       	movw	r30, r18
    3172:	20 81       	ld	r18, Z
    3174:	2d 6a       	ori	r18, 0xAD	; 173
    3176:	fc 01       	movw	r30, r24
    3178:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    317a:	8a e2       	ldi	r24, 0x2A	; 42
    317c:	90 e0       	ldi	r25, 0x00	; 0
    317e:	2a e2       	ldi	r18, 0x2A	; 42
    3180:	30 e0       	ldi	r19, 0x00	; 0
    3182:	f9 01       	movw	r30, r18
    3184:	20 81       	ld	r18, Z
    3186:	20 68       	ori	r18, 0x80	; 128
    3188:	fc 01       	movw	r30, r24
    318a:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    318c:	87 e2       	ldi	r24, 0x27	; 39
    318e:	90 e0       	ldi	r25, 0x00	; 0
    3190:	27 e2       	ldi	r18, 0x27	; 39
    3192:	30 e0       	ldi	r19, 0x00	; 0
    3194:	f9 01       	movw	r30, r18
    3196:	20 81       	ld	r18, Z
    3198:	24 60       	ori	r18, 0x04	; 4
    319a:	fc 01       	movw	r30, r24
    319c:	20 83       	st	Z, r18
	prtSLEEPled |= (1 << bnSLEEPled);	//turn off initially
    319e:	8b e2       	ldi	r24, 0x2B	; 43
    31a0:	90 e0       	ldi	r25, 0x00	; 0
    31a2:	2b e2       	ldi	r18, 0x2B	; 43
    31a4:	30 e0       	ldi	r19, 0x00	; 0
    31a6:	f9 01       	movw	r30, r18
    31a8:	20 81       	ld	r18, Z
    31aa:	20 68       	ori	r18, 0x80	; 128
    31ac:	fc 01       	movw	r30, r24
    31ae:	20 83       	st	Z, r18
	prtSTATUSled &= ~(1 << bnSTATUSled);	//turn on initially
    31b0:	88 e2       	ldi	r24, 0x28	; 40
    31b2:	90 e0       	ldi	r25, 0x00	; 0
    31b4:	28 e2       	ldi	r18, 0x28	; 40
    31b6:	30 e0       	ldi	r19, 0x00	; 0
    31b8:	f9 01       	movw	r30, r18
    31ba:	20 81       	ld	r18, Z
    31bc:	2b 7f       	andi	r18, 0xFB	; 251
    31be:	fc 01       	movw	r30, r24
    31c0:	20 83       	st	Z, r18
	
	//Enable BB and GAVR interrupts for COMMUNICATION
	ddrBONEINT |= (1 << bnBONEINT);
    31c2:	81 e2       	ldi	r24, 0x21	; 33
    31c4:	90 e0       	ldi	r25, 0x00	; 0
    31c6:	21 e2       	ldi	r18, 0x21	; 33
    31c8:	30 e0       	ldi	r19, 0x00	; 0
    31ca:	f9 01       	movw	r30, r18
    31cc:	20 81       	ld	r18, Z
    31ce:	22 60       	ori	r18, 0x02	; 2
    31d0:	fc 01       	movw	r30, r24
    31d2:	20 83       	st	Z, r18
	ddrGAVRINT |= (1 << bnGAVRINT);
    31d4:	84 e2       	ldi	r24, 0x24	; 36
    31d6:	90 e0       	ldi	r25, 0x00	; 0
    31d8:	24 e2       	ldi	r18, 0x24	; 36
    31da:	30 e0       	ldi	r19, 0x00	; 0
    31dc:	f9 01       	movw	r30, r18
    31de:	20 81       	ld	r18, Z
    31e0:	28 60       	ori	r18, 0x08	; 8
    31e2:	fc 01       	movw	r30, r24
    31e4:	20 83       	st	Z, r18
	prtBONEINT &= ~(1 << bnBONEINT);
    31e6:	82 e2       	ldi	r24, 0x22	; 34
    31e8:	90 e0       	ldi	r25, 0x00	; 0
    31ea:	22 e2       	ldi	r18, 0x22	; 34
    31ec:	30 e0       	ldi	r19, 0x00	; 0
    31ee:	f9 01       	movw	r30, r18
    31f0:	20 81       	ld	r18, Z
    31f2:	2d 7f       	andi	r18, 0xFD	; 253
    31f4:	fc 01       	movw	r30, r24
    31f6:	20 83       	st	Z, r18
	prtGAVRINT &= ~(1 << bnGAVRINT);
    31f8:	85 e2       	ldi	r24, 0x25	; 37
    31fa:	90 e0       	ldi	r25, 0x00	; 0
    31fc:	25 e2       	ldi	r18, 0x25	; 37
    31fe:	30 e0       	ldi	r19, 0x00	; 0
    3200:	f9 01       	movw	r30, r18
    3202:	20 81       	ld	r18, Z
    3204:	27 7f       	andi	r18, 0xF7	; 247
    3206:	fc 01       	movw	r30, r24
    3208:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrInterrupts |= (1 << bnGAVRint)|(1 << bnBBint);
    320a:	81 e2       	ldi	r24, 0x21	; 33
    320c:	90 e0       	ldi	r25, 0x00	; 0
    320e:	21 e2       	ldi	r18, 0x21	; 33
    3210:	30 e0       	ldi	r19, 0x00	; 0
    3212:	f9 01       	movw	r30, r18
    3214:	20 81       	ld	r18, Z
    3216:	2c 60       	ori	r18, 0x0C	; 12
    3218:	fc 01       	movw	r30, r24
    321a:	20 83       	st	Z, r18
	prtInterrupts &= ~((1 << bnGAVRint)|(1 << bnBBint));
    321c:	82 e2       	ldi	r24, 0x22	; 34
    321e:	90 e0       	ldi	r25, 0x00	; 0
    3220:	22 e2       	ldi	r18, 0x22	; 34
    3222:	30 e0       	ldi	r19, 0x00	; 0
    3224:	f9 01       	movw	r30, r18
    3226:	20 81       	ld	r18, Z
    3228:	23 7f       	andi	r18, 0xF3	; 243
    322a:	fc 01       	movw	r30, r24
    322c:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen)|(1 << bnBBen);
    322e:	81 e2       	ldi	r24, 0x21	; 33
    3230:	90 e0       	ldi	r25, 0x00	; 0
    3232:	21 e2       	ldi	r18, 0x21	; 33
    3234:	30 e0       	ldi	r19, 0x00	; 0
    3236:	f9 01       	movw	r30, r18
    3238:	20 81       	ld	r18, Z
    323a:	20 6f       	ori	r18, 0xF0	; 240
    323c:	fc 01       	movw	r30, r24
    323e:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    3240:	84 e2       	ldi	r24, 0x24	; 36
    3242:	90 e0       	ldi	r25, 0x00	; 0
    3244:	24 e2       	ldi	r18, 0x24	; 36
    3246:	30 e0       	ldi	r19, 0x00	; 0
    3248:	f9 01       	movw	r30, r18
    324a:	20 81       	ld	r18, Z
    324c:	21 60       	ori	r18, 0x01	; 1
    324e:	fc 01       	movw	r30, r24
    3250:	20 83       	st	Z, r18
	ddrMAINen |= (1 << bnMAINen);
    3252:	87 e2       	ldi	r24, 0x27	; 39
    3254:	90 e0       	ldi	r25, 0x00	; 0
    3256:	27 e2       	ldi	r18, 0x27	; 39
    3258:	30 e0       	ldi	r19, 0x00	; 0
    325a:	f9 01       	movw	r30, r18
    325c:	20 81       	ld	r18, Z
    325e:	21 60       	ori	r18, 0x01	; 1
    3260:	fc 01       	movw	r30, r24
    3262:	20 83       	st	Z, r18
	__killMain();
    3264:	88 e2       	ldi	r24, 0x28	; 40
    3266:	90 e0       	ldi	r25, 0x00	; 0
    3268:	28 e2       	ldi	r18, 0x28	; 40
    326a:	30 e0       	ldi	r19, 0x00	; 0
    326c:	f9 01       	movw	r30, r18
    326e:	20 81       	ld	r18, Z
    3270:	2e 7f       	andi	r18, 0xFE	; 254
    3272:	fc 01       	movw	r30, r24
    3274:	20 83       	st	Z, r18
	__killBeagleBone();
    3276:	82 e2       	ldi	r24, 0x22	; 34
    3278:	90 e0       	ldi	r25, 0x00	; 0
    327a:	22 e2       	ldi	r18, 0x22	; 34
    327c:	30 e0       	ldi	r19, 0x00	; 0
    327e:	f9 01       	movw	r30, r18
    3280:	20 81       	ld	r18, Z
    3282:	2f 7e       	andi	r18, 0xEF	; 239
    3284:	fc 01       	movw	r30, r24
    3286:	20 83       	st	Z, r18
	__enableTemp();
    3288:	85 e2       	ldi	r24, 0x25	; 37
    328a:	90 e0       	ldi	r25, 0x00	; 0
    328c:	25 e2       	ldi	r18, 0x25	; 37
    328e:	30 e0       	ldi	r19, 0x00	; 0
    3290:	f9 01       	movw	r30, r18
    3292:	20 81       	ld	r18, Z
    3294:	21 60       	ori	r18, 0x01	; 1
    3296:	fc 01       	movw	r30, r24
    3298:	20 83       	st	Z, r18
	__killLCD();
    329a:	82 e2       	ldi	r24, 0x22	; 34
    329c:	90 e0       	ldi	r25, 0x00	; 0
    329e:	22 e2       	ldi	r18, 0x22	; 34
    32a0:	30 e0       	ldi	r19, 0x00	; 0
    32a2:	f9 01       	movw	r30, r18
    32a4:	20 81       	ld	r18, Z
    32a6:	2f 7d       	andi	r18, 0xDF	; 223
    32a8:	fc 01       	movw	r30, r24
    32aa:	20 83       	st	Z, r18
	__killGPSandGAVR();
    32ac:	82 e2       	ldi	r24, 0x22	; 34
    32ae:	90 e0       	ldi	r25, 0x00	; 0
    32b0:	22 e2       	ldi	r18, 0x22	; 34
    32b2:	30 e0       	ldi	r19, 0x00	; 0
    32b4:	f9 01       	movw	r30, r18
    32b6:	20 81       	ld	r18, Z
    32b8:	2f 73       	andi	r18, 0x3F	; 63
    32ba:	fc 01       	movw	r30, r24
    32bc:	20 83       	st	Z, r18

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	__killCommINT();
    32be:	8d e3       	ldi	r24, 0x3D	; 61
    32c0:	90 e0       	ldi	r25, 0x00	; 0
    32c2:	fc 01       	movw	r30, r24
    32c4:	10 82       	st	Z, r1
    32c6:	8d e6       	ldi	r24, 0x6D	; 109
    32c8:	90 e0       	ldi	r25, 0x00	; 0
    32ca:	fc 01       	movw	r30, r24
    32cc:	10 82       	st	Z, r1
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    32ce:	89 e6       	ldi	r24, 0x69	; 105
    32d0:	90 e0       	ldi	r25, 0x00	; 0
    32d2:	20 e3       	ldi	r18, 0x30	; 48
    32d4:	fc 01       	movw	r30, r24
    32d6:	20 83       	st	Z, r18
	//Enable PCINT17
	PCICR |= (1 << PCIE2);
    32d8:	88 e6       	ldi	r24, 0x68	; 104
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	28 e6       	ldi	r18, 0x68	; 104
    32de:	30 e0       	ldi	r19, 0x00	; 0
    32e0:	f9 01       	movw	r30, r18
    32e2:	20 81       	ld	r18, Z
    32e4:	24 60       	ori	r18, 0x04	; 4
    32e6:	fc 01       	movw	r30, r24
    32e8:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    32ea:	84 e2       	ldi	r24, 0x24	; 36
    32ec:	90 e0       	ldi	r25, 0x00	; 0
    32ee:	24 e2       	ldi	r18, 0x24	; 36
    32f0:	30 e0       	ldi	r19, 0x00	; 0
    32f2:	f9 01       	movw	r30, r18
    32f4:	20 81       	ld	r18, Z
    32f6:	20 6b       	ori	r18, 0xB0	; 176
    32f8:	fc 01       	movw	r30, r24
    32fa:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    32fc:	84 e2       	ldi	r24, 0x24	; 36
    32fe:	90 e0       	ldi	r25, 0x00	; 0
    3300:	24 e2       	ldi	r18, 0x24	; 36
    3302:	30 e0       	ldi	r19, 0x00	; 0
    3304:	f9 01       	movw	r30, r18
    3306:	20 81       	ld	r18, Z
    3308:	2f 7b       	andi	r18, 0xBF	; 191
    330a:	fc 01       	movw	r30, r24
    330c:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    330e:	85 e2       	ldi	r24, 0x25	; 37
    3310:	90 e0       	ldi	r25, 0x00	; 0
    3312:	25 e2       	ldi	r18, 0x25	; 37
    3314:	30 e0       	ldi	r19, 0x00	; 0
    3316:	f9 01       	movw	r30, r18
    3318:	20 81       	ld	r18, Z
    331a:	20 69       	ori	r18, 0x90	; 144
    331c:	fc 01       	movw	r30, r24
    331e:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    3320:	85 e2       	ldi	r24, 0x25	; 37
    3322:	90 e0       	ldi	r25, 0x00	; 0
    3324:	25 e2       	ldi	r18, 0x25	; 37
    3326:	30 e0       	ldi	r19, 0x00	; 0
    3328:	f9 01       	movw	r30, r18
    332a:	20 81       	ld	r18, Z
    332c:	2f 7d       	andi	r18, 0xDF	; 223
    332e:	fc 01       	movw	r30, r24
    3330:	20 83       	st	Z, r18
	
}
    3332:	0f 90       	pop	r0
    3334:	0f 90       	pop	r0
    3336:	df 91       	pop	r29
    3338:	cf 91       	pop	r28
    333a:	08 95       	ret

0000333c <_Z9InitBoolsv>:
/*************************************************************************************************************/
void InitBools(){
    333c:	cf 93       	push	r28
    333e:	df 93       	push	r29
    3340:	cd b7       	in	r28, 0x3d	; 61
    3342:	de b7       	in	r29, 0x3e	; 62
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    3344:	81 e0       	ldi	r24, 0x01	; 1
    3346:	80 93 0a 02 	sts	0x020A, r24
	flagReceivingBone = fFalse;
    334a:	10 92 0b 02 	sts	0x020B, r1
	flagNormalMode=fTrue;
    334e:	81 e0       	ldi	r24, 0x01	; 1
    3350:	80 93 0c 02 	sts	0x020C, r24
	flagReceivingGAVR=fFalse;
    3354:	10 92 0d 02 	sts	0x020D, r1
	flagWaitingForReceiveGAVR=fFalse;
    3358:	10 92 0e 02 	sts	0x020E, r1
	flagWaitingForSYNGAVR=fFalse;
    335c:	10 92 0f 02 	sts	0x020F, r1
	flagWaitingForSYNBone=fFalse;
    3360:	10 92 10 02 	sts	0x0210, r1

	flagUpdateGAVRClock=fFalse;
    3364:	10 92 11 02 	sts	0x0211, r1
	flagSendingGAVR=fFalse;
    3368:	10 92 12 02 	sts	0x0212, r1
	flagUserClock=fFalse;
    336c:	10 92 13 02 	sts	0x0213, r1
	flagInvalidDateTime=fFalse;
    3370:	10 92 14 02 	sts	0x0214, r1
	flagWaitingToSendGAVR=fFalse;
    3374:	10 92 15 02 	sts	0x0215, r1
	flagGPSTime=fFalse;
    3378:	10 92 16 02 	sts	0x0216, r1
	
	restart=fFalse;
    337c:	10 92 1b 02 	sts	0x021B, r1
	//flagNewShutdown=fFalse;
	flagShutdown=fFalse;		//Initialized in startup procedure in beginning of "main"
    3380:	10 92 18 02 	sts	0x0218, r1
	flagGoodVolts=fFalse;
    3384:	10 92 1a 02 	sts	0x021A, r1
	flagGoodTemp=fFalse;
    3388:	10 92 19 02 	sts	0x0219, r1
	//flagFreshStart=fTrue;		//Initialized in startup procedure in beginning of "main"
}
    338c:	df 91       	pop	r29
    338e:	cf 91       	pop	r28
    3390:	08 95       	ret

00003392 <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    3392:	cf 93       	push	r28
    3394:	df 93       	push	r29
    3396:	cd b7       	in	r28, 0x3d	; 61
    3398:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    339a:	84 e6       	ldi	r24, 0x64	; 100
    339c:	90 e0       	ldi	r25, 0x00	; 0
    339e:	24 e6       	ldi	r18, 0x64	; 100
    33a0:	30 e0       	ldi	r19, 0x00	; 0
    33a2:	f9 01       	movw	r30, r18
    33a4:	20 81       	ld	r18, Z
    33a6:	2f 7b       	andi	r18, 0xBF	; 191
    33a8:	fc 01       	movw	r30, r24
    33aa:	20 83       	st	Z, r18
	Wait_ms(5);	//give it time to power on
    33ac:	85 e0       	ldi	r24, 0x05	; 5
    33ae:	90 e0       	ldi	r25, 0x00	; 0
    33b0:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    33b4:	86 eb       	ldi	r24, 0xB6	; 182
    33b6:	90 e0       	ldi	r25, 0x00	; 0
    33b8:	26 eb       	ldi	r18, 0xB6	; 182
    33ba:	30 e0       	ldi	r19, 0x00	; 0
    33bc:	f9 01       	movw	r30, r18
    33be:	20 81       	ld	r18, Z
    33c0:	20 62       	ori	r18, 0x20	; 32
    33c2:	fc 01       	movw	r30, r24
    33c4:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    33c6:	81 eb       	ldi	r24, 0xB1	; 177
    33c8:	90 e0       	ldi	r25, 0x00	; 0
    33ca:	21 eb       	ldi	r18, 0xB1	; 177
    33cc:	30 e0       	ldi	r19, 0x00	; 0
    33ce:	f9 01       	movw	r30, r18
    33d0:	20 81       	ld	r18, Z
    33d2:	25 60       	ori	r18, 0x05	; 5
    33d4:	fc 01       	movw	r30, r24
    33d6:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    33d8:	86 eb       	ldi	r24, 0xB6	; 182
    33da:	90 e0       	ldi	r25, 0x00	; 0
    33dc:	fc 01       	movw	r30, r24
    33de:	80 81       	ld	r24, Z
    33e0:	88 2f       	mov	r24, r24
    33e2:	90 e0       	ldi	r25, 0x00	; 0
    33e4:	81 71       	andi	r24, 0x11	; 17
    33e6:	90 70       	andi	r25, 0x00	; 0
    33e8:	21 e0       	ldi	r18, 0x01	; 1
    33ea:	00 97       	sbiw	r24, 0x00	; 0
    33ec:	09 f4       	brne	.+2      	; 0x33f0 <_Z14EnableRTCTimerv+0x5e>
    33ee:	20 e0       	ldi	r18, 0x00	; 0
    33f0:	22 23       	and	r18, r18
    33f2:	91 f7       	brne	.-28     	; 0x33d8 <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    33f4:	87 e3       	ldi	r24, 0x37	; 55
    33f6:	90 e0       	ldi	r25, 0x00	; 0
    33f8:	21 e0       	ldi	r18, 0x01	; 1
    33fa:	fc 01       	movw	r30, r24
    33fc:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    33fe:	80 e7       	ldi	r24, 0x70	; 112
    3400:	90 e0       	ldi	r25, 0x00	; 0
    3402:	21 e0       	ldi	r18, 0x01	; 1
    3404:	fc 01       	movw	r30, r24
    3406:	20 83       	st	Z, r18
	
	//Away we go
}
    3408:	df 91       	pop	r29
    340a:	cf 91       	pop	r28
    340c:	08 95       	ret

0000340e <_Z9GoToSleeph>:

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    340e:	cf 93       	push	r28
    3410:	df 93       	push	r29
    3412:	00 d0       	rcall	.+0      	; 0x3414 <_Z9GoToSleeph+0x6>
    3414:	00 d0       	rcall	.+0      	; 0x3416 <_Z9GoToSleeph+0x8>
    3416:	0f 92       	push	r0
    3418:	cd b7       	in	r28, 0x3d	; 61
    341a:	de b7       	in	r29, 0x3e	; 62
    341c:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    341e:	78 94       	sei
		int sleepTime, sleepTicks = 0;
    3420:	1c 82       	std	Y+4, r1	; 0x04
    3422:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong){
    3424:	8d 81       	ldd	r24, Y+5	; 0x05
    3426:	88 23       	and	r24, r24
    3428:	29 f0       	breq	.+10     	; 0x3434 <_Z9GoToSleeph+0x26>
			sleepTime = SLEEP_TICKS_LOWV;
    342a:	8c e0       	ldi	r24, 0x0C	; 12
    342c:	90 e0       	ldi	r25, 0x00	; 0
    342e:	9a 83       	std	Y+2, r25	; 0x02
    3430:	89 83       	std	Y+1, r24	; 0x01
    3432:	04 c0       	rjmp	.+8      	; 0x343c <_Z9GoToSleeph+0x2e>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    3434:	8a e0       	ldi	r24, 0x0A	; 10
    3436:	90 e0       	ldi	r25, 0x00	; 0
    3438:	9a 83       	std	Y+2, r25	; 0x02
    343a:	89 83       	std	Y+1, r24	; 0x01
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    343c:	88 e2       	ldi	r24, 0x28	; 40
    343e:	90 e0       	ldi	r25, 0x00	; 0
    3440:	28 e2       	ldi	r18, 0x28	; 40
    3442:	30 e0       	ldi	r19, 0x00	; 0
    3444:	f9 01       	movw	r30, r18
    3446:	20 81       	ld	r18, Z
    3448:	2b 7f       	andi	r18, 0xFB	; 251
    344a:	fc 01       	movw	r30, r24
    344c:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    344e:	83 e5       	ldi	r24, 0x53	; 83
    3450:	90 e0       	ldi	r25, 0x00	; 0
    3452:	26 e0       	ldi	r18, 0x06	; 6
    3454:	fc 01       	movw	r30, r24
    3456:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    3458:	83 e5       	ldi	r24, 0x53	; 83
    345a:	90 e0       	ldi	r25, 0x00	; 0
    345c:	23 e5       	ldi	r18, 0x53	; 83
    345e:	30 e0       	ldi	r19, 0x00	; 0
    3460:	f9 01       	movw	r30, r18
    3462:	20 81       	ld	r18, Z
    3464:	21 60       	ori	r18, 0x01	; 1
    3466:	fc 01       	movw	r30, r24
    3468:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    346a:	81 e0       	ldi	r24, 0x01	; 1
    346c:	90 e0       	ldi	r25, 0x00	; 0
    346e:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3472:	06 c0       	rjmp	.+12     	; 0x3480 <_Z9GoToSleeph+0x72>
			asm volatile("SLEEP");
    3474:	88 95       	sleep
			sleepTicks++;
    3476:	8b 81       	ldd	r24, Y+3	; 0x03
    3478:	9c 81       	ldd	r25, Y+4	; 0x04
    347a:	01 96       	adiw	r24, 0x01	; 1
    347c:	9c 83       	std	Y+4, r25	; 0x04
    347e:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3480:	2b 81       	ldd	r18, Y+3	; 0x03
    3482:	3c 81       	ldd	r19, Y+4	; 0x04
    3484:	89 81       	ldd	r24, Y+1	; 0x01
    3486:	9a 81       	ldd	r25, Y+2	; 0x02
    3488:	28 17       	cp	r18, r24
    348a:	39 07       	cpc	r19, r25
    348c:	34 f4       	brge	.+12     	; 0x349a <_Z9GoToSleeph+0x8c>
    348e:	80 91 0a 02 	lds	r24, 0x020A
    3492:	88 23       	and	r24, r24
    3494:	11 f0       	breq	.+4      	; 0x349a <_Z9GoToSleeph+0x8c>
    3496:	81 e0       	ldi	r24, 0x01	; 1
    3498:	01 c0       	rjmp	.+2      	; 0x349c <_Z9GoToSleeph+0x8e>
    349a:	80 e0       	ldi	r24, 0x00	; 0
    349c:	88 23       	and	r24, r24
    349e:	51 f7       	brne	.-44     	; 0x3474 <_Z9GoToSleeph+0x66>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(1);
    34a0:	81 e0       	ldi	r24, 0x01	; 1
    34a2:	90 e0       	ldi	r25, 0x00	; 0
    34a4:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSTATUSled |= (1 << bnSTATUSled);
    34a8:	88 e2       	ldi	r24, 0x28	; 40
    34aa:	90 e0       	ldi	r25, 0x00	; 0
    34ac:	28 e2       	ldi	r18, 0x28	; 40
    34ae:	30 e0       	ldi	r19, 0x00	; 0
    34b0:	f9 01       	movw	r30, r18
    34b2:	20 81       	ld	r18, Z
    34b4:	24 60       	ori	r18, 0x04	; 4
    34b6:	fc 01       	movw	r30, r24
    34b8:	20 83       	st	Z, r18
}
    34ba:	0f 90       	pop	r0
    34bc:	0f 90       	pop	r0
    34be:	0f 90       	pop	r0
    34c0:	0f 90       	pop	r0
    34c2:	0f 90       	pop	r0
    34c4:	df 91       	pop	r29
    34c6:	cf 91       	pop	r28
    34c8:	08 95       	ret

000034ca <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    34ca:	cf 93       	push	r28
    34cc:	df 93       	push	r29
    34ce:	cd b7       	in	r28, 0x3d	; 61
    34d0:	de b7       	in	r29, 0x3e	; 62
    34d2:	2e 97       	sbiw	r28, 0x0e	; 14
    34d4:	0f b6       	in	r0, 0x3f	; 63
    34d6:	f8 94       	cli
    34d8:	de bf       	out	0x3e, r29	; 62
    34da:	0f be       	out	0x3f, r0	; 63
    34dc:	cd bf       	out	0x3d, r28	; 61
	WORD adcReading = 0;
    34de:	1c 82       	std	Y+4, r1	; 0x04
    34e0:	1b 82       	std	Y+3, r1	; 0x03
	
	prtInterrupts |= (1 << bnBBint);
    34e2:	82 e2       	ldi	r24, 0x22	; 34
    34e4:	90 e0       	ldi	r25, 0x00	; 0
    34e6:	22 e2       	ldi	r18, 0x22	; 34
    34e8:	30 e0       	ldi	r19, 0x00	; 0
    34ea:	f9 01       	movw	r30, r18
    34ec:	20 81       	ld	r18, Z
    34ee:	24 60       	ori	r18, 0x04	; 4
    34f0:	fc 01       	movw	r30, r24
    34f2:	20 83       	st	Z, r18
	
	__killCommINT();
    34f4:	8d e3       	ldi	r24, 0x3D	; 61
    34f6:	90 e0       	ldi	r25, 0x00	; 0
    34f8:	fc 01       	movw	r30, r24
    34fa:	10 82       	st	Z, r1
    34fc:	8d e6       	ldi	r24, 0x6D	; 109
    34fe:	90 e0       	ldi	r25, 0x00	; 0
    3500:	fc 01       	movw	r30, r24
    3502:	10 82       	st	Z, r1
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    3504:	84 e6       	ldi	r24, 0x64	; 100
    3506:	90 e0       	ldi	r25, 0x00	; 0
    3508:	24 e6       	ldi	r18, 0x64	; 100
    350a:	30 e0       	ldi	r19, 0x00	; 0
    350c:	f9 01       	movw	r30, r18
    350e:	20 81       	ld	r18, Z
    3510:	2e 7f       	andi	r18, 0xFE	; 254
    3512:	fc 01       	movw	r30, r24
    3514:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    3516:	8c e7       	ldi	r24, 0x7C	; 124
    3518:	90 e0       	ldi	r25, 0x00	; 0
    351a:	2c e7       	ldi	r18, 0x7C	; 124
    351c:	30 e0       	ldi	r19, 0x00	; 0
    351e:	f9 01       	movw	r30, r18
    3520:	20 81       	ld	r18, Z
    3522:	20 68       	ori	r18, 0x80	; 128
    3524:	fc 01       	movw	r30, r24
    3526:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    3528:	8a e7       	ldi	r24, 0x7A	; 122
    352a:	90 e0       	ldi	r25, 0x00	; 0
    352c:	2a e7       	ldi	r18, 0x7A	; 122
    352e:	30 e0       	ldi	r19, 0x00	; 0
    3530:	f9 01       	movw	r30, r18
    3532:	20 81       	ld	r18, Z
    3534:	24 68       	ori	r18, 0x84	; 132
    3536:	fc 01       	movw	r30, r24
    3538:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    353a:	8e e7       	ldi	r24, 0x7E	; 126
    353c:	90 e0       	ldi	r25, 0x00	; 0
    353e:	2e ef       	ldi	r18, 0xFE	; 254
    3540:	fc 01       	movw	r30, r24
    3542:	20 83       	st	Z, r18
	Wait_ms(2);									//Tim for registers to setup
    3544:	82 e0       	ldi	r24, 0x02	; 2
    3546:	90 e0       	ldi	r25, 0x00	; 0
    3548:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
	
	//cli();
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    354c:	1a 82       	std	Y+2, r1	; 0x02
    354e:	19 82       	std	Y+1, r1	; 0x01
    3550:	1c c0       	rjmp	.+56     	; 0x358a <_Z7TakeADCv+0xc0>
    3552:	8a e7       	ldi	r24, 0x7A	; 122
    3554:	90 e0       	ldi	r25, 0x00	; 0
    3556:	2a e7       	ldi	r18, 0x7A	; 122
    3558:	30 e0       	ldi	r19, 0x00	; 0
    355a:	f9 01       	movw	r30, r18
    355c:	20 81       	ld	r18, Z
    355e:	20 64       	ori	r18, 0x40	; 64
    3560:	fc 01       	movw	r30, r24
    3562:	20 83       	st	Z, r18
    3564:	8a e7       	ldi	r24, 0x7A	; 122
    3566:	90 e0       	ldi	r25, 0x00	; 0
    3568:	fc 01       	movw	r30, r24
    356a:	80 81       	ld	r24, Z
    356c:	88 2f       	mov	r24, r24
    356e:	90 e0       	ldi	r25, 0x00	; 0
    3570:	80 74       	andi	r24, 0x40	; 64
    3572:	90 70       	andi	r25, 0x00	; 0
    3574:	21 e0       	ldi	r18, 0x01	; 1
    3576:	00 97       	sbiw	r24, 0x00	; 0
    3578:	09 f4       	brne	.+2      	; 0x357c <_Z7TakeADCv+0xb2>
    357a:	20 e0       	ldi	r18, 0x00	; 0
    357c:	22 23       	and	r18, r18
    357e:	91 f7       	brne	.-28     	; 0x3564 <_Z7TakeADCv+0x9a>
    3580:	89 81       	ldd	r24, Y+1	; 0x01
    3582:	9a 81       	ldd	r25, Y+2	; 0x02
    3584:	01 96       	adiw	r24, 0x01	; 1
    3586:	9a 83       	std	Y+2, r25	; 0x02
    3588:	89 83       	std	Y+1, r24	; 0x01
    358a:	21 e0       	ldi	r18, 0x01	; 1
    358c:	89 81       	ldd	r24, Y+1	; 0x01
    358e:	9a 81       	ldd	r25, Y+2	; 0x02
    3590:	82 30       	cpi	r24, 0x02	; 2
    3592:	91 05       	cpc	r25, r1
    3594:	0c f0       	brlt	.+2      	; 0x3598 <_Z7TakeADCv+0xce>
    3596:	20 e0       	ldi	r18, 0x00	; 0
    3598:	22 23       	and	r18, r18
    359a:	d9 f6       	brne	.-74     	; 0x3552 <_Z7TakeADCv+0x88>
	
	//Re-enable interrupts	
	//sei();
	
	//Put conversion into buffer
	adcReading = ADCL;
    359c:	88 e7       	ldi	r24, 0x78	; 120
    359e:	90 e0       	ldi	r25, 0x00	; 0
    35a0:	fc 01       	movw	r30, r24
    35a2:	80 81       	ld	r24, Z
    35a4:	88 2f       	mov	r24, r24
    35a6:	90 e0       	ldi	r25, 0x00	; 0
    35a8:	9c 83       	std	Y+4, r25	; 0x04
    35aa:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    35ac:	89 e7       	ldi	r24, 0x79	; 121
    35ae:	90 e0       	ldi	r25, 0x00	; 0
    35b0:	fc 01       	movw	r30, r24
    35b2:	80 81       	ld	r24, Z
    35b4:	88 2f       	mov	r24, r24
    35b6:	90 e0       	ldi	r25, 0x00	; 0
    35b8:	98 2f       	mov	r25, r24
    35ba:	88 27       	eor	r24, r24
    35bc:	2b 81       	ldd	r18, Y+3	; 0x03
    35be:	3c 81       	ldd	r19, Y+4	; 0x04
    35c0:	82 2b       	or	r24, r18
    35c2:	93 2b       	or	r25, r19
    35c4:	9c 83       	std	Y+4, r25	; 0x04
    35c6:	8b 83       	std	Y+3, r24	; 0x03
		
	//Assign global reading and set flag
	globalADC=adcReading;
    35c8:	8b 81       	ldd	r24, Y+3	; 0x03
    35ca:	9c 81       	ldd	r25, Y+4	; 0x04
    35cc:	90 93 df 01 	sts	0x01DF, r25
    35d0:	80 93 de 01 	sts	0x01DE, r24
	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    35d4:	21 e0       	ldi	r18, 0x01	; 1
    35d6:	8b 81       	ldd	r24, Y+3	; 0x03
    35d8:	9c 81       	ldd	r25, Y+4	; 0x04
    35da:	f3 e0       	ldi	r31, 0x03	; 3
    35dc:	82 37       	cpi	r24, 0x72	; 114
    35de:	9f 07       	cpc	r25, r31
    35e0:	08 f4       	brcc	.+2      	; 0x35e4 <_Z7TakeADCv+0x11a>
    35e2:	20 e0       	ldi	r18, 0x00	; 0
    35e4:	20 93 1a 02 	sts	0x021A, r18
		
	//Disable ADC hardware/registers
	ADCSRA = 0;
    35e8:	8a e7       	ldi	r24, 0x7A	; 122
    35ea:	90 e0       	ldi	r25, 0x00	; 0
    35ec:	fc 01       	movw	r30, r24
    35ee:	10 82       	st	Z, r1
	ADMUX = 0;
    35f0:	8c e7       	ldi	r24, 0x7C	; 124
    35f2:	90 e0       	ldi	r25, 0x00	; 0
    35f4:	fc 01       	movw	r30, r24
    35f6:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    35f8:	8e e7       	ldi	r24, 0x7E	; 126
    35fa:	90 e0       	ldi	r25, 0x00	; 0
    35fc:	2e e7       	ldi	r18, 0x7E	; 126
    35fe:	30 e0       	ldi	r19, 0x00	; 0
    3600:	f9 01       	movw	r30, r18
    3602:	20 81       	ld	r18, Z
    3604:	21 60       	ori	r18, 0x01	; 1
    3606:	fc 01       	movw	r30, r24
    3608:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    360a:	84 e6       	ldi	r24, 0x64	; 100
    360c:	90 e0       	ldi	r25, 0x00	; 0
    360e:	24 e6       	ldi	r18, 0x64	; 100
    3610:	30 e0       	ldi	r19, 0x00	; 0
    3612:	f9 01       	movw	r30, r18
    3614:	20 81       	ld	r18, Z
    3616:	21 60       	ori	r18, 0x01	; 1
    3618:	fc 01       	movw	r30, r24
    361a:	20 83       	st	Z, r18

	char tempString[10];
	itoa(globalADC,tempString,10);
    361c:	80 91 de 01 	lds	r24, 0x01DE
    3620:	90 91 df 01 	lds	r25, 0x01DF
    3624:	9e 01       	movw	r18, r28
    3626:	2b 5f       	subi	r18, 0xFB	; 251
    3628:	3f 4f       	sbci	r19, 0xFF	; 255
    362a:	b9 01       	movw	r22, r18
    362c:	4a e0       	ldi	r20, 0x0A	; 10
    362e:	50 e0       	ldi	r21, 0x00	; 0
    3630:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <itoa>
	tempString[9]='\0';
    3634:	1e 86       	std	Y+14, r1	; 0x0e
	//PrintBone("ADC: ");
	//PrintBone(tempString);
	prtInterrupts &= ~(1 << bnBBint);
    3636:	82 e2       	ldi	r24, 0x22	; 34
    3638:	90 e0       	ldi	r25, 0x00	; 0
    363a:	22 e2       	ldi	r18, 0x22	; 34
    363c:	30 e0       	ldi	r19, 0x00	; 0
    363e:	f9 01       	movw	r30, r18
    3640:	20 81       	ld	r18, Z
    3642:	2b 7f       	andi	r18, 0xFB	; 251
    3644:	fc 01       	movw	r30, r24
    3646:	20 83       	st	Z, r18
	__enableCommINT();
    3648:	8d e3       	ldi	r24, 0x3D	; 61
    364a:	90 e0       	ldi	r25, 0x00	; 0
    364c:	2d e3       	ldi	r18, 0x3D	; 61
    364e:	30 e0       	ldi	r19, 0x00	; 0
    3650:	f9 01       	movw	r30, r18
    3652:	20 81       	ld	r18, Z
    3654:	24 60       	ori	r18, 0x04	; 4
    3656:	fc 01       	movw	r30, r24
    3658:	20 83       	st	Z, r18
    365a:	8d e6       	ldi	r24, 0x6D	; 109
    365c:	90 e0       	ldi	r25, 0x00	; 0
    365e:	22 e0       	ldi	r18, 0x02	; 2
    3660:	fc 01       	movw	r30, r24
    3662:	20 83       	st	Z, r18
}
    3664:	2e 96       	adiw	r28, 0x0e	; 14
    3666:	0f b6       	in	r0, 0x3f	; 63
    3668:	f8 94       	cli
    366a:	de bf       	out	0x3e, r29	; 62
    366c:	0f be       	out	0x3f, r0	; 63
    366e:	cd bf       	out	0x3d, r28	; 61
    3670:	df 91       	pop	r29
    3672:	cf 91       	pop	r28
    3674:	08 95       	ret

00003676 <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    3676:	cf 93       	push	r28
    3678:	df 93       	push	r29
    367a:	cd b7       	in	r28, 0x3d	; 61
    367c:	de b7       	in	r29, 0x3e	; 62
    367e:	2b 97       	sbiw	r28, 0x0b	; 11
    3680:	0f b6       	in	r0, 0x3f	; 63
    3682:	f8 94       	cli
    3684:	de bf       	out	0x3e, r29	; 62
    3686:	0f be       	out	0x3f, r0	; 63
    3688:	cd bf       	out	0x3d, r28	; 61
	WORD rawTemp = 0;
    368a:	1a 82       	std	Y+2, r1	; 0x02
    368c:	19 82       	std	Y+1, r1	; 0x01

	__killCommINT();
    368e:	8d e3       	ldi	r24, 0x3D	; 61
    3690:	90 e0       	ldi	r25, 0x00	; 0
    3692:	fc 01       	movw	r30, r24
    3694:	10 82       	st	Z, r1
    3696:	8d e6       	ldi	r24, 0x6D	; 109
    3698:	90 e0       	ldi	r25, 0x00	; 0
    369a:	fc 01       	movw	r30, r24
    369c:	10 82       	st	Z, r1

	PRR0 &= ~(1 << PRSPI);	
    369e:	84 e6       	ldi	r24, 0x64	; 100
    36a0:	90 e0       	ldi	r25, 0x00	; 0
    36a2:	24 e6       	ldi	r18, 0x64	; 100
    36a4:	30 e0       	ldi	r19, 0x00	; 0
    36a6:	f9 01       	movw	r30, r18
    36a8:	20 81       	ld	r18, Z
    36aa:	2b 7f       	andi	r18, 0xFB	; 251
    36ac:	fc 01       	movw	r30, r24
    36ae:	20 83       	st	Z, r18
	SPCR |= (1 << MSTR)|(1 << SPE)|(1 << SPR0);			//enables SPI, master, fck/64
    36b0:	8c e4       	ldi	r24, 0x4C	; 76
    36b2:	90 e0       	ldi	r25, 0x00	; 0
    36b4:	2c e4       	ldi	r18, 0x4C	; 76
    36b6:	30 e0       	ldi	r19, 0x00	; 0
    36b8:	f9 01       	movw	r30, r18
    36ba:	20 81       	ld	r18, Z
    36bc:	21 65       	ori	r18, 0x51	; 81
    36be:	fc 01       	movw	r30, r24
    36c0:	20 83       	st	Z, r18
	Wait_sec(2);
    36c2:	82 e0       	ldi	r24, 0x02	; 2
    36c4:	90 e0       	ldi	r25, 0x00	; 0
    36c6:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    36ca:	85 e2       	ldi	r24, 0x25	; 37
    36cc:	90 e0       	ldi	r25, 0x00	; 0
    36ce:	25 e2       	ldi	r18, 0x25	; 37
    36d0:	30 e0       	ldi	r19, 0x00	; 0
    36d2:	f9 01       	movw	r30, r18
    36d4:	20 81       	ld	r18, Z
    36d6:	2f 76       	andi	r18, 0x6F	; 111
    36d8:	fc 01       	movw	r30, r24
    36da:	20 83       	st	Z, r18
	
	cli();
    36dc:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR = 0x00;
    36de:	8e e4       	ldi	r24, 0x4E	; 78
    36e0:	90 e0       	ldi	r25, 0x00	; 0
    36e2:	fc 01       	movw	r30, r24
    36e4:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR & (1 << SPIF)));
    36e6:	00 00       	nop
    36e8:	8d e4       	ldi	r24, 0x4D	; 77
    36ea:	90 e0       	ldi	r25, 0x00	; 0
    36ec:	fc 01       	movw	r30, r24
    36ee:	80 81       	ld	r24, Z
    36f0:	80 95       	com	r24
    36f2:	88 1f       	adc	r24, r24
    36f4:	88 27       	eor	r24, r24
    36f6:	88 1f       	adc	r24, r24
    36f8:	88 23       	and	r24, r24
    36fa:	b1 f7       	brne	.-20     	; 0x36e8 <_Z7GetTempv+0x72>
	rawTemp = (SPDR0 << 8);
    36fc:	1a 82       	std	Y+2, r1	; 0x02
    36fe:	19 82       	std	Y+1, r1	; 0x01
	SPDR = 0x00;
    3700:	8e e4       	ldi	r24, 0x4E	; 78
    3702:	90 e0       	ldi	r25, 0x00	; 0
    3704:	fc 01       	movw	r30, r24
    3706:	10 82       	st	Z, r1
	while (!(SPSR & (1 << SPIF)));
    3708:	00 00       	nop
    370a:	8d e4       	ldi	r24, 0x4D	; 77
    370c:	90 e0       	ldi	r25, 0x00	; 0
    370e:	fc 01       	movw	r30, r24
    3710:	80 81       	ld	r24, Z
    3712:	80 95       	com	r24
    3714:	88 1f       	adc	r24, r24
    3716:	88 27       	eor	r24, r24
    3718:	88 1f       	adc	r24, r24
    371a:	88 23       	and	r24, r24
    371c:	b1 f7       	brne	.-20     	; 0x370a <_Z7GetTempv+0x94>
	rawTemp |= SPDR0;
	
	//Set flag to correct value, update global value
	//flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
	globalTemp=rawTemp;
    371e:	89 81       	ldd	r24, Y+1	; 0x01
    3720:	9a 81       	ldd	r25, Y+2	; 0x02
    3722:	90 93 e1 01 	sts	0x01E1, r25
    3726:	80 93 e0 01 	sts	0x01E0, r24
	
	//re enable interrupts
	sei();
    372a:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    372c:	85 e2       	ldi	r24, 0x25	; 37
    372e:	90 e0       	ldi	r25, 0x00	; 0
    3730:	25 e2       	ldi	r18, 0x25	; 37
    3732:	30 e0       	ldi	r19, 0x00	; 0
    3734:	f9 01       	movw	r30, r18
    3736:	20 81       	ld	r18, Z
    3738:	20 69       	ori	r18, 0x90	; 144
    373a:	fc 01       	movw	r30, r24
    373c:	20 83       	st	Z, r18
	SPCR=0x00;	
    373e:	8c e4       	ldi	r24, 0x4C	; 76
    3740:	90 e0       	ldi	r25, 0x00	; 0
    3742:	fc 01       	movw	r30, r24
    3744:	10 82       	st	Z, r1
	//__killTemp();
	PRR0 |= (1 << PRSPI);
    3746:	84 e6       	ldi	r24, 0x64	; 100
    3748:	90 e0       	ldi	r25, 0x00	; 0
    374a:	24 e6       	ldi	r18, 0x64	; 100
    374c:	30 e0       	ldi	r19, 0x00	; 0
    374e:	f9 01       	movw	r30, r18
    3750:	20 81       	ld	r18, Z
    3752:	24 60       	ori	r18, 0x04	; 4
    3754:	fc 01       	movw	r30, r24
    3756:	20 83       	st	Z, r18
	
	char tempString[9];
	itoa(globalTemp,tempString,10);
    3758:	80 91 e0 01 	lds	r24, 0x01E0
    375c:	90 91 e1 01 	lds	r25, 0x01E1
    3760:	9e 01       	movw	r18, r28
    3762:	2d 5f       	subi	r18, 0xFD	; 253
    3764:	3f 4f       	sbci	r19, 0xFF	; 255
    3766:	b9 01       	movw	r22, r18
    3768:	4a e0       	ldi	r20, 0x0A	; 10
    376a:	50 e0       	ldi	r21, 0x00	; 0
    376c:	0e 94 1e 1d 	call	0x3a3c	; 0x3a3c <itoa>
	tempString[8]='\0';
    3770:	1b 86       	std	Y+11, r1	; 0x0b

	__enableCommINT();
    3772:	8d e3       	ldi	r24, 0x3D	; 61
    3774:	90 e0       	ldi	r25, 0x00	; 0
    3776:	2d e3       	ldi	r18, 0x3D	; 61
    3778:	30 e0       	ldi	r19, 0x00	; 0
    377a:	f9 01       	movw	r30, r18
    377c:	20 81       	ld	r18, Z
    377e:	24 60       	ori	r18, 0x04	; 4
    3780:	fc 01       	movw	r30, r24
    3782:	20 83       	st	Z, r18
    3784:	8d e6       	ldi	r24, 0x6D	; 109
    3786:	90 e0       	ldi	r25, 0x00	; 0
    3788:	22 e0       	ldi	r18, 0x02	; 2
    378a:	fc 01       	movw	r30, r24
    378c:	20 83       	st	Z, r18
}
    378e:	2b 96       	adiw	r28, 0x0b	; 11
    3790:	0f b6       	in	r0, 0x3f	; 63
    3792:	f8 94       	cli
    3794:	de bf       	out	0x3e, r29	; 62
    3796:	0f be       	out	0x3f, r0	; 63
    3798:	cd bf       	out	0x3d, r28	; 61
    379a:	df 91       	pop	r29
    379c:	cf 91       	pop	r28
    379e:	08 95       	ret

000037a0 <_Z7PowerUpj>:
/*************************************************************************************************************/
void PowerUp(WORD interval){
    37a0:	cf 93       	push	r28
    37a2:	df 93       	push	r29
    37a4:	00 d0       	rcall	.+0      	; 0x37a6 <_Z7PowerUpj+0x6>
    37a6:	cd b7       	in	r28, 0x3d	; 61
    37a8:	de b7       	in	r29, 0x3e	; 62
    37aa:	9a 83       	std	Y+2, r25	; 0x02
    37ac:	89 83       	std	Y+1, r24	; 0x01
	__killCommINT();
    37ae:	8d e3       	ldi	r24, 0x3D	; 61
    37b0:	90 e0       	ldi	r25, 0x00	; 0
    37b2:	fc 01       	movw	r30, r24
    37b4:	10 82       	st	Z, r1
    37b6:	8d e6       	ldi	r24, 0x6D	; 109
    37b8:	90 e0       	ldi	r25, 0x00	; 0
    37ba:	fc 01       	movw	r30, r24
    37bc:	10 82       	st	Z, r1
	
	//First power on main regulator
	__enableMain();
    37be:	88 e2       	ldi	r24, 0x28	; 40
    37c0:	90 e0       	ldi	r25, 0x00	; 0
    37c2:	28 e2       	ldi	r18, 0x28	; 40
    37c4:	30 e0       	ldi	r19, 0x00	; 0
    37c6:	f9 01       	movw	r30, r18
    37c8:	20 81       	ld	r18, Z
    37ca:	21 60       	ori	r18, 0x01	; 1
    37cc:	fc 01       	movw	r30, r24
    37ce:	20 83       	st	Z, r18
	Wait_sec(interval);
    37d0:	89 81       	ldd	r24, Y+1	; 0x01
    37d2:	9a 81       	ldd	r25, Y+2	; 0x02
    37d4:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	
	//Power on BeagleBone next, takes longer time.
	__enableBeagleBone();
    37d8:	82 e2       	ldi	r24, 0x22	; 34
    37da:	90 e0       	ldi	r25, 0x00	; 0
    37dc:	22 e2       	ldi	r18, 0x22	; 34
    37de:	30 e0       	ldi	r19, 0x00	; 0
    37e0:	f9 01       	movw	r30, r18
    37e2:	20 81       	ld	r18, Z
    37e4:	20 61       	ori	r18, 0x10	; 16
    37e6:	fc 01       	movw	r30, r24
    37e8:	20 83       	st	Z, r18
	Wait_sec(interval*2);
    37ea:	89 81       	ldd	r24, Y+1	; 0x01
    37ec:	9a 81       	ldd	r25, Y+2	; 0x02
    37ee:	88 0f       	add	r24, r24
    37f0:	99 1f       	adc	r25, r25
    37f2:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	//while (!(pinBBio & (1 << bnW0B9)));	//Wait for GPIO line to go high
	
	//Power on GAVR and Enable GPS
	__enableGPSandGAVR();
    37f6:	82 e2       	ldi	r24, 0x22	; 34
    37f8:	90 e0       	ldi	r25, 0x00	; 0
    37fa:	22 e2       	ldi	r18, 0x22	; 34
    37fc:	30 e0       	ldi	r19, 0x00	; 0
    37fe:	f9 01       	movw	r30, r18
    3800:	20 81       	ld	r18, Z
    3802:	20 6c       	ori	r18, 0xC0	; 192
    3804:	fc 01       	movw	r30, r24
    3806:	20 83       	st	Z, r18
	//Wait_sec(interval);
	//while (!(pinGAVRio & (1 << bnW3G0)));	//Wait for GPIO line to go high signifying correct boot

	//Power on LCD
	__enableLCD();
    3808:	82 e2       	ldi	r24, 0x22	; 34
    380a:	90 e0       	ldi	r25, 0x00	; 0
    380c:	22 e2       	ldi	r18, 0x22	; 34
    380e:	30 e0       	ldi	r19, 0x00	; 0
    3810:	f9 01       	movw	r30, r18
    3812:	20 81       	ld	r18, Z
    3814:	20 62       	ori	r18, 0x20	; 32
    3816:	fc 01       	movw	r30, r24
    3818:	20 83       	st	Z, r18
	Wait_sec(interval);
    381a:	89 81       	ldd	r24, Y+1	; 0x01
    381c:	9a 81       	ldd	r25, Y+2	; 0x02
    381e:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	
	__enableCommINT();
    3822:	8d e3       	ldi	r24, 0x3D	; 61
    3824:	90 e0       	ldi	r25, 0x00	; 0
    3826:	2d e3       	ldi	r18, 0x3D	; 61
    3828:	30 e0       	ldi	r19, 0x00	; 0
    382a:	f9 01       	movw	r30, r18
    382c:	20 81       	ld	r18, Z
    382e:	24 60       	ori	r18, 0x04	; 4
    3830:	fc 01       	movw	r30, r24
    3832:	20 83       	st	Z, r18
    3834:	8d e6       	ldi	r24, 0x6D	; 109
    3836:	90 e0       	ldi	r25, 0x00	; 0
    3838:	22 e0       	ldi	r18, 0x02	; 2
    383a:	fc 01       	movw	r30, r24
    383c:	20 83       	st	Z, r18
	
}
    383e:	0f 90       	pop	r0
    3840:	0f 90       	pop	r0
    3842:	df 91       	pop	r29
    3844:	cf 91       	pop	r28
    3846:	08 95       	ret

00003848 <_Z9PowerDownv>:
/*************************************************************************************************************/
void PowerDown(){
    3848:	cf 93       	push	r28
    384a:	df 93       	push	r29
    384c:	cd b7       	in	r28, 0x3d	; 61
    384e:	de b7       	in	r29, 0x3e	; 62
	__killCommINT();
    3850:	8d e3       	ldi	r24, 0x3D	; 61
    3852:	90 e0       	ldi	r25, 0x00	; 0
    3854:	fc 01       	movw	r30, r24
    3856:	10 82       	st	Z, r1
    3858:	8d e6       	ldi	r24, 0x6D	; 109
    385a:	90 e0       	ldi	r25, 0x00	; 0
    385c:	fc 01       	movw	r30, r24
    385e:	10 82       	st	Z, r1

	//Signify interrupts, wait 6 seconds for all processing to stop.
	prtInterrupts |= (1 << bnBBint)|(1 << bnGAVRint);
    3860:	82 e2       	ldi	r24, 0x22	; 34
    3862:	90 e0       	ldi	r25, 0x00	; 0
    3864:	22 e2       	ldi	r18, 0x22	; 34
    3866:	30 e0       	ldi	r19, 0x00	; 0
    3868:	f9 01       	movw	r30, r18
    386a:	20 81       	ld	r18, Z
    386c:	2c 60       	ori	r18, 0x0C	; 12
    386e:	fc 01       	movw	r30, r24
    3870:	20 83       	st	Z, r18
	Wait_sec(6);
    3872:	86 e0       	ldi	r24, 0x06	; 6
    3874:	90 e0       	ldi	r25, 0x00	; 0
    3876:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	prtInterrupts &= ~((1 << bnBBint)|(1 << bnGAVRint));
    387a:	82 e2       	ldi	r24, 0x22	; 34
    387c:	90 e0       	ldi	r25, 0x00	; 0
    387e:	22 e2       	ldi	r18, 0x22	; 34
    3880:	30 e0       	ldi	r19, 0x00	; 0
    3882:	f9 01       	movw	r30, r18
    3884:	20 81       	ld	r18, Z
    3886:	23 7f       	andi	r18, 0xF3	; 243
    3888:	fc 01       	movw	r30, r24
    388a:	20 83       	st	Z, r18
	__killLCD();
    388c:	82 e2       	ldi	r24, 0x22	; 34
    388e:	90 e0       	ldi	r25, 0x00	; 0
    3890:	22 e2       	ldi	r18, 0x22	; 34
    3892:	30 e0       	ldi	r19, 0x00	; 0
    3894:	f9 01       	movw	r30, r18
    3896:	20 81       	ld	r18, Z
    3898:	2f 7d       	andi	r18, 0xDF	; 223
    389a:	fc 01       	movw	r30, r24
    389c:	20 83       	st	Z, r18
	__killGPSandGAVR();
    389e:	82 e2       	ldi	r24, 0x22	; 34
    38a0:	90 e0       	ldi	r25, 0x00	; 0
    38a2:	22 e2       	ldi	r18, 0x22	; 34
    38a4:	30 e0       	ldi	r19, 0x00	; 0
    38a6:	f9 01       	movw	r30, r18
    38a8:	20 81       	ld	r18, Z
    38aa:	2f 73       	andi	r18, 0x3F	; 63
    38ac:	fc 01       	movw	r30, r24
    38ae:	20 83       	st	Z, r18
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
    38b0:	86 e0       	ldi	r24, 0x06	; 6
    38b2:	90 e0       	ldi	r25, 0x00	; 0
    38b4:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	__killBeagleBone();
    38b8:	82 e2       	ldi	r24, 0x22	; 34
    38ba:	90 e0       	ldi	r25, 0x00	; 0
    38bc:	22 e2       	ldi	r18, 0x22	; 34
    38be:	30 e0       	ldi	r19, 0x00	; 0
    38c0:	f9 01       	movw	r30, r18
    38c2:	20 81       	ld	r18, Z
    38c4:	2f 7e       	andi	r18, 0xEF	; 239
    38c6:	fc 01       	movw	r30, r24
    38c8:	20 83       	st	Z, r18
	__killMain();
    38ca:	88 e2       	ldi	r24, 0x28	; 40
    38cc:	90 e0       	ldi	r25, 0x00	; 0
    38ce:	28 e2       	ldi	r18, 0x28	; 40
    38d0:	30 e0       	ldi	r19, 0x00	; 0
    38d2:	f9 01       	movw	r30, r18
    38d4:	20 81       	ld	r18, Z
    38d6:	2e 7f       	andi	r18, 0xFE	; 254
    38d8:	fc 01       	movw	r30, r24
    38da:	20 83       	st	Z, r18
}
    38dc:	df 91       	pop	r29
    38de:	cf 91       	pop	r28
    38e0:	08 95       	ret

000038e2 <_Z41__static_initialization_and_destruction_0ii>:
    38e2:	cf 93       	push	r28
    38e4:	df 93       	push	r29
    38e6:	00 d0       	rcall	.+0      	; 0x38e8 <_Z41__static_initialization_and_destruction_0ii+0x6>
    38e8:	00 d0       	rcall	.+0      	; 0x38ea <_Z41__static_initialization_and_destruction_0ii+0x8>
    38ea:	cd b7       	in	r28, 0x3d	; 61
    38ec:	de b7       	in	r29, 0x3e	; 62
    38ee:	9a 83       	std	Y+2, r25	; 0x02
    38f0:	89 83       	std	Y+1, r24	; 0x01
    38f2:	7c 83       	std	Y+4, r23	; 0x04
    38f4:	6b 83       	std	Y+3, r22	; 0x03
    38f6:	89 81       	ldd	r24, Y+1	; 0x01
    38f8:	9a 81       	ldd	r25, Y+2	; 0x02
    38fa:	81 30       	cpi	r24, 0x01	; 1
    38fc:	91 05       	cpc	r25, r1
    38fe:	51 f4       	brne	.+20     	; 0x3914 <_Z41__static_initialization_and_destruction_0ii+0x32>
    3900:	8b 81       	ldd	r24, Y+3	; 0x03
    3902:	9c 81       	ldd	r25, Y+4	; 0x04
    3904:	2f ef       	ldi	r18, 0xFF	; 255
    3906:	8f 3f       	cpi	r24, 0xFF	; 255
    3908:	92 07       	cpc	r25, r18
    390a:	21 f4       	brne	.+8      	; 0x3914 <_Z41__static_initialization_and_destruction_0ii+0x32>

/*********************************************GLOBAL VARIABLES***************************************************/
/****************************************************************************************************************/
WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    390c:	82 ee       	ldi	r24, 0xE2	; 226
    390e:	91 e0       	ldi	r25, 0x01	; 1
    3910:	0e 94 10 04 	call	0x820	; 0x820 <_ZN6myTimeC1Ev>
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
	__killBeagleBone();
	__killMain();
}
    3914:	0f 90       	pop	r0
    3916:	0f 90       	pop	r0
    3918:	0f 90       	pop	r0
    391a:	0f 90       	pop	r0
    391c:	df 91       	pop	r29
    391e:	cf 91       	pop	r28
    3920:	08 95       	ret

00003922 <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    3922:	cf 93       	push	r28
    3924:	df 93       	push	r29
    3926:	cd b7       	in	r28, 0x3d	; 61
    3928:	de b7       	in	r29, 0x3e	; 62
    392a:	81 e0       	ldi	r24, 0x01	; 1
    392c:	90 e0       	ldi	r25, 0x00	; 0
    392e:	6f ef       	ldi	r22, 0xFF	; 255
    3930:	7f ef       	ldi	r23, 0xFF	; 255
    3932:	0e 94 71 1c 	call	0x38e2	; 0x38e2 <_Z41__static_initialization_and_destruction_0ii>
    3936:	df 91       	pop	r29
    3938:	cf 91       	pop	r28
    393a:	08 95       	ret

0000393c <__udivmodqi4>:
    393c:	99 1b       	sub	r25, r25
    393e:	79 e0       	ldi	r23, 0x09	; 9
    3940:	04 c0       	rjmp	.+8      	; 0x394a <__udivmodqi4_ep>

00003942 <__udivmodqi4_loop>:
    3942:	99 1f       	adc	r25, r25
    3944:	96 17       	cp	r25, r22
    3946:	08 f0       	brcs	.+2      	; 0x394a <__udivmodqi4_ep>
    3948:	96 1b       	sub	r25, r22

0000394a <__udivmodqi4_ep>:
    394a:	88 1f       	adc	r24, r24
    394c:	7a 95       	dec	r23
    394e:	c9 f7       	brne	.-14     	; 0x3942 <__udivmodqi4_loop>
    3950:	80 95       	com	r24
    3952:	08 95       	ret

00003954 <__divmodhi4>:
    3954:	97 fb       	bst	r25, 7
    3956:	09 2e       	mov	r0, r25
    3958:	07 26       	eor	r0, r23
    395a:	0a d0       	rcall	.+20     	; 0x3970 <__divmodhi4_neg1>
    395c:	77 fd       	sbrc	r23, 7
    395e:	04 d0       	rcall	.+8      	; 0x3968 <__divmodhi4_neg2>
    3960:	0c d0       	rcall	.+24     	; 0x397a <__udivmodhi4>
    3962:	06 d0       	rcall	.+12     	; 0x3970 <__divmodhi4_neg1>
    3964:	00 20       	and	r0, r0
    3966:	1a f4       	brpl	.+6      	; 0x396e <__divmodhi4_exit>

00003968 <__divmodhi4_neg2>:
    3968:	70 95       	com	r23
    396a:	61 95       	neg	r22
    396c:	7f 4f       	sbci	r23, 0xFF	; 255

0000396e <__divmodhi4_exit>:
    396e:	08 95       	ret

00003970 <__divmodhi4_neg1>:
    3970:	f6 f7       	brtc	.-4      	; 0x396e <__divmodhi4_exit>
    3972:	90 95       	com	r25
    3974:	81 95       	neg	r24
    3976:	9f 4f       	sbci	r25, 0xFF	; 255
    3978:	08 95       	ret

0000397a <__udivmodhi4>:
    397a:	aa 1b       	sub	r26, r26
    397c:	bb 1b       	sub	r27, r27
    397e:	51 e1       	ldi	r21, 0x11	; 17
    3980:	07 c0       	rjmp	.+14     	; 0x3990 <__udivmodhi4_ep>

00003982 <__udivmodhi4_loop>:
    3982:	aa 1f       	adc	r26, r26
    3984:	bb 1f       	adc	r27, r27
    3986:	a6 17       	cp	r26, r22
    3988:	b7 07       	cpc	r27, r23
    398a:	10 f0       	brcs	.+4      	; 0x3990 <__udivmodhi4_ep>
    398c:	a6 1b       	sub	r26, r22
    398e:	b7 0b       	sbc	r27, r23

00003990 <__udivmodhi4_ep>:
    3990:	88 1f       	adc	r24, r24
    3992:	99 1f       	adc	r25, r25
    3994:	5a 95       	dec	r21
    3996:	a9 f7       	brne	.-22     	; 0x3982 <__udivmodhi4_loop>
    3998:	80 95       	com	r24
    399a:	90 95       	com	r25
    399c:	bc 01       	movw	r22, r24
    399e:	cd 01       	movw	r24, r26
    39a0:	08 95       	ret

000039a2 <__tablejump2__>:
    39a2:	ee 0f       	add	r30, r30
    39a4:	ff 1f       	adc	r31, r31

000039a6 <__tablejump__>:
    39a6:	05 90       	lpm	r0, Z+
    39a8:	f4 91       	lpm	r31, Z
    39aa:	e0 2d       	mov	r30, r0
    39ac:	09 94       	ijmp

000039ae <atoi>:
    39ae:	fc 01       	movw	r30, r24
    39b0:	88 27       	eor	r24, r24
    39b2:	99 27       	eor	r25, r25
    39b4:	e8 94       	clt
    39b6:	21 91       	ld	r18, Z+
    39b8:	20 32       	cpi	r18, 0x20	; 32
    39ba:	e9 f3       	breq	.-6      	; 0x39b6 <atoi+0x8>
    39bc:	29 30       	cpi	r18, 0x09	; 9
    39be:	10 f0       	brcs	.+4      	; 0x39c4 <atoi+0x16>
    39c0:	2e 30       	cpi	r18, 0x0E	; 14
    39c2:	c8 f3       	brcs	.-14     	; 0x39b6 <atoi+0x8>
    39c4:	2b 32       	cpi	r18, 0x2B	; 43
    39c6:	41 f0       	breq	.+16     	; 0x39d8 <atoi+0x2a>
    39c8:	2d 32       	cpi	r18, 0x2D	; 45
    39ca:	39 f4       	brne	.+14     	; 0x39da <atoi+0x2c>
    39cc:	68 94       	set
    39ce:	04 c0       	rjmp	.+8      	; 0x39d8 <atoi+0x2a>
    39d0:	0e 94 3f 1d 	call	0x3a7e	; 0x3a7e <__mulhi_const_10>
    39d4:	82 0f       	add	r24, r18
    39d6:	91 1d       	adc	r25, r1
    39d8:	21 91       	ld	r18, Z+
    39da:	20 53       	subi	r18, 0x30	; 48
    39dc:	2a 30       	cpi	r18, 0x0A	; 10
    39de:	c0 f3       	brcs	.-16     	; 0x39d0 <atoi+0x22>
    39e0:	1e f4       	brtc	.+6      	; 0x39e8 <atoi+0x3a>
    39e2:	90 95       	com	r25
    39e4:	81 95       	neg	r24
    39e6:	9f 4f       	sbci	r25, 0xFF	; 255
    39e8:	08 95       	ret

000039ea <strcat>:
    39ea:	fb 01       	movw	r30, r22
    39ec:	dc 01       	movw	r26, r24
    39ee:	0d 90       	ld	r0, X+
    39f0:	00 20       	and	r0, r0
    39f2:	e9 f7       	brne	.-6      	; 0x39ee <strcat+0x4>
    39f4:	11 97       	sbiw	r26, 0x01	; 1
    39f6:	01 90       	ld	r0, Z+
    39f8:	0d 92       	st	X+, r0
    39fa:	00 20       	and	r0, r0
    39fc:	e1 f7       	brne	.-8      	; 0x39f6 <strcat+0xc>
    39fe:	08 95       	ret

00003a00 <strcmp>:
    3a00:	fb 01       	movw	r30, r22
    3a02:	dc 01       	movw	r26, r24
    3a04:	8d 91       	ld	r24, X+
    3a06:	01 90       	ld	r0, Z+
    3a08:	80 19       	sub	r24, r0
    3a0a:	01 10       	cpse	r0, r1
    3a0c:	d9 f3       	breq	.-10     	; 0x3a04 <strcmp+0x4>
    3a0e:	99 0b       	sbc	r25, r25
    3a10:	08 95       	ret

00003a12 <strcpy>:
    3a12:	fb 01       	movw	r30, r22
    3a14:	dc 01       	movw	r26, r24
    3a16:	01 90       	ld	r0, Z+
    3a18:	0d 92       	st	X+, r0
    3a1a:	00 20       	and	r0, r0
    3a1c:	e1 f7       	brne	.-8      	; 0x3a16 <strcpy+0x4>
    3a1e:	08 95       	ret

00003a20 <strncmp>:
    3a20:	fb 01       	movw	r30, r22
    3a22:	dc 01       	movw	r26, r24
    3a24:	41 50       	subi	r20, 0x01	; 1
    3a26:	50 40       	sbci	r21, 0x00	; 0
    3a28:	30 f0       	brcs	.+12     	; 0x3a36 <strncmp+0x16>
    3a2a:	8d 91       	ld	r24, X+
    3a2c:	01 90       	ld	r0, Z+
    3a2e:	80 19       	sub	r24, r0
    3a30:	19 f4       	brne	.+6      	; 0x3a38 <strncmp+0x18>
    3a32:	00 20       	and	r0, r0
    3a34:	b9 f7       	brne	.-18     	; 0x3a24 <strncmp+0x4>
    3a36:	88 1b       	sub	r24, r24
    3a38:	99 0b       	sbc	r25, r25
    3a3a:	08 95       	ret

00003a3c <itoa>:
    3a3c:	fb 01       	movw	r30, r22
    3a3e:	9f 01       	movw	r18, r30
    3a40:	e8 94       	clt
    3a42:	42 30       	cpi	r20, 0x02	; 2
    3a44:	c4 f0       	brlt	.+48     	; 0x3a76 <itoa+0x3a>
    3a46:	45 32       	cpi	r20, 0x25	; 37
    3a48:	b4 f4       	brge	.+44     	; 0x3a76 <itoa+0x3a>
    3a4a:	4a 30       	cpi	r20, 0x0A	; 10
    3a4c:	29 f4       	brne	.+10     	; 0x3a58 <itoa+0x1c>
    3a4e:	97 fb       	bst	r25, 7
    3a50:	1e f4       	brtc	.+6      	; 0x3a58 <itoa+0x1c>
    3a52:	90 95       	com	r25
    3a54:	81 95       	neg	r24
    3a56:	9f 4f       	sbci	r25, 0xFF	; 255
    3a58:	64 2f       	mov	r22, r20
    3a5a:	77 27       	eor	r23, r23
    3a5c:	0e 94 bd 1c 	call	0x397a	; 0x397a <__udivmodhi4>
    3a60:	80 5d       	subi	r24, 0xD0	; 208
    3a62:	8a 33       	cpi	r24, 0x3A	; 58
    3a64:	0c f0       	brlt	.+2      	; 0x3a68 <itoa+0x2c>
    3a66:	89 5d       	subi	r24, 0xD9	; 217
    3a68:	81 93       	st	Z+, r24
    3a6a:	cb 01       	movw	r24, r22
    3a6c:	00 97       	sbiw	r24, 0x00	; 0
    3a6e:	a1 f7       	brne	.-24     	; 0x3a58 <itoa+0x1c>
    3a70:	16 f4       	brtc	.+4      	; 0x3a76 <itoa+0x3a>
    3a72:	5d e2       	ldi	r21, 0x2D	; 45
    3a74:	51 93       	st	Z+, r21
    3a76:	10 82       	st	Z, r1
    3a78:	c9 01       	movw	r24, r18
    3a7a:	0c 94 7e 1d 	jmp	0x3afc	; 0x3afc <strrev>

00003a7e <__mulhi_const_10>:
    3a7e:	7a e0       	ldi	r23, 0x0A	; 10
    3a80:	97 9f       	mul	r25, r23
    3a82:	90 2d       	mov	r25, r0
    3a84:	87 9f       	mul	r24, r23
    3a86:	80 2d       	mov	r24, r0
    3a88:	91 0d       	add	r25, r1
    3a8a:	11 24       	eor	r1, r1
    3a8c:	08 95       	ret

00003a8e <utoa>:
    3a8e:	fb 01       	movw	r30, r22
    3a90:	9f 01       	movw	r18, r30
    3a92:	42 30       	cpi	r20, 0x02	; 2
    3a94:	74 f0       	brlt	.+28     	; 0x3ab2 <utoa+0x24>
    3a96:	45 32       	cpi	r20, 0x25	; 37
    3a98:	64 f4       	brge	.+24     	; 0x3ab2 <utoa+0x24>
    3a9a:	64 2f       	mov	r22, r20
    3a9c:	77 27       	eor	r23, r23
    3a9e:	0e 94 bd 1c 	call	0x397a	; 0x397a <__udivmodhi4>
    3aa2:	80 5d       	subi	r24, 0xD0	; 208
    3aa4:	8a 33       	cpi	r24, 0x3A	; 58
    3aa6:	0c f0       	brlt	.+2      	; 0x3aaa <utoa+0x1c>
    3aa8:	89 5d       	subi	r24, 0xD9	; 217
    3aaa:	81 93       	st	Z+, r24
    3aac:	cb 01       	movw	r24, r22
    3aae:	00 97       	sbiw	r24, 0x00	; 0
    3ab0:	a1 f7       	brne	.-24     	; 0x3a9a <utoa+0xc>
    3ab2:	10 82       	st	Z, r1
    3ab4:	c9 01       	movw	r24, r18
    3ab6:	0c 94 7e 1d 	jmp	0x3afc	; 0x3afc <strrev>

00003aba <__eerd_byte_m644pa>:
    3aba:	f9 99       	sbic	0x1f, 1	; 31
    3abc:	fe cf       	rjmp	.-4      	; 0x3aba <__eerd_byte_m644pa>
    3abe:	92 bd       	out	0x22, r25	; 34
    3ac0:	81 bd       	out	0x21, r24	; 33
    3ac2:	f8 9a       	sbi	0x1f, 0	; 31
    3ac4:	99 27       	eor	r25, r25
    3ac6:	80 b5       	in	r24, 0x20	; 32
    3ac8:	08 95       	ret

00003aca <__eerd_word_m644pa>:
    3aca:	a8 e1       	ldi	r26, 0x18	; 24
    3acc:	b0 e0       	ldi	r27, 0x00	; 0
    3ace:	42 e0       	ldi	r20, 0x02	; 2
    3ad0:	50 e0       	ldi	r21, 0x00	; 0
    3ad2:	0c 94 90 1d 	jmp	0x3b20	; 0x3b20 <__eerd_blraw_m644pa>

00003ad6 <__eewr_byte_m644pa>:
    3ad6:	26 2f       	mov	r18, r22

00003ad8 <__eewr_r18_m644pa>:
    3ad8:	f9 99       	sbic	0x1f, 1	; 31
    3ada:	fe cf       	rjmp	.-4      	; 0x3ad8 <__eewr_r18_m644pa>
    3adc:	1f ba       	out	0x1f, r1	; 31
    3ade:	92 bd       	out	0x22, r25	; 34
    3ae0:	81 bd       	out	0x21, r24	; 33
    3ae2:	20 bd       	out	0x20, r18	; 32
    3ae4:	0f b6       	in	r0, 0x3f	; 63
    3ae6:	f8 94       	cli
    3ae8:	fa 9a       	sbi	0x1f, 2	; 31
    3aea:	f9 9a       	sbi	0x1f, 1	; 31
    3aec:	0f be       	out	0x3f, r0	; 63
    3aee:	01 96       	adiw	r24, 0x01	; 1
    3af0:	08 95       	ret

00003af2 <__eewr_word_m644pa>:
    3af2:	0e 94 6b 1d 	call	0x3ad6	; 0x3ad6 <__eewr_byte_m644pa>
    3af6:	27 2f       	mov	r18, r23
    3af8:	0c 94 6c 1d 	jmp	0x3ad8	; 0x3ad8 <__eewr_r18_m644pa>

00003afc <strrev>:
    3afc:	dc 01       	movw	r26, r24
    3afe:	fc 01       	movw	r30, r24
    3b00:	67 2f       	mov	r22, r23
    3b02:	71 91       	ld	r23, Z+
    3b04:	77 23       	and	r23, r23
    3b06:	e1 f7       	brne	.-8      	; 0x3b00 <strrev+0x4>
    3b08:	32 97       	sbiw	r30, 0x02	; 2
    3b0a:	04 c0       	rjmp	.+8      	; 0x3b14 <strrev+0x18>
    3b0c:	7c 91       	ld	r23, X
    3b0e:	6d 93       	st	X+, r22
    3b10:	70 83       	st	Z, r23
    3b12:	62 91       	ld	r22, -Z
    3b14:	ae 17       	cp	r26, r30
    3b16:	bf 07       	cpc	r27, r31
    3b18:	c8 f3       	brcs	.-14     	; 0x3b0c <strrev+0x10>
    3b1a:	08 95       	ret

00003b1c <__eerd_block_m644pa>:
    3b1c:	dc 01       	movw	r26, r24
    3b1e:	cb 01       	movw	r24, r22

00003b20 <__eerd_blraw_m644pa>:
    3b20:	fc 01       	movw	r30, r24
    3b22:	f9 99       	sbic	0x1f, 1	; 31
    3b24:	fe cf       	rjmp	.-4      	; 0x3b22 <__eerd_blraw_m644pa+0x2>
    3b26:	06 c0       	rjmp	.+12     	; 0x3b34 <__eerd_blraw_m644pa+0x14>
    3b28:	f2 bd       	out	0x22, r31	; 34
    3b2a:	e1 bd       	out	0x21, r30	; 33
    3b2c:	f8 9a       	sbi	0x1f, 0	; 31
    3b2e:	31 96       	adiw	r30, 0x01	; 1
    3b30:	00 b4       	in	r0, 0x20	; 32
    3b32:	0d 92       	st	X+, r0
    3b34:	41 50       	subi	r20, 0x01	; 1
    3b36:	50 40       	sbci	r21, 0x00	; 0
    3b38:	b8 f7       	brcc	.-18     	; 0x3b28 <__eerd_blraw_m644pa+0x8>
    3b3a:	08 95       	ret

00003b3c <_exit>:
    3b3c:	f8 94       	cli

00003b3e <__stop_program>:
    3b3e:	ff cf       	rjmp	.-2      	; 0x3b3e <__stop_program>
