
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800100  00003f30  00003fe4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003f30  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000048  0080018e  0080018e  00004072  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  00004072  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00002160  00000000  00000000  0000407c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000ae4  00000000  00000000  000061dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  00006cc0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000023dc  00000000  00000000  00006de0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000003ec  00000000  00000000  000091bc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000110f  00000000  00000000  000095a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008bc  00000000  00000000  0000a6b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b68  00000000  00000000  0000af74  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001262  00000000  00000000  0000badc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  0000cd3e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 25 15 	jmp	0x2a4a	; 0x2a4a <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 ce 14 	jmp	0x299c	; 0x299c <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 d5 15 	jmp	0x2baa	; 0x2baa <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 6f 15 	jmp	0x2ade	; 0x2ade <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 a2 15 	jmp	0x2b44	; 0x2b44 <__vector_28>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	7d 1d       	adc	r23, r13

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d0 e1       	ldi	r29, 0x10	; 16
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	e0 e3       	ldi	r30, 0x30	; 48
      92:	ff e3       	ldi	r31, 0x3F	; 63
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	ae 38       	cpi	r26, 0x8E	; 142
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	ae e8       	ldi	r26, 0x8E	; 142
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	a6 3d       	cpi	r26, 0xD6	; 214
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 cb 1e 	call	0x3d96	; 0x3d96 <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 71 17 	call	0x2ee2	; 0x2ee2 <main>
      ca:	0c 94 96 1f 	jmp	0x3f2c	; 0x3f2c <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate17checkValidityDateEv>:

BOOL myDate::checkValidityDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	00 d0       	rcall	.+0      	; 0x60a <_ZN6myDate17checkValidityDateEv+0x6>
     60a:	0f 92       	push	r0
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	9b 83       	std	Y+3, r25	; 0x03
     612:	8a 83       	std	Y+2, r24	; 0x02
	BOOL checkYear=fFalse;
     614:	19 82       	std	Y+1, r1	; 0x01
	if (month/13==0){
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	9b 81       	ldd	r25, Y+3	; 0x03
     61a:	fc 01       	movw	r30, r24
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	0c 96       	adiw	r24, 0x0c	; 12
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	89 31       	cpi	r24, 0x19	; 25
     626:	91 05       	cpc	r25, r1
     628:	08 f0       	brcs	.+2      	; 0x62c <_ZN6myDate17checkValidityDateEv+0x28>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	22 23       	and	r18, r18
     62e:	09 f4       	brne	.+2      	; 0x632 <_ZN6myDate17checkValidityDateEv+0x2e>
     630:	66 c0       	rjmp	.+204    	; 0x6fe <_ZN6myDate17checkValidityDateEv+0xfa>
			if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	89 30       	cpi	r24, 0x09	; 9
     63e:	91 05       	cpc	r25, r1
     640:	81 f0       	breq	.+32     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     642:	8a 81       	ldd	r24, Y+2	; 0x02
     644:	9b 81       	ldd	r25, Y+3	; 0x03
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
     64a:	91 81       	ldd	r25, Z+1	; 0x01
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	91 05       	cpc	r25, r1
     650:	41 f0       	breq	.+16     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	9b 81       	ldd	r25, Y+3	; 0x03
     656:	fc 01       	movw	r30, r24
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	86 30       	cpi	r24, 0x06	; 6
     65e:	91 05       	cpc	r25, r1
     660:	59 f4       	brne	.+22     	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	4e 96       	adiw	r24, 0x1e	; 30
     66e:	8d 33       	cpi	r24, 0x3D	; 61
     670:	91 05       	cpc	r25, r1
     672:	10 f4       	brcc	.+4      	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	01 c0       	rjmp	.+2      	; 0x67a <_ZN6myDate17checkValidityDateEv+0x76>
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	88 23       	and	r24, r24
     67c:	19 f0       	breq	.+6      	; 0x684 <_ZN6myDate17checkValidityDateEv+0x80>
				checkYear=fTrue;
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	89 83       	std	Y+1, r24	; 0x01
     682:	28 c0       	rjmp	.+80     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else if (month == 2 && day/29 == 0){
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	fc 01       	movw	r30, r24
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	91 05       	cpc	r25, r1
     692:	59 f4       	brne	.+22     	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     694:	8a 81       	ldd	r24, Y+2	; 0x02
     696:	9b 81       	ldd	r25, Y+3	; 0x03
     698:	fc 01       	movw	r30, r24
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	4c 96       	adiw	r24, 0x1c	; 28
     6a0:	89 33       	cpi	r24, 0x39	; 57
     6a2:	91 05       	cpc	r25, r1
     6a4:	10 f4       	brcc	.+4      	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_ZN6myDate17checkValidityDateEv+0xa8>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	88 23       	and	r24, r24
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_ZN6myDate17checkValidityDateEv+0xb2>
				checkYear=fTrue;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	89 83       	std	Y+1, r24	; 0x01
     6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else{
				if (day/32 == 0){
     6b6:	8a 81       	ldd	r24, Y+2	; 0x02
     6b8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ba:	fc 01       	movw	r30, r24
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	4f 96       	adiw	r24, 0x1f	; 31
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	8f 33       	cpi	r24, 0x3F	; 63
     6c6:	91 05       	cpc	r25, r1
     6c8:	08 f0       	brcs	.+2      	; 0x6cc <_ZN6myDate17checkValidityDateEv+0xc8>
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	22 23       	and	r18, r18
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
					checkYear=fTrue;
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
			
			//Check year
			if (checkYear && year>=2013){return fTrue;}
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	88 23       	and	r24, r24
     6d8:	59 f0       	breq	.+22     	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	84 81       	ldd	r24, Z+4	; 0x04
     6e2:	95 81       	ldd	r25, Z+5	; 0x05
     6e4:	f7 e0       	ldi	r31, 0x07	; 7
     6e6:	8d 3d       	cpi	r24, 0xDD	; 221
     6e8:	9f 07       	cpc	r25, r31
     6ea:	14 f0       	brlt	.+4      	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <_ZN6myDate17checkValidityDateEv+0xee>
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	88 23       	and	r24, r24
     6f4:	11 f0       	breq	.+4      	; 0x6fa <_ZN6myDate17checkValidityDateEv+0xf6>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	03 c0       	rjmp	.+6      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
			else {return fFalse;}
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
	} else {return fFalse;}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	cd b7       	in	r28, 0x3d	; 61
     712:	de b7       	in	r29, 0x3e	; 62
     714:	2d 97       	sbiw	r28, 0x0d	; 13
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	9d 87       	std	Y+13, r25	; 0x0d
     722:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     724:	8c 85       	ldd	r24, Y+12	; 0x0c
     726:	9d 85       	ldd	r25, Y+13	; 0x0d
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	91 81       	ldd	r25, Z+1	; 0x01
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <itoa>
	itoa(day,dayString,10);
     73e:	8c 85       	ldd	r24, Y+12	; 0x0c
     740:	9d 85       	ldd	r25, Y+13	; 0x0d
     742:	fc 01       	movw	r30, r24
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9e 01       	movw	r18, r28
     74a:	2c 5f       	subi	r18, 0xFC	; 252
     74c:	3f 4f       	sbci	r19, 0xFF	; 255
     74e:	b9 01       	movw	r22, r18
     750:	4a e0       	ldi	r20, 0x0A	; 10
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <itoa>
	itoa(year,yearString,10);
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	fc 01       	movw	r30, r24
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9e 01       	movw	r18, r28
     764:	29 5f       	subi	r18, 0xF9	; 249
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	4a e0       	ldi	r20, 0x0A	; 10
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <itoa>
	strcpy(dateString,monthString);
     772:	8c 85       	ldd	r24, Y+12	; 0x0c
     774:	9d 85       	ldd	r25, Y+13	; 0x0d
     776:	06 96       	adiw	r24, 0x06	; 6
     778:	9e 01       	movw	r18, r28
     77a:	2f 5f       	subi	r18, 0xFF	; 255
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <strcpy>
	strcat(dateString,",");
     784:	8c 85       	ldd	r24, Y+12	; 0x0c
     786:	9d 85       	ldd	r25, Y+13	; 0x0d
     788:	9c 01       	movw	r18, r24
     78a:	2a 5f       	subi	r18, 0xFA	; 250
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	c9 01       	movw	r24, r18
     790:	ac 01       	movw	r20, r24
     792:	fa 01       	movw	r30, r20
     794:	01 90       	ld	r0, Z+
     796:	00 20       	and	r0, r0
     798:	e9 f7       	brne	.-6      	; 0x794 <_ZN6myDate7getDateEv+0x88>
     79a:	cf 01       	movw	r24, r30
     79c:	01 97       	sbiw	r24, 0x01	; 1
     79e:	84 1b       	sub	r24, r20
     7a0:	95 0b       	sbc	r25, r21
     7a2:	82 0f       	add	r24, r18
     7a4:	93 1f       	adc	r25, r19
     7a6:	2c e2       	ldi	r18, 0x2C	; 44
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	fc 01       	movw	r30, r24
     7ac:	31 83       	std	Z+1, r19	; 0x01
     7ae:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     7b0:	8c 85       	ldd	r24, Y+12	; 0x0c
     7b2:	9d 85       	ldd	r25, Y+13	; 0x0d
     7b4:	06 96       	adiw	r24, 0x06	; 6
     7b6:	9e 01       	movw	r18, r28
     7b8:	2c 5f       	subi	r18, 0xFC	; 252
     7ba:	3f 4f       	sbci	r19, 0xFF	; 255
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <strcat>
	strcat(dateString,",");
     7c2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7c4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7c6:	9c 01       	movw	r18, r24
     7c8:	2a 5f       	subi	r18, 0xFA	; 250
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	c9 01       	movw	r24, r18
     7ce:	ac 01       	movw	r20, r24
     7d0:	fa 01       	movw	r30, r20
     7d2:	01 90       	ld	r0, Z+
     7d4:	00 20       	and	r0, r0
     7d6:	e9 f7       	brne	.-6      	; 0x7d2 <_ZN6myDate7getDateEv+0xc6>
     7d8:	cf 01       	movw	r24, r30
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	84 1b       	sub	r24, r20
     7de:	95 0b       	sbc	r25, r21
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	2c e2       	ldi	r18, 0x2C	; 44
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	fc 01       	movw	r30, r24
     7ea:	31 83       	std	Z+1, r19	; 0x01
     7ec:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     7ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     7f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f2:	06 96       	adiw	r24, 0x06	; 6
     7f4:	9e 01       	movw	r18, r28
     7f6:	29 5f       	subi	r18, 0xF9	; 249
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <strcat>
	dateString[16] = '\0';
     800:	8c 85       	ldd	r24, Y+12	; 0x0c
     802:	9d 85       	ldd	r25, Y+13	; 0x0d
     804:	fc 01       	movw	r30, r24
     806:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     808:	8c 85       	ldd	r24, Y+12	; 0x0c
     80a:	9d 85       	ldd	r25, Y+13	; 0x0d
     80c:	06 96       	adiw	r24, 0x06	; 6
     80e:	2d 96       	adiw	r28, 0x0d	; 13
     810:	0f b6       	in	r0, 0x3f	; 63
     812:	f8 94       	cli
     814:	de bf       	out	0x3e, r29	; 62
     816:	0f be       	out	0x3f, r0	; 63
     818:	cd bf       	out	0x3d, r28	; 61
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	08 95       	ret

00000820 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	00 d0       	rcall	.+0      	; 0x826 <_ZN6myTimeC1Ev+0x6>
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	9a 83       	std	Y+2, r25	; 0x02
     82c:	89 83       	std	Y+1, r24	; 0x01
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     836:	89 81       	ldd	r24, Y+1	; 0x01
     838:	9a 81       	ldd	r25, Y+2	; 0x02
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	40 e0       	ldi	r20, 0x00	; 0
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	08 95       	ret

00000854 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	28 97       	sbiw	r28, 0x08	; 8
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 83       	std	Y+2, r25	; 0x02
     86a:	89 83       	std	Y+1, r24	; 0x01
     86c:	7c 83       	std	Y+4, r23	; 0x04
     86e:	6b 83       	std	Y+3, r22	; 0x03
     870:	5e 83       	std	Y+6, r21	; 0x06
     872:	4d 83       	std	Y+5, r20	; 0x05
     874:	38 87       	std	Y+8, r19	; 0x08
     876:	2f 83       	std	Y+7, r18	; 0x07
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	9a 81       	ldd	r25, Y+2	; 0x02
     87c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	9a 81       	ldd	r25, Y+2	; 0x02
     884:	6b 81       	ldd	r22, Y+3	; 0x03
     886:	7c 81       	ldd	r23, Y+4	; 0x04
     888:	4d 81       	ldd	r20, Y+5	; 0x05
     88a:	5e 81       	ldd	r21, Y+6	; 0x06
     88c:	2f 81       	ldd	r18, Y+7	; 0x07
     88e:	38 85       	ldd	r19, Y+8	; 0x08
     890:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     894:	28 96       	adiw	r28, 0x08	; 8
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	de bf       	out	0x3e, r29	; 62
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	cd bf       	out	0x3d, r28	; 61
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	08 95       	ret

000008a6 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     8a6:	cf 92       	push	r12
     8a8:	df 92       	push	r13
     8aa:	ef 92       	push	r14
     8ac:	ff 92       	push	r15
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
     8ba:	2e 97       	sbiw	r28, 0x0e	; 14
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	f8 94       	cli
     8c0:	de bf       	out	0x3e, r29	; 62
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	cd bf       	out	0x3d, r28	; 61
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01
     8ca:	7c 83       	std	Y+4, r23	; 0x04
     8cc:	6b 83       	std	Y+3, r22	; 0x03
     8ce:	5e 83       	std	Y+6, r21	; 0x06
     8d0:	4d 83       	std	Y+5, r20	; 0x05
     8d2:	38 87       	std	Y+8, r19	; 0x08
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	1a 87       	std	Y+10, r17	; 0x0a
     8d8:	09 87       	std	Y+9, r16	; 0x09
     8da:	fc 86       	std	Y+12, r15	; 0x0c
     8dc:	eb 86       	std	Y+11, r14	; 0x0b
     8de:	de 86       	std	Y+14, r13	; 0x0e
     8e0:	cd 86       	std	Y+13, r12	; 0x0d
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	69 85       	ldd	r22, Y+9	; 0x09
     8e8:	7a 85       	ldd	r23, Y+10	; 0x0a
     8ea:	4b 85       	ldd	r20, Y+11	; 0x0b
     8ec:	5c 85       	ldd	r21, Y+12	; 0x0c
     8ee:	2d 85       	ldd	r18, Y+13	; 0x0d
     8f0:	3e 85       	ldd	r19, Y+14	; 0x0e
     8f2:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	9a 81       	ldd	r25, Y+2	; 0x02
     8fa:	6b 81       	ldd	r22, Y+3	; 0x03
     8fc:	7c 81       	ldd	r23, Y+4	; 0x04
     8fe:	4d 81       	ldd	r20, Y+5	; 0x05
     900:	5e 81       	ldd	r21, Y+6	; 0x06
     902:	2f 81       	ldd	r18, Y+7	; 0x07
     904:	38 85       	ldd	r19, Y+8	; 0x08
     906:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     90a:	2e 96       	adiw	r28, 0x0e	; 14
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	de bf       	out	0x3e, r29	; 62
     912:	0f be       	out	0x3f, r0	; 63
     914:	cd bf       	out	0x3d, r28	; 61
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	08 95       	ret

00000928 <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	00 d0       	rcall	.+0      	; 0x92e <_ZN6myTime10getSecondsEv+0x6>
     92e:	cd b7       	in	r28, 0x3d	; 61
     930:	de b7       	in	r29, 0x3e	; 62
     932:	9a 83       	std	Y+2, r25	; 0x02
     934:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     936:	89 81       	ldd	r24, Y+1	; 0x01
     938:	9a 81       	ldd	r25, Y+2	; 0x02
     93a:	fc 01       	movw	r30, r24
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	00 d0       	rcall	.+0      	; 0x950 <_ZN6myTime10getMinutesEv+0x6>
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	9a 83       	std	Y+2, r25	; 0x02
     956:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	9a 81       	ldd	r25, Y+2	; 0x02
     95c:	fc 01       	movw	r30, r24
     95e:	81 8d       	ldd	r24, Z+25	; 0x19
     960:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	00 d0       	rcall	.+0      	; 0x972 <_ZN6myTime8getHoursEv+0x6>
     972:	cd b7       	in	r28, 0x3d	; 61
     974:	de b7       	in	r29, 0x3e	; 62
     976:	9a 83       	std	Y+2, r25	; 0x02
     978:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	87 89       	ldd	r24, Z+23	; 0x17
     982:	90 8d       	ldd	r25, Z+24	; 0x18
}
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
     996:	a2 97       	sbiw	r28, 0x22	; 34
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	f8 94       	cli
     99c:	de bf       	out	0x3e, r29	; 62
     99e:	0f be       	out	0x3f, r0	; 63
     9a0:	cd bf       	out	0x3d, r28	; 61
     9a2:	98 a3       	lds	r25, 0x58
     9a4:	8f 8f       	std	Y+31, r24	; 0x1f
     9a6:	7a a3       	lds	r23, 0x5a
     9a8:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     9aa:	ce 01       	movw	r24, r28
     9ac:	0b 96       	adiw	r24, 0x0b	; 11
     9ae:	29 a1       	lds	r18, 0x49
     9b0:	3a a1       	lds	r19, 0x4a
     9b2:	b9 01       	movw	r22, r18
     9b4:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <strcpy>
	for (int j=0; j<3; j++){
     9b8:	1a 82       	std	Y+2, r1	; 0x02
     9ba:	19 82       	std	Y+1, r1	; 0x01
     9bc:	43 c0       	rjmp	.+134    	; 0xa44 <_ZN6myTime7setTimeEPc+0xb6>
		for (int i=0; i<2; i++){
     9be:	1c 82       	std	Y+4, r1	; 0x04
     9c0:	1b 82       	std	Y+3, r1	; 0x03
     9c2:	20 c0       	rjmp	.+64     	; 0xa04 <_ZN6myTime7setTimeEPc+0x76>
				tempString[i]=currentString[i+j*3];
     9c4:	29 81       	ldd	r18, Y+1	; 0x01
     9c6:	3a 81       	ldd	r19, Y+2	; 0x02
     9c8:	c9 01       	movw	r24, r18
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	28 0f       	add	r18, r24
     9d0:	39 1f       	adc	r19, r25
     9d2:	8b 81       	ldd	r24, Y+3	; 0x03
     9d4:	9c 81       	ldd	r25, Y+4	; 0x04
     9d6:	82 0f       	add	r24, r18
     9d8:	93 1f       	adc	r25, r19
     9da:	9e 01       	movw	r18, r28
     9dc:	25 5f       	subi	r18, 0xF5	; 245
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	fc 01       	movw	r30, r24
     9e6:	40 81       	ld	r20, Z
     9e8:	9e 01       	movw	r18, r28
     9ea:	2b 5e       	subi	r18, 0xEB	; 235
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	8b 81       	ldd	r24, Y+3	; 0x03
     9f0:	9c 81       	ldd	r25, Y+4	; 0x04
     9f2:	82 0f       	add	r24, r18
     9f4:	93 1f       	adc	r25, r19
     9f6:	fc 01       	movw	r30, r24
     9f8:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
     9fc:	9c 81       	ldd	r25, Y+4	; 0x04
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	9c 83       	std	Y+4, r25	; 0x04
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	21 e0       	ldi	r18, 0x01	; 1
     a06:	8b 81       	ldd	r24, Y+3	; 0x03
     a08:	9c 81       	ldd	r25, Y+4	; 0x04
     a0a:	82 30       	cpi	r24, 0x02	; 2
     a0c:	91 05       	cpc	r25, r1
     a0e:	0c f0       	brlt	.+2      	; 0xa12 <_ZN6myTime7setTimeEPc+0x84>
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	22 23       	and	r18, r18
     a14:	b9 f6       	brne	.-82     	; 0x9c4 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     a16:	ce 01       	movw	r24, r28
     a18:	45 96       	adiw	r24, 0x15	; 21
     a1a:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
     a1e:	9c 01       	movw	r18, r24
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	ae 01       	movw	r20, r28
     a2a:	4f 5f       	subi	r20, 0xFF	; 255
     a2c:	5f 4f       	sbci	r21, 0xFF	; 255
     a2e:	84 0f       	add	r24, r20
     a30:	95 1f       	adc	r25, r21
     a32:	04 96       	adiw	r24, 0x04	; 4
     a34:	fc 01       	movw	r30, r24
     a36:	31 83       	std	Z+1, r19	; 0x01
     a38:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	9a 81       	ldd	r25, Y+2	; 0x02
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	9a 83       	std	Y+2, r25	; 0x02
     a42:	89 83       	std	Y+1, r24	; 0x01
     a44:	21 e0       	ldi	r18, 0x01	; 1
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	9a 81       	ldd	r25, Y+2	; 0x02
     a4a:	83 30       	cpi	r24, 0x03	; 3
     a4c:	91 05       	cpc	r25, r1
     a4e:	0c f0       	brlt	.+2      	; 0xa52 <_ZN6myTime7setTimeEPc+0xc4>
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	22 23       	and	r18, r18
     a54:	09 f0       	breq	.+2      	; 0xa58 <_ZN6myTime7setTimeEPc+0xca>
     a56:	b3 cf       	rjmp	.-154    	; 0x9be <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	9e 81       	ldd	r25, Y+6	; 0x06
     a5c:	47 96       	adiw	r24, 0x17	; 23
     a5e:	8f 32       	cpi	r24, 0x2F	; 47
     a60:	91 05       	cpc	r25, r1
     a62:	c0 f4       	brcc	.+48     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a64:	8f 81       	ldd	r24, Y+7	; 0x07
     a66:	98 85       	ldd	r25, Y+8	; 0x08
     a68:	cb 96       	adiw	r24, 0x3b	; 59
     a6a:	87 37       	cpi	r24, 0x77	; 119
     a6c:	91 05       	cpc	r25, r1
     a6e:	90 f4       	brcc	.+36     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a70:	89 85       	ldd	r24, Y+9	; 0x09
     a72:	9a 85       	ldd	r25, Y+10	; 0x0a
     a74:	cb 96       	adiw	r24, 0x3b	; 59
     a76:	87 37       	cpi	r24, 0x77	; 119
     a78:	91 05       	cpc	r25, r1
     a7a:	60 f4       	brcc	.+24     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     a7c:	6d 81       	ldd	r22, Y+5	; 0x05
     a7e:	7e 81       	ldd	r23, Y+6	; 0x06
     a80:	4f 81       	ldd	r20, Y+7	; 0x07
     a82:	58 85       	ldd	r21, Y+8	; 0x08
     a84:	29 85       	ldd	r18, Y+9	; 0x09
     a86:	3a 85       	ldd	r19, Y+10	; 0x0a
     a88:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a8a:	98 a1       	lds	r25, 0x48
     a8c:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
		return fTrue;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	01 c0       	rjmp	.+2      	; 0xa96 <_ZN6myTime7setTimeEPc+0x108>
	} 
	return fFalse;
     a94:	80 e0       	ldi	r24, 0x00	; 0
}
     a96:	a2 96       	adiw	r28, 0x22	; 34
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	cd bf       	out	0x3d, r28	; 61
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	cd b7       	in	r28, 0x3d	; 61
     aae:	de b7       	in	r29, 0x3e	; 62
     ab0:	28 97       	sbiw	r28, 0x08	; 8
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	9a 83       	std	Y+2, r25	; 0x02
     abe:	89 83       	std	Y+1, r24	; 0x01
     ac0:	7c 83       	std	Y+4, r23	; 0x04
     ac2:	6b 83       	std	Y+3, r22	; 0x03
     ac4:	5e 83       	std	Y+6, r21	; 0x06
     ac6:	4d 83       	std	Y+5, r20	; 0x05
     ac8:	38 87       	std	Y+8, r19	; 0x08
     aca:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
     ad0:	2b 81       	ldd	r18, Y+3	; 0x03
     ad2:	3c 81       	ldd	r19, Y+4	; 0x04
     ad4:	b9 01       	movw	r22, r18
     ad6:	0e 94 84 05 	call	0xb08	; 0xb08 <_ZN6myTime7setHourEi>
	setMinute(minute);
     ada:	89 81       	ldd	r24, Y+1	; 0x01
     adc:	9a 81       	ldd	r25, Y+2	; 0x02
     ade:	2d 81       	ldd	r18, Y+5	; 0x05
     ae0:	3e 81       	ldd	r19, Y+6	; 0x06
     ae2:	b9 01       	movw	r22, r18
     ae4:	0e 94 a2 05 	call	0xb44	; 0xb44 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     ae8:	89 81       	ldd	r24, Y+1	; 0x01
     aea:	9a 81       	ldd	r25, Y+2	; 0x02
     aec:	2f 81       	ldd	r18, Y+7	; 0x07
     aee:	38 85       	ldd	r19, Y+8	; 0x08
     af0:	b9 01       	movw	r22, r18
     af2:	0e 94 c0 05 	call	0xb80	; 0xb80 <_ZN6myTime9setSecondEi>
}
     af6:	28 96       	adiw	r28, 0x08	; 8
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	de bf       	out	0x3e, r29	; 62
     afe:	0f be       	out	0x3f, r0	; 63
     b00:	cd bf       	out	0x3d, r28	; 61
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     b08:	cf 93       	push	r28
     b0a:	df 93       	push	r29
     b0c:	00 d0       	rcall	.+0      	; 0xb0e <_ZN6myTime7setHourEi+0x6>
     b0e:	00 d0       	rcall	.+0      	; 0xb10 <_ZN6myTime7setHourEi+0x8>
     b10:	cd b7       	in	r28, 0x3d	; 61
     b12:	de b7       	in	r29, 0x3e	; 62
     b14:	9a 83       	std	Y+2, r25	; 0x02
     b16:	89 83       	std	Y+1, r24	; 0x01
     b18:	7c 83       	std	Y+4, r23	; 0x04
     b1a:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     b1c:	8b 81       	ldd	r24, Y+3	; 0x03
     b1e:	9c 81       	ldd	r25, Y+4	; 0x04
     b20:	47 96       	adiw	r24, 0x17	; 23
     b22:	8f 32       	cpi	r24, 0x2F	; 47
     b24:	91 05       	cpc	r25, r1
     b26:	38 f4       	brcc	.+14     	; 0xb36 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     b28:	89 81       	ldd	r24, Y+1	; 0x01
     b2a:	9a 81       	ldd	r25, Y+2	; 0x02
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	3c 81       	ldd	r19, Y+4	; 0x04
     b30:	fc 01       	movw	r30, r24
     b32:	30 8f       	std	Z+24, r19	; 0x18
     b34:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	0f 90       	pop	r0
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <_ZN6myTime9setMinuteEi+0x6>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <_ZN6myTime9setMinuteEi+0x8>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01
     b54:	7c 83       	std	Y+4, r23	; 0x04
     b56:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	cb 96       	adiw	r24, 0x3b	; 59
     b5e:	87 37       	cpi	r24, 0x77	; 119
     b60:	91 05       	cpc	r25, r1
     b62:	38 f4       	brcc	.+14     	; 0xb72 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	2b 81       	ldd	r18, Y+3	; 0x03
     b6a:	3c 81       	ldd	r19, Y+4	; 0x04
     b6c:	fc 01       	movw	r30, r24
     b6e:	32 8f       	std	Z+26, r19	; 0x1a
     b70:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     b72:	0f 90       	pop	r0
     b74:	0f 90       	pop	r0
     b76:	0f 90       	pop	r0
     b78:	0f 90       	pop	r0
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	00 d0       	rcall	.+0      	; 0xb86 <_ZN6myTime9setSecondEi+0x6>
     b86:	00 d0       	rcall	.+0      	; 0xb88 <_ZN6myTime9setSecondEi+0x8>
     b88:	cd b7       	in	r28, 0x3d	; 61
     b8a:	de b7       	in	r29, 0x3e	; 62
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
     b90:	7c 83       	std	Y+4, r23	; 0x04
     b92:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	cb 96       	adiw	r24, 0x3b	; 59
     b9a:	87 37       	cpi	r24, 0x77	; 119
     b9c:	91 05       	cpc	r25, r1
     b9e:	38 f4       	brcc	.+14     	; 0xbae <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	9a 81       	ldd	r25, Y+2	; 0x02
     ba4:	2b 81       	ldd	r18, Y+3	; 0x03
     ba6:	3c 81       	ldd	r19, Y+4	; 0x04
     ba8:	fc 01       	movw	r30, r24
     baa:	34 8f       	std	Z+28, r19	; 0x1c
     bac:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	28 97       	sbiw	r28, 0x08	; 8
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	de bf       	out	0x3e, r29	; 62
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	cd bf       	out	0x3d, r28	; 61
     bd0:	9e 83       	std	Y+6, r25	; 0x06
     bd2:	8d 83       	std	Y+5, r24	; 0x05
     bd4:	78 87       	std	Y+8, r23	; 0x08
     bd6:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     bd8:	8d 81       	ldd	r24, Y+5	; 0x05
     bda:	9e 81       	ldd	r25, Y+6	; 0x06
     bdc:	fc 01       	movw	r30, r24
     bde:	27 89       	ldd	r18, Z+23	; 0x17
     be0:	30 8d       	ldd	r19, Z+24	; 0x18
     be2:	8f 81       	ldd	r24, Y+7	; 0x07
     be4:	98 85       	ldd	r25, Y+8	; 0x08
     be6:	82 0f       	add	r24, r18
     be8:	93 1f       	adc	r25, r19
     bea:	9a 83       	std	Y+2, r25	; 0x02
     bec:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	9a 81       	ldd	r25, Y+2	; 0x02
     bf2:	28 e1       	ldi	r18, 0x18	; 24
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	b9 01       	movw	r22, r18
     bf8:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     bfc:	9c 01       	movw	r18, r24
     bfe:	8d 81       	ldd	r24, Y+5	; 0x05
     c00:	9e 81       	ldd	r25, Y+6	; 0x06
     c02:	fc 01       	movw	r30, r24
     c04:	30 8f       	std	Z+24, r19	; 0x18
     c06:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a 81       	ldd	r25, Y+2	; 0x02
     c0c:	21 e0       	ldi	r18, 0x01	; 1
     c0e:	88 31       	cpi	r24, 0x18	; 24
     c10:	91 05       	cpc	r25, r1
     c12:	0c f4       	brge	.+2      	; 0xc16 <_ZN6myTime8addHoursEi+0x5a>
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	22 23       	and	r18, r18
     c18:	91 f0       	breq	.+36     	; 0xc3e <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	28 e1       	ldi	r18, 0x18	; 24
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	b9 01       	movw	r22, r18
     c24:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     c28:	9b 01       	movw	r18, r22
     c2a:	c9 01       	movw	r24, r18
     c2c:	9c 83       	std	Y+4, r25	; 0x04
     c2e:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     c30:	8d 81       	ldd	r24, Y+5	; 0x05
     c32:	9e 81       	ldd	r25, Y+6	; 0x06
     c34:	2b 81       	ldd	r18, Y+3	; 0x03
     c36:	3c 81       	ldd	r19, Y+4	; 0x04
     c38:	b9 01       	movw	r22, r18
     c3a:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     c3e:	28 96       	adiw	r28, 0x08	; 8
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	08 95       	ret

00000c50 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
     c58:	28 97       	sbiw	r28, 0x08	; 8
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	9e 83       	std	Y+6, r25	; 0x06
     c66:	8d 83       	std	Y+5, r24	; 0x05
     c68:	78 87       	std	Y+8, r23	; 0x08
     c6a:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     c6c:	8d 81       	ldd	r24, Y+5	; 0x05
     c6e:	9e 81       	ldd	r25, Y+6	; 0x06
     c70:	fc 01       	movw	r30, r24
     c72:	21 8d       	ldd	r18, Z+25	; 0x19
     c74:	32 8d       	ldd	r19, Z+26	; 0x1a
     c76:	8f 81       	ldd	r24, Y+7	; 0x07
     c78:	98 85       	ldd	r25, Y+8	; 0x08
     c7a:	82 0f       	add	r24, r18
     c7c:	93 1f       	adc	r25, r19
     c7e:	9a 83       	std	Y+2, r25	; 0x02
     c80:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	9a 81       	ldd	r25, Y+2	; 0x02
     c86:	2c e3       	ldi	r18, 0x3C	; 60
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	b9 01       	movw	r22, r18
     c8c:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     c90:	9c 01       	movw	r18, r24
     c92:	8d 81       	ldd	r24, Y+5	; 0x05
     c94:	9e 81       	ldd	r25, Y+6	; 0x06
     c96:	fc 01       	movw	r30, r24
     c98:	32 8f       	std	Z+26, r19	; 0x1a
     c9a:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ca0:	21 e0       	ldi	r18, 0x01	; 1
     ca2:	8c 33       	cpi	r24, 0x3C	; 60
     ca4:	91 05       	cpc	r25, r1
     ca6:	0c f4       	brge	.+2      	; 0xcaa <_ZN6myTime10addMinutesEi+0x5a>
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	22 23       	and	r18, r18
     cac:	91 f0       	breq	.+36     	; 0xcd2 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	2c e3       	ldi	r18, 0x3C	; 60
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	b9 01       	movw	r22, r18
     cb8:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     cbc:	9b 01       	movw	r18, r22
     cbe:	c9 01       	movw	r24, r18
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     cc4:	2b 81       	ldd	r18, Y+3	; 0x03
     cc6:	3c 81       	ldd	r19, Y+4	; 0x04
     cc8:	8d 81       	ldd	r24, Y+5	; 0x05
     cca:	9e 81       	ldd	r25, Y+6	; 0x06
     ccc:	b9 01       	movw	r22, r18
     cce:	0e 94 de 05 	call	0xbbc	; 0xbbc <_ZN6myTime8addHoursEi>
	}
}
     cd2:	28 96       	adiw	r28, 0x08	; 8
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	cd b7       	in	r28, 0x3d	; 61
     cea:	de b7       	in	r29, 0x3e	; 62
     cec:	28 97       	sbiw	r28, 0x08	; 8
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	de bf       	out	0x3e, r29	; 62
     cf4:	0f be       	out	0x3f, r0	; 63
     cf6:	cd bf       	out	0x3d, r28	; 61
     cf8:	9e 83       	std	Y+6, r25	; 0x06
     cfa:	8d 83       	std	Y+5, r24	; 0x05
     cfc:	78 87       	std	Y+8, r23	; 0x08
     cfe:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	9e 81       	ldd	r25, Y+6	; 0x06
     d04:	fc 01       	movw	r30, r24
     d06:	23 8d       	ldd	r18, Z+27	; 0x1b
     d08:	34 8d       	ldd	r19, Z+28	; 0x1c
     d0a:	8f 81       	ldd	r24, Y+7	; 0x07
     d0c:	98 85       	ldd	r25, Y+8	; 0x08
     d0e:	82 0f       	add	r24, r18
     d10:	93 1f       	adc	r25, r19
     d12:	9a 83       	std	Y+2, r25	; 0x02
     d14:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     d16:	89 81       	ldd	r24, Y+1	; 0x01
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	2c e3       	ldi	r18, 0x3C	; 60
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	b9 01       	movw	r22, r18
     d20:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     d24:	9c 01       	movw	r18, r24
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	fc 01       	movw	r30, r24
     d2c:	34 8f       	std	Z+28, r19	; 0x1c
     d2e:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	9a 81       	ldd	r25, Y+2	; 0x02
     d34:	21 e0       	ldi	r18, 0x01	; 1
     d36:	8c 33       	cpi	r24, 0x3C	; 60
     d38:	91 05       	cpc	r25, r1
     d3a:	0c f4       	brge	.+2      	; 0xd3e <_ZN6myTime10addSecondsEi+0x5a>
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	22 23       	and	r18, r18
     d40:	91 f0       	breq	.+36     	; 0xd66 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     d42:	89 81       	ldd	r24, Y+1	; 0x01
     d44:	9a 81       	ldd	r25, Y+2	; 0x02
     d46:	2c e3       	ldi	r18, 0x3C	; 60
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	b9 01       	movw	r22, r18
     d4c:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
     d50:	9b 01       	movw	r18, r22
     d52:	c9 01       	movw	r24, r18
     d54:	9c 83       	std	Y+4, r25	; 0x04
     d56:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     d58:	2b 81       	ldd	r18, Y+3	; 0x03
     d5a:	3c 81       	ldd	r19, Y+4	; 0x04
     d5c:	8d 81       	ldd	r24, Y+5	; 0x05
     d5e:	9e 81       	ldd	r25, Y+6	; 0x06
     d60:	b9 01       	movw	r22, r18
     d62:	0e 94 28 06 	call	0xc50	; 0xc50 <_ZN6myTime10addMinutesEi>
	}
}
     d66:	28 96       	adiw	r28, 0x08	; 8
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	08 95       	ret

00000d78 <_ZN6myTime13checkValidityEv>:

BOOL myTime::checkValidity(){
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	00 d0       	rcall	.+0      	; 0xd7e <_ZN6myTime13checkValidityEv+0x6>
     d7e:	0f 92       	push	r0
     d80:	cd b7       	in	r28, 0x3d	; 61
     d82:	de b7       	in	r29, 0x3e	; 62
     d84:	9b 83       	std	Y+3, r25	; 0x03
     d86:	8a 83       	std	Y+2, r24	; 0x02
	BOOL stillValid=fTrue;
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	89 83       	std	Y+1, r24	; 0x01
	if (second/60==0 && minute/60==0 && hour/24==0){
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	fc 01       	movw	r30, r24
     d92:	83 8d       	ldd	r24, Z+27	; 0x1b
     d94:	94 8d       	ldd	r25, Z+28	; 0x1c
     d96:	cb 96       	adiw	r24, 0x3b	; 59
     d98:	87 37       	cpi	r24, 0x77	; 119
     d9a:	91 05       	cpc	r25, r1
     d9c:	a0 f4       	brcc	.+40     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	fc 01       	movw	r30, r24
     da4:	81 8d       	ldd	r24, Z+25	; 0x19
     da6:	92 8d       	ldd	r25, Z+26	; 0x1a
     da8:	cb 96       	adiw	r24, 0x3b	; 59
     daa:	87 37       	cpi	r24, 0x77	; 119
     dac:	91 05       	cpc	r25, r1
     dae:	58 f4       	brcc	.+22     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	9b 81       	ldd	r25, Y+3	; 0x03
     db4:	fc 01       	movw	r30, r24
     db6:	87 89       	ldd	r24, Z+23	; 0x17
     db8:	90 8d       	ldd	r25, Z+24	; 0x18
     dba:	47 96       	adiw	r24, 0x17	; 23
     dbc:	8f 32       	cpi	r24, 0x2F	; 47
     dbe:	91 05       	cpc	r25, r1
     dc0:	10 f4       	brcc	.+4      	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <_ZN6myTime13checkValidityEv+0x50>
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	88 23       	and	r24, r24
     dca:	69 f0       	breq	.+26     	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
		if (checkValidityDate()){return fTrue;}
     dcc:	8a 81       	ldd	r24, Y+2	; 0x02
     dce:	9b 81       	ldd	r25, Y+3	; 0x03
     dd0:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate17checkValidityDateEv>
     dd4:	98 2f       	mov	r25, r24
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	99 23       	and	r25, r25
     dda:	09 f4       	brne	.+2      	; 0xdde <_ZN6myTime13checkValidityEv+0x66>
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	88 23       	and	r24, r24
     de0:	11 f0       	breq	.+4      	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	01 c0       	rjmp	.+2      	; 0xde8 <_ZN6myTime13checkValidityEv+0x70>
	}
	return fFalse;
     de6:	80 e0       	ldi	r24, 0x00	; 0
}
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	cd b7       	in	r28, 0x3d	; 61
     dfa:	de b7       	in	r29, 0x3e	; 62
     dfc:	2b 97       	sbiw	r28, 0x0b	; 11
     dfe:	0f b6       	in	r0, 0x3f	; 63
     e00:	f8 94       	cli
     e02:	de bf       	out	0x3e, r29	; 62
     e04:	0f be       	out	0x3f, r0	; 63
     e06:	cd bf       	out	0x3d, r28	; 61
     e08:	9b 87       	std	Y+11, r25	; 0x0b
     e0a:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e10:	fc 01       	movw	r30, r24
     e12:	87 89       	ldd	r24, Z+23	; 0x17
     e14:	90 8d       	ldd	r25, Z+24	; 0x18
     e16:	9e 01       	movw	r18, r28
     e18:	2f 5f       	subi	r18, 0xFF	; 255
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	b9 01       	movw	r22, r18
     e1e:	4a e0       	ldi	r20, 0x0A	; 10
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <itoa>
	itoa(minute,minuteString,10);
     e26:	8a 85       	ldd	r24, Y+10	; 0x0a
     e28:	9b 85       	ldd	r25, Y+11	; 0x0b
     e2a:	fc 01       	movw	r30, r24
     e2c:	81 8d       	ldd	r24, Z+25	; 0x19
     e2e:	92 8d       	ldd	r25, Z+26	; 0x1a
     e30:	9e 01       	movw	r18, r28
     e32:	2c 5f       	subi	r18, 0xFC	; 252
     e34:	3f 4f       	sbci	r19, 0xFF	; 255
     e36:	b9 01       	movw	r22, r18
     e38:	4a e0       	ldi	r20, 0x0A	; 10
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <itoa>
	itoa(second,secondString,10);
     e40:	8a 85       	ldd	r24, Y+10	; 0x0a
     e42:	9b 85       	ldd	r25, Y+11	; 0x0b
     e44:	fc 01       	movw	r30, r24
     e46:	83 8d       	ldd	r24, Z+27	; 0x1b
     e48:	94 8d       	ldd	r25, Z+28	; 0x1c
     e4a:	9e 01       	movw	r18, r28
     e4c:	29 5f       	subi	r18, 0xF9	; 249
     e4e:	3f 4f       	sbci	r19, 0xFF	; 255
     e50:	b9 01       	movw	r22, r18
     e52:	4a e0       	ldi	r20, 0x0A	; 10
     e54:	50 e0       	ldi	r21, 0x00	; 0
     e56:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <itoa>
	strcpy(timeString,hourString);
     e5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e5e:	4d 96       	adiw	r24, 0x1d	; 29
     e60:	9e 01       	movw	r18, r28
     e62:	2f 5f       	subi	r18, 0xFF	; 255
     e64:	3f 4f       	sbci	r19, 0xFF	; 255
     e66:	b9 01       	movw	r22, r18
     e68:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <strcpy>
	strcat(timeString,":");
     e6c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e6e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e70:	9c 01       	movw	r18, r24
     e72:	23 5e       	subi	r18, 0xE3	; 227
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	c9 01       	movw	r24, r18
     e78:	ac 01       	movw	r20, r24
     e7a:	fa 01       	movw	r30, r20
     e7c:	01 90       	ld	r0, Z+
     e7e:	00 20       	and	r0, r0
     e80:	e9 f7       	brne	.-6      	; 0xe7c <_ZN6myTime7getTimeEv+0x88>
     e82:	cf 01       	movw	r24, r30
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	84 1b       	sub	r24, r20
     e88:	95 0b       	sbc	r25, r21
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	2a e3       	ldi	r18, 0x3A	; 58
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	fc 01       	movw	r30, r24
     e94:	31 83       	std	Z+1, r19	; 0x01
     e96:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     e98:	8a 85       	ldd	r24, Y+10	; 0x0a
     e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9c:	4d 96       	adiw	r24, 0x1d	; 29
     e9e:	9e 01       	movw	r18, r28
     ea0:	2c 5f       	subi	r18, 0xFC	; 252
     ea2:	3f 4f       	sbci	r19, 0xFF	; 255
     ea4:	b9 01       	movw	r22, r18
     ea6:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <strcat>
	strcat(timeString,":");
     eaa:	8a 85       	ldd	r24, Y+10	; 0x0a
     eac:	9b 85       	ldd	r25, Y+11	; 0x0b
     eae:	9c 01       	movw	r18, r24
     eb0:	23 5e       	subi	r18, 0xE3	; 227
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	c9 01       	movw	r24, r18
     eb6:	ac 01       	movw	r20, r24
     eb8:	fa 01       	movw	r30, r20
     eba:	01 90       	ld	r0, Z+
     ebc:	00 20       	and	r0, r0
     ebe:	e9 f7       	brne	.-6      	; 0xeba <_ZN6myTime7getTimeEv+0xc6>
     ec0:	cf 01       	movw	r24, r30
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	84 1b       	sub	r24, r20
     ec6:	95 0b       	sbc	r25, r21
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	2a e3       	ldi	r18, 0x3A	; 58
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	fc 01       	movw	r30, r24
     ed2:	31 83       	std	Z+1, r19	; 0x01
     ed4:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
     eda:	4d 96       	adiw	r24, 0x1d	; 29
     edc:	9e 01       	movw	r18, r28
     ede:	29 5f       	subi	r18, 0xF9	; 249
     ee0:	3f 4f       	sbci	r19, 0xFF	; 255
     ee2:	b9 01       	movw	r22, r18
     ee4:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <strcat>
	timeString[11] = '\0';
     ee8:	8a 85       	ldd	r24, Y+10	; 0x0a
     eea:	9b 85       	ldd	r25, Y+11	; 0x0b
     eec:	fc 01       	movw	r30, r24
     eee:	10 a6       	lds	r17, 0xb0
	return timeString;
     ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ef4:	4d 96       	adiw	r24, 0x1d	; 29
     ef6:	2b 96       	adiw	r28, 0x0b	; 11
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 31;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	2f 97       	sbiw	r28, 0x0f	; 15
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	8e 87       	std	Y+14, r24	; 0x0e
     f1e:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     f20:	f8 94       	cli
	if (gTime){
     f22:	8e 85       	ldd	r24, Y+14	; 0x0e
     f24:	88 23       	and	r24, r24
     f26:	09 f4       	brne	.+2      	; 0xf2a <_Z18getDateTime_eepromhh+0x22>
     f28:	4b c0       	rjmp	.+150    	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     f2a:	1a 82       	std	Y+2, r1	; 0x02
     f2c:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     f32:	2c c0       	rjmp	.+88     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <__eerd_byte_m644pa>
     f3c:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <__eerd_byte_m644pa>
     f46:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <__eerd_byte_m644pa>
     f50:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     f52:	8f 81       	ldd	r24, Y+7	; 0x07
     f54:	8c 33       	cpi	r24, 0x3C	; 60
     f56:	a8 f4       	brcc	.+42     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f58:	88 85       	ldd	r24, Y+8	; 0x08
     f5a:	8c 33       	cpi	r24, 0x3C	; 60
     f5c:	90 f4       	brcc	.+36     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f5e:	89 85       	ldd	r24, Y+9	; 0x09
     f60:	88 31       	cpi	r24, 0x18	; 24
     f62:	78 f4       	brcc	.+30     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	68 2f       	mov	r22, r24
     f68:	70 e0       	ldi	r23, 0x00	; 0
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	48 2f       	mov	r20, r24
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	8f 81       	ldd	r24, Y+7	; 0x07
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	82 e9       	ldi	r24, 0x92	; 146
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
     f7e:	1b 82       	std	Y+3, r1	; 0x03
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	9a 81       	ldd	r25, Y+2	; 0x02
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     f8c:	8b 81       	ldd	r24, Y+3	; 0x03
     f8e:	88 23       	and	r24, r24
     f90:	39 f0       	breq	.+14     	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	9a 81       	ldd	r25, Y+2	; 0x02
     f96:	83 30       	cpi	r24, 0x03	; 3
     f98:	91 05       	cpc	r25, r1
     f9a:	14 f4       	brge	.+4      	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <_Z18getDateTime_eepromhh+0x9a>
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	88 23       	and	r24, r24
     fa4:	39 f6       	brne	.-114    	; 0xf34 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     fa6:	8b 81       	ldd	r24, Y+3	; 0x03
     fa8:	88 23       	and	r24, r24
     faa:	51 f0       	breq	.+20     	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
     fac:	82 e9       	ldi	r24, 0x92	; 146
     fae:	91 e0       	ldi	r25, 0x01	; 1
     fb0:	61 e0       	ldi	r22, 0x01	; 1
     fb2:	70 e0       	ldi	r23, 0x00	; 0
     fb4:	41 e0       	ldi	r20, 0x01	; 1
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	21 e0       	ldi	r18, 0x01	; 1
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
     fc2:	88 23       	and	r24, r24
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <_Z18getDateTime_eepromhh+0xc0>
     fc6:	4e c0       	rjmp	.+156    	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     fc8:	1d 82       	std	Y+5, r1	; 0x05
     fca:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     fcc:	81 e0       	ldi	r24, 0x01	; 1
     fce:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     fd0:	2f c0       	rjmp	.+94     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     fd2:	84 e0       	ldi	r24, 0x04	; 4
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <__eerd_byte_m644pa>
     fda:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 55 1f 	call	0x3eaa	; 0x3eaa <__eerd_byte_m644pa>
     fe4:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     fe6:	85 e0       	ldi	r24, 0x05	; 5
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	0e 94 5d 1f 	call	0x3eba	; 0x3eba <__eerd_word_m644pa>
     fee:	9d 87       	std	Y+13, r25	; 0x0d
     ff0:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     ff2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff4:	8f 31       	cpi	r24, 0x1F	; 31
     ff6:	b8 f4       	brcc	.+46     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ff8:	8b 85       	ldd	r24, Y+11	; 0x0b
     ffa:	8d 30       	cpi	r24, 0x0D	; 13
     ffc:	a0 f4       	brcc	.+40     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ffe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1000:	9d 85       	ldd	r25, Y+13	; 0x0d
    1002:	27 e2       	ldi	r18, 0x27	; 39
    1004:	80 31       	cpi	r24, 0x10	; 16
    1006:	92 07       	cpc	r25, r18
    1008:	70 f4       	brcc	.+28     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
    100a:	8b 85       	ldd	r24, Y+11	; 0x0b
    100c:	68 2f       	mov	r22, r24
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	8a 85       	ldd	r24, Y+10	; 0x0a
    1012:	48 2f       	mov	r20, r24
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	2c 85       	ldd	r18, Y+12	; 0x0c
    1018:	3d 85       	ldd	r19, Y+13	; 0x0d
    101a:	82 e9       	ldi	r24, 0x92	; 146
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
    1022:	1e 82       	std	Y+6, r1	; 0x06
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
    1026:	8c 81       	ldd	r24, Y+4	; 0x04
    1028:	9d 81       	ldd	r25, Y+5	; 0x05
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	9d 83       	std	Y+5, r25	; 0x05
    102e:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
    1030:	8e 81       	ldd	r24, Y+6	; 0x06
    1032:	88 23       	and	r24, r24
    1034:	39 f0       	breq	.+14     	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	9d 81       	ldd	r25, Y+5	; 0x05
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	91 05       	cpc	r25, r1
    103e:	14 f4       	brge	.+4      	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <_Z18getDateTime_eepromhh+0x13e>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	88 23       	and	r24, r24
    1048:	21 f6       	brne	.-120    	; 0xfd2 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	88 23       	and	r24, r24
    104e:	51 f0       	breq	.+20     	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
    1050:	82 e9       	ldi	r24, 0x92	; 146
    1052:	91 e0       	ldi	r25, 0x01	; 1
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	70 e0       	ldi	r23, 0x00	; 0
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	21 ed       	ldi	r18, 0xD1	; 209
    105e:	37 e0       	ldi	r19, 0x07	; 7
    1060:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
    1064:	78 94       	sei
}
    1066:	2f 96       	adiw	r28, 0x0f	; 15
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	29 97       	sbiw	r28, 0x09	; 9
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	88 87       	std	Y+8, r24	; 0x08
    108e:	69 87       	std	Y+9, r22	; 0x09
	cli();
    1090:	f8 94       	cli
	if (sTime){
    1092:	88 85       	ldd	r24, Y+8	; 0x08
    1094:	88 23       	and	r24, r24
    1096:	f1 f0       	breq	.+60     	; 0x10d4 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
    1098:	82 e9       	ldi	r24, 0x92	; 146
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    10a0:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
    10a2:	82 e9       	ldi	r24, 0x92	; 146
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    10aa:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
    10ac:	82 e9       	ldi	r24, 0x92	; 146
    10ae:	91 e0       	ldi	r25, 0x01	; 1
    10b0:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    10b4:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	6b 81       	ldd	r22, Y+3	; 0x03
    10bc:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeMinute,tempMin);
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	6a 81       	ldd	r22, Y+2	; 0x02
    10c6:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeHour,tempHour);
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	69 81       	ldd	r22, Y+1	; 0x01
    10d0:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <__eewr_byte_m644pa>
	}
	if (sDate){
    10d4:	89 85       	ldd	r24, Y+9	; 0x09
    10d6:	88 23       	and	r24, r24
    10d8:	09 f1       	breq	.+66     	; 0x111c <__stack+0x1d>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
    10da:	82 e9       	ldi	r24, 0x92	; 146
    10dc:	91 e0       	ldi	r25, 0x01	; 1
    10de:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
    10e2:	9d 83       	std	Y+5, r25	; 0x05
    10e4:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
    10e6:	82 e9       	ldi	r24, 0x92	; 146
    10e8:	91 e0       	ldi	r25, 0x01	; 1
    10ea:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
    10ee:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
    10f0:	82 e9       	ldi	r24, 0x92	; 146
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
    10f8:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
    10fa:	85 e0       	ldi	r24, 0x05	; 5
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1100:	3d 81       	ldd	r19, Y+5	; 0x05
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 71 1f 	call	0x3ee2	; 0x3ee2 <__eewr_word_m644pa>
		eeprom_write_byte(&eeMonth,tempMonth);
    1108:	83 e0       	ldi	r24, 0x03	; 3
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	6e 81       	ldd	r22, Y+6	; 0x06
    110e:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeDay,tempDay);
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	6f 81       	ldd	r22, Y+7	; 0x07
    1118:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <__eewr_byte_m644pa>
	}
	sei();
    111c:	78 94       	sei
}
    111e:	29 96       	adiw	r28, 0x09	; 9
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	cd bf       	out	0x3d, r28	; 61
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	08 95       	ret

00001130 <_Z13PutUartChBonec>:
extern BOOL flagReceivingBone, flagFreshStart, restart, flagReceivingGAVR,flagWaitingForReceiveGAVR;
extern WORD globalADC, globalTemp;
extern myTime currentTime;

/**************************************************************************************************************/
void PutUartChBone(char ch){
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	0f 92       	push	r0
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
    113a:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
    113c:	00 00       	nop
    113e:	80 ec       	ldi	r24, 0xC0	; 192
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	fc 01       	movw	r30, r24
    1144:	80 81       	ld	r24, Z
    1146:	88 2f       	mov	r24, r24
    1148:	90 e0       	ldi	r25, 0x00	; 0
    114a:	80 72       	andi	r24, 0x20	; 32
    114c:	90 70       	andi	r25, 0x00	; 0
    114e:	21 e0       	ldi	r18, 0x01	; 1
    1150:	00 97       	sbiw	r24, 0x00	; 0
    1152:	09 f0       	breq	.+2      	; 0x1156 <_Z13PutUartChBonec+0x26>
    1154:	20 e0       	ldi	r18, 0x00	; 0
    1156:	22 23       	and	r18, r18
    1158:	91 f7       	brne	.-28     	; 0x113e <_Z13PutUartChBonec+0xe>
	UDR0=ch;
    115a:	86 ec       	ldi	r24, 0xC6	; 198
    115c:	90 e0       	ldi	r25, 0x00	; 0
    115e:	29 81       	ldd	r18, Y+1	; 0x01
    1160:	fc 01       	movw	r30, r24
    1162:	20 83       	st	Z, r18
}
    1164:	0f 90       	pop	r0
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	08 95       	ret

0000116c <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
    116c:	0f 93       	push	r16
    116e:	1f 93       	push	r17
    1170:	cf 93       	push	r28
    1172:	df 93       	push	r29
    1174:	cd b7       	in	r28, 0x3d	; 61
    1176:	de b7       	in	r29, 0x3e	; 62
    1178:	61 97       	sbiw	r28, 0x11	; 17
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	f8 94       	cli
    117e:	de bf       	out	0x3e, r29	; 62
    1180:	0f be       	out	0x3f, r0	; 63
    1182:	cd bf       	out	0x3d, r28	; 61
    1184:	99 8b       	std	Y+17, r25	; 0x11
    1186:	88 8b       	std	Y+16, r24	; 0x10
	BYTE i=0;
    1188:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    118a:	92 c0       	rjmp	.+292    	; 0x12b0 <_Z9PrintBonePc+0x144>
		PutUartChBone(string[i++]);
    118c:	89 81       	ldd	r24, Y+1	; 0x01
    118e:	88 2f       	mov	r24, r24
    1190:	90 e0       	ldi	r25, 0x00	; 0
    1192:	28 89       	ldd	r18, Y+16	; 0x10
    1194:	39 89       	ldd	r19, Y+17	; 0x11
    1196:	82 0f       	add	r24, r18
    1198:	93 1f       	adc	r25, r19
    119a:	fc 01       	movw	r30, r24
    119c:	80 81       	ld	r24, Z
    119e:	99 81       	ldd	r25, Y+1	; 0x01
    11a0:	9f 5f       	subi	r25, 0xFF	; 255
    11a2:	99 83       	std	Y+1, r25	; 0x01
    11a4:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z13PutUartChBonec>
    11a8:	80 e0       	ldi	r24, 0x00	; 0
    11aa:	90 e0       	ldi	r25, 0x00	; 0
    11ac:	a8 e4       	ldi	r26, 0x48	; 72
    11ae:	b3 e4       	ldi	r27, 0x43	; 67
    11b0:	8a 83       	std	Y+2, r24	; 0x02
    11b2:	9b 83       	std	Y+3, r25	; 0x03
    11b4:	ac 83       	std	Y+4, r26	; 0x04
    11b6:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    11b8:	6a 81       	ldd	r22, Y+2	; 0x02
    11ba:	7b 81       	ldd	r23, Y+3	; 0x03
    11bc:	8c 81       	ldd	r24, Y+4	; 0x04
    11be:	9d 81       	ldd	r25, Y+5	; 0x05
    11c0:	20 e0       	ldi	r18, 0x00	; 0
    11c2:	30 e0       	ldi	r19, 0x00	; 0
    11c4:	4a e7       	ldi	r20, 0x7A	; 122
    11c6:	53 e4       	ldi	r21, 0x43	; 67
    11c8:	0e 94 0b 1e 	call	0x3c16	; 0x3c16 <__mulsf3>
    11cc:	dc 01       	movw	r26, r24
    11ce:	cb 01       	movw	r24, r22
    11d0:	8e 83       	std	Y+6, r24	; 0x06
    11d2:	9f 83       	std	Y+7, r25	; 0x07
    11d4:	a8 87       	std	Y+8, r26	; 0x08
    11d6:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    11d8:	11 e0       	ldi	r17, 0x01	; 1
    11da:	6e 81       	ldd	r22, Y+6	; 0x06
    11dc:	7f 81       	ldd	r23, Y+7	; 0x07
    11de:	88 85       	ldd	r24, Y+8	; 0x08
    11e0:	99 85       	ldd	r25, Y+9	; 0x09
    11e2:	20 e0       	ldi	r18, 0x00	; 0
    11e4:	30 e0       	ldi	r19, 0x00	; 0
    11e6:	40 e8       	ldi	r20, 0x80	; 128
    11e8:	5f e3       	ldi	r21, 0x3F	; 63
    11ea:	0e 94 8a 1d 	call	0x3b14	; 0x3b14 <__cmpsf2>
    11ee:	88 23       	and	r24, r24
    11f0:	0c f0       	brlt	.+2      	; 0x11f4 <_Z9PrintBonePc+0x88>
    11f2:	10 e0       	ldi	r17, 0x00	; 0
    11f4:	11 23       	and	r17, r17
    11f6:	29 f0       	breq	.+10     	; 0x1202 <_Z9PrintBonePc+0x96>
		__ticks = 1;
    11f8:	81 e0       	ldi	r24, 0x01	; 1
    11fa:	90 e0       	ldi	r25, 0x00	; 0
    11fc:	9b 87       	std	Y+11, r25	; 0x0b
    11fe:	8a 87       	std	Y+10, r24	; 0x0a
    1200:	4a c0       	rjmp	.+148    	; 0x1296 <_Z9PrintBonePc+0x12a>
	else if (__tmp > 65535)
    1202:	11 e0       	ldi	r17, 0x01	; 1
    1204:	6e 81       	ldd	r22, Y+6	; 0x06
    1206:	7f 81       	ldd	r23, Y+7	; 0x07
    1208:	88 85       	ldd	r24, Y+8	; 0x08
    120a:	99 85       	ldd	r25, Y+9	; 0x09
    120c:	20 e0       	ldi	r18, 0x00	; 0
    120e:	3f ef       	ldi	r19, 0xFF	; 255
    1210:	4f e7       	ldi	r20, 0x7F	; 127
    1212:	57 e4       	ldi	r21, 0x47	; 71
    1214:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <__gesf2>
    1218:	18 16       	cp	r1, r24
    121a:	0c f0       	brlt	.+2      	; 0x121e <_Z9PrintBonePc+0xb2>
    121c:	10 e0       	ldi	r17, 0x00	; 0
    121e:	11 23       	and	r17, r17
    1220:	81 f1       	breq	.+96     	; 0x1282 <_Z9PrintBonePc+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1222:	6a 81       	ldd	r22, Y+2	; 0x02
    1224:	7b 81       	ldd	r23, Y+3	; 0x03
    1226:	8c 81       	ldd	r24, Y+4	; 0x04
    1228:	9d 81       	ldd	r25, Y+5	; 0x05
    122a:	20 e0       	ldi	r18, 0x00	; 0
    122c:	30 e0       	ldi	r19, 0x00	; 0
    122e:	40 e2       	ldi	r20, 0x20	; 32
    1230:	51 e4       	ldi	r21, 0x41	; 65
    1232:	0e 94 0b 1e 	call	0x3c16	; 0x3c16 <__mulsf3>
    1236:	dc 01       	movw	r26, r24
    1238:	cb 01       	movw	r24, r22
    123a:	bc 01       	movw	r22, r24
    123c:	cd 01       	movw	r24, r26
    123e:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <__fixunssfsi>
    1242:	dc 01       	movw	r26, r24
    1244:	cb 01       	movw	r24, r22
    1246:	9b 87       	std	Y+11, r25	; 0x0b
    1248:	8a 87       	std	Y+10, r24	; 0x0a
    124a:	12 c0       	rjmp	.+36     	; 0x1270 <_Z9PrintBonePc+0x104>
    124c:	89 e1       	ldi	r24, 0x19	; 25
    124e:	90 e0       	ldi	r25, 0x00	; 0
    1250:	9d 87       	std	Y+13, r25	; 0x0d
    1252:	8c 87       	std	Y+12, r24	; 0x0c
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    1254:	8c 85       	ldd	r24, Y+12	; 0x0c
    1256:	9d 85       	ldd	r25, Y+13	; 0x0d
    1258:	8c 01       	movw	r16, r24
    125a:	c8 01       	movw	r24, r16
    125c:	01 97       	sbiw	r24, 0x01	; 1
    125e:	f1 f7       	brne	.-4      	; 0x125c <_Z9PrintBonePc+0xf0>
    1260:	8c 01       	movw	r16, r24
    1262:	1d 87       	std	Y+13, r17	; 0x0d
    1264:	0c 87       	std	Y+12, r16	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1266:	8a 85       	ldd	r24, Y+10	; 0x0a
    1268:	9b 85       	ldd	r25, Y+11	; 0x0b
    126a:	01 97       	sbiw	r24, 0x01	; 1
    126c:	9b 87       	std	Y+11, r25	; 0x0b
    126e:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1270:	21 e0       	ldi	r18, 0x01	; 1
    1272:	8a 85       	ldd	r24, Y+10	; 0x0a
    1274:	9b 85       	ldd	r25, Y+11	; 0x0b
    1276:	00 97       	sbiw	r24, 0x00	; 0
    1278:	09 f4       	brne	.+2      	; 0x127c <_Z9PrintBonePc+0x110>
    127a:	20 e0       	ldi	r18, 0x00	; 0
    127c:	22 23       	and	r18, r18
    127e:	31 f7       	brne	.-52     	; 0x124c <_Z9PrintBonePc+0xe0>
    1280:	17 c0       	rjmp	.+46     	; 0x12b0 <_Z9PrintBonePc+0x144>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1282:	6e 81       	ldd	r22, Y+6	; 0x06
    1284:	7f 81       	ldd	r23, Y+7	; 0x07
    1286:	88 85       	ldd	r24, Y+8	; 0x08
    1288:	99 85       	ldd	r25, Y+9	; 0x09
    128a:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <__fixunssfsi>
    128e:	dc 01       	movw	r26, r24
    1290:	cb 01       	movw	r24, r22
    1292:	9b 87       	std	Y+11, r25	; 0x0b
    1294:	8a 87       	std	Y+10, r24	; 0x0a
    1296:	8a 85       	ldd	r24, Y+10	; 0x0a
    1298:	9b 85       	ldd	r25, Y+11	; 0x0b
    129a:	9f 87       	std	Y+15, r25	; 0x0f
    129c:	8e 87       	std	Y+14, r24	; 0x0e
    129e:	8e 85       	ldd	r24, Y+14	; 0x0e
    12a0:	9f 85       	ldd	r25, Y+15	; 0x0f
    12a2:	8c 01       	movw	r16, r24
    12a4:	f8 01       	movw	r30, r16
    12a6:	31 97       	sbiw	r30, 0x01	; 1
    12a8:	f1 f7       	brne	.-4      	; 0x12a6 <_Z9PrintBonePc+0x13a>
    12aa:	8f 01       	movw	r16, r30
    12ac:	1f 87       	std	Y+15, r17	; 0x0f
    12ae:	0e 87       	std	Y+14, r16	; 0x0e
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    12b0:	89 81       	ldd	r24, Y+1	; 0x01
    12b2:	88 2f       	mov	r24, r24
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	28 89       	ldd	r18, Y+16	; 0x10
    12b8:	39 89       	ldd	r19, Y+17	; 0x11
    12ba:	82 0f       	add	r24, r18
    12bc:	93 1f       	adc	r25, r19
    12be:	fc 01       	movw	r30, r24
    12c0:	90 81       	ld	r25, Z
    12c2:	81 e0       	ldi	r24, 0x01	; 1
    12c4:	99 23       	and	r25, r25
    12c6:	09 f4       	brne	.+2      	; 0x12ca <_Z9PrintBonePc+0x15e>
    12c8:	80 e0       	ldi	r24, 0x00	; 0
    12ca:	88 23       	and	r24, r24
    12cc:	09 f0       	breq	.+2      	; 0x12d0 <_Z9PrintBonePc+0x164>
    12ce:	5e cf       	rjmp	.-324    	; 0x118c <_Z9PrintBonePc+0x20>
		PutUartChBone(string[i++]);
		_delay_ms(200);
	}
}
    12d0:	61 96       	adiw	r28, 0x11	; 17
    12d2:	0f b6       	in	r0, 0x3f	; 63
    12d4:	f8 94       	cli
    12d6:	de bf       	out	0x3e, r29	; 62
    12d8:	0f be       	out	0x3f, r0	; 63
    12da:	cd bf       	out	0x3d, r28	; 61
    12dc:	df 91       	pop	r29
    12de:	cf 91       	pop	r28
    12e0:	1f 91       	pop	r17
    12e2:	0f 91       	pop	r16
    12e4:	08 95       	ret

000012e6 <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    12e6:	cf 93       	push	r28
    12e8:	df 93       	push	r29
    12ea:	0f 92       	push	r0
    12ec:	cd b7       	in	r28, 0x3d	; 61
    12ee:	de b7       	in	r29, 0x3e	; 62
    12f0:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    12f2:	00 00       	nop
    12f4:	88 ec       	ldi	r24, 0xC8	; 200
    12f6:	90 e0       	ldi	r25, 0x00	; 0
    12f8:	fc 01       	movw	r30, r24
    12fa:	80 81       	ld	r24, Z
    12fc:	88 2f       	mov	r24, r24
    12fe:	90 e0       	ldi	r25, 0x00	; 0
    1300:	80 72       	andi	r24, 0x20	; 32
    1302:	90 70       	andi	r25, 0x00	; 0
    1304:	21 e0       	ldi	r18, 0x01	; 1
    1306:	00 97       	sbiw	r24, 0x00	; 0
    1308:	09 f0       	breq	.+2      	; 0x130c <_Z13PutUartChGAVRc+0x26>
    130a:	20 e0       	ldi	r18, 0x00	; 0
    130c:	22 23       	and	r18, r18
    130e:	91 f7       	brne	.-28     	; 0x12f4 <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    1310:	8e ec       	ldi	r24, 0xCE	; 206
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	29 81       	ldd	r18, Y+1	; 0x01
    1316:	fc 01       	movw	r30, r24
    1318:	20 83       	st	Z, r18
}
    131a:	0f 90       	pop	r0
    131c:	df 91       	pop	r29
    131e:	cf 91       	pop	r28
    1320:	08 95       	ret

00001322 <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    1322:	0f 93       	push	r16
    1324:	1f 93       	push	r17
    1326:	cf 93       	push	r28
    1328:	df 93       	push	r29
    132a:	cd b7       	in	r28, 0x3d	; 61
    132c:	de b7       	in	r29, 0x3e	; 62
    132e:	61 97       	sbiw	r28, 0x11	; 17
    1330:	0f b6       	in	r0, 0x3f	; 63
    1332:	f8 94       	cli
    1334:	de bf       	out	0x3e, r29	; 62
    1336:	0f be       	out	0x3f, r0	; 63
    1338:	cd bf       	out	0x3d, r28	; 61
    133a:	99 8b       	std	Y+17, r25	; 0x11
    133c:	88 8b       	std	Y+16, r24	; 0x10
	BYTE i=0;
    133e:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    1340:	92 c0       	rjmp	.+292    	; 0x1466 <_Z9PrintGAVRPc+0x144>
		PutUartChGAVR(string[i++]);
    1342:	89 81       	ldd	r24, Y+1	; 0x01
    1344:	88 2f       	mov	r24, r24
    1346:	90 e0       	ldi	r25, 0x00	; 0
    1348:	28 89       	ldd	r18, Y+16	; 0x10
    134a:	39 89       	ldd	r19, Y+17	; 0x11
    134c:	82 0f       	add	r24, r18
    134e:	93 1f       	adc	r25, r19
    1350:	fc 01       	movw	r30, r24
    1352:	80 81       	ld	r24, Z
    1354:	99 81       	ldd	r25, Y+1	; 0x01
    1356:	9f 5f       	subi	r25, 0xFF	; 255
    1358:	99 83       	std	Y+1, r25	; 0x01
    135a:	0e 94 73 09 	call	0x12e6	; 0x12e6 <_Z13PutUartChGAVRc>
    135e:	80 e0       	ldi	r24, 0x00	; 0
    1360:	90 e0       	ldi	r25, 0x00	; 0
    1362:	a8 e4       	ldi	r26, 0x48	; 72
    1364:	b3 e4       	ldi	r27, 0x43	; 67
    1366:	8a 83       	std	Y+2, r24	; 0x02
    1368:	9b 83       	std	Y+3, r25	; 0x03
    136a:	ac 83       	std	Y+4, r26	; 0x04
    136c:	bd 83       	std	Y+5, r27	; 0x05
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    136e:	6a 81       	ldd	r22, Y+2	; 0x02
    1370:	7b 81       	ldd	r23, Y+3	; 0x03
    1372:	8c 81       	ldd	r24, Y+4	; 0x04
    1374:	9d 81       	ldd	r25, Y+5	; 0x05
    1376:	20 e0       	ldi	r18, 0x00	; 0
    1378:	30 e0       	ldi	r19, 0x00	; 0
    137a:	4a e7       	ldi	r20, 0x7A	; 122
    137c:	53 e4       	ldi	r21, 0x43	; 67
    137e:	0e 94 0b 1e 	call	0x3c16	; 0x3c16 <__mulsf3>
    1382:	dc 01       	movw	r26, r24
    1384:	cb 01       	movw	r24, r22
    1386:	8e 83       	std	Y+6, r24	; 0x06
    1388:	9f 83       	std	Y+7, r25	; 0x07
    138a:	a8 87       	std	Y+8, r26	; 0x08
    138c:	b9 87       	std	Y+9, r27	; 0x09
	if (__tmp < 1.0)
    138e:	11 e0       	ldi	r17, 0x01	; 1
    1390:	6e 81       	ldd	r22, Y+6	; 0x06
    1392:	7f 81       	ldd	r23, Y+7	; 0x07
    1394:	88 85       	ldd	r24, Y+8	; 0x08
    1396:	99 85       	ldd	r25, Y+9	; 0x09
    1398:	20 e0       	ldi	r18, 0x00	; 0
    139a:	30 e0       	ldi	r19, 0x00	; 0
    139c:	40 e8       	ldi	r20, 0x80	; 128
    139e:	5f e3       	ldi	r21, 0x3F	; 63
    13a0:	0e 94 8a 1d 	call	0x3b14	; 0x3b14 <__cmpsf2>
    13a4:	88 23       	and	r24, r24
    13a6:	0c f0       	brlt	.+2      	; 0x13aa <_Z9PrintGAVRPc+0x88>
    13a8:	10 e0       	ldi	r17, 0x00	; 0
    13aa:	11 23       	and	r17, r17
    13ac:	29 f0       	breq	.+10     	; 0x13b8 <_Z9PrintGAVRPc+0x96>
		__ticks = 1;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	90 e0       	ldi	r25, 0x00	; 0
    13b2:	9b 87       	std	Y+11, r25	; 0x0b
    13b4:	8a 87       	std	Y+10, r24	; 0x0a
    13b6:	4a c0       	rjmp	.+148    	; 0x144c <_Z9PrintGAVRPc+0x12a>
	else if (__tmp > 65535)
    13b8:	11 e0       	ldi	r17, 0x01	; 1
    13ba:	6e 81       	ldd	r22, Y+6	; 0x06
    13bc:	7f 81       	ldd	r23, Y+7	; 0x07
    13be:	88 85       	ldd	r24, Y+8	; 0x08
    13c0:	99 85       	ldd	r25, Y+9	; 0x09
    13c2:	20 e0       	ldi	r18, 0x00	; 0
    13c4:	3f ef       	ldi	r19, 0xFF	; 255
    13c6:	4f e7       	ldi	r20, 0x7F	; 127
    13c8:	57 e4       	ldi	r21, 0x47	; 71
    13ca:	0e 94 07 1e 	call	0x3c0e	; 0x3c0e <__gesf2>
    13ce:	18 16       	cp	r1, r24
    13d0:	0c f0       	brlt	.+2      	; 0x13d4 <_Z9PrintGAVRPc+0xb2>
    13d2:	10 e0       	ldi	r17, 0x00	; 0
    13d4:	11 23       	and	r17, r17
    13d6:	81 f1       	breq	.+96     	; 0x1438 <_Z9PrintGAVRPc+0x116>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    13d8:	6a 81       	ldd	r22, Y+2	; 0x02
    13da:	7b 81       	ldd	r23, Y+3	; 0x03
    13dc:	8c 81       	ldd	r24, Y+4	; 0x04
    13de:	9d 81       	ldd	r25, Y+5	; 0x05
    13e0:	20 e0       	ldi	r18, 0x00	; 0
    13e2:	30 e0       	ldi	r19, 0x00	; 0
    13e4:	40 e2       	ldi	r20, 0x20	; 32
    13e6:	51 e4       	ldi	r21, 0x41	; 65
    13e8:	0e 94 0b 1e 	call	0x3c16	; 0x3c16 <__mulsf3>
    13ec:	dc 01       	movw	r26, r24
    13ee:	cb 01       	movw	r24, r22
    13f0:	bc 01       	movw	r22, r24
    13f2:	cd 01       	movw	r24, r26
    13f4:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <__fixunssfsi>
    13f8:	dc 01       	movw	r26, r24
    13fa:	cb 01       	movw	r24, r22
    13fc:	9b 87       	std	Y+11, r25	; 0x0b
    13fe:	8a 87       	std	Y+10, r24	; 0x0a
    1400:	12 c0       	rjmp	.+36     	; 0x1426 <_Z9PrintGAVRPc+0x104>
    1402:	89 e1       	ldi	r24, 0x19	; 25
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	9d 87       	std	Y+13, r25	; 0x0d
    1408:	8c 87       	std	Y+12, r24	; 0x0c
    140a:	8c 85       	ldd	r24, Y+12	; 0x0c
    140c:	9d 85       	ldd	r25, Y+13	; 0x0d
    140e:	8c 01       	movw	r16, r24
    1410:	c8 01       	movw	r24, r16
    1412:	01 97       	sbiw	r24, 0x01	; 1
    1414:	f1 f7       	brne	.-4      	; 0x1412 <_Z9PrintGAVRPc+0xf0>
    1416:	8c 01       	movw	r16, r24
    1418:	1d 87       	std	Y+13, r17	; 0x0d
    141a:	0c 87       	std	Y+12, r16	; 0x0c
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    141c:	8a 85       	ldd	r24, Y+10	; 0x0a
    141e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1420:	01 97       	sbiw	r24, 0x01	; 1
    1422:	9b 87       	std	Y+11, r25	; 0x0b
    1424:	8a 87       	std	Y+10, r24	; 0x0a
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1426:	21 e0       	ldi	r18, 0x01	; 1
    1428:	8a 85       	ldd	r24, Y+10	; 0x0a
    142a:	9b 85       	ldd	r25, Y+11	; 0x0b
    142c:	00 97       	sbiw	r24, 0x00	; 0
    142e:	09 f4       	brne	.+2      	; 0x1432 <_Z9PrintGAVRPc+0x110>
    1430:	20 e0       	ldi	r18, 0x00	; 0
    1432:	22 23       	and	r18, r18
    1434:	31 f7       	brne	.-52     	; 0x1402 <_Z9PrintGAVRPc+0xe0>
    1436:	17 c0       	rjmp	.+46     	; 0x1466 <_Z9PrintGAVRPc+0x144>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1438:	6e 81       	ldd	r22, Y+6	; 0x06
    143a:	7f 81       	ldd	r23, Y+7	; 0x07
    143c:	88 85       	ldd	r24, Y+8	; 0x08
    143e:	99 85       	ldd	r25, Y+9	; 0x09
    1440:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <__fixunssfsi>
    1444:	dc 01       	movw	r26, r24
    1446:	cb 01       	movw	r24, r22
    1448:	9b 87       	std	Y+11, r25	; 0x0b
    144a:	8a 87       	std	Y+10, r24	; 0x0a
    144c:	8a 85       	ldd	r24, Y+10	; 0x0a
    144e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1450:	9f 87       	std	Y+15, r25	; 0x0f
    1452:	8e 87       	std	Y+14, r24	; 0x0e
    1454:	8e 85       	ldd	r24, Y+14	; 0x0e
    1456:	9f 85       	ldd	r25, Y+15	; 0x0f
    1458:	8c 01       	movw	r16, r24
    145a:	f8 01       	movw	r30, r16
    145c:	31 97       	sbiw	r30, 0x01	; 1
    145e:	f1 f7       	brne	.-4      	; 0x145c <_Z9PrintGAVRPc+0x13a>
    1460:	8f 01       	movw	r16, r30
    1462:	1f 87       	std	Y+15, r17	; 0x0f
    1464:	0e 87       	std	Y+14, r16	; 0x0e
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    1466:	89 81       	ldd	r24, Y+1	; 0x01
    1468:	88 2f       	mov	r24, r24
    146a:	90 e0       	ldi	r25, 0x00	; 0
    146c:	28 89       	ldd	r18, Y+16	; 0x10
    146e:	39 89       	ldd	r19, Y+17	; 0x11
    1470:	82 0f       	add	r24, r18
    1472:	93 1f       	adc	r25, r19
    1474:	fc 01       	movw	r30, r24
    1476:	90 81       	ld	r25, Z
    1478:	81 e0       	ldi	r24, 0x01	; 1
    147a:	99 23       	and	r25, r25
    147c:	09 f4       	brne	.+2      	; 0x1480 <_Z9PrintGAVRPc+0x15e>
    147e:	80 e0       	ldi	r24, 0x00	; 0
    1480:	88 23       	and	r24, r24
    1482:	09 f0       	breq	.+2      	; 0x1486 <_Z9PrintGAVRPc+0x164>
    1484:	5e cf       	rjmp	.-324    	; 0x1342 <_Z9PrintGAVRPc+0x20>
		PutUartChGAVR(string[i++]);
		_delay_ms(200);
	}
}
    1486:	61 96       	adiw	r28, 0x11	; 17
    1488:	0f b6       	in	r0, 0x3f	; 63
    148a:	f8 94       	cli
    148c:	de bf       	out	0x3e, r29	; 62
    148e:	0f be       	out	0x3f, r0	; 63
    1490:	cd bf       	out	0x3d, r28	; 61
    1492:	df 91       	pop	r29
    1494:	cf 91       	pop	r28
    1496:	1f 91       	pop	r17
    1498:	0f 91       	pop	r16
    149a:	08 95       	ret

0000149c <_Z8sendGAVRv>:
/*************************************************************************************************************/
void sendGAVR(){
    149c:	cf 93       	push	r28
    149e:	df 93       	push	r29
    14a0:	cd b7       	in	r28, 0x3d	; 61
    14a2:	de b7       	in	r29, 0x3e	; 62
    14a4:	ce 55       	subi	r28, 0x5E	; 94
    14a6:	d0 40       	sbci	r29, 0x00	; 0
    14a8:	0f b6       	in	r0, 0x3f	; 63
    14aa:	f8 94       	cli
    14ac:	de bf       	out	0x3e, r29	; 62
    14ae:	0f be       	out	0x3f, r0	; 63
    14b0:	cd bf       	out	0x3d, r28	; 61
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	8e 87       	std	Y+14, r24	; 0x0e
	char recChar, recString[40], sentString[40];
	unsigned int strLoc=0;
    14b6:	1a 82       	std	Y+2, r1	; 0x02
    14b8:	19 82       	std	Y+1, r1	; 0x01
	
	//Used for shutdown connection logic if there was a timeout in sending or receiving
	BOOL flagTimeout=fFalse;
    14ba:	1b 82       	std	Y+3, r1	; 0x03
	
	//Set sending flag
	flagSendingGAVR=fTrue;
    14bc:	81 e0       	ldi	r24, 0x01	; 1
    14be:	80 93 c1 01 	sts	0x01C1, r24
	
	//Transmission protocol
	while (flagSendingGAVR && !flagTimeout){
    14c2:	34 c2       	rjmp	.+1128   	; 0x192c <_Z8sendGAVRv+0x490>
		/* State 5: Successful transmission and reception. Kill sending flag, reset state, exit.					 */
		/* State 6: ACKBAD received, check to see if we have an invalid date/time in our clock or it was just noisy  */
		/*			and had error in transmission/reception. If valid, go to waiting state. Else exit and set flag.	 */
		/* State 7: Got the wrong ack for something, set a flag to let the WAVR do its thing then try again.		 */
		/*************************************************************************************************************/
		switch (state){
    14c4:	80 91 d4 01 	lds	r24, 0x01D4
    14c8:	90 91 d5 01 	lds	r25, 0x01D5
    14cc:	83 30       	cpi	r24, 0x03	; 3
    14ce:	91 05       	cpc	r25, r1
    14d0:	09 f4       	brne	.+2      	; 0x14d4 <_Z8sendGAVRv+0x38>
    14d2:	1e c1       	rjmp	.+572    	; 0x1710 <_Z8sendGAVRv+0x274>
    14d4:	84 30       	cpi	r24, 0x04	; 4
    14d6:	91 05       	cpc	r25, r1
    14d8:	48 f4       	brcc	.+18     	; 0x14ec <_Z8sendGAVRv+0x50>
    14da:	81 30       	cpi	r24, 0x01	; 1
    14dc:	91 05       	cpc	r25, r1
    14de:	09 f4       	brne	.+2      	; 0x14e2 <_Z8sendGAVRv+0x46>
    14e0:	98 c0       	rjmp	.+304    	; 0x1612 <_Z8sendGAVRv+0x176>
    14e2:	82 30       	cpi	r24, 0x02	; 2
    14e4:	91 05       	cpc	r25, r1
    14e6:	08 f0       	brcs	.+2      	; 0x14ea <_Z8sendGAVRv+0x4e>
    14e8:	a2 c0       	rjmp	.+324    	; 0x162e <_Z8sendGAVRv+0x192>
    14ea:	11 c0       	rjmp	.+34     	; 0x150e <_Z8sendGAVRv+0x72>
    14ec:	85 30       	cpi	r24, 0x05	; 5
    14ee:	91 05       	cpc	r25, r1
    14f0:	09 f4       	brne	.+2      	; 0x14f4 <_Z8sendGAVRv+0x58>
    14f2:	ad c1       	rjmp	.+858    	; 0x184e <_Z8sendGAVRv+0x3b2>
    14f4:	85 30       	cpi	r24, 0x05	; 5
    14f6:	91 05       	cpc	r25, r1
    14f8:	08 f4       	brcc	.+2      	; 0x14fc <_Z8sendGAVRv+0x60>
    14fa:	9e c1       	rjmp	.+828    	; 0x1838 <_Z8sendGAVRv+0x39c>
    14fc:	86 30       	cpi	r24, 0x06	; 6
    14fe:	91 05       	cpc	r25, r1
    1500:	09 f4       	brne	.+2      	; 0x1504 <_Z8sendGAVRv+0x68>
    1502:	cb c1       	rjmp	.+918    	; 0x189a <_Z8sendGAVRv+0x3fe>
    1504:	87 30       	cpi	r24, 0x07	; 7
    1506:	91 05       	cpc	r25, r1
    1508:	09 f4       	brne	.+2      	; 0x150c <_Z8sendGAVRv+0x70>
    150a:	e0 c1       	rjmp	.+960    	; 0x18cc <_Z8sendGAVRv+0x430>
    150c:	06 c2       	rjmp	.+1036   	; 0x191a <_Z8sendGAVRv+0x47e>
			case 0: {
				//Raise interrupts to GAVR for three ish clock cycles.
				prtGAVRINT |= (1 << bnGAVRINT);
    150e:	85 e2       	ldi	r24, 0x25	; 37
    1510:	90 e0       	ldi	r25, 0x00	; 0
    1512:	25 e2       	ldi	r18, 0x25	; 37
    1514:	30 e0       	ldi	r19, 0x00	; 0
    1516:	f9 01       	movw	r30, r18
    1518:	20 81       	ld	r18, Z
    151a:	28 60       	ori	r18, 0x08	; 8
    151c:	fc 01       	movw	r30, r24
    151e:	20 83       	st	Z, r18
				for (int i=0; i<2; i++){asm volatile("nop");}
    1520:	1d 82       	std	Y+5, r1	; 0x05
    1522:	1c 82       	std	Y+4, r1	; 0x04
    1524:	06 c0       	rjmp	.+12     	; 0x1532 <_Z8sendGAVRv+0x96>
    1526:	00 00       	nop
    1528:	8c 81       	ldd	r24, Y+4	; 0x04
    152a:	9d 81       	ldd	r25, Y+5	; 0x05
    152c:	01 96       	adiw	r24, 0x01	; 1
    152e:	9d 83       	std	Y+5, r25	; 0x05
    1530:	8c 83       	std	Y+4, r24	; 0x04
    1532:	21 e0       	ldi	r18, 0x01	; 1
    1534:	8c 81       	ldd	r24, Y+4	; 0x04
    1536:	9d 81       	ldd	r25, Y+5	; 0x05
    1538:	82 30       	cpi	r24, 0x02	; 2
    153a:	91 05       	cpc	r25, r1
    153c:	0c f0       	brlt	.+2      	; 0x1540 <_Z8sendGAVRv+0xa4>
    153e:	20 e0       	ldi	r18, 0x00	; 0
    1540:	22 23       	and	r18, r18
    1542:	89 f7       	brne	.-30     	; 0x1526 <_Z8sendGAVRv+0x8a>
				prtGAVRINT &= ~(1 << bnGAVRINT);
    1544:	85 e2       	ldi	r24, 0x25	; 37
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	25 e2       	ldi	r18, 0x25	; 37
    154a:	30 e0       	ldi	r19, 0x00	; 0
    154c:	f9 01       	movw	r30, r18
    154e:	20 81       	ld	r18, Z
    1550:	27 7f       	andi	r18, 0xF7	; 247
    1552:	fc 01       	movw	r30, r24
    1554:	20 83       	st	Z, r18
				state=1;
    1556:	81 e0       	ldi	r24, 0x01	; 1
    1558:	90 e0       	ldi	r25, 0x00	; 0
    155a:	90 93 d5 01 	sts	0x01D5, r25
    155e:	80 93 d4 01 	sts	0x01D4, r24
				break;
    1562:	e4 c1       	rjmp	.+968    	; 0x192c <_Z8sendGAVRv+0x490>
			}//end case 0
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
    1564:	00 00       	nop
    1566:	88 ec       	ldi	r24, 0xC8	; 200
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	fc 01       	movw	r30, r24
    156c:	80 81       	ld	r24, Z
    156e:	88 23       	and	r24, r24
    1570:	34 f0       	brlt	.+12     	; 0x157e <_Z8sendGAVRv+0xe2>
    1572:	80 91 c1 01 	lds	r24, 0x01C1
    1576:	88 23       	and	r24, r24
    1578:	11 f0       	breq	.+4      	; 0x157e <_Z8sendGAVRv+0xe2>
    157a:	81 e0       	ldi	r24, 0x01	; 1
    157c:	01 c0       	rjmp	.+2      	; 0x1580 <_Z8sendGAVRv+0xe4>
    157e:	80 e0       	ldi	r24, 0x00	; 0
    1580:	88 23       	and	r24, r24
    1582:	89 f7       	brne	.-30     	; 0x1566 <_Z8sendGAVRv+0xca>
					if (!flagSendingGAVR){state=0; flagTimeout=fTrue; break;}		//if timeout is why we broke, just exit
    1584:	80 91 c1 01 	lds	r24, 0x01C1
    1588:	88 23       	and	r24, r24
    158a:	41 f4       	brne	.+16     	; 0x159c <_Z8sendGAVRv+0x100>
    158c:	10 92 d5 01 	sts	0x01D5, r1
    1590:	10 92 d4 01 	sts	0x01D4, r1
    1594:	81 e0       	ldi	r24, 0x01	; 1
    1596:	8b 83       	std	Y+3, r24	; 0x03
    1598:	00 00       	nop
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    159a:	c8 c1       	rjmp	.+912    	; 0x192c <_Z8sendGAVRv+0x490>
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
					if (!flagSendingGAVR){state=0; flagTimeout=fTrue; break;}		//if timeout is why we broke, just exit
					recChar=UDR1;
    159c:	8e ec       	ldi	r24, 0xCE	; 206
    159e:	90 e0       	ldi	r25, 0x00	; 0
    15a0:	fc 01       	movw	r30, r24
    15a2:	80 81       	ld	r24, Z
    15a4:	8c 87       	std	Y+12, r24	; 0x0c
					recString[strLoc++]=recChar;
    15a6:	9e 01       	movw	r18, r28
    15a8:	29 5c       	subi	r18, 0xC9	; 201
    15aa:	3f 4f       	sbci	r19, 0xFF	; 255
    15ac:	89 81       	ldd	r24, Y+1	; 0x01
    15ae:	9a 81       	ldd	r25, Y+2	; 0x02
    15b0:	82 0f       	add	r24, r18
    15b2:	93 1f       	adc	r25, r19
    15b4:	2c 85       	ldd	r18, Y+12	; 0x0c
    15b6:	fc 01       	movw	r30, r24
    15b8:	20 83       	st	Z, r18
    15ba:	89 81       	ldd	r24, Y+1	; 0x01
    15bc:	9a 81       	ldd	r25, Y+2	; 0x02
    15be:	01 96       	adiw	r24, 0x01	; 1
    15c0:	9a 83       	std	Y+2, r25	; 0x02
    15c2:	89 83       	std	Y+1, r24	; 0x01
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
    15c4:	8c 85       	ldd	r24, Y+12	; 0x0c
    15c6:	8e 32       	cpi	r24, 0x2E	; 46
    15c8:	b1 f4       	brne	.+44     	; 0x15f6 <_Z8sendGAVRv+0x15a>
    15ca:	9e 01       	movw	r18, r28
    15cc:	29 5c       	subi	r18, 0xC9	; 201
    15ce:	3f 4f       	sbci	r19, 0xFF	; 255
    15d0:	89 81       	ldd	r24, Y+1	; 0x01
    15d2:	9a 81       	ldd	r25, Y+2	; 0x02
    15d4:	82 0f       	add	r24, r18
    15d6:	93 1f       	adc	r25, r19
    15d8:	fc 01       	movw	r30, r24
    15da:	10 82       	st	Z, r1
    15dc:	89 81       	ldd	r24, Y+1	; 0x01
    15de:	9a 81       	ldd	r25, Y+2	; 0x02
    15e0:	01 96       	adiw	r24, 0x01	; 1
    15e2:	9a 83       	std	Y+2, r25	; 0x02
    15e4:	89 83       	std	Y+1, r24	; 0x01
    15e6:	82 e0       	ldi	r24, 0x02	; 2
    15e8:	90 e0       	ldi	r25, 0x00	; 0
    15ea:	90 93 d5 01 	sts	0x01D5, r25
    15ee:	80 93 d4 01 	sts	0x01D4, r24
    15f2:	1e 86       	std	Y+14, r1	; 0x0e
    15f4:	0e c0       	rjmp	.+28     	; 0x1612 <_Z8sendGAVRv+0x176>
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
    15f6:	89 81       	ldd	r24, Y+1	; 0x01
    15f8:	9a 81       	ldd	r25, Y+2	; 0x02
    15fa:	87 32       	cpi	r24, 0x27	; 39
    15fc:	91 05       	cpc	r25, r1
    15fe:	48 f0       	brcs	.+18     	; 0x1612 <_Z8sendGAVRv+0x176>
    1600:	1a 82       	std	Y+2, r1	; 0x02
    1602:	19 82       	std	Y+1, r1	; 0x01
    1604:	1e 86       	std	Y+14, r1	; 0x0e
    1606:	87 e0       	ldi	r24, 0x07	; 7
    1608:	90 e0       	ldi	r25, 0x00	; 0
    160a:	90 93 d5 01 	sts	0x01D5, r25
    160e:	80 93 d4 01 	sts	0x01D4, r24
				state=1;
				break;
			}//end case 0
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    1612:	8e 85       	ldd	r24, Y+14	; 0x0e
    1614:	88 23       	and	r24, r24
    1616:	31 f0       	breq	.+12     	; 0x1624 <_Z8sendGAVRv+0x188>
    1618:	80 91 c1 01 	lds	r24, 0x01C1
    161c:	88 23       	and	r24, r24
    161e:	11 f0       	breq	.+4      	; 0x1624 <_Z8sendGAVRv+0x188>
    1620:	81 e0       	ldi	r24, 0x01	; 1
    1622:	01 c0       	rjmp	.+2      	; 0x1626 <_Z8sendGAVRv+0x18a>
    1624:	80 e0       	ldi	r24, 0x00	; 0
    1626:	88 23       	and	r24, r24
    1628:	09 f0       	breq	.+2      	; 0x162c <_Z8sendGAVRv+0x190>
    162a:	9c cf       	rjmp	.-200    	; 0x1564 <_Z8sendGAVRv+0xc8>
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    162c:	7f c1       	rjmp	.+766    	; 0x192c <_Z8sendGAVRv+0x490>
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
    162e:	ce 01       	movw	r24, r28
    1630:	c7 96       	adiw	r24, 0x37	; 55
    1632:	20 e0       	ldi	r18, 0x00	; 0
    1634:	31 e0       	ldi	r19, 0x01	; 1
    1636:	b9 01       	movw	r22, r18
    1638:	45 e0       	ldi	r20, 0x05	; 5
    163a:	50 e0       	ldi	r21, 0x00	; 0
    163c:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1640:	00 97       	sbiw	r24, 0x00	; 0
    1642:	39 f4       	brne	.+14     	; 0x1652 <_Z8sendGAVRv+0x1b6>
    1644:	83 e0       	ldi	r24, 0x03	; 3
    1646:	90 e0       	ldi	r25, 0x00	; 0
    1648:	90 93 d5 01 	sts	0x01D5, r25
    164c:	80 93 d4 01 	sts	0x01D4, r24
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1650:	6d c1       	rjmp	.+730    	; 0x192c <_Z8sendGAVRv+0x490>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
    1652:	ce 01       	movw	r24, r28
    1654:	c7 96       	adiw	r24, 0x37	; 55
    1656:	26 e0       	ldi	r18, 0x06	; 6
    1658:	31 e0       	ldi	r19, 0x01	; 1
    165a:	b9 01       	movw	r22, r18
    165c:	46 e0       	ldi	r20, 0x06	; 6
    165e:	50 e0       	ldi	r21, 0x00	; 0
    1660:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1664:	00 97       	sbiw	r24, 0x00	; 0
    1666:	39 f4       	brne	.+14     	; 0x1676 <_Z8sendGAVRv+0x1da>
    1668:	84 e0       	ldi	r24, 0x04	; 4
    166a:	90 e0       	ldi	r25, 0x00	; 0
    166c:	90 93 d5 01 	sts	0x01D5, r25
    1670:	80 93 d4 01 	sts	0x01D4, r24
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1674:	5b c1       	rjmp	.+694    	; 0x192c <_Z8sendGAVRv+0x490>
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
    1676:	ce 01       	movw	r24, r28
    1678:	c7 96       	adiw	r24, 0x37	; 55
    167a:	2d e0       	ldi	r18, 0x0D	; 13
    167c:	31 e0       	ldi	r19, 0x01	; 1
    167e:	b9 01       	movw	r22, r18
    1680:	47 e0       	ldi	r20, 0x07	; 7
    1682:	50 e0       	ldi	r21, 0x00	; 0
    1684:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1688:	00 97       	sbiw	r24, 0x00	; 0
    168a:	39 f4       	brne	.+14     	; 0x169a <_Z8sendGAVRv+0x1fe>
    168c:	86 e0       	ldi	r24, 0x06	; 6
    168e:	90 e0       	ldi	r25, 0x00	; 0
    1690:	90 93 d5 01 	sts	0x01D5, r25
    1694:	80 93 d4 01 	sts	0x01D4, r24
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1698:	49 c1       	rjmp	.+658    	; 0x192c <_Z8sendGAVRv+0x490>
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
    169a:	80 91 c0 01 	lds	r24, 0x01C0
    169e:	88 23       	and	r24, r24
    16a0:	89 f0       	breq	.+34     	; 0x16c4 <_Z8sendGAVRv+0x228>
    16a2:	ce 01       	movw	r24, r28
    16a4:	c7 96       	adiw	r24, 0x37	; 55
    16a6:	9e 01       	movw	r18, r28
    16a8:	21 5f       	subi	r18, 0xF1	; 241
    16aa:	3f 4f       	sbci	r19, 0xFF	; 255
    16ac:	b9 01       	movw	r22, r18
    16ae:	0e 94 f8 1e 	call	0x3df0	; 0x3df0 <strcmp>
    16b2:	00 97       	sbiw	r24, 0x00	; 0
    16b4:	39 f4       	brne	.+14     	; 0x16c4 <_Z8sendGAVRv+0x228>
    16b6:	85 e0       	ldi	r24, 0x05	; 5
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	90 93 d5 01 	sts	0x01D5, r25
    16be:	80 93 d4 01 	sts	0x01D4, r24
    16c2:	25 c0       	rjmp	.+74     	; 0x170e <_Z8sendGAVRv+0x272>
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
    16c4:	80 91 c0 01 	lds	r24, 0x01C0
    16c8:	88 23       	and	r24, r24
    16ca:	d1 f0       	breq	.+52     	; 0x1700 <_Z8sendGAVRv+0x264>
    16cc:	ce 01       	movw	r24, r28
    16ce:	c7 96       	adiw	r24, 0x37	; 55
    16d0:	9e 01       	movw	r18, r28
    16d2:	21 5f       	subi	r18, 0xF1	; 241
    16d4:	3f 4f       	sbci	r19, 0xFF	; 255
    16d6:	b9 01       	movw	r22, r18
    16d8:	0e 94 f8 1e 	call	0x3df0	; 0x3df0 <strcmp>
    16dc:	00 97       	sbiw	r24, 0x00	; 0
    16de:	81 f0       	breq	.+32     	; 0x1700 <_Z8sendGAVRv+0x264>
    16e0:	ce 01       	movw	r24, r28
    16e2:	c7 96       	adiw	r24, 0x37	; 55
    16e4:	2d e0       	ldi	r18, 0x0D	; 13
    16e6:	31 e0       	ldi	r19, 0x01	; 1
    16e8:	b9 01       	movw	r22, r18
    16ea:	0e 94 f8 1e 	call	0x3df0	; 0x3df0 <strcmp>
    16ee:	00 97       	sbiw	r24, 0x00	; 0
    16f0:	39 f0       	breq	.+14     	; 0x1700 <_Z8sendGAVRv+0x264>
    16f2:	87 e0       	ldi	r24, 0x07	; 7
    16f4:	90 e0       	ldi	r25, 0x00	; 0
    16f6:	90 93 d5 01 	sts	0x01D5, r25
    16fa:	80 93 d4 01 	sts	0x01D4, r24
    16fe:	07 c0       	rjmp	.+14     	; 0x170e <_Z8sendGAVRv+0x272>
				else{state=7;} //invalid ack. ACKERROR goes here.
    1700:	87 e0       	ldi	r24, 0x07	; 7
    1702:	90 e0       	ldi	r25, 0x00	; 0
    1704:	90 93 d5 01 	sts	0x01D5, r25
    1708:	80 93 d4 01 	sts	0x01D4, r24
				break;
    170c:	0f c1       	rjmp	.+542    	; 0x192c <_Z8sendGAVRv+0x490>
    170e:	0e c1       	rjmp	.+540    	; 0x192c <_Z8sendGAVRv+0x490>
				}//end case 2
			case 3:{
				if (flagUserClock && !flagUpdateGAVRClock){
    1710:	80 91 c2 01 	lds	r24, 0x01C2
    1714:	88 23       	and	r24, r24
    1716:	61 f0       	breq	.+24     	; 0x1730 <_Z8sendGAVRv+0x294>
    1718:	80 91 c0 01 	lds	r24, 0x01C0
    171c:	88 23       	and	r24, r24
    171e:	41 f4       	brne	.+16     	; 0x1730 <_Z8sendGAVRv+0x294>
					PrintGAVR("SYNGB.");
    1720:	85 e1       	ldi	r24, 0x15	; 21
    1722:	91 e0       	ldi	r25, 0x01	; 1
    1724:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
					flagWaitingForReceiveGAVR=fTrue;				
    1728:	81 e0       	ldi	r24, 0x01	; 1
    172a:	80 93 bd 01 	sts	0x01BD, r24
    172e:	5d c0       	rjmp	.+186    	; 0x17ea <_Z8sendGAVRv+0x34e>
				//If we are updating the gavr, send the time and date together regardless. preface with SYN
				} else if (flagUpdateGAVRClock && !flagUserClock){
    1730:	80 91 c0 01 	lds	r24, 0x01C0
    1734:	88 23       	and	r24, r24
    1736:	09 f4       	brne	.+2      	; 0x173a <_Z8sendGAVRv+0x29e>
    1738:	58 c0       	rjmp	.+176    	; 0x17ea <_Z8sendGAVRv+0x34e>
    173a:	80 91 c2 01 	lds	r24, 0x01C2
    173e:	88 23       	and	r24, r24
    1740:	09 f0       	breq	.+2      	; 0x1744 <_Z8sendGAVRv+0x2a8>
    1742:	53 c0       	rjmp	.+166    	; 0x17ea <_Z8sendGAVRv+0x34e>
					strcpy(sentString,"ACK");			//this is a syn, not ack to save logic in GAVR code. Can change if we want.
    1744:	9e 01       	movw	r18, r28
    1746:	21 5f       	subi	r18, 0xF1	; 241
    1748:	3f 4f       	sbci	r19, 0xFF	; 255
    174a:	81 e4       	ldi	r24, 0x41	; 65
    174c:	93 e4       	ldi	r25, 0x43	; 67
    174e:	ab e4       	ldi	r26, 0x4B	; 75
    1750:	b0 e0       	ldi	r27, 0x00	; 0
    1752:	f9 01       	movw	r30, r18
    1754:	80 83       	st	Z, r24
    1756:	91 83       	std	Z+1, r25	; 0x01
    1758:	a2 83       	std	Z+2, r26	; 0x02
    175a:	b3 83       	std	Z+3, r27	; 0x03
					strcat(sentString,currentTime.getTime());
    175c:	82 e9       	ldi	r24, 0x92	; 146
    175e:	91 e0       	ldi	r25, 0x01	; 1
    1760:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    1764:	9c 01       	movw	r18, r24
    1766:	ce 01       	movw	r24, r28
    1768:	0f 96       	adiw	r24, 0x0f	; 15
    176a:	b9 01       	movw	r22, r18
    176c:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <strcat>
					strcat(sentString,"/");	//add delimiter.
    1770:	ce 01       	movw	r24, r28
    1772:	0f 96       	adiw	r24, 0x0f	; 15
    1774:	9c 01       	movw	r18, r24
    1776:	f9 01       	movw	r30, r18
    1778:	01 90       	ld	r0, Z+
    177a:	00 20       	and	r0, r0
    177c:	e9 f7       	brne	.-6      	; 0x1778 <_Z8sendGAVRv+0x2dc>
    177e:	cf 01       	movw	r24, r30
    1780:	01 97       	sbiw	r24, 0x01	; 1
    1782:	82 1b       	sub	r24, r18
    1784:	93 0b       	sbc	r25, r19
    1786:	9e 01       	movw	r18, r28
    1788:	21 5f       	subi	r18, 0xF1	; 241
    178a:	3f 4f       	sbci	r19, 0xFF	; 255
    178c:	82 0f       	add	r24, r18
    178e:	93 1f       	adc	r25, r19
    1790:	2f e2       	ldi	r18, 0x2F	; 47
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	fc 01       	movw	r30, r24
    1796:	31 83       	std	Z+1, r19	; 0x01
    1798:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getDate());
    179a:	82 e9       	ldi	r24, 0x92	; 146
    179c:	91 e0       	ldi	r25, 0x01	; 1
    179e:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    17a2:	9c 01       	movw	r18, r24
    17a4:	ce 01       	movw	r24, r28
    17a6:	0f 96       	adiw	r24, 0x0f	; 15
    17a8:	b9 01       	movw	r22, r18
    17aa:	0e 94 ed 1e 	call	0x3dda	; 0x3dda <strcat>
					strcat(sentString,".\0");
    17ae:	ce 01       	movw	r24, r28
    17b0:	0f 96       	adiw	r24, 0x0f	; 15
    17b2:	9c 01       	movw	r18, r24
    17b4:	f9 01       	movw	r30, r18
    17b6:	01 90       	ld	r0, Z+
    17b8:	00 20       	and	r0, r0
    17ba:	e9 f7       	brne	.-6      	; 0x17b6 <_Z8sendGAVRv+0x31a>
    17bc:	cf 01       	movw	r24, r30
    17be:	01 97       	sbiw	r24, 0x01	; 1
    17c0:	82 1b       	sub	r24, r18
    17c2:	93 0b       	sbc	r25, r19
    17c4:	9e 01       	movw	r18, r28
    17c6:	21 5f       	subi	r18, 0xF1	; 241
    17c8:	3f 4f       	sbci	r19, 0xFF	; 255
    17ca:	82 0f       	add	r24, r18
    17cc:	93 1f       	adc	r25, r19
    17ce:	2e e2       	ldi	r18, 0x2E	; 46
    17d0:	30 e0       	ldi	r19, 0x00	; 0
    17d2:	fc 01       	movw	r30, r24
    17d4:	31 83       	std	Z+1, r19	; 0x01
    17d6:	20 83       	st	Z, r18
					PrintGAVR("SYN");
    17d8:	8c e1       	ldi	r24, 0x1C	; 28
    17da:	91 e0       	ldi	r25, 0x01	; 1
    17dc:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
    17e0:	80 e0       	ldi	r24, 0x00	; 0
    17e2:	61 e0       	ldi	r22, 0x01	; 1
    17e4:	41 e0       	ldi	r20, 0x01	; 1
    17e6:	0e 94 64 14 	call	0x28c8	; 0x28c8 <_Z13printTimeDatehhh>
				} else;	//end if-else (what we are doing).
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    17ea:	1f 82       	std	Y+7, r1	; 0x07
    17ec:	1e 82       	std	Y+6, r1	; 0x06
    17ee:	0e c0       	rjmp	.+28     	; 0x180c <_Z8sendGAVRv+0x370>
    17f0:	9e 01       	movw	r18, r28
    17f2:	29 5c       	subi	r18, 0xC9	; 201
    17f4:	3f 4f       	sbci	r19, 0xFF	; 255
    17f6:	8e 81       	ldd	r24, Y+6	; 0x06
    17f8:	9f 81       	ldd	r25, Y+7	; 0x07
    17fa:	82 0f       	add	r24, r18
    17fc:	93 1f       	adc	r25, r19
    17fe:	fc 01       	movw	r30, r24
    1800:	10 82       	st	Z, r1
    1802:	8e 81       	ldd	r24, Y+6	; 0x06
    1804:	9f 81       	ldd	r25, Y+7	; 0x07
    1806:	01 96       	adiw	r24, 0x01	; 1
    1808:	9f 83       	std	Y+7, r25	; 0x07
    180a:	8e 83       	std	Y+6, r24	; 0x06
    180c:	2e 81       	ldd	r18, Y+6	; 0x06
    180e:	3f 81       	ldd	r19, Y+7	; 0x07
    1810:	41 e0       	ldi	r20, 0x01	; 1
    1812:	89 81       	ldd	r24, Y+1	; 0x01
    1814:	9a 81       	ldd	r25, Y+2	; 0x02
    1816:	28 17       	cp	r18, r24
    1818:	39 07       	cpc	r19, r25
    181a:	08 f0       	brcs	.+2      	; 0x181e <_Z8sendGAVRv+0x382>
    181c:	40 e0       	ldi	r20, 0x00	; 0
    181e:	44 23       	and	r20, r20
    1820:	39 f7       	brne	.-50     	; 0x17f0 <_Z8sendGAVRv+0x354>
					
				//Reset the carriage feature, string location and go back to the receiving state.
				noCarriage=fTrue;
    1822:	81 e0       	ldi	r24, 0x01	; 1
    1824:	8e 87       	std	Y+14, r24	; 0x0e
				strLoc=0;
    1826:	1a 82       	std	Y+2, r1	; 0x02
    1828:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	90 e0       	ldi	r25, 0x00	; 0
    182e:	90 93 d5 01 	sts	0x01D5, r25
    1832:	80 93 d4 01 	sts	0x01D4, r24
				break;
    1836:	7a c0       	rjmp	.+244    	; 0x192c <_Z8sendGAVRv+0x490>
				}//end case 3
			case 4:{
				//Successful communication with just flags
				PrintGAVR("SYNDONE.");	//end the communication
    1838:	80 e2       	ldi	r24, 0x20	; 32
    183a:	91 e0       	ldi	r25, 0x01	; 1
    183c:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
				state=5;
    1840:	85 e0       	ldi	r24, 0x05	; 5
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	90 93 d5 01 	sts	0x01D5, r25
    1848:	80 93 d4 01 	sts	0x01D4, r24
				break;				
    184c:	6f c0       	rjmp	.+222    	; 0x192c <_Z8sendGAVRv+0x490>
				}//end case 4	
			case 5:{
				//Successful communications overall
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    184e:	19 86       	std	Y+9, r1	; 0x09
    1850:	18 86       	std	Y+8, r1	; 0x08
    1852:	0e c0       	rjmp	.+28     	; 0x1870 <_Z8sendGAVRv+0x3d4>
    1854:	9e 01       	movw	r18, r28
    1856:	29 5c       	subi	r18, 0xC9	; 201
    1858:	3f 4f       	sbci	r19, 0xFF	; 255
    185a:	88 85       	ldd	r24, Y+8	; 0x08
    185c:	99 85       	ldd	r25, Y+9	; 0x09
    185e:	82 0f       	add	r24, r18
    1860:	93 1f       	adc	r25, r19
    1862:	fc 01       	movw	r30, r24
    1864:	10 82       	st	Z, r1
    1866:	88 85       	ldd	r24, Y+8	; 0x08
    1868:	99 85       	ldd	r25, Y+9	; 0x09
    186a:	01 96       	adiw	r24, 0x01	; 1
    186c:	99 87       	std	Y+9, r25	; 0x09
    186e:	88 87       	std	Y+8, r24	; 0x08
    1870:	28 85       	ldd	r18, Y+8	; 0x08
    1872:	39 85       	ldd	r19, Y+9	; 0x09
    1874:	41 e0       	ldi	r20, 0x01	; 1
    1876:	89 81       	ldd	r24, Y+1	; 0x01
    1878:	9a 81       	ldd	r25, Y+2	; 0x02
    187a:	28 17       	cp	r18, r24
    187c:	39 07       	cpc	r19, r25
    187e:	08 f0       	brcs	.+2      	; 0x1882 <_Z8sendGAVRv+0x3e6>
    1880:	40 e0       	ldi	r20, 0x00	; 0
    1882:	44 23       	and	r20, r20
    1884:	39 f7       	brne	.-50     	; 0x1854 <_Z8sendGAVRv+0x3b8>
				flagSendingGAVR=fFalse;
    1886:	10 92 c1 01 	sts	0x01C1, r1
				flagWaitingToSendGAVR=fFalse;
    188a:	10 92 c4 01 	sts	0x01C4, r1
				flagTimeout=fFalse;
    188e:	1b 82       	std	Y+3, r1	; 0x03
				state=0;
    1890:	10 92 d5 01 	sts	0x01D5, r1
    1894:	10 92 d4 01 	sts	0x01D4, r1
				break;
    1898:	49 c0       	rjmp	.+146    	; 0x192c <_Z8sendGAVRv+0x490>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
    189a:	82 e9       	ldi	r24, 0x92	; 146
    189c:	91 e0       	ldi	r25, 0x01	; 1
    189e:	0e 94 bc 06 	call	0xd78	; 0xd78 <_ZN6myTime13checkValidityEv>
    18a2:	8d 87       	std	Y+13, r24	; 0x0d
				if (dateOK){state=7;}
    18a4:	8d 85       	ldd	r24, Y+13	; 0x0d
    18a6:	88 23       	and	r24, r24
    18a8:	39 f0       	breq	.+14     	; 0x18b8 <_Z8sendGAVRv+0x41c>
    18aa:	87 e0       	ldi	r24, 0x07	; 7
    18ac:	90 e0       	ldi	r25, 0x00	; 0
    18ae:	90 93 d5 01 	sts	0x01D5, r25
    18b2:	80 93 d4 01 	sts	0x01D4, r24
				else {state=5; flagInvalidDateTime=fTrue;}
				break;
    18b6:	3a c0       	rjmp	.+116    	; 0x192c <_Z8sendGAVRv+0x490>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
				if (dateOK){state=7;}
				else {state=5; flagInvalidDateTime=fTrue;}
    18b8:	85 e0       	ldi	r24, 0x05	; 5
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	90 93 d5 01 	sts	0x01D5, r25
    18c0:	80 93 d4 01 	sts	0x01D4, r24
    18c4:	81 e0       	ldi	r24, 0x01	; 1
    18c6:	80 93 c3 01 	sts	0x01C3, r24
				break;
    18ca:	30 c0       	rjmp	.+96     	; 0x192c <_Z8sendGAVRv+0x490>
				}//end case 6
			case 7:{
				//Got the wrong ACK back, or invalid ACK. Wait for next cycle then resend. Keep all the flags the same
				flagWaitingToSendGAVR=fTrue;
    18cc:	81 e0       	ldi	r24, 0x01	; 1
    18ce:	80 93 c4 01 	sts	0x01C4, r24
				flagSendingGAVR=fFalse;
    18d2:	10 92 c1 01 	sts	0x01C1, r1
				flagTimeout=fFalse;
    18d6:	1b 82       	std	Y+3, r1	; 0x03
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    18d8:	1b 86       	std	Y+11, r1	; 0x0b
    18da:	1a 86       	std	Y+10, r1	; 0x0a
    18dc:	0e c0       	rjmp	.+28     	; 0x18fa <_Z8sendGAVRv+0x45e>
    18de:	9e 01       	movw	r18, r28
    18e0:	29 5c       	subi	r18, 0xC9	; 201
    18e2:	3f 4f       	sbci	r19, 0xFF	; 255
    18e4:	8a 85       	ldd	r24, Y+10	; 0x0a
    18e6:	9b 85       	ldd	r25, Y+11	; 0x0b
    18e8:	82 0f       	add	r24, r18
    18ea:	93 1f       	adc	r25, r19
    18ec:	fc 01       	movw	r30, r24
    18ee:	10 82       	st	Z, r1
    18f0:	8a 85       	ldd	r24, Y+10	; 0x0a
    18f2:	9b 85       	ldd	r25, Y+11	; 0x0b
    18f4:	01 96       	adiw	r24, 0x01	; 1
    18f6:	9b 87       	std	Y+11, r25	; 0x0b
    18f8:	8a 87       	std	Y+10, r24	; 0x0a
    18fa:	2a 85       	ldd	r18, Y+10	; 0x0a
    18fc:	3b 85       	ldd	r19, Y+11	; 0x0b
    18fe:	41 e0       	ldi	r20, 0x01	; 1
    1900:	89 81       	ldd	r24, Y+1	; 0x01
    1902:	9a 81       	ldd	r25, Y+2	; 0x02
    1904:	28 17       	cp	r18, r24
    1906:	39 07       	cpc	r19, r25
    1908:	08 f0       	brcs	.+2      	; 0x190c <_Z8sendGAVRv+0x470>
    190a:	40 e0       	ldi	r20, 0x00	; 0
    190c:	44 23       	and	r20, r20
    190e:	39 f7       	brne	.-50     	; 0x18de <_Z8sendGAVRv+0x442>
				state=0;
    1910:	10 92 d5 01 	sts	0x01D5, r1
    1914:	10 92 d4 01 	sts	0x01D4, r1
				break;
    1918:	09 c0       	rjmp	.+18     	; 0x192c <_Z8sendGAVRv+0x490>
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; flagTimeout=fFalse;break;}
    191a:	10 92 d5 01 	sts	0x01D5, r1
    191e:	10 92 d4 01 	sts	0x01D4, r1
    1922:	10 92 c1 01 	sts	0x01C1, r1
    1926:	1e 86       	std	Y+14, r1	; 0x0e
    1928:	1b 82       	std	Y+3, r1	; 0x03
    192a:	00 00       	nop
	
	//Set sending flag
	flagSendingGAVR=fTrue;
	
	//Transmission protocol
	while (flagSendingGAVR && !flagTimeout){
    192c:	80 91 c1 01 	lds	r24, 0x01C1
    1930:	88 23       	and	r24, r24
    1932:	29 f0       	breq	.+10     	; 0x193e <_Z8sendGAVRv+0x4a2>
    1934:	8b 81       	ldd	r24, Y+3	; 0x03
    1936:	88 23       	and	r24, r24
    1938:	11 f4       	brne	.+4      	; 0x193e <_Z8sendGAVRv+0x4a2>
    193a:	81 e0       	ldi	r24, 0x01	; 1
    193c:	01 c0       	rjmp	.+2      	; 0x1940 <_Z8sendGAVRv+0x4a4>
    193e:	80 e0       	ldi	r24, 0x00	; 0
    1940:	88 23       	and	r24, r24
    1942:	09 f0       	breq	.+2      	; 0x1946 <_Z8sendGAVRv+0x4aa>
    1944:	bf cd       	rjmp	.-1154   	; 0x14c4 <_Z8sendGAVRv+0x28>
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; flagTimeout=fFalse;break;}
		}//end switch
	}//end while
	
	//If there was a timeout and the wiating flag has not been set yet, make sure waiting flag.
	if (noCarriage || flagTimeout){
    1946:	8e 85       	ldd	r24, Y+14	; 0x0e
    1948:	88 23       	and	r24, r24
    194a:	19 f4       	brne	.+6      	; 0x1952 <_Z8sendGAVRv+0x4b6>
    194c:	8b 81       	ldd	r24, Y+3	; 0x03
    194e:	88 23       	and	r24, r24
    1950:	11 f0       	breq	.+4      	; 0x1956 <_Z8sendGAVRv+0x4ba>
    1952:	81 e0       	ldi	r24, 0x01	; 1
    1954:	01 c0       	rjmp	.+2      	; 0x1958 <_Z8sendGAVRv+0x4bc>
    1956:	80 e0       	ldi	r24, 0x00	; 0
    1958:	88 23       	and	r24, r24
    195a:	19 f0       	breq	.+6      	; 0x1962 <_Z8sendGAVRv+0x4c6>
		flagWaitingToSendGAVR=fTrue;
    195c:	81 e0       	ldi	r24, 0x01	; 1
    195e:	80 93 c4 01 	sts	0x01C4, r24
	}
	
	//If we aren't waiting for the next round, don't reset the flags. If we are waiting, just reset the waiting flag->the UserCLock and GAVRClcok flags
	//will still be at the values they were before.
	if (!flagWaitingToSendGAVR){
    1962:	80 91 c4 01 	lds	r24, 0x01C4
    1966:	88 23       	and	r24, r24
    1968:	29 f4       	brne	.+10     	; 0x1974 <_Z8sendGAVRv+0x4d8>
		flagUserClock=fFalse;
    196a:	10 92 c2 01 	sts	0x01C2, r1
		flagUpdateGAVRClock=fFalse;	
    196e:	10 92 c0 01 	sts	0x01C0, r1
    1972:	02 c0       	rjmp	.+4      	; 0x1978 <_Z8sendGAVRv+0x4dc>
	} else {flagWaitingToSendGAVR=fFalse;}
    1974:	10 92 c4 01 	sts	0x01C4, r1
}//end function 	
    1978:	c2 5a       	subi	r28, 0xA2	; 162
    197a:	df 4f       	sbci	r29, 0xFF	; 255
    197c:	0f b6       	in	r0, 0x3f	; 63
    197e:	f8 94       	cli
    1980:	de bf       	out	0x3e, r29	; 62
    1982:	0f be       	out	0x3f, r0	; 63
    1984:	cd bf       	out	0x3d, r28	; 61
    1986:	df 91       	pop	r29
    1988:	cf 91       	pop	r28
    198a:	08 95       	ret

0000198c <_Z11ReceiveBonev>:
	
/*************************************************************************************************************/
void ReceiveBone(){
    198c:	cf 93       	push	r28
    198e:	df 93       	push	r29
    1990:	cd b7       	in	r28, 0x3d	; 61
    1992:	de b7       	in	r29, 0x3e	; 62
    1994:	c5 56       	subi	r28, 0x65	; 101
    1996:	d0 40       	sbci	r29, 0x00	; 0
    1998:	0f b6       	in	r0, 0x3f	; 63
    199a:	f8 94       	cli
    199c:	de bf       	out	0x3e, r29	; 62
    199e:	0f be       	out	0x3f, r0	; 63
    19a0:	cd bf       	out	0x3d, r28	; 61
	unsigned int state=0;
    19a2:	1a 82       	std	Y+2, r1	; 0x02
    19a4:	19 82       	std	Y+1, r1	; 0x01
	char recChar, recString[40];
	unsigned int strLoc=0;
    19a6:	1c 82       	std	Y+4, r1	; 0x04
    19a8:	1b 82       	std	Y+3, r1	; 0x03
	BOOL noCarriage=fTrue;
    19aa:	81 e0       	ldi	r24, 0x01	; 1
    19ac:	8d 83       	std	Y+5, r24	; 0x05
	
	while (flagReceivingBone){
    19ae:	09 c4       	rjmp	.+2066   	; 0x21c2 <_Z11ReceiveBonev+0x836>
			/* State 6: Graceful exit. Exit from a command like adc or temp.																*/
			/* State 7: Parse the input string for the time and date. Should be time(:)'/'date(,) where : and , are the delimiters. Term by */
			/*			'.'																													*/
			/********************************************************************************************************************************/
			
			switch(state){
    19b0:	89 81       	ldd	r24, Y+1	; 0x01
    19b2:	9a 81       	ldd	r25, Y+2	; 0x02
    19b4:	83 30       	cpi	r24, 0x03	; 3
    19b6:	91 05       	cpc	r25, r1
    19b8:	09 f4       	brne	.+2      	; 0x19bc <_Z11ReceiveBonev+0x30>
    19ba:	62 c1       	rjmp	.+708    	; 0x1c80 <_Z11ReceiveBonev+0x2f4>
    19bc:	84 30       	cpi	r24, 0x04	; 4
    19be:	91 05       	cpc	r25, r1
    19c0:	48 f4       	brcc	.+18     	; 0x19d4 <_Z11ReceiveBonev+0x48>
    19c2:	81 30       	cpi	r24, 0x01	; 1
    19c4:	91 05       	cpc	r25, r1
    19c6:	09 f4       	brne	.+2      	; 0x19ca <_Z11ReceiveBonev+0x3e>
    19c8:	81 c0       	rjmp	.+258    	; 0x1acc <_Z11ReceiveBonev+0x140>
    19ca:	82 30       	cpi	r24, 0x02	; 2
    19cc:	91 05       	cpc	r25, r1
    19ce:	08 f0       	brcs	.+2      	; 0x19d2 <_Z11ReceiveBonev+0x46>
    19d0:	8b c0       	rjmp	.+278    	; 0x1ae8 <_Z11ReceiveBonev+0x15c>
    19d2:	11 c0       	rjmp	.+34     	; 0x19f6 <_Z11ReceiveBonev+0x6a>
    19d4:	85 30       	cpi	r24, 0x05	; 5
    19d6:	91 05       	cpc	r25, r1
    19d8:	09 f4       	brne	.+2      	; 0x19dc <_Z11ReceiveBonev+0x50>
    19da:	a6 c1       	rjmp	.+844    	; 0x1d28 <_Z11ReceiveBonev+0x39c>
    19dc:	85 30       	cpi	r24, 0x05	; 5
    19de:	91 05       	cpc	r25, r1
    19e0:	08 f4       	brcc	.+2      	; 0x19e4 <_Z11ReceiveBonev+0x58>
    19e2:	7d c1       	rjmp	.+762    	; 0x1cde <_Z11ReceiveBonev+0x352>
    19e4:	86 30       	cpi	r24, 0x06	; 6
    19e6:	91 05       	cpc	r25, r1
    19e8:	09 f4       	brne	.+2      	; 0x19ec <_Z11ReceiveBonev+0x60>
    19ea:	c3 c1       	rjmp	.+902    	; 0x1d72 <_Z11ReceiveBonev+0x3e6>
    19ec:	87 30       	cpi	r24, 0x07	; 7
    19ee:	91 05       	cpc	r25, r1
    19f0:	09 f4       	brne	.+2      	; 0x19f4 <_Z11ReceiveBonev+0x68>
    19f2:	e0 c1       	rjmp	.+960    	; 0x1db4 <_Z11ReceiveBonev+0x428>
    19f4:	e1 c3       	rjmp	.+1986   	; 0x21b8 <_Z11ReceiveBonev+0x82c>
				case 0:{
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
    19f6:	1c 82       	std	Y+4, r1	; 0x04
    19f8:	1b 82       	std	Y+3, r1	; 0x03
					recChar = UDR0;
    19fa:	86 ec       	ldi	r24, 0xC6	; 198
    19fc:	90 e0       	ldi	r25, 0x00	; 0
    19fe:	fc 01       	movw	r30, r24
    1a00:	80 81       	ld	r24, Z
    1a02:	8e 8f       	std	Y+30, r24	; 0x1e
					if (recChar=='.'){
    1a04:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a06:	8e 32       	cpi	r24, 0x2E	; 46
    1a08:	29 f4       	brne	.+10     	; 0x1a14 <_Z11ReceiveBonev+0x88>
						state=5;
    1a0a:	85 e0       	ldi	r24, 0x05	; 5
    1a0c:	90 e0       	ldi	r25, 0x00	; 0
    1a0e:	9a 83       	std	Y+2, r25	; 0x02
    1a10:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
    1a12:	d7 c3       	rjmp	.+1966   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
					recChar = UDR0;
					if (recChar=='.'){
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
    1a14:	9e 01       	movw	r18, r28
    1a16:	22 5c       	subi	r18, 0xC2	; 194
    1a18:	3f 4f       	sbci	r19, 0xFF	; 255
    1a1a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a1e:	82 0f       	add	r24, r18
    1a20:	93 1f       	adc	r25, r19
    1a22:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1a24:	fc 01       	movw	r30, r24
    1a26:	20 83       	st	Z, r18
    1a28:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2a:	9c 81       	ldd	r25, Y+4	; 0x04
    1a2c:	01 96       	adiw	r24, 0x01	; 1
    1a2e:	9c 83       	std	Y+4, r25	; 0x04
    1a30:	8b 83       	std	Y+3, r24	; 0x03
    1a32:	81 e0       	ldi	r24, 0x01	; 1
    1a34:	90 e0       	ldi	r25, 0x00	; 0
    1a36:	9a 83       	std	Y+2, r25	; 0x02
    1a38:	89 83       	std	Y+1, r24	; 0x01
					break;				
    1a3a:	c3 c3       	rjmp	.+1926   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while ((!(UCSR0A & (1 << RXC0))) && flagReceivingBone);		//get the next character
    1a3c:	00 00       	nop
    1a3e:	80 ec       	ldi	r24, 0xC0	; 192
    1a40:	90 e0       	ldi	r25, 0x00	; 0
    1a42:	fc 01       	movw	r30, r24
    1a44:	80 81       	ld	r24, Z
    1a46:	88 23       	and	r24, r24
    1a48:	34 f0       	brlt	.+12     	; 0x1a56 <_Z11ReceiveBonev+0xca>
    1a4a:	80 91 ba 01 	lds	r24, 0x01BA
    1a4e:	88 23       	and	r24, r24
    1a50:	11 f0       	breq	.+4      	; 0x1a56 <_Z11ReceiveBonev+0xca>
    1a52:	81 e0       	ldi	r24, 0x01	; 1
    1a54:	01 c0       	rjmp	.+2      	; 0x1a58 <_Z11ReceiveBonev+0xcc>
    1a56:	80 e0       	ldi	r24, 0x00	; 0
    1a58:	88 23       	and	r24, r24
    1a5a:	89 f7       	brne	.-30     	; 0x1a3e <_Z11ReceiveBonev+0xb2>
						if (!flagReceivingBone){state=6;}					//if there was a timeout, break out and reset state
    1a5c:	80 91 ba 01 	lds	r24, 0x01BA
    1a60:	88 23       	and	r24, r24
    1a62:	21 f4       	brne	.+8      	; 0x1a6c <_Z11ReceiveBonev+0xe0>
    1a64:	86 e0       	ldi	r24, 0x06	; 6
    1a66:	90 e0       	ldi	r25, 0x00	; 0
    1a68:	9a 83       	std	Y+2, r25	; 0x02
    1a6a:	89 83       	std	Y+1, r24	; 0x01
						recChar=UDR0;
    1a6c:	86 ec       	ldi	r24, 0xC6	; 198
    1a6e:	90 e0       	ldi	r25, 0x00	; 0
    1a70:	fc 01       	movw	r30, r24
    1a72:	80 81       	ld	r24, Z
    1a74:	8e 8f       	std	Y+30, r24	; 0x1e
						recString[strLoc++]=recChar;
    1a76:	9e 01       	movw	r18, r28
    1a78:	22 5c       	subi	r18, 0xC2	; 194
    1a7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a7c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a7e:	9c 81       	ldd	r25, Y+4	; 0x04
    1a80:	82 0f       	add	r24, r18
    1a82:	93 1f       	adc	r25, r19
    1a84:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1a86:	fc 01       	movw	r30, r24
    1a88:	20 83       	st	Z, r18
    1a8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a8e:	01 96       	adiw	r24, 0x01	; 1
    1a90:	9c 83       	std	Y+4, r25	; 0x04
    1a92:	8b 83       	std	Y+3, r24	; 0x03
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1a94:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1a96:	8e 32       	cpi	r24, 0x2E	; 46
    1a98:	79 f4       	brne	.+30     	; 0x1ab8 <_Z11ReceiveBonev+0x12c>
    1a9a:	9e 01       	movw	r18, r28
    1a9c:	22 5c       	subi	r18, 0xC2	; 194
    1a9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1aa0:	8b 81       	ldd	r24, Y+3	; 0x03
    1aa2:	9c 81       	ldd	r25, Y+4	; 0x04
    1aa4:	82 0f       	add	r24, r18
    1aa6:	93 1f       	adc	r25, r19
    1aa8:	fc 01       	movw	r30, r24
    1aaa:	10 82       	st	Z, r1
    1aac:	1d 82       	std	Y+5, r1	; 0x05
    1aae:	82 e0       	ldi	r24, 0x02	; 2
    1ab0:	90 e0       	ldi	r25, 0x00	; 0
    1ab2:	9a 83       	std	Y+2, r25	; 0x02
    1ab4:	89 83       	std	Y+1, r24	; 0x01
    1ab6:	0a c0       	rjmp	.+20     	; 0x1acc <_Z11ReceiveBonev+0x140>
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
    1ab8:	8b 81       	ldd	r24, Y+3	; 0x03
    1aba:	9c 81       	ldd	r25, Y+4	; 0x04
    1abc:	87 32       	cpi	r24, 0x27	; 39
    1abe:	91 05       	cpc	r25, r1
    1ac0:	28 f0       	brcs	.+10     	; 0x1acc <_Z11ReceiveBonev+0x140>
    1ac2:	85 e0       	ldi	r24, 0x05	; 5
    1ac4:	90 e0       	ldi	r25, 0x00	; 0
    1ac6:	9a 83       	std	Y+2, r25	; 0x02
    1ac8:	89 83       	std	Y+1, r24	; 0x01
    1aca:	1d 82       	std	Y+5, r1	; 0x05
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    1acc:	8d 81       	ldd	r24, Y+5	; 0x05
    1ace:	88 23       	and	r24, r24
    1ad0:	31 f0       	breq	.+12     	; 0x1ade <_Z11ReceiveBonev+0x152>
    1ad2:	80 91 ba 01 	lds	r24, 0x01BA
    1ad6:	88 23       	and	r24, r24
    1ad8:	11 f0       	breq	.+4      	; 0x1ade <_Z11ReceiveBonev+0x152>
    1ada:	81 e0       	ldi	r24, 0x01	; 1
    1adc:	01 c0       	rjmp	.+2      	; 0x1ae0 <_Z11ReceiveBonev+0x154>
    1ade:	80 e0       	ldi	r24, 0x00	; 0
    1ae0:	88 23       	and	r24, r24
    1ae2:	09 f0       	breq	.+2      	; 0x1ae6 <_Z11ReceiveBonev+0x15a>
    1ae4:	ab cf       	rjmp	.-170    	; 0x1a3c <_Z11ReceiveBonev+0xb0>
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    1ae6:	6d c3       	rjmp	.+1754   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
    1ae8:	ce 01       	movw	r24, r28
    1aea:	ce 96       	adiw	r24, 0x3e	; 62
    1aec:	29 e2       	ldi	r18, 0x29	; 41
    1aee:	31 e0       	ldi	r19, 0x01	; 1
    1af0:	b9 01       	movw	r22, r18
    1af2:	45 e0       	ldi	r20, 0x05	; 5
    1af4:	50 e0       	ldi	r21, 0x00	; 0
    1af6:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1afa:	00 97       	sbiw	r24, 0x00	; 0
    1afc:	51 f4       	brne	.+20     	; 0x1b12 <_Z11ReceiveBonev+0x186>
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	60 e0       	ldi	r22, 0x00	; 0
    1b02:	41 e0       	ldi	r20, 0x01	; 1
    1b04:	0e 94 64 14 	call	0x28c8	; 0x28c8 <_Z13printTimeDatehhh>
    1b08:	86 e0       	ldi	r24, 0x06	; 6
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	9a 83       	std	Y+2, r25	; 0x02
    1b0e:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1b10:	58 c3       	rjmp	.+1712   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end while
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
    1b12:	ce 01       	movw	r24, r28
    1b14:	ce 96       	adiw	r24, 0x3e	; 62
    1b16:	2f e2       	ldi	r18, 0x2F	; 47
    1b18:	31 e0       	ldi	r19, 0x01	; 1
    1b1a:	b9 01       	movw	r22, r18
    1b1c:	45 e0       	ldi	r20, 0x05	; 5
    1b1e:	50 e0       	ldi	r21, 0x00	; 0
    1b20:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1b24:	00 97       	sbiw	r24, 0x00	; 0
    1b26:	51 f4       	brne	.+20     	; 0x1b3c <_Z11ReceiveBonev+0x1b0>
    1b28:	81 e0       	ldi	r24, 0x01	; 1
    1b2a:	61 e0       	ldi	r22, 0x01	; 1
    1b2c:	40 e0       	ldi	r20, 0x00	; 0
    1b2e:	0e 94 64 14 	call	0x28c8	; 0x28c8 <_Z13printTimeDatehhh>
    1b32:	86 e0       	ldi	r24, 0x06	; 6
    1b34:	90 e0       	ldi	r25, 0x00	; 0
    1b36:	9a 83       	std	Y+2, r25	; 0x02
    1b38:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1b3a:	43 c3       	rjmp	.+1670   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
    1b3c:	ce 01       	movw	r24, r28
    1b3e:	ce 96       	adiw	r24, 0x3e	; 62
    1b40:	25 e3       	ldi	r18, 0x35	; 53
    1b42:	31 e0       	ldi	r19, 0x01	; 1
    1b44:	b9 01       	movw	r22, r18
    1b46:	45 e0       	ldi	r20, 0x05	; 5
    1b48:	50 e0       	ldi	r21, 0x00	; 0
    1b4a:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1b4e:	00 97       	sbiw	r24, 0x00	; 0
    1b50:	51 f4       	brne	.+20     	; 0x1b66 <_Z11ReceiveBonev+0x1da>
    1b52:	81 e0       	ldi	r24, 0x01	; 1
    1b54:	61 e0       	ldi	r22, 0x01	; 1
    1b56:	41 e0       	ldi	r20, 0x01	; 1
    1b58:	0e 94 64 14 	call	0x28c8	; 0x28c8 <_Z13printTimeDatehhh>
    1b5c:	86 e0       	ldi	r24, 0x06	; 6
    1b5e:	90 e0       	ldi	r25, 0x00	; 0
    1b60:	9a 83       	std	Y+2, r25	; 0x02
    1b62:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1b64:	2e c3       	rjmp	.+1628   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
    1b66:	ce 01       	movw	r24, r28
    1b68:	ce 96       	adiw	r24, 0x3e	; 62
    1b6a:	2b e3       	ldi	r18, 0x3B	; 59
    1b6c:	31 e0       	ldi	r19, 0x01	; 1
    1b6e:	b9 01       	movw	r22, r18
    1b70:	45 e0       	ldi	r20, 0x05	; 5
    1b72:	50 e0       	ldi	r21, 0x00	; 0
    1b74:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1b78:	00 97       	sbiw	r24, 0x00	; 0
    1b7a:	69 f4       	brne	.+26     	; 0x1b96 <_Z11ReceiveBonev+0x20a>
    1b7c:	81 e0       	ldi	r24, 0x01	; 1
    1b7e:	60 e0       	ldi	r22, 0x00	; 0
    1b80:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    1b84:	ce 01       	movw	r24, r28
    1b86:	ce 96       	adiw	r24, 0x3e	; 62
    1b88:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    1b8c:	86 e0       	ldi	r24, 0x06	; 6
    1b8e:	90 e0       	ldi	r25, 0x00	; 0
    1b90:	9a 83       	std	Y+2, r25	; 0x02
    1b92:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1b94:	16 c3       	rjmp	.+1580   	; 0x21c2 <_Z11ReceiveBonev+0x836>
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    1b96:	ce 01       	movw	r24, r28
    1b98:	ce 96       	adiw	r24, 0x3e	; 62
    1b9a:	21 e4       	ldi	r18, 0x41	; 65
    1b9c:	31 e0       	ldi	r19, 0x01	; 1
    1b9e:	b9 01       	movw	r22, r18
    1ba0:	44 e0       	ldi	r20, 0x04	; 4
    1ba2:	50 e0       	ldi	r21, 0x00	; 0
    1ba4:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1ba8:	00 97       	sbiw	r24, 0x00	; 0
    1baa:	b1 f4       	brne	.+44     	; 0x1bd8 <_Z11ReceiveBonev+0x24c>
    1bac:	80 91 8e 01 	lds	r24, 0x018E
    1bb0:	90 91 8f 01 	lds	r25, 0x018F
    1bb4:	9e 01       	movw	r18, r28
    1bb6:	21 5e       	subi	r18, 0xE1	; 225
    1bb8:	3f 4f       	sbci	r19, 0xFF	; 255
    1bba:	b9 01       	movw	r22, r18
    1bbc:	4a e0       	ldi	r20, 0x0A	; 10
    1bbe:	50 e0       	ldi	r21, 0x00	; 0
    1bc0:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <utoa>
    1bc4:	1d a2       	lds	r17, 0x9d
    1bc6:	ce 01       	movw	r24, r28
    1bc8:	4f 96       	adiw	r24, 0x1f	; 31
    1bca:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    1bce:	86 e0       	ldi	r24, 0x06	; 6
    1bd0:	90 e0       	ldi	r25, 0x00	; 0
    1bd2:	9a 83       	std	Y+2, r25	; 0x02
    1bd4:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1bd6:	f5 c2       	rjmp	.+1514   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    1bd8:	ce 01       	movw	r24, r28
    1bda:	ce 96       	adiw	r24, 0x3e	; 62
    1bdc:	26 e4       	ldi	r18, 0x46	; 70
    1bde:	31 e0       	ldi	r19, 0x01	; 1
    1be0:	b9 01       	movw	r22, r18
    1be2:	45 e0       	ldi	r20, 0x05	; 5
    1be4:	50 e0       	ldi	r21, 0x00	; 0
    1be6:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1bea:	00 97       	sbiw	r24, 0x00	; 0
    1bec:	b1 f4       	brne	.+44     	; 0x1c1a <_Z11ReceiveBonev+0x28e>
    1bee:	80 91 90 01 	lds	r24, 0x0190
    1bf2:	90 91 91 01 	lds	r25, 0x0191
    1bf6:	9e 01       	movw	r18, r28
    1bf8:	2a 5d       	subi	r18, 0xDA	; 218
    1bfa:	3f 4f       	sbci	r19, 0xFF	; 255
    1bfc:	b9 01       	movw	r22, r18
    1bfe:	4a e0       	ldi	r20, 0x0A	; 10
    1c00:	50 e0       	ldi	r21, 0x00	; 0
    1c02:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <utoa>
    1c06:	1c a6       	lds	r17, 0xbc
    1c08:	ce 01       	movw	r24, r28
    1c0a:	86 96       	adiw	r24, 0x26	; 38
    1c0c:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    1c10:	86 e0       	ldi	r24, 0x06	; 6
    1c12:	90 e0       	ldi	r25, 0x00	; 0
    1c14:	9a 83       	std	Y+2, r25	; 0x02
    1c16:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1c18:	d4 c2       	rjmp	.+1448   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
    1c1a:	ce 01       	movw	r24, r28
    1c1c:	8e 5b       	subi	r24, 0xBE	; 190
    1c1e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c20:	fc 01       	movw	r30, r24
    1c22:	80 81       	ld	r24, Z
    1c24:	21 e0       	ldi	r18, 0x01	; 1
    1c26:	8a 33       	cpi	r24, 0x3A	; 58
    1c28:	09 f0       	breq	.+2      	; 0x1c2c <_Z11ReceiveBonev+0x2a0>
    1c2a:	20 e0       	ldi	r18, 0x00	; 0
    1c2c:	ce 01       	movw	r24, r28
    1c2e:	8d 5b       	subi	r24, 0xBD	; 189
    1c30:	9f 4f       	sbci	r25, 0xFF	; 255
    1c32:	fc 01       	movw	r30, r24
    1c34:	90 81       	ld	r25, Z
    1c36:	81 e0       	ldi	r24, 0x01	; 1
    1c38:	9a 33       	cpi	r25, 0x3A	; 58
    1c3a:	09 f0       	breq	.+2      	; 0x1c3e <_Z11ReceiveBonev+0x2b2>
    1c3c:	80 e0       	ldi	r24, 0x00	; 0
    1c3e:	82 27       	eor	r24, r18
    1c40:	88 23       	and	r24, r24
    1c42:	29 f0       	breq	.+10     	; 0x1c4e <_Z11ReceiveBonev+0x2c2>
						state=7;	
    1c44:	87 e0       	ldi	r24, 0x07	; 7
    1c46:	90 e0       	ldi	r25, 0x00	; 0
    1c48:	9a 83       	std	Y+2, r25	; 0x02
    1c4a:	89 83       	std	Y+1, r24	; 0x01
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1c4c:	ba c2       	rjmp	.+1396   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
    1c4e:	ce 01       	movw	r24, r28
    1c50:	ce 96       	adiw	r24, 0x3e	; 62
    1c52:	2c e4       	ldi	r18, 0x4C	; 76
    1c54:	31 e0       	ldi	r19, 0x01	; 1
    1c56:	b9 01       	movw	r22, r18
    1c58:	48 e0       	ldi	r20, 0x08	; 8
    1c5a:	50 e0       	ldi	r21, 0x00	; 0
    1c5c:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    1c60:	00 97       	sbiw	r24, 0x00	; 0
    1c62:	49 f4       	brne	.+18     	; 0x1c76 <_Z11ReceiveBonev+0x2ea>
    1c64:	85 e5       	ldi	r24, 0x55	; 85
    1c66:	91 e0       	ldi	r25, 0x01	; 1
    1c68:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    1c6c:	86 e0       	ldi	r24, 0x06	; 6
    1c6e:	90 e0       	ldi	r25, 0x00	; 0
    1c70:	9a 83       	std	Y+2, r25	; 0x02
    1c72:	89 83       	std	Y+1, r24	; 0x01
					else {state=5;}						
					break;
    1c74:	a6 c2       	rjmp	.+1356   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
    1c76:	85 e0       	ldi	r24, 0x05	; 5
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	9a 83       	std	Y+2, r25	; 0x02
    1c7c:	89 83       	std	Y+1, r24	; 0x01
					break;
    1c7e:	a1 c2       	rjmp	.+1346   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 2
				case 3:{
					//Successful receive state of time, change SYN to ACK, then print what we got.
					recString[0]='A';
    1c80:	81 e4       	ldi	r24, 0x41	; 65
    1c82:	8e af       	sts	0x7e, r24
					recString[1]='C';
    1c84:	83 e4       	ldi	r24, 0x43	; 67
    1c86:	8f af       	sts	0x7f, r24
					recString[2]='K';
    1c88:	2b e4       	ldi	r18, 0x4B	; 75
    1c8a:	ce 01       	movw	r24, r28
    1c8c:	80 5c       	subi	r24, 0xC0	; 192
    1c8e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c90:	fc 01       	movw	r30, r24
    1c92:	20 83       	st	Z, r18
					PrintBone(recString);
    1c94:	ce 01       	movw	r24, r28
    1c96:	ce 96       	adiw	r24, 0x3e	; 62
    1c98:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					state=0;
    1c9c:	1a 82       	std	Y+2, r1	; 0x02
    1c9e:	19 82       	std	Y+1, r1	; 0x01
					flagReceivingBone=fFalse;
    1ca0:	10 92 ba 01 	sts	0x01BA, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1ca4:	1f 82       	std	Y+7, r1	; 0x07
    1ca6:	1e 82       	std	Y+6, r1	; 0x06
    1ca8:	0e c0       	rjmp	.+28     	; 0x1cc6 <_Z11ReceiveBonev+0x33a>
    1caa:	9e 01       	movw	r18, r28
    1cac:	22 5c       	subi	r18, 0xC2	; 194
    1cae:	3f 4f       	sbci	r19, 0xFF	; 255
    1cb0:	8e 81       	ldd	r24, Y+6	; 0x06
    1cb2:	9f 81       	ldd	r25, Y+7	; 0x07
    1cb4:	82 0f       	add	r24, r18
    1cb6:	93 1f       	adc	r25, r19
    1cb8:	fc 01       	movw	r30, r24
    1cba:	10 82       	st	Z, r1
    1cbc:	8e 81       	ldd	r24, Y+6	; 0x06
    1cbe:	9f 81       	ldd	r25, Y+7	; 0x07
    1cc0:	01 96       	adiw	r24, 0x01	; 1
    1cc2:	9f 83       	std	Y+7, r25	; 0x07
    1cc4:	8e 83       	std	Y+6, r24	; 0x06
    1cc6:	2e 81       	ldd	r18, Y+6	; 0x06
    1cc8:	3f 81       	ldd	r19, Y+7	; 0x07
    1cca:	41 e0       	ldi	r20, 0x01	; 1
    1ccc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cce:	9c 81       	ldd	r25, Y+4	; 0x04
    1cd0:	28 17       	cp	r18, r24
    1cd2:	39 07       	cpc	r19, r25
    1cd4:	08 f0       	brcs	.+2      	; 0x1cd8 <_Z11ReceiveBonev+0x34c>
    1cd6:	40 e0       	ldi	r20, 0x00	; 0
    1cd8:	44 23       	and	r20, r20
    1cda:	39 f7       	brne	.-50     	; 0x1caa <_Z11ReceiveBonev+0x31e>
					break;
    1cdc:	72 c2       	rjmp	.+1252   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 3
				case 4:{
					//Bad time string.
					PrintBone("ACKBAD.");
    1cde:	8d e0       	ldi	r24, 0x0D	; 13
    1ce0:	91 e0       	ldi	r25, 0x01	; 1
    1ce2:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1ce6:	10 92 ba 01 	sts	0x01BA, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1cea:	19 86       	std	Y+9, r1	; 0x09
    1cec:	18 86       	std	Y+8, r1	; 0x08
    1cee:	0e c0       	rjmp	.+28     	; 0x1d0c <_Z11ReceiveBonev+0x380>
    1cf0:	9e 01       	movw	r18, r28
    1cf2:	22 5c       	subi	r18, 0xC2	; 194
    1cf4:	3f 4f       	sbci	r19, 0xFF	; 255
    1cf6:	88 85       	ldd	r24, Y+8	; 0x08
    1cf8:	99 85       	ldd	r25, Y+9	; 0x09
    1cfa:	82 0f       	add	r24, r18
    1cfc:	93 1f       	adc	r25, r19
    1cfe:	fc 01       	movw	r30, r24
    1d00:	10 82       	st	Z, r1
    1d02:	88 85       	ldd	r24, Y+8	; 0x08
    1d04:	99 85       	ldd	r25, Y+9	; 0x09
    1d06:	01 96       	adiw	r24, 0x01	; 1
    1d08:	99 87       	std	Y+9, r25	; 0x09
    1d0a:	88 87       	std	Y+8, r24	; 0x08
    1d0c:	28 85       	ldd	r18, Y+8	; 0x08
    1d0e:	39 85       	ldd	r19, Y+9	; 0x09
    1d10:	41 e0       	ldi	r20, 0x01	; 1
    1d12:	8b 81       	ldd	r24, Y+3	; 0x03
    1d14:	9c 81       	ldd	r25, Y+4	; 0x04
    1d16:	28 17       	cp	r18, r24
    1d18:	39 07       	cpc	r19, r25
    1d1a:	08 f0       	brcs	.+2      	; 0x1d1e <_Z11ReceiveBonev+0x392>
    1d1c:	40 e0       	ldi	r20, 0x00	; 0
    1d1e:	44 23       	and	r20, r20
    1d20:	39 f7       	brne	.-50     	; 0x1cf0 <_Z11ReceiveBonev+0x364>
					state=0;
    1d22:	1a 82       	std	Y+2, r1	; 0x02
    1d24:	19 82       	std	Y+1, r1	; 0x01
					break;
    1d26:	4d c2       	rjmp	.+1178   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 4
				case 5:{
					//Didn't get a good ack or there was an error.
					PrintBone("ACKERROR.");
    1d28:	8e e5       	ldi	r24, 0x5E	; 94
    1d2a:	91 e0       	ldi	r25, 0x01	; 1
    1d2c:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1d30:	10 92 ba 01 	sts	0x01BA, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1d34:	1b 86       	std	Y+11, r1	; 0x0b
    1d36:	1a 86       	std	Y+10, r1	; 0x0a
    1d38:	0e c0       	rjmp	.+28     	; 0x1d56 <_Z11ReceiveBonev+0x3ca>
    1d3a:	9e 01       	movw	r18, r28
    1d3c:	22 5c       	subi	r18, 0xC2	; 194
    1d3e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d40:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d42:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d44:	82 0f       	add	r24, r18
    1d46:	93 1f       	adc	r25, r19
    1d48:	fc 01       	movw	r30, r24
    1d4a:	10 82       	st	Z, r1
    1d4c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1d4e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1d50:	01 96       	adiw	r24, 0x01	; 1
    1d52:	9b 87       	std	Y+11, r25	; 0x0b
    1d54:	8a 87       	std	Y+10, r24	; 0x0a
    1d56:	2a 85       	ldd	r18, Y+10	; 0x0a
    1d58:	3b 85       	ldd	r19, Y+11	; 0x0b
    1d5a:	41 e0       	ldi	r20, 0x01	; 1
    1d5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1d5e:	9c 81       	ldd	r25, Y+4	; 0x04
    1d60:	28 17       	cp	r18, r24
    1d62:	39 07       	cpc	r19, r25
    1d64:	08 f0       	brcs	.+2      	; 0x1d68 <_Z11ReceiveBonev+0x3dc>
    1d66:	40 e0       	ldi	r20, 0x00	; 0
    1d68:	44 23       	and	r20, r20
    1d6a:	39 f7       	brne	.-50     	; 0x1d3a <_Z11ReceiveBonev+0x3ae>
					state=0;
    1d6c:	1a 82       	std	Y+2, r1	; 0x02
    1d6e:	19 82       	std	Y+1, r1	; 0x01
					break;
    1d70:	28 c2       	rjmp	.+1104   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 5
				case 6:{
					//Graceful exit.
					flagReceivingBone=fFalse;
    1d72:	10 92 ba 01 	sts	0x01BA, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1d76:	1d 86       	std	Y+13, r1	; 0x0d
    1d78:	1c 86       	std	Y+12, r1	; 0x0c
    1d7a:	0e c0       	rjmp	.+28     	; 0x1d98 <_Z11ReceiveBonev+0x40c>
    1d7c:	9e 01       	movw	r18, r28
    1d7e:	22 5c       	subi	r18, 0xC2	; 194
    1d80:	3f 4f       	sbci	r19, 0xFF	; 255
    1d82:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d84:	9d 85       	ldd	r25, Y+13	; 0x0d
    1d86:	82 0f       	add	r24, r18
    1d88:	93 1f       	adc	r25, r19
    1d8a:	fc 01       	movw	r30, r24
    1d8c:	10 82       	st	Z, r1
    1d8e:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d90:	9d 85       	ldd	r25, Y+13	; 0x0d
    1d92:	01 96       	adiw	r24, 0x01	; 1
    1d94:	9d 87       	std	Y+13, r25	; 0x0d
    1d96:	8c 87       	std	Y+12, r24	; 0x0c
    1d98:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d9a:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d9c:	41 e0       	ldi	r20, 0x01	; 1
    1d9e:	8b 81       	ldd	r24, Y+3	; 0x03
    1da0:	9c 81       	ldd	r25, Y+4	; 0x04
    1da2:	28 17       	cp	r18, r24
    1da4:	39 07       	cpc	r19, r25
    1da6:	08 f0       	brcs	.+2      	; 0x1daa <_Z11ReceiveBonev+0x41e>
    1da8:	40 e0       	ldi	r20, 0x00	; 0
    1daa:	44 23       	and	r20, r20
    1dac:	39 f7       	brne	.-50     	; 0x1d7c <_Z11ReceiveBonev+0x3f0>
					state=0;
    1dae:	1a 82       	std	Y+2, r1	; 0x02
    1db0:	19 82       	std	Y+1, r1	; 0x01
					break;
    1db2:	07 c2       	rjmp	.+1038   	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 6
				case 7:{
					//Parse the string
					//Go through the string and parse for the time. Must go through the time to get the date.
					BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    1db4:	1e 86       	std	Y+14, r1	; 0x0e
    1db6:	1f 86       	std	Y+15, r1	; 0x0f
					int counter=3;
    1db8:	83 e0       	ldi	r24, 0x03	; 3
    1dba:	90 e0       	ldi	r25, 0x00	; 0
    1dbc:	99 8b       	std	Y+17, r25	; 0x11
    1dbe:	88 8b       	std	Y+16, r24	; 0x10
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    1dc0:	1e a6       	lds	r17, 0xbe
    1dc2:	1d a6       	lds	r17, 0xbd
    1dc4:	18 aa       	sts	0x98, r17
    1dc6:	1f a6       	lds	r17, 0xbf
    1dc8:	1a aa       	sts	0x9a, r17
    1dca:	19 aa       	sts	0x99, r17
    1dcc:	1c aa       	sts	0x9c, r17
    1dce:	1b aa       	sts	0x9b, r17
    1dd0:	1e aa       	sts	0x9e, r17
    1dd2:	1d aa       	sts	0x9d, r17
    1dd4:	18 ae       	sts	0xb8, r17
    1dd6:	1f aa       	sts	0x9f, r17
    1dd8:	1b 8a       	std	Y+19, r1	; 0x13
    1dda:	1a 8a       	std	Y+18, r1	; 0x12
    1ddc:	1d 8a       	std	Y+21, r1	; 0x15
    1dde:	1c 8a       	std	Y+20, r1	; 0x14
    1de0:	1f 8a       	std	Y+23, r1	; 0x17
    1de2:	1e 8a       	std	Y+22, r1	; 0x16
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    1de4:	73 c0       	rjmp	.+230    	; 0x1ecc <_Z11ReceiveBonev+0x540>
						//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
						if (recString[counter]!=':' && hms<3){
    1de6:	9e 01       	movw	r18, r28
    1de8:	22 5c       	subi	r18, 0xC2	; 194
    1dea:	3f 4f       	sbci	r19, 0xFF	; 255
    1dec:	88 89       	ldd	r24, Y+16	; 0x10
    1dee:	99 89       	ldd	r25, Y+17	; 0x11
    1df0:	82 0f       	add	r24, r18
    1df2:	93 1f       	adc	r25, r19
    1df4:	fc 01       	movw	r30, r24
    1df6:	80 81       	ld	r24, Z
    1df8:	8a 33       	cpi	r24, 0x3A	; 58
    1dfa:	e9 f0       	breq	.+58     	; 0x1e36 <_Z11ReceiveBonev+0x4aa>
    1dfc:	8c 89       	ldd	r24, Y+20	; 0x14
    1dfe:	9d 89       	ldd	r25, Y+21	; 0x15
    1e00:	83 30       	cpi	r24, 0x03	; 3
    1e02:	91 05       	cpc	r25, r1
    1e04:	c4 f4       	brge	.+48     	; 0x1e36 <_Z11ReceiveBonev+0x4aa>
							tempStringNum[placement++]=recString[counter];
    1e06:	9e 01       	movw	r18, r28
    1e08:	22 5c       	subi	r18, 0xC2	; 194
    1e0a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e0c:	88 89       	ldd	r24, Y+16	; 0x10
    1e0e:	99 89       	ldd	r25, Y+17	; 0x11
    1e10:	82 0f       	add	r24, r18
    1e12:	93 1f       	adc	r25, r19
    1e14:	fc 01       	movw	r30, r24
    1e16:	40 81       	ld	r20, Z
    1e18:	9e 01       	movw	r18, r28
    1e1a:	27 5c       	subi	r18, 0xC7	; 199
    1e1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1e1e:	8e 89       	ldd	r24, Y+22	; 0x16
    1e20:	9f 89       	ldd	r25, Y+23	; 0x17
    1e22:	82 0f       	add	r24, r18
    1e24:	93 1f       	adc	r25, r19
    1e26:	fc 01       	movw	r30, r24
    1e28:	40 83       	st	Z, r20
    1e2a:	8e 89       	ldd	r24, Y+22	; 0x16
    1e2c:	9f 89       	ldd	r25, Y+23	; 0x17
    1e2e:	01 96       	adiw	r24, 0x01	; 1
    1e30:	9f 8b       	std	Y+23, r25	; 0x17
    1e32:	8e 8b       	std	Y+22, r24	; 0x16
    1e34:	46 c0       	rjmp	.+140    	; 0x1ec2 <_Z11ReceiveBonev+0x536>
						//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
						} else if (hms<2 && recString[counter] == ':') {
    1e36:	8c 89       	ldd	r24, Y+20	; 0x14
    1e38:	9d 89       	ldd	r25, Y+21	; 0x15
    1e3a:	82 30       	cpi	r24, 0x02	; 2
    1e3c:	91 05       	cpc	r25, r1
    1e3e:	0c f0       	brlt	.+2      	; 0x1e42 <_Z11ReceiveBonev+0x4b6>
    1e40:	40 c0       	rjmp	.+128    	; 0x1ec2 <_Z11ReceiveBonev+0x536>
    1e42:	9e 01       	movw	r18, r28
    1e44:	22 5c       	subi	r18, 0xC2	; 194
    1e46:	3f 4f       	sbci	r19, 0xFF	; 255
    1e48:	88 89       	ldd	r24, Y+16	; 0x10
    1e4a:	99 89       	ldd	r25, Y+17	; 0x11
    1e4c:	82 0f       	add	r24, r18
    1e4e:	93 1f       	adc	r25, r19
    1e50:	fc 01       	movw	r30, r24
    1e52:	80 81       	ld	r24, Z
    1e54:	8a 33       	cpi	r24, 0x3A	; 58
    1e56:	a9 f5       	brne	.+106    	; 0x1ec2 <_Z11ReceiveBonev+0x536>
							tempNum[hms++] = atoi(tempStringNum);
    1e58:	ce 01       	movw	r24, r28
    1e5a:	c9 96       	adiw	r24, 0x39	; 57
    1e5c:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
    1e60:	9c 01       	movw	r18, r24
    1e62:	8c 89       	ldd	r24, Y+20	; 0x14
    1e64:	9d 89       	ldd	r25, Y+21	; 0x15
    1e66:	88 0f       	add	r24, r24
    1e68:	99 1f       	adc	r25, r25
    1e6a:	ae 01       	movw	r20, r28
    1e6c:	4f 5f       	subi	r20, 0xFF	; 255
    1e6e:	5f 4f       	sbci	r21, 0xFF	; 255
    1e70:	84 0f       	add	r24, r20
    1e72:	95 1f       	adc	r25, r21
    1e74:	8c 96       	adiw	r24, 0x2c	; 44
    1e76:	fc 01       	movw	r30, r24
    1e78:	31 83       	std	Z+1, r19	; 0x01
    1e7a:	20 83       	st	Z, r18
    1e7c:	8c 89       	ldd	r24, Y+20	; 0x14
    1e7e:	9d 89       	ldd	r25, Y+21	; 0x15
    1e80:	01 96       	adiw	r24, 0x01	; 1
    1e82:	9d 8b       	std	Y+21, r25	; 0x15
    1e84:	8c 8b       	std	Y+20, r24	; 0x14
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1e86:	19 8e       	std	Y+25, r1	; 0x19
    1e88:	18 8e       	std	Y+24, r1	; 0x18
    1e8a:	0e c0       	rjmp	.+28     	; 0x1ea8 <_Z11ReceiveBonev+0x51c>
    1e8c:	9e 01       	movw	r18, r28
    1e8e:	27 5c       	subi	r18, 0xC7	; 199
    1e90:	3f 4f       	sbci	r19, 0xFF	; 255
    1e92:	88 8d       	ldd	r24, Y+24	; 0x18
    1e94:	99 8d       	ldd	r25, Y+25	; 0x19
    1e96:	82 0f       	add	r24, r18
    1e98:	93 1f       	adc	r25, r19
    1e9a:	fc 01       	movw	r30, r24
    1e9c:	10 82       	st	Z, r1
    1e9e:	88 8d       	ldd	r24, Y+24	; 0x18
    1ea0:	99 8d       	ldd	r25, Y+25	; 0x19
    1ea2:	01 96       	adiw	r24, 0x01	; 1
    1ea4:	99 8f       	std	Y+25, r25	; 0x19
    1ea6:	88 8f       	std	Y+24, r24	; 0x18
    1ea8:	41 e0       	ldi	r20, 0x01	; 1
    1eaa:	28 8d       	ldd	r18, Y+24	; 0x18
    1eac:	39 8d       	ldd	r19, Y+25	; 0x19
    1eae:	8e 89       	ldd	r24, Y+22	; 0x16
    1eb0:	9f 89       	ldd	r25, Y+23	; 0x17
    1eb2:	82 17       	cp	r24, r18
    1eb4:	93 07       	cpc	r25, r19
    1eb6:	0c f4       	brge	.+2      	; 0x1eba <_Z11ReceiveBonev+0x52e>
    1eb8:	40 e0       	ldi	r20, 0x00	; 0
    1eba:	44 23       	and	r20, r20
    1ebc:	39 f7       	brne	.-50     	; 0x1e8c <_Z11ReceiveBonev+0x500>
							placement=0;												//reset placement
    1ebe:	1f 8a       	std	Y+23, r1	; 0x17
    1ec0:	1e 8a       	std	Y+22, r1	; 0x16
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
    1ec2:	88 89       	ldd	r24, Y+16	; 0x10
    1ec4:	99 89       	ldd	r25, Y+17	; 0x11
    1ec6:	01 96       	adiw	r24, 0x01	; 1
    1ec8:	99 8b       	std	Y+17, r25	; 0x11
    1eca:	88 8b       	std	Y+16, r24	; 0x10
					int counter=3;
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    1ecc:	9e 01       	movw	r18, r28
    1ece:	22 5c       	subi	r18, 0xC2	; 194
    1ed0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ed2:	88 89       	ldd	r24, Y+16	; 0x10
    1ed4:	99 89       	ldd	r25, Y+17	; 0x11
    1ed6:	82 0f       	add	r24, r18
    1ed8:	93 1f       	adc	r25, r19
    1eda:	fc 01       	movw	r30, r24
    1edc:	80 81       	ld	r24, Z
    1ede:	8f 32       	cpi	r24, 0x2F	; 47
    1ee0:	69 f0       	breq	.+26     	; 0x1efc <_Z11ReceiveBonev+0x570>
    1ee2:	9e 01       	movw	r18, r28
    1ee4:	22 5c       	subi	r18, 0xC2	; 194
    1ee6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ee8:	88 89       	ldd	r24, Y+16	; 0x10
    1eea:	99 89       	ldd	r25, Y+17	; 0x11
    1eec:	82 0f       	add	r24, r18
    1eee:	93 1f       	adc	r25, r19
    1ef0:	fc 01       	movw	r30, r24
    1ef2:	80 81       	ld	r24, Z
    1ef4:	88 23       	and	r24, r24
    1ef6:	11 f0       	breq	.+4      	; 0x1efc <_Z11ReceiveBonev+0x570>
    1ef8:	81 e0       	ldi	r24, 0x01	; 1
    1efa:	01 c0       	rjmp	.+2      	; 0x1efe <_Z11ReceiveBonev+0x572>
    1efc:	80 e0       	ldi	r24, 0x00	; 0
    1efe:	88 23       	and	r24, r24
    1f00:	09 f0       	breq	.+2      	; 0x1f04 <_Z11ReceiveBonev+0x578>
    1f02:	71 cf       	rjmp	.-286    	; 0x1de6 <_Z11ReceiveBonev+0x45a>
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
					}//end while
					//Found a '/', assign tempNum otherwise exit with ACKBAD
					if (recString[counter] == '/'){
    1f04:	9e 01       	movw	r18, r28
    1f06:	22 5c       	subi	r18, 0xC2	; 194
    1f08:	3f 4f       	sbci	r19, 0xFF	; 255
    1f0a:	88 89       	ldd	r24, Y+16	; 0x10
    1f0c:	99 89       	ldd	r25, Y+17	; 0x11
    1f0e:	82 0f       	add	r24, r18
    1f10:	93 1f       	adc	r25, r19
    1f12:	fc 01       	movw	r30, r24
    1f14:	80 81       	ld	r24, Z
    1f16:	8f 32       	cpi	r24, 0x2F	; 47
    1f18:	a9 f4       	brne	.+42     	; 0x1f44 <_Z11ReceiveBonev+0x5b8>
						tempNum[hms] = atoi(tempStringNum);
    1f1a:	ce 01       	movw	r24, r28
    1f1c:	c9 96       	adiw	r24, 0x39	; 57
    1f1e:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
    1f22:	9c 01       	movw	r18, r24
    1f24:	8c 89       	ldd	r24, Y+20	; 0x14
    1f26:	9d 89       	ldd	r25, Y+21	; 0x15
    1f28:	88 0f       	add	r24, r24
    1f2a:	99 1f       	adc	r25, r25
    1f2c:	ae 01       	movw	r20, r28
    1f2e:	4f 5f       	subi	r20, 0xFF	; 255
    1f30:	5f 4f       	sbci	r21, 0xFF	; 255
    1f32:	84 0f       	add	r24, r20
    1f34:	95 1f       	adc	r25, r21
    1f36:	8c 96       	adiw	r24, 0x2c	; 44
    1f38:	fc 01       	movw	r30, r24
    1f3a:	31 83       	std	Z+1, r19	; 0x01
    1f3c:	20 83       	st	Z, r18
						successTime=fTrue;
    1f3e:	81 e0       	ldi	r24, 0x01	; 1
    1f40:	8e 87       	std	Y+14, r24	; 0x0e
    1f42:	04 c0       	rjmp	.+8      	; 0x1f4c <_Z11ReceiveBonev+0x5c0>
					} else {
						state=4;
    1f44:	84 e0       	ldi	r24, 0x04	; 4
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	9a 83       	std	Y+2, r25	; 0x02
    1f4a:	89 83       	std	Y+1, r24	; 0x01
					}
					
					//If flag for Date is set, then parse the string and do something with it.
					//Now get the date. have to null the tempStringNum
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1f4c:	1b 8e       	std	Y+27, r1	; 0x1b
    1f4e:	1a 8e       	std	Y+26, r1	; 0x1a
    1f50:	0e c0       	rjmp	.+28     	; 0x1f6e <_Z11ReceiveBonev+0x5e2>
    1f52:	9e 01       	movw	r18, r28
    1f54:	27 5c       	subi	r18, 0xC7	; 199
    1f56:	3f 4f       	sbci	r19, 0xFF	; 255
    1f58:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f5a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1f5c:	82 0f       	add	r24, r18
    1f5e:	93 1f       	adc	r25, r19
    1f60:	fc 01       	movw	r30, r24
    1f62:	10 82       	st	Z, r1
    1f64:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1f66:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1f68:	01 96       	adiw	r24, 0x01	; 1
    1f6a:	9b 8f       	std	Y+27, r25	; 0x1b
    1f6c:	8a 8f       	std	Y+26, r24	; 0x1a
    1f6e:	41 e0       	ldi	r20, 0x01	; 1
    1f70:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1f72:	3b 8d       	ldd	r19, Y+27	; 0x1b
    1f74:	8e 89       	ldd	r24, Y+22	; 0x16
    1f76:	9f 89       	ldd	r25, Y+23	; 0x17
    1f78:	82 17       	cp	r24, r18
    1f7a:	93 07       	cpc	r25, r19
    1f7c:	0c f4       	brge	.+2      	; 0x1f80 <_Z11ReceiveBonev+0x5f4>
    1f7e:	40 e0       	ldi	r20, 0x00	; 0
    1f80:	44 23       	and	r20, r20
    1f82:	39 f7       	brne	.-50     	; 0x1f52 <_Z11ReceiveBonev+0x5c6>
					placement=0;
    1f84:	1f 8a       	std	Y+23, r1	; 0x17
    1f86:	1e 8a       	std	Y+22, r1	; 0x16
					counter++;	//get past the '/'
    1f88:	88 89       	ldd	r24, Y+16	; 0x10
    1f8a:	99 89       	ldd	r25, Y+17	; 0x11
    1f8c:	01 96       	adiw	r24, 0x01	; 1
    1f8e:	99 8b       	std	Y+17, r25	; 0x11
    1f90:	88 8b       	std	Y+16, r24	; 0x10
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1f92:	73 c0       	rjmp	.+230    	; 0x207a <_Z11ReceiveBonev+0x6ee>
						//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
						if  (recString[counter] != ',' && dmy < 3){
    1f94:	9e 01       	movw	r18, r28
    1f96:	22 5c       	subi	r18, 0xC2	; 194
    1f98:	3f 4f       	sbci	r19, 0xFF	; 255
    1f9a:	88 89       	ldd	r24, Y+16	; 0x10
    1f9c:	99 89       	ldd	r25, Y+17	; 0x11
    1f9e:	82 0f       	add	r24, r18
    1fa0:	93 1f       	adc	r25, r19
    1fa2:	fc 01       	movw	r30, r24
    1fa4:	80 81       	ld	r24, Z
    1fa6:	8c 32       	cpi	r24, 0x2C	; 44
    1fa8:	e9 f0       	breq	.+58     	; 0x1fe4 <_Z11ReceiveBonev+0x658>
    1faa:	8a 89       	ldd	r24, Y+18	; 0x12
    1fac:	9b 89       	ldd	r25, Y+19	; 0x13
    1fae:	83 30       	cpi	r24, 0x03	; 3
    1fb0:	91 05       	cpc	r25, r1
    1fb2:	c4 f4       	brge	.+48     	; 0x1fe4 <_Z11ReceiveBonev+0x658>
							tempStringNum[placement++]=recString[counter];
    1fb4:	9e 01       	movw	r18, r28
    1fb6:	22 5c       	subi	r18, 0xC2	; 194
    1fb8:	3f 4f       	sbci	r19, 0xFF	; 255
    1fba:	88 89       	ldd	r24, Y+16	; 0x10
    1fbc:	99 89       	ldd	r25, Y+17	; 0x11
    1fbe:	82 0f       	add	r24, r18
    1fc0:	93 1f       	adc	r25, r19
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	40 81       	ld	r20, Z
    1fc6:	9e 01       	movw	r18, r28
    1fc8:	27 5c       	subi	r18, 0xC7	; 199
    1fca:	3f 4f       	sbci	r19, 0xFF	; 255
    1fcc:	8e 89       	ldd	r24, Y+22	; 0x16
    1fce:	9f 89       	ldd	r25, Y+23	; 0x17
    1fd0:	82 0f       	add	r24, r18
    1fd2:	93 1f       	adc	r25, r19
    1fd4:	fc 01       	movw	r30, r24
    1fd6:	40 83       	st	Z, r20
    1fd8:	8e 89       	ldd	r24, Y+22	; 0x16
    1fda:	9f 89       	ldd	r25, Y+23	; 0x17
    1fdc:	01 96       	adiw	r24, 0x01	; 1
    1fde:	9f 8b       	std	Y+23, r25	; 0x17
    1fe0:	8e 8b       	std	Y+22, r24	; 0x16
    1fe2:	46 c0       	rjmp	.+140    	; 0x2070 <_Z11ReceiveBonev+0x6e4>
						//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
						} else if (dmy<2 && recString[counter]==','){
    1fe4:	8a 89       	ldd	r24, Y+18	; 0x12
    1fe6:	9b 89       	ldd	r25, Y+19	; 0x13
    1fe8:	82 30       	cpi	r24, 0x02	; 2
    1fea:	91 05       	cpc	r25, r1
    1fec:	0c f0       	brlt	.+2      	; 0x1ff0 <_Z11ReceiveBonev+0x664>
    1fee:	40 c0       	rjmp	.+128    	; 0x2070 <_Z11ReceiveBonev+0x6e4>
    1ff0:	9e 01       	movw	r18, r28
    1ff2:	22 5c       	subi	r18, 0xC2	; 194
    1ff4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ff6:	88 89       	ldd	r24, Y+16	; 0x10
    1ff8:	99 89       	ldd	r25, Y+17	; 0x11
    1ffa:	82 0f       	add	r24, r18
    1ffc:	93 1f       	adc	r25, r19
    1ffe:	fc 01       	movw	r30, r24
    2000:	80 81       	ld	r24, Z
    2002:	8c 32       	cpi	r24, 0x2C	; 44
    2004:	a9 f5       	brne	.+106    	; 0x2070 <_Z11ReceiveBonev+0x6e4>
							tempNum1[dmy++] = atoi(tempStringNum);
    2006:	ce 01       	movw	r24, r28
    2008:	c9 96       	adiw	r24, 0x39	; 57
    200a:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
    200e:	9c 01       	movw	r18, r24
    2010:	8a 89       	ldd	r24, Y+18	; 0x12
    2012:	9b 89       	ldd	r25, Y+19	; 0x13
    2014:	88 0f       	add	r24, r24
    2016:	99 1f       	adc	r25, r25
    2018:	ae 01       	movw	r20, r28
    201a:	4f 5f       	subi	r20, 0xFF	; 255
    201c:	5f 4f       	sbci	r21, 0xFF	; 255
    201e:	84 0f       	add	r24, r20
    2020:	95 1f       	adc	r25, r21
    2022:	c2 96       	adiw	r24, 0x32	; 50
    2024:	fc 01       	movw	r30, r24
    2026:	31 83       	std	Z+1, r19	; 0x01
    2028:	20 83       	st	Z, r18
    202a:	8a 89       	ldd	r24, Y+18	; 0x12
    202c:	9b 89       	ldd	r25, Y+19	; 0x13
    202e:	01 96       	adiw	r24, 0x01	; 1
    2030:	9b 8b       	std	Y+19, r25	; 0x13
    2032:	8a 8b       	std	Y+18, r24	; 0x12
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    2034:	1d 8e       	std	Y+29, r1	; 0x1d
    2036:	1c 8e       	std	Y+28, r1	; 0x1c
    2038:	0e c0       	rjmp	.+28     	; 0x2056 <_Z11ReceiveBonev+0x6ca>
    203a:	9e 01       	movw	r18, r28
    203c:	27 5c       	subi	r18, 0xC7	; 199
    203e:	3f 4f       	sbci	r19, 0xFF	; 255
    2040:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2042:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2044:	82 0f       	add	r24, r18
    2046:	93 1f       	adc	r25, r19
    2048:	fc 01       	movw	r30, r24
    204a:	10 82       	st	Z, r1
    204c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    204e:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2050:	01 96       	adiw	r24, 0x01	; 1
    2052:	9d 8f       	std	Y+29, r25	; 0x1d
    2054:	8c 8f       	std	Y+28, r24	; 0x1c
    2056:	41 e0       	ldi	r20, 0x01	; 1
    2058:	2c 8d       	ldd	r18, Y+28	; 0x1c
    205a:	3d 8d       	ldd	r19, Y+29	; 0x1d
    205c:	8e 89       	ldd	r24, Y+22	; 0x16
    205e:	9f 89       	ldd	r25, Y+23	; 0x17
    2060:	82 17       	cp	r24, r18
    2062:	93 07       	cpc	r25, r19
    2064:	0c f4       	brge	.+2      	; 0x2068 <_Z11ReceiveBonev+0x6dc>
    2066:	40 e0       	ldi	r20, 0x00	; 0
    2068:	44 23       	and	r20, r20
    206a:	39 f7       	brne	.-50     	; 0x203a <_Z11ReceiveBonev+0x6ae>
							placement=0;
    206c:	1f 8a       	std	Y+23, r1	; 0x17
    206e:	1e 8a       	std	Y+22, r1	; 0x16
						} else;
						counter++;							
    2070:	88 89       	ldd	r24, Y+16	; 0x10
    2072:	99 89       	ldd	r25, Y+17	; 0x11
    2074:	01 96       	adiw	r24, 0x01	; 1
    2076:	99 8b       	std	Y+17, r25	; 0x11
    2078:	88 8b       	std	Y+16, r24	; 0x10
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
					placement=0;
					counter++;	//get past the '/'
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    207a:	9e 01       	movw	r18, r28
    207c:	22 5c       	subi	r18, 0xC2	; 194
    207e:	3f 4f       	sbci	r19, 0xFF	; 255
    2080:	88 89       	ldd	r24, Y+16	; 0x10
    2082:	99 89       	ldd	r25, Y+17	; 0x11
    2084:	82 0f       	add	r24, r18
    2086:	93 1f       	adc	r25, r19
    2088:	fc 01       	movw	r30, r24
    208a:	80 81       	ld	r24, Z
    208c:	8e 32       	cpi	r24, 0x2E	; 46
    208e:	a1 f0       	breq	.+40     	; 0x20b8 <_Z11ReceiveBonev+0x72c>
    2090:	9e 01       	movw	r18, r28
    2092:	22 5c       	subi	r18, 0xC2	; 194
    2094:	3f 4f       	sbci	r19, 0xFF	; 255
    2096:	88 89       	ldd	r24, Y+16	; 0x10
    2098:	99 89       	ldd	r25, Y+17	; 0x11
    209a:	82 0f       	add	r24, r18
    209c:	93 1f       	adc	r25, r19
    209e:	fc 01       	movw	r30, r24
    20a0:	80 81       	ld	r24, Z
    20a2:	88 23       	and	r24, r24
    20a4:	49 f0       	breq	.+18     	; 0x20b8 <_Z11ReceiveBonev+0x72c>
    20a6:	28 89       	ldd	r18, Y+16	; 0x10
    20a8:	39 89       	ldd	r19, Y+17	; 0x11
    20aa:	8b 81       	ldd	r24, Y+3	; 0x03
    20ac:	9c 81       	ldd	r25, Y+4	; 0x04
    20ae:	28 17       	cp	r18, r24
    20b0:	39 07       	cpc	r19, r25
    20b2:	11 f0       	breq	.+4      	; 0x20b8 <_Z11ReceiveBonev+0x72c>
    20b4:	81 e0       	ldi	r24, 0x01	; 1
    20b6:	01 c0       	rjmp	.+2      	; 0x20ba <_Z11ReceiveBonev+0x72e>
    20b8:	80 e0       	ldi	r24, 0x00	; 0
    20ba:	88 23       	and	r24, r24
    20bc:	09 f0       	breq	.+2      	; 0x20c0 <_Z11ReceiveBonev+0x734>
    20be:	6a cf       	rjmp	.-300    	; 0x1f94 <_Z11ReceiveBonev+0x608>
						} else;
						counter++;							
					}//end while
					
					//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
					if (recString[counter] == '.'){
    20c0:	9e 01       	movw	r18, r28
    20c2:	22 5c       	subi	r18, 0xC2	; 194
    20c4:	3f 4f       	sbci	r19, 0xFF	; 255
    20c6:	88 89       	ldd	r24, Y+16	; 0x10
    20c8:	99 89       	ldd	r25, Y+17	; 0x11
    20ca:	82 0f       	add	r24, r18
    20cc:	93 1f       	adc	r25, r19
    20ce:	fc 01       	movw	r30, r24
    20d0:	80 81       	ld	r24, Z
    20d2:	8e 32       	cpi	r24, 0x2E	; 46
    20d4:	a9 f4       	brne	.+42     	; 0x2100 <_Z11ReceiveBonev+0x774>
						tempNum1[dmy] = atoi(tempStringNum);
    20d6:	ce 01       	movw	r24, r28
    20d8:	c9 96       	adiw	r24, 0x39	; 57
    20da:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
    20de:	9c 01       	movw	r18, r24
    20e0:	8a 89       	ldd	r24, Y+18	; 0x12
    20e2:	9b 89       	ldd	r25, Y+19	; 0x13
    20e4:	88 0f       	add	r24, r24
    20e6:	99 1f       	adc	r25, r25
    20e8:	ae 01       	movw	r20, r28
    20ea:	4f 5f       	subi	r20, 0xFF	; 255
    20ec:	5f 4f       	sbci	r21, 0xFF	; 255
    20ee:	84 0f       	add	r24, r20
    20f0:	95 1f       	adc	r25, r21
    20f2:	c2 96       	adiw	r24, 0x32	; 50
    20f4:	fc 01       	movw	r30, r24
    20f6:	31 83       	std	Z+1, r19	; 0x01
    20f8:	20 83       	st	Z, r18
						successDate=fTrue;
    20fa:	81 e0       	ldi	r24, 0x01	; 1
    20fc:	8f 87       	std	Y+15, r24	; 0x0f
    20fe:	04 c0       	rjmp	.+8      	; 0x2108 <_Z11ReceiveBonev+0x77c>
					} else {//something in the string was wrong, ACKBAD and then exit
						state=4;
    2100:	84 e0       	ldi	r24, 0x04	; 4
    2102:	90 e0       	ldi	r25, 0x00	; 0
    2104:	9a 83       	std	Y+2, r25	; 0x02
    2106:	89 83       	std	Y+1, r24	; 0x01
					}	
					
					//NOw set the time and date, then save it to EEPROM
					if (successDate && successTime){
    2108:	8f 85       	ldd	r24, Y+15	; 0x0f
    210a:	88 23       	and	r24, r24
    210c:	29 f1       	breq	.+74     	; 0x2158 <_Z11ReceiveBonev+0x7cc>
    210e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2110:	88 23       	and	r24, r24
    2112:	11 f1       	breq	.+68     	; 0x2158 <_Z11ReceiveBonev+0x7cc>
						currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    2114:	6b a9       	sts	0x4b, r22
    2116:	7c a9       	sts	0x4c, r23
    2118:	4d a9       	sts	0x4d, r20
    211a:	5e a9       	sts	0x4e, r21
    211c:	2f a9       	sts	0x4f, r18
    211e:	38 ad       	sts	0x68, r19
    2120:	82 e9       	ldi	r24, 0x92	; 146
    2122:	91 e0       	ldi	r25, 0x01	; 1
    2124:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
						currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    2128:	6d a5       	lds	r22, 0x6d
    212a:	7e a5       	lds	r23, 0x6e
    212c:	4f a5       	lds	r20, 0x6f
    212e:	58 a9       	sts	0x48, r21
    2130:	29 a9       	sts	0x49, r18
    2132:	3a a9       	sts	0x4a, r19
    2134:	82 e9       	ldi	r24, 0x92	; 146
    2136:	91 e0       	ldi	r25, 0x01	; 1
    2138:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
						saveDateTime_eeprom(fTrue,fTrue);
    213c:	81 e0       	ldi	r24, 0x01	; 1
    213e:	61 e0       	ldi	r22, 0x01	; 1
    2140:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    2144:	81 e0       	ldi	r24, 0x01	; 1
    2146:	80 93 c0 01 	sts	0x01C0, r24
						//Make sure UserCLock flags are down
						flagUserClock=fFalse;
    214a:	10 92 c2 01 	sts	0x01C2, r1
						state=3;	//Graceful exit
    214e:	83 e0       	ldi	r24, 0x03	; 3
    2150:	90 e0       	ldi	r25, 0x00	; 0
    2152:	9a 83       	std	Y+2, r25	; 0x02
    2154:	89 83       	std	Y+1, r24	; 0x01
    2156:	2b c0       	rjmp	.+86     	; 0x21ae <_Z11ReceiveBonev+0x822>
					} else if (!(successDate && successTime) && restart){
    2158:	8f 85       	ldd	r24, Y+15	; 0x0f
    215a:	88 23       	and	r24, r24
    215c:	19 f0       	breq	.+6      	; 0x2164 <_Z11ReceiveBonev+0x7d8>
    215e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2160:	88 23       	and	r24, r24
    2162:	71 f4       	brne	.+28     	; 0x2180 <_Z11ReceiveBonev+0x7f4>
    2164:	80 91 ca 01 	lds	r24, 0x01CA
    2168:	88 23       	and	r24, r24
    216a:	51 f0       	breq	.+20     	; 0x2180 <_Z11ReceiveBonev+0x7f4>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	80 93 c0 01 	sts	0x01C0, r24
						flagUserClock=fFalse;
    2172:	10 92 c2 01 	sts	0x01C2, r1
						state=4;	//ACKBAD
    2176:	84 e0       	ldi	r24, 0x04	; 4
    2178:	90 e0       	ldi	r25, 0x00	; 0
    217a:	9a 83       	std	Y+2, r25	; 0x02
    217c:	89 83       	std	Y+1, r24	; 0x01
    217e:	17 c0       	rjmp	.+46     	; 0x21ae <_Z11ReceiveBonev+0x822>
					} else if (!(successDate && successTime) && flagFreshStart && !restart){
    2180:	8f 85       	ldd	r24, Y+15	; 0x0f
    2182:	88 23       	and	r24, r24
    2184:	19 f0       	breq	.+6      	; 0x218c <_Z11ReceiveBonev+0x800>
    2186:	8e 85       	ldd	r24, Y+14	; 0x0e
    2188:	88 23       	and	r24, r24
    218a:	89 f4       	brne	.+34     	; 0x21ae <_Z11ReceiveBonev+0x822>
    218c:	80 91 cb 01 	lds	r24, 0x01CB
    2190:	88 23       	and	r24, r24
    2192:	69 f0       	breq	.+26     	; 0x21ae <_Z11ReceiveBonev+0x822>
    2194:	80 91 ca 01 	lds	r24, 0x01CA
    2198:	88 23       	and	r24, r24
    219a:	49 f4       	brne	.+18     	; 0x21ae <_Z11ReceiveBonev+0x822>
						flagUserClock=fTrue;
    219c:	81 e0       	ldi	r24, 0x01	; 1
    219e:	80 93 c2 01 	sts	0x01C2, r24
						flagUpdateGAVRClock=fFalse;
    21a2:	10 92 c0 01 	sts	0x01C0, r1
						state=4;	//ACKBAD
    21a6:	84 e0       	ldi	r24, 0x04	; 4
    21a8:	90 e0       	ldi	r25, 0x00	; 0
    21aa:	9a 83       	std	Y+2, r25	; 0x02
    21ac:	89 83       	std	Y+1, r24	; 0x01
					} else;		
					
					//Lower restart flags. Should have parallel case in timer just in case this state doesn't happen.
					flagFreshStart=fFalse;
    21ae:	10 92 cb 01 	sts	0x01CB, r1
					restart=fFalse;		
    21b2:	10 92 ca 01 	sts	0x01CA, r1
					break;
    21b6:	05 c0       	rjmp	.+10     	; 0x21c2 <_Z11ReceiveBonev+0x836>
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
    21b8:	10 92 ba 01 	sts	0x01BA, r1
    21bc:	1a 82       	std	Y+2, r1	; 0x02
    21be:	19 82       	std	Y+1, r1	; 0x01
    21c0:	00 00       	nop
	unsigned int state=0;
	char recChar, recString[40];
	unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	while (flagReceivingBone){
    21c2:	90 91 ba 01 	lds	r25, 0x01BA
    21c6:	81 e0       	ldi	r24, 0x01	; 1
    21c8:	99 23       	and	r25, r25
    21ca:	09 f4       	brne	.+2      	; 0x21ce <_Z11ReceiveBonev+0x842>
    21cc:	80 e0       	ldi	r24, 0x00	; 0
    21ce:	88 23       	and	r24, r24
    21d0:	09 f0       	breq	.+2      	; 0x21d4 <_Z11ReceiveBonev+0x848>
    21d2:	ee cb       	rjmp	.-2084   	; 0x19b0 <_Z11ReceiveBonev+0x24>
					break;
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
			}//end switch
	}//end while(flagUARTbone)	
}//end ReceiveBone()
    21d4:	cb 59       	subi	r28, 0x9B	; 155
    21d6:	df 4f       	sbci	r29, 0xFF	; 255
    21d8:	0f b6       	in	r0, 0x3f	; 63
    21da:	f8 94       	cli
    21dc:	de bf       	out	0x3e, r29	; 62
    21de:	0f be       	out	0x3f, r0	; 63
    21e0:	cd bf       	out	0x3d, r28	; 61
    21e2:	df 91       	pop	r29
    21e4:	cf 91       	pop	r28
    21e6:	08 95       	ret

000021e8 <_Z11ReceiveGAVRv>:

/*************************************************************************************************************/
void ReceiveGAVR(){
    21e8:	cf 93       	push	r28
    21ea:	df 93       	push	r29
    21ec:	cd b7       	in	r28, 0x3d	; 61
    21ee:	de b7       	in	r29, 0x3e	; 62
    21f0:	c1 55       	subi	r28, 0x51	; 81
    21f2:	d0 40       	sbci	r29, 0x00	; 0
    21f4:	0f b6       	in	r0, 0x3f	; 63
    21f6:	f8 94       	cli
    21f8:	de bf       	out	0x3e, r29	; 62
    21fa:	0f be       	out	0x3f, r0	; 63
    21fc:	cd bf       	out	0x3d, r28	; 61
	unsigned int state=0;
    21fe:	1a 82       	std	Y+2, r1	; 0x02
    2200:	19 82       	std	Y+1, r1	; 0x01
	char recChar, recString[40];
	unsigned int strLoc=0;
    2202:	1c 82       	std	Y+4, r1	; 0x04
    2204:	1b 82       	std	Y+3, r1	; 0x03
	BOOL noCarriage=fTrue;
    2206:	81 e0       	ldi	r24, 0x01	; 1
    2208:	8d 83       	std	Y+5, r24	; 0x05
	
	//While Loop
	while (flagReceivingGAVR){
    220a:	4b c3       	rjmp	.+1686   	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
			/** State 5: Exit case. Lower "flagReceivingGAVR" which causes and exit.													   **/
			/** State 6: ACKERROR state. Send "ACKERROR", then exit through state 5.													   **/
			/** State 7: Successful acquire of time/date.																				   **/
			/** Default: Set state to 0, doesn't really matter though. Exit signalling timeout to sender.								   **/
			/********************************************************************************************************************************/			
			switch(state){
    220c:	89 81       	ldd	r24, Y+1	; 0x01
    220e:	9a 81       	ldd	r25, Y+2	; 0x02
    2210:	83 30       	cpi	r24, 0x03	; 3
    2212:	91 05       	cpc	r25, r1
    2214:	09 f4       	brne	.+2      	; 0x2218 <_Z11ReceiveGAVRv+0x30>
    2216:	bd c0       	rjmp	.+378    	; 0x2392 <_Z11ReceiveGAVRv+0x1aa>
    2218:	84 30       	cpi	r24, 0x04	; 4
    221a:	91 05       	cpc	r25, r1
    221c:	48 f4       	brcc	.+18     	; 0x2230 <_Z11ReceiveGAVRv+0x48>
    221e:	81 30       	cpi	r24, 0x01	; 1
    2220:	91 05       	cpc	r25, r1
    2222:	09 f4       	brne	.+2      	; 0x2226 <_Z11ReceiveGAVRv+0x3e>
    2224:	81 c0       	rjmp	.+258    	; 0x2328 <_Z11ReceiveGAVRv+0x140>
    2226:	82 30       	cpi	r24, 0x02	; 2
    2228:	91 05       	cpc	r25, r1
    222a:	08 f0       	brcs	.+2      	; 0x222e <_Z11ReceiveGAVRv+0x46>
    222c:	8b c0       	rjmp	.+278    	; 0x2344 <_Z11ReceiveGAVRv+0x15c>
    222e:	11 c0       	rjmp	.+34     	; 0x2252 <_Z11ReceiveGAVRv+0x6a>
    2230:	85 30       	cpi	r24, 0x05	; 5
    2232:	91 05       	cpc	r25, r1
    2234:	09 f4       	brne	.+2      	; 0x2238 <_Z11ReceiveGAVRv+0x50>
    2236:	f5 c2       	rjmp	.+1514   	; 0x2822 <_Z11ReceiveGAVRv+0x63a>
    2238:	85 30       	cpi	r24, 0x05	; 5
    223a:	91 05       	cpc	r25, r1
    223c:	08 f4       	brcc	.+2      	; 0x2240 <_Z11ReceiveGAVRv+0x58>
    223e:	dc c2       	rjmp	.+1464   	; 0x27f8 <_Z11ReceiveGAVRv+0x610>
    2240:	86 30       	cpi	r24, 0x06	; 6
    2242:	91 05       	cpc	r25, r1
    2244:	09 f4       	brne	.+2      	; 0x2248 <_Z11ReceiveGAVRv+0x60>
    2246:	0e c3       	rjmp	.+1564   	; 0x2864 <_Z11ReceiveGAVRv+0x67c>
    2248:	87 30       	cpi	r24, 0x07	; 7
    224a:	91 05       	cpc	r25, r1
    224c:	09 f4       	brne	.+2      	; 0x2250 <_Z11ReceiveGAVRv+0x68>
    224e:	13 c3       	rjmp	.+1574   	; 0x2876 <_Z11ReceiveGAVRv+0x68e>
    2250:	21 c3       	rjmp	.+1602   	; 0x2894 <_Z11ReceiveGAVRv+0x6ac>
				case 0:{
					//Beginning case
					strLoc=0;
    2252:	1c 82       	std	Y+4, r1	; 0x04
    2254:	1b 82       	std	Y+3, r1	; 0x03
					recChar = UDR1;
    2256:	8e ec       	ldi	r24, 0xCE	; 206
    2258:	90 e0       	ldi	r25, 0x00	; 0
    225a:	fc 01       	movw	r30, r24
    225c:	80 81       	ld	r24, Z
    225e:	88 8f       	std	Y+24, r24	; 0x18
					if (recChar=='.'){
    2260:	88 8d       	ldd	r24, Y+24	; 0x18
    2262:	8e 32       	cpi	r24, 0x2E	; 46
    2264:	29 f4       	brne	.+10     	; 0x2270 <_Z11ReceiveGAVRv+0x88>
						state=6;															//Go to error state.
    2266:	86 e0       	ldi	r24, 0x06	; 6
    2268:	90 e0       	ldi	r25, 0x00	; 0
    226a:	9a 83       	std	Y+2, r25	; 0x02
    226c:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
    226e:	19 c3       	rjmp	.+1586   	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
					//Beginning case
					strLoc=0;
					recChar = UDR1;
					if (recChar=='.'){
						state=6;															//Go to error state.
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
    2270:	9e 01       	movw	r18, r28
    2272:	26 5d       	subi	r18, 0xD6	; 214
    2274:	3f 4f       	sbci	r19, 0xFF	; 255
    2276:	8b 81       	ldd	r24, Y+3	; 0x03
    2278:	9c 81       	ldd	r25, Y+4	; 0x04
    227a:	82 0f       	add	r24, r18
    227c:	93 1f       	adc	r25, r19
    227e:	28 8d       	ldd	r18, Y+24	; 0x18
    2280:	fc 01       	movw	r30, r24
    2282:	20 83       	st	Z, r18
    2284:	8b 81       	ldd	r24, Y+3	; 0x03
    2286:	9c 81       	ldd	r25, Y+4	; 0x04
    2288:	01 96       	adiw	r24, 0x01	; 1
    228a:	9c 83       	std	Y+4, r25	; 0x04
    228c:	8b 83       	std	Y+3, r24	; 0x03
    228e:	81 e0       	ldi	r24, 0x01	; 1
    2290:	90 e0       	ldi	r25, 0x00	; 0
    2292:	9a 83       	std	Y+2, r25	; 0x02
    2294:	89 83       	std	Y+1, r24	; 0x01
					break;
    2296:	05 c3       	rjmp	.+1546   	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
    2298:	00 00       	nop
    229a:	88 ec       	ldi	r24, 0xC8	; 200
    229c:	90 e0       	ldi	r25, 0x00	; 0
    229e:	fc 01       	movw	r30, r24
    22a0:	80 81       	ld	r24, Z
    22a2:	88 23       	and	r24, r24
    22a4:	34 f0       	brlt	.+12     	; 0x22b2 <_Z11ReceiveGAVRv+0xca>
    22a6:	80 91 bc 01 	lds	r24, 0x01BC
    22aa:	88 23       	and	r24, r24
    22ac:	11 f0       	breq	.+4      	; 0x22b2 <_Z11ReceiveGAVRv+0xca>
    22ae:	81 e0       	ldi	r24, 0x01	; 1
    22b0:	01 c0       	rjmp	.+2      	; 0x22b4 <_Z11ReceiveGAVRv+0xcc>
    22b2:	80 e0       	ldi	r24, 0x00	; 0
    22b4:	88 23       	and	r24, r24
    22b6:	89 f7       	brne	.-30     	; 0x229a <_Z11ReceiveGAVRv+0xb2>
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
    22b8:	80 91 bc 01 	lds	r24, 0x01BC
    22bc:	88 23       	and	r24, r24
    22be:	21 f4       	brne	.+8      	; 0x22c8 <_Z11ReceiveGAVRv+0xe0>
    22c0:	1a 82       	std	Y+2, r1	; 0x02
    22c2:	19 82       	std	Y+1, r1	; 0x01
    22c4:	00 00       	nop
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    22c6:	ed c2       	rjmp	.+1498   	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
						recChar=UDR1;
    22c8:	8e ec       	ldi	r24, 0xCE	; 206
    22ca:	90 e0       	ldi	r25, 0x00	; 0
    22cc:	fc 01       	movw	r30, r24
    22ce:	80 81       	ld	r24, Z
    22d0:	88 8f       	std	Y+24, r24	; 0x18
						recString[strLoc++]=recChar;										//'.' always included into recString
    22d2:	9e 01       	movw	r18, r28
    22d4:	26 5d       	subi	r18, 0xD6	; 214
    22d6:	3f 4f       	sbci	r19, 0xFF	; 255
    22d8:	8b 81       	ldd	r24, Y+3	; 0x03
    22da:	9c 81       	ldd	r25, Y+4	; 0x04
    22dc:	82 0f       	add	r24, r18
    22de:	93 1f       	adc	r25, r19
    22e0:	28 8d       	ldd	r18, Y+24	; 0x18
    22e2:	fc 01       	movw	r30, r24
    22e4:	20 83       	st	Z, r18
    22e6:	8b 81       	ldd	r24, Y+3	; 0x03
    22e8:	9c 81       	ldd	r25, Y+4	; 0x04
    22ea:	01 96       	adiw	r24, 0x01	; 1
    22ec:	9c 83       	std	Y+4, r25	; 0x04
    22ee:	8b 83       	std	Y+3, r24	; 0x03
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    22f0:	88 8d       	ldd	r24, Y+24	; 0x18
    22f2:	8e 32       	cpi	r24, 0x2E	; 46
    22f4:	79 f4       	brne	.+30     	; 0x2314 <_Z11ReceiveGAVRv+0x12c>
    22f6:	9e 01       	movw	r18, r28
    22f8:	26 5d       	subi	r18, 0xD6	; 214
    22fa:	3f 4f       	sbci	r19, 0xFF	; 255
    22fc:	8b 81       	ldd	r24, Y+3	; 0x03
    22fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2300:	82 0f       	add	r24, r18
    2302:	93 1f       	adc	r25, r19
    2304:	fc 01       	movw	r30, r24
    2306:	10 82       	st	Z, r1
    2308:	1d 82       	std	Y+5, r1	; 0x05
    230a:	82 e0       	ldi	r24, 0x02	; 2
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	9a 83       	std	Y+2, r25	; 0x02
    2310:	89 83       	std	Y+1, r24	; 0x01
    2312:	0a c0       	rjmp	.+20     	; 0x2328 <_Z11ReceiveGAVRv+0x140>
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
    2314:	8b 81       	ldd	r24, Y+3	; 0x03
    2316:	9c 81       	ldd	r25, Y+4	; 0x04
    2318:	87 32       	cpi	r24, 0x27	; 39
    231a:	91 05       	cpc	r25, r1
    231c:	28 f0       	brcs	.+10     	; 0x2328 <_Z11ReceiveGAVRv+0x140>
    231e:	86 e0       	ldi	r24, 0x06	; 6
    2320:	90 e0       	ldi	r25, 0x00	; 0
    2322:	9a 83       	std	Y+2, r25	; 0x02
    2324:	89 83       	std	Y+1, r24	; 0x01
    2326:	1d 82       	std	Y+5, r1	; 0x05
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
    2328:	8d 81       	ldd	r24, Y+5	; 0x05
    232a:	88 23       	and	r24, r24
    232c:	31 f0       	breq	.+12     	; 0x233a <_Z11ReceiveGAVRv+0x152>
    232e:	80 91 bc 01 	lds	r24, 0x01BC
    2332:	88 23       	and	r24, r24
    2334:	11 f0       	breq	.+4      	; 0x233a <_Z11ReceiveGAVRv+0x152>
    2336:	81 e0       	ldi	r24, 0x01	; 1
    2338:	01 c0       	rjmp	.+2      	; 0x233c <_Z11ReceiveGAVRv+0x154>
    233a:	80 e0       	ldi	r24, 0x00	; 0
    233c:	88 23       	and	r24, r24
    233e:	09 f0       	breq	.+2      	; 0x2342 <_Z11ReceiveGAVRv+0x15a>
    2340:	ab cf       	rjmp	.-170    	; 0x2298 <_Z11ReceiveGAVRv+0xb0>
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    2342:	af c2       	rjmp	.+1374   	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
    2344:	ce 01       	movw	r24, r28
    2346:	8a 96       	adiw	r24, 0x2a	; 42
    2348:	28 e6       	ldi	r18, 0x68	; 104
    234a:	31 e0       	ldi	r19, 0x01	; 1
    234c:	b9 01       	movw	r22, r18
    234e:	48 e0       	ldi	r20, 0x08	; 8
    2350:	50 e0       	ldi	r21, 0x00	; 0
    2352:	0e 94 08 1f 	call	0x3e10	; 0x3e10 <strncmp>
    2356:	00 97       	sbiw	r24, 0x00	; 0
    2358:	29 f4       	brne	.+10     	; 0x2364 <_Z11ReceiveGAVRv+0x17c>
    235a:	84 e0       	ldi	r24, 0x04	; 4
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	9a 83       	std	Y+2, r25	; 0x02
    2360:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
					break;
    2362:	9f c2       	rjmp	.+1342   	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
					break;
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
    2364:	8e a5       	lds	r24, 0x6e
    2366:	91 e0       	ldi	r25, 0x01	; 1
    2368:	8a 33       	cpi	r24, 0x3A	; 58
    236a:	09 f0       	breq	.+2      	; 0x236e <_Z11ReceiveGAVRv+0x186>
    236c:	90 e0       	ldi	r25, 0x00	; 0
    236e:	2f a5       	lds	r18, 0x6f
    2370:	81 e0       	ldi	r24, 0x01	; 1
    2372:	2a 33       	cpi	r18, 0x3A	; 58
    2374:	09 f0       	breq	.+2      	; 0x2378 <_Z11ReceiveGAVRv+0x190>
    2376:	80 e0       	ldi	r24, 0x00	; 0
    2378:	89 27       	eor	r24, r25
    237a:	88 23       	and	r24, r24
    237c:	29 f0       	breq	.+10     	; 0x2388 <_Z11ReceiveGAVRv+0x1a0>
    237e:	83 e0       	ldi	r24, 0x03	; 3
    2380:	90 e0       	ldi	r25, 0x00	; 0
    2382:	9a 83       	std	Y+2, r25	; 0x02
    2384:	89 83       	std	Y+1, r24	; 0x01
					else {state=6;}
					break;
    2386:	8d c2       	rjmp	.+1306   	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
    2388:	86 e0       	ldi	r24, 0x06	; 6
    238a:	90 e0       	ldi	r25, 0x00	; 0
    238c:	9a 83       	std	Y+2, r25	; 0x02
    238e:	89 83       	std	Y+1, r24	; 0x01
					break;
    2390:	88 c2       	rjmp	.+1296   	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				}//end case 2
				case 3:{
					//Parse for date/time case
					if (flagUserClock){
    2392:	80 91 c2 01 	lds	r24, 0x01C2
    2396:	88 23       	and	r24, r24
    2398:	09 f4       	brne	.+2      	; 0x239c <_Z11ReceiveGAVRv+0x1b4>
    239a:	25 c2       	rjmp	.+1098   	; 0x27e6 <_Z11ReceiveGAVRv+0x5fe>
						//Go through the string and parse for the time. Must go through the time to get the date.
						BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    239c:	1e 82       	std	Y+6, r1	; 0x06
    239e:	1f 82       	std	Y+7, r1	; 0x07
						int counter=0;
    23a0:	19 86       	std	Y+9, r1	; 0x09
    23a2:	18 86       	std	Y+8, r1	; 0x08
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    23a4:	1a 8e       	std	Y+26, r1	; 0x1a
    23a6:	19 8e       	std	Y+25, r1	; 0x19
    23a8:	1c 8e       	std	Y+28, r1	; 0x1c
    23aa:	1b 8e       	std	Y+27, r1	; 0x1b
    23ac:	1e 8e       	std	Y+30, r1	; 0x1e
    23ae:	1d 8e       	std	Y+29, r1	; 0x1d
    23b0:	18 a2       	lds	r17, 0x98
    23b2:	1f 8e       	std	Y+31, r1	; 0x1f
    23b4:	1a a2       	lds	r17, 0x9a
    23b6:	19 a2       	lds	r17, 0x99
    23b8:	1c a2       	lds	r17, 0x9c
    23ba:	1b a2       	lds	r17, 0x9b
    23bc:	1b 86       	std	Y+11, r1	; 0x0b
    23be:	1a 86       	std	Y+10, r1	; 0x0a
    23c0:	1d 86       	std	Y+13, r1	; 0x0d
    23c2:	1c 86       	std	Y+12, r1	; 0x0c
    23c4:	1f 86       	std	Y+15, r1	; 0x0f
    23c6:	1e 86       	std	Y+14, r1	; 0x0e
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    23c8:	73 c0       	rjmp	.+230    	; 0x24b0 <_Z11ReceiveGAVRv+0x2c8>
							//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
							if (recString[counter]!=':' && hms<3){
    23ca:	9e 01       	movw	r18, r28
    23cc:	26 5d       	subi	r18, 0xD6	; 214
    23ce:	3f 4f       	sbci	r19, 0xFF	; 255
    23d0:	88 85       	ldd	r24, Y+8	; 0x08
    23d2:	99 85       	ldd	r25, Y+9	; 0x09
    23d4:	82 0f       	add	r24, r18
    23d6:	93 1f       	adc	r25, r19
    23d8:	fc 01       	movw	r30, r24
    23da:	80 81       	ld	r24, Z
    23dc:	8a 33       	cpi	r24, 0x3A	; 58
    23de:	e9 f0       	breq	.+58     	; 0x241a <_Z11ReceiveGAVRv+0x232>
    23e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    23e2:	9d 85       	ldd	r25, Y+13	; 0x0d
    23e4:	83 30       	cpi	r24, 0x03	; 3
    23e6:	91 05       	cpc	r25, r1
    23e8:	c4 f4       	brge	.+48     	; 0x241a <_Z11ReceiveGAVRv+0x232>
								tempStringNum[placement++]=recString[counter];
    23ea:	9e 01       	movw	r18, r28
    23ec:	26 5d       	subi	r18, 0xD6	; 214
    23ee:	3f 4f       	sbci	r19, 0xFF	; 255
    23f0:	88 85       	ldd	r24, Y+8	; 0x08
    23f2:	99 85       	ldd	r25, Y+9	; 0x09
    23f4:	82 0f       	add	r24, r18
    23f6:	93 1f       	adc	r25, r19
    23f8:	fc 01       	movw	r30, r24
    23fa:	40 81       	ld	r20, Z
    23fc:	9e 01       	movw	r18, r28
    23fe:	2b 5d       	subi	r18, 0xDB	; 219
    2400:	3f 4f       	sbci	r19, 0xFF	; 255
    2402:	8e 85       	ldd	r24, Y+14	; 0x0e
    2404:	9f 85       	ldd	r25, Y+15	; 0x0f
    2406:	82 0f       	add	r24, r18
    2408:	93 1f       	adc	r25, r19
    240a:	fc 01       	movw	r30, r24
    240c:	40 83       	st	Z, r20
    240e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2410:	9f 85       	ldd	r25, Y+15	; 0x0f
    2412:	01 96       	adiw	r24, 0x01	; 1
    2414:	9f 87       	std	Y+15, r25	; 0x0f
    2416:	8e 87       	std	Y+14, r24	; 0x0e
    2418:	46 c0       	rjmp	.+140    	; 0x24a6 <_Z11ReceiveGAVRv+0x2be>
							//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
							} else if (hms<2 && recString[counter] == ':') {
    241a:	8c 85       	ldd	r24, Y+12	; 0x0c
    241c:	9d 85       	ldd	r25, Y+13	; 0x0d
    241e:	82 30       	cpi	r24, 0x02	; 2
    2420:	91 05       	cpc	r25, r1
    2422:	0c f0       	brlt	.+2      	; 0x2426 <_Z11ReceiveGAVRv+0x23e>
    2424:	40 c0       	rjmp	.+128    	; 0x24a6 <_Z11ReceiveGAVRv+0x2be>
    2426:	9e 01       	movw	r18, r28
    2428:	26 5d       	subi	r18, 0xD6	; 214
    242a:	3f 4f       	sbci	r19, 0xFF	; 255
    242c:	88 85       	ldd	r24, Y+8	; 0x08
    242e:	99 85       	ldd	r25, Y+9	; 0x09
    2430:	82 0f       	add	r24, r18
    2432:	93 1f       	adc	r25, r19
    2434:	fc 01       	movw	r30, r24
    2436:	80 81       	ld	r24, Z
    2438:	8a 33       	cpi	r24, 0x3A	; 58
    243a:	a9 f5       	brne	.+106    	; 0x24a6 <_Z11ReceiveGAVRv+0x2be>
								tempNum[hms++] = atoi(tempStringNum);
    243c:	ce 01       	movw	r24, r28
    243e:	85 96       	adiw	r24, 0x25	; 37
    2440:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
    2444:	9c 01       	movw	r18, r24
    2446:	8c 85       	ldd	r24, Y+12	; 0x0c
    2448:	9d 85       	ldd	r25, Y+13	; 0x0d
    244a:	88 0f       	add	r24, r24
    244c:	99 1f       	adc	r25, r25
    244e:	ae 01       	movw	r20, r28
    2450:	4f 5f       	subi	r20, 0xFF	; 255
    2452:	5f 4f       	sbci	r21, 0xFF	; 255
    2454:	84 0f       	add	r24, r20
    2456:	95 1f       	adc	r25, r21
    2458:	48 96       	adiw	r24, 0x18	; 24
    245a:	fc 01       	movw	r30, r24
    245c:	31 83       	std	Z+1, r19	; 0x01
    245e:	20 83       	st	Z, r18
    2460:	8c 85       	ldd	r24, Y+12	; 0x0c
    2462:	9d 85       	ldd	r25, Y+13	; 0x0d
    2464:	01 96       	adiw	r24, 0x01	; 1
    2466:	9d 87       	std	Y+13, r25	; 0x0d
    2468:	8c 87       	std	Y+12, r24	; 0x0c
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    246a:	19 8a       	std	Y+17, r1	; 0x11
    246c:	18 8a       	std	Y+16, r1	; 0x10
    246e:	0e c0       	rjmp	.+28     	; 0x248c <_Z11ReceiveGAVRv+0x2a4>
    2470:	9e 01       	movw	r18, r28
    2472:	2b 5d       	subi	r18, 0xDB	; 219
    2474:	3f 4f       	sbci	r19, 0xFF	; 255
    2476:	88 89       	ldd	r24, Y+16	; 0x10
    2478:	99 89       	ldd	r25, Y+17	; 0x11
    247a:	82 0f       	add	r24, r18
    247c:	93 1f       	adc	r25, r19
    247e:	fc 01       	movw	r30, r24
    2480:	10 82       	st	Z, r1
    2482:	88 89       	ldd	r24, Y+16	; 0x10
    2484:	99 89       	ldd	r25, Y+17	; 0x11
    2486:	01 96       	adiw	r24, 0x01	; 1
    2488:	99 8b       	std	Y+17, r25	; 0x11
    248a:	88 8b       	std	Y+16, r24	; 0x10
    248c:	41 e0       	ldi	r20, 0x01	; 1
    248e:	28 89       	ldd	r18, Y+16	; 0x10
    2490:	39 89       	ldd	r19, Y+17	; 0x11
    2492:	8e 85       	ldd	r24, Y+14	; 0x0e
    2494:	9f 85       	ldd	r25, Y+15	; 0x0f
    2496:	82 17       	cp	r24, r18
    2498:	93 07       	cpc	r25, r19
    249a:	0c f4       	brge	.+2      	; 0x249e <_Z11ReceiveGAVRv+0x2b6>
    249c:	40 e0       	ldi	r20, 0x00	; 0
    249e:	44 23       	and	r20, r20
    24a0:	39 f7       	brne	.-50     	; 0x2470 <_Z11ReceiveGAVRv+0x288>
								placement=0;												//reset placement
    24a2:	1f 86       	std	Y+15, r1	; 0x0f
    24a4:	1e 86       	std	Y+14, r1	; 0x0e
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
    24a6:	88 85       	ldd	r24, Y+8	; 0x08
    24a8:	99 85       	ldd	r25, Y+9	; 0x09
    24aa:	01 96       	adiw	r24, 0x01	; 1
    24ac:	99 87       	std	Y+9, r25	; 0x09
    24ae:	88 87       	std	Y+8, r24	; 0x08
						int counter=0;
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    24b0:	9e 01       	movw	r18, r28
    24b2:	26 5d       	subi	r18, 0xD6	; 214
    24b4:	3f 4f       	sbci	r19, 0xFF	; 255
    24b6:	88 85       	ldd	r24, Y+8	; 0x08
    24b8:	99 85       	ldd	r25, Y+9	; 0x09
    24ba:	82 0f       	add	r24, r18
    24bc:	93 1f       	adc	r25, r19
    24be:	fc 01       	movw	r30, r24
    24c0:	80 81       	ld	r24, Z
    24c2:	8f 32       	cpi	r24, 0x2F	; 47
    24c4:	69 f0       	breq	.+26     	; 0x24e0 <_Z11ReceiveGAVRv+0x2f8>
    24c6:	9e 01       	movw	r18, r28
    24c8:	26 5d       	subi	r18, 0xD6	; 214
    24ca:	3f 4f       	sbci	r19, 0xFF	; 255
    24cc:	88 85       	ldd	r24, Y+8	; 0x08
    24ce:	99 85       	ldd	r25, Y+9	; 0x09
    24d0:	82 0f       	add	r24, r18
    24d2:	93 1f       	adc	r25, r19
    24d4:	fc 01       	movw	r30, r24
    24d6:	80 81       	ld	r24, Z
    24d8:	88 23       	and	r24, r24
    24da:	11 f0       	breq	.+4      	; 0x24e0 <_Z11ReceiveGAVRv+0x2f8>
    24dc:	81 e0       	ldi	r24, 0x01	; 1
    24de:	01 c0       	rjmp	.+2      	; 0x24e2 <_Z11ReceiveGAVRv+0x2fa>
    24e0:	80 e0       	ldi	r24, 0x00	; 0
    24e2:	88 23       	and	r24, r24
    24e4:	09 f0       	breq	.+2      	; 0x24e8 <_Z11ReceiveGAVRv+0x300>
    24e6:	71 cf       	rjmp	.-286    	; 0x23ca <_Z11ReceiveGAVRv+0x1e2>
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
						}//end while
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
    24e8:	9e 01       	movw	r18, r28
    24ea:	26 5d       	subi	r18, 0xD6	; 214
    24ec:	3f 4f       	sbci	r19, 0xFF	; 255
    24ee:	88 85       	ldd	r24, Y+8	; 0x08
    24f0:	99 85       	ldd	r25, Y+9	; 0x09
    24f2:	82 0f       	add	r24, r18
    24f4:	93 1f       	adc	r25, r19
    24f6:	fc 01       	movw	r30, r24
    24f8:	80 81       	ld	r24, Z
    24fa:	8f 32       	cpi	r24, 0x2F	; 47
    24fc:	a9 f4       	brne	.+42     	; 0x2528 <_Z11ReceiveGAVRv+0x340>
							tempNum[hms] = atoi(tempStringNum);
    24fe:	ce 01       	movw	r24, r28
    2500:	85 96       	adiw	r24, 0x25	; 37
    2502:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
    2506:	9c 01       	movw	r18, r24
    2508:	8c 85       	ldd	r24, Y+12	; 0x0c
    250a:	9d 85       	ldd	r25, Y+13	; 0x0d
    250c:	88 0f       	add	r24, r24
    250e:	99 1f       	adc	r25, r25
    2510:	ae 01       	movw	r20, r28
    2512:	4f 5f       	subi	r20, 0xFF	; 255
    2514:	5f 4f       	sbci	r21, 0xFF	; 255
    2516:	84 0f       	add	r24, r20
    2518:	95 1f       	adc	r25, r21
    251a:	48 96       	adiw	r24, 0x18	; 24
    251c:	fc 01       	movw	r30, r24
    251e:	31 83       	std	Z+1, r19	; 0x01
    2520:	20 83       	st	Z, r18
							successTime=fTrue;
    2522:	81 e0       	ldi	r24, 0x01	; 1
    2524:	8e 83       	std	Y+6, r24	; 0x06
    2526:	08 c0       	rjmp	.+16     	; 0x2538 <_Z11ReceiveGAVRv+0x350>
						} else {
							state=5;
    2528:	85 e0       	ldi	r24, 0x05	; 5
    252a:	90 e0       	ldi	r25, 0x00	; 0
    252c:	9a 83       	std	Y+2, r25	; 0x02
    252e:	89 83       	std	Y+1, r24	; 0x01
							PrintGAVR("ACKBAD.");
    2530:	8d e0       	ldi	r24, 0x0D	; 13
    2532:	91 e0       	ldi	r25, 0x01	; 1
    2534:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    2538:	1b 8a       	std	Y+19, r1	; 0x13
    253a:	1a 8a       	std	Y+18, r1	; 0x12
    253c:	0e c0       	rjmp	.+28     	; 0x255a <_Z11ReceiveGAVRv+0x372>
    253e:	9e 01       	movw	r18, r28
    2540:	2b 5d       	subi	r18, 0xDB	; 219
    2542:	3f 4f       	sbci	r19, 0xFF	; 255
    2544:	8a 89       	ldd	r24, Y+18	; 0x12
    2546:	9b 89       	ldd	r25, Y+19	; 0x13
    2548:	82 0f       	add	r24, r18
    254a:	93 1f       	adc	r25, r19
    254c:	fc 01       	movw	r30, r24
    254e:	10 82       	st	Z, r1
    2550:	8a 89       	ldd	r24, Y+18	; 0x12
    2552:	9b 89       	ldd	r25, Y+19	; 0x13
    2554:	01 96       	adiw	r24, 0x01	; 1
    2556:	9b 8b       	std	Y+19, r25	; 0x13
    2558:	8a 8b       	std	Y+18, r24	; 0x12
    255a:	41 e0       	ldi	r20, 0x01	; 1
    255c:	2a 89       	ldd	r18, Y+18	; 0x12
    255e:	3b 89       	ldd	r19, Y+19	; 0x13
    2560:	8e 85       	ldd	r24, Y+14	; 0x0e
    2562:	9f 85       	ldd	r25, Y+15	; 0x0f
    2564:	82 17       	cp	r24, r18
    2566:	93 07       	cpc	r25, r19
    2568:	0c f4       	brge	.+2      	; 0x256c <_Z11ReceiveGAVRv+0x384>
    256a:	40 e0       	ldi	r20, 0x00	; 0
    256c:	44 23       	and	r20, r20
    256e:	39 f7       	brne	.-50     	; 0x253e <_Z11ReceiveGAVRv+0x356>
						placement=0;
    2570:	1f 86       	std	Y+15, r1	; 0x0f
    2572:	1e 86       	std	Y+14, r1	; 0x0e
						counter++;	//get past the '/'
    2574:	88 85       	ldd	r24, Y+8	; 0x08
    2576:	99 85       	ldd	r25, Y+9	; 0x09
    2578:	01 96       	adiw	r24, 0x01	; 1
    257a:	99 87       	std	Y+9, r25	; 0x09
    257c:	88 87       	std	Y+8, r24	; 0x08
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    257e:	73 c0       	rjmp	.+230    	; 0x2666 <_Z11ReceiveGAVRv+0x47e>
							//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
							if  (recString[counter] != ',' && dmy < 3){
    2580:	9e 01       	movw	r18, r28
    2582:	26 5d       	subi	r18, 0xD6	; 214
    2584:	3f 4f       	sbci	r19, 0xFF	; 255
    2586:	88 85       	ldd	r24, Y+8	; 0x08
    2588:	99 85       	ldd	r25, Y+9	; 0x09
    258a:	82 0f       	add	r24, r18
    258c:	93 1f       	adc	r25, r19
    258e:	fc 01       	movw	r30, r24
    2590:	80 81       	ld	r24, Z
    2592:	8c 32       	cpi	r24, 0x2C	; 44
    2594:	e9 f0       	breq	.+58     	; 0x25d0 <_Z11ReceiveGAVRv+0x3e8>
    2596:	8a 85       	ldd	r24, Y+10	; 0x0a
    2598:	9b 85       	ldd	r25, Y+11	; 0x0b
    259a:	83 30       	cpi	r24, 0x03	; 3
    259c:	91 05       	cpc	r25, r1
    259e:	c4 f4       	brge	.+48     	; 0x25d0 <_Z11ReceiveGAVRv+0x3e8>
								tempStringNum[placement++]=recString[counter];
    25a0:	9e 01       	movw	r18, r28
    25a2:	26 5d       	subi	r18, 0xD6	; 214
    25a4:	3f 4f       	sbci	r19, 0xFF	; 255
    25a6:	88 85       	ldd	r24, Y+8	; 0x08
    25a8:	99 85       	ldd	r25, Y+9	; 0x09
    25aa:	82 0f       	add	r24, r18
    25ac:	93 1f       	adc	r25, r19
    25ae:	fc 01       	movw	r30, r24
    25b0:	40 81       	ld	r20, Z
    25b2:	9e 01       	movw	r18, r28
    25b4:	2b 5d       	subi	r18, 0xDB	; 219
    25b6:	3f 4f       	sbci	r19, 0xFF	; 255
    25b8:	8e 85       	ldd	r24, Y+14	; 0x0e
    25ba:	9f 85       	ldd	r25, Y+15	; 0x0f
    25bc:	82 0f       	add	r24, r18
    25be:	93 1f       	adc	r25, r19
    25c0:	fc 01       	movw	r30, r24
    25c2:	40 83       	st	Z, r20
    25c4:	8e 85       	ldd	r24, Y+14	; 0x0e
    25c6:	9f 85       	ldd	r25, Y+15	; 0x0f
    25c8:	01 96       	adiw	r24, 0x01	; 1
    25ca:	9f 87       	std	Y+15, r25	; 0x0f
    25cc:	8e 87       	std	Y+14, r24	; 0x0e
    25ce:	46 c0       	rjmp	.+140    	; 0x265c <_Z11ReceiveGAVRv+0x474>
							//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
							} else if (dmy<2 && recString[counter]==','){
    25d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    25d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    25d4:	82 30       	cpi	r24, 0x02	; 2
    25d6:	91 05       	cpc	r25, r1
    25d8:	0c f0       	brlt	.+2      	; 0x25dc <_Z11ReceiveGAVRv+0x3f4>
    25da:	40 c0       	rjmp	.+128    	; 0x265c <_Z11ReceiveGAVRv+0x474>
    25dc:	9e 01       	movw	r18, r28
    25de:	26 5d       	subi	r18, 0xD6	; 214
    25e0:	3f 4f       	sbci	r19, 0xFF	; 255
    25e2:	88 85       	ldd	r24, Y+8	; 0x08
    25e4:	99 85       	ldd	r25, Y+9	; 0x09
    25e6:	82 0f       	add	r24, r18
    25e8:	93 1f       	adc	r25, r19
    25ea:	fc 01       	movw	r30, r24
    25ec:	80 81       	ld	r24, Z
    25ee:	8c 32       	cpi	r24, 0x2C	; 44
    25f0:	a9 f5       	brne	.+106    	; 0x265c <_Z11ReceiveGAVRv+0x474>
								tempNum1[dmy++] = atoi(tempStringNum);
    25f2:	ce 01       	movw	r24, r28
    25f4:	85 96       	adiw	r24, 0x25	; 37
    25f6:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
    25fa:	9c 01       	movw	r18, r24
    25fc:	8a 85       	ldd	r24, Y+10	; 0x0a
    25fe:	9b 85       	ldd	r25, Y+11	; 0x0b
    2600:	88 0f       	add	r24, r24
    2602:	99 1f       	adc	r25, r25
    2604:	ae 01       	movw	r20, r28
    2606:	4f 5f       	subi	r20, 0xFF	; 255
    2608:	5f 4f       	sbci	r21, 0xFF	; 255
    260a:	84 0f       	add	r24, r20
    260c:	95 1f       	adc	r25, r21
    260e:	4e 96       	adiw	r24, 0x1e	; 30
    2610:	fc 01       	movw	r30, r24
    2612:	31 83       	std	Z+1, r19	; 0x01
    2614:	20 83       	st	Z, r18
    2616:	8a 85       	ldd	r24, Y+10	; 0x0a
    2618:	9b 85       	ldd	r25, Y+11	; 0x0b
    261a:	01 96       	adiw	r24, 0x01	; 1
    261c:	9b 87       	std	Y+11, r25	; 0x0b
    261e:	8a 87       	std	Y+10, r24	; 0x0a
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    2620:	1d 8a       	std	Y+21, r1	; 0x15
    2622:	1c 8a       	std	Y+20, r1	; 0x14
    2624:	0e c0       	rjmp	.+28     	; 0x2642 <_Z11ReceiveGAVRv+0x45a>
    2626:	9e 01       	movw	r18, r28
    2628:	2b 5d       	subi	r18, 0xDB	; 219
    262a:	3f 4f       	sbci	r19, 0xFF	; 255
    262c:	8c 89       	ldd	r24, Y+20	; 0x14
    262e:	9d 89       	ldd	r25, Y+21	; 0x15
    2630:	82 0f       	add	r24, r18
    2632:	93 1f       	adc	r25, r19
    2634:	fc 01       	movw	r30, r24
    2636:	10 82       	st	Z, r1
    2638:	8c 89       	ldd	r24, Y+20	; 0x14
    263a:	9d 89       	ldd	r25, Y+21	; 0x15
    263c:	01 96       	adiw	r24, 0x01	; 1
    263e:	9d 8b       	std	Y+21, r25	; 0x15
    2640:	8c 8b       	std	Y+20, r24	; 0x14
    2642:	41 e0       	ldi	r20, 0x01	; 1
    2644:	2c 89       	ldd	r18, Y+20	; 0x14
    2646:	3d 89       	ldd	r19, Y+21	; 0x15
    2648:	8e 85       	ldd	r24, Y+14	; 0x0e
    264a:	9f 85       	ldd	r25, Y+15	; 0x0f
    264c:	82 17       	cp	r24, r18
    264e:	93 07       	cpc	r25, r19
    2650:	0c f4       	brge	.+2      	; 0x2654 <_Z11ReceiveGAVRv+0x46c>
    2652:	40 e0       	ldi	r20, 0x00	; 0
    2654:	44 23       	and	r20, r20
    2656:	39 f7       	brne	.-50     	; 0x2626 <_Z11ReceiveGAVRv+0x43e>
								placement=0;
    2658:	1f 86       	std	Y+15, r1	; 0x0f
    265a:	1e 86       	std	Y+14, r1	; 0x0e
							} else;
							counter++;							
    265c:	88 85       	ldd	r24, Y+8	; 0x08
    265e:	99 85       	ldd	r25, Y+9	; 0x09
    2660:	01 96       	adiw	r24, 0x01	; 1
    2662:	99 87       	std	Y+9, r25	; 0x09
    2664:	88 87       	std	Y+8, r24	; 0x08
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
						placement=0;
						counter++;	//get past the '/'
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    2666:	9e 01       	movw	r18, r28
    2668:	26 5d       	subi	r18, 0xD6	; 214
    266a:	3f 4f       	sbci	r19, 0xFF	; 255
    266c:	88 85       	ldd	r24, Y+8	; 0x08
    266e:	99 85       	ldd	r25, Y+9	; 0x09
    2670:	82 0f       	add	r24, r18
    2672:	93 1f       	adc	r25, r19
    2674:	fc 01       	movw	r30, r24
    2676:	80 81       	ld	r24, Z
    2678:	8e 32       	cpi	r24, 0x2E	; 46
    267a:	a1 f0       	breq	.+40     	; 0x26a4 <_Z11ReceiveGAVRv+0x4bc>
    267c:	9e 01       	movw	r18, r28
    267e:	26 5d       	subi	r18, 0xD6	; 214
    2680:	3f 4f       	sbci	r19, 0xFF	; 255
    2682:	88 85       	ldd	r24, Y+8	; 0x08
    2684:	99 85       	ldd	r25, Y+9	; 0x09
    2686:	82 0f       	add	r24, r18
    2688:	93 1f       	adc	r25, r19
    268a:	fc 01       	movw	r30, r24
    268c:	80 81       	ld	r24, Z
    268e:	88 23       	and	r24, r24
    2690:	49 f0       	breq	.+18     	; 0x26a4 <_Z11ReceiveGAVRv+0x4bc>
    2692:	28 85       	ldd	r18, Y+8	; 0x08
    2694:	39 85       	ldd	r19, Y+9	; 0x09
    2696:	8b 81       	ldd	r24, Y+3	; 0x03
    2698:	9c 81       	ldd	r25, Y+4	; 0x04
    269a:	28 17       	cp	r18, r24
    269c:	39 07       	cpc	r19, r25
    269e:	11 f0       	breq	.+4      	; 0x26a4 <_Z11ReceiveGAVRv+0x4bc>
    26a0:	81 e0       	ldi	r24, 0x01	; 1
    26a2:	01 c0       	rjmp	.+2      	; 0x26a6 <_Z11ReceiveGAVRv+0x4be>
    26a4:	80 e0       	ldi	r24, 0x00	; 0
    26a6:	88 23       	and	r24, r24
    26a8:	09 f0       	breq	.+2      	; 0x26ac <_Z11ReceiveGAVRv+0x4c4>
    26aa:	6a cf       	rjmp	.-300    	; 0x2580 <_Z11ReceiveGAVRv+0x398>
								placement=0;
							} else;
							counter++;							
						}//end while
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
    26ac:	9e 01       	movw	r18, r28
    26ae:	26 5d       	subi	r18, 0xD6	; 214
    26b0:	3f 4f       	sbci	r19, 0xFF	; 255
    26b2:	88 85       	ldd	r24, Y+8	; 0x08
    26b4:	99 85       	ldd	r25, Y+9	; 0x09
    26b6:	82 0f       	add	r24, r18
    26b8:	93 1f       	adc	r25, r19
    26ba:	fc 01       	movw	r30, r24
    26bc:	80 81       	ld	r24, Z
    26be:	8e 32       	cpi	r24, 0x2E	; 46
    26c0:	a9 f4       	brne	.+42     	; 0x26ec <_Z11ReceiveGAVRv+0x504>
							tempNum1[dmy] = atoi(tempStringNum);
    26c2:	ce 01       	movw	r24, r28
    26c4:	85 96       	adiw	r24, 0x25	; 37
    26c6:	0e 94 cf 1e 	call	0x3d9e	; 0x3d9e <atoi>
    26ca:	9c 01       	movw	r18, r24
    26cc:	8a 85       	ldd	r24, Y+10	; 0x0a
    26ce:	9b 85       	ldd	r25, Y+11	; 0x0b
    26d0:	88 0f       	add	r24, r24
    26d2:	99 1f       	adc	r25, r25
    26d4:	ae 01       	movw	r20, r28
    26d6:	4f 5f       	subi	r20, 0xFF	; 255
    26d8:	5f 4f       	sbci	r21, 0xFF	; 255
    26da:	84 0f       	add	r24, r20
    26dc:	95 1f       	adc	r25, r21
    26de:	4e 96       	adiw	r24, 0x1e	; 30
    26e0:	fc 01       	movw	r30, r24
    26e2:	31 83       	std	Z+1, r19	; 0x01
    26e4:	20 83       	st	Z, r18
							successDate=fTrue;
    26e6:	81 e0       	ldi	r24, 0x01	; 1
    26e8:	8f 83       	std	Y+7, r24	; 0x07
    26ea:	08 c0       	rjmp	.+16     	; 0x26fc <_Z11ReceiveGAVRv+0x514>
						} else {//something in the string was wrong, ACKBAD and then exit
							PrintGAVR("ACKBAD.");
    26ec:	8d e0       	ldi	r24, 0x0D	; 13
    26ee:	91 e0       	ldi	r25, 0x01	; 1
    26f0:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
							state=5;
    26f4:	85 e0       	ldi	r24, 0x05	; 5
    26f6:	90 e0       	ldi	r25, 0x00	; 0
    26f8:	9a 83       	std	Y+2, r25	; 0x02
    26fa:	89 83       	std	Y+1, r24	; 0x01
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0 && successTime){
    26fc:	89 8d       	ldd	r24, Y+25	; 0x19
    26fe:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2700:	47 96       	adiw	r24, 0x17	; 23
    2702:	8f 32       	cpi	r24, 0x2F	; 47
    2704:	91 05       	cpc	r25, r1
    2706:	f0 f4       	brcc	.+60     	; 0x2744 <_Z11ReceiveGAVRv+0x55c>
    2708:	8b 8d       	ldd	r24, Y+27	; 0x1b
    270a:	9c 8d       	ldd	r25, Y+28	; 0x1c
    270c:	cb 96       	adiw	r24, 0x3b	; 59
    270e:	87 37       	cpi	r24, 0x77	; 119
    2710:	91 05       	cpc	r25, r1
    2712:	c0 f4       	brcc	.+48     	; 0x2744 <_Z11ReceiveGAVRv+0x55c>
    2714:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2716:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2718:	cb 96       	adiw	r24, 0x3b	; 59
    271a:	87 37       	cpi	r24, 0x77	; 119
    271c:	91 05       	cpc	r25, r1
    271e:	90 f4       	brcc	.+36     	; 0x2744 <_Z11ReceiveGAVRv+0x55c>
    2720:	8e 81       	ldd	r24, Y+6	; 0x06
    2722:	88 23       	and	r24, r24
    2724:	79 f0       	breq	.+30     	; 0x2744 <_Z11ReceiveGAVRv+0x55c>
							currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    2726:	69 8d       	ldd	r22, Y+25	; 0x19
    2728:	7a 8d       	ldd	r23, Y+26	; 0x1a
    272a:	4b 8d       	ldd	r20, Y+27	; 0x1b
    272c:	5c 8d       	ldd	r21, Y+28	; 0x1c
    272e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2730:	3e 8d       	ldd	r19, Y+30	; 0x1e
    2732:	82 e9       	ldi	r24, 0x92	; 146
    2734:	91 e0       	ldi	r25, 0x01	; 1
    2736:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
							saveDateTime_eeprom(fTrue,fFalse);
    273a:	81 e0       	ldi	r24, 0x01	; 1
    273c:	60 e0       	ldi	r22, 0x00	; 0
    273e:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    2742:	08 c0       	rjmp	.+16     	; 0x2754 <_Z11ReceiveGAVRv+0x56c>
						} else {
							PrintGAVR("ACKBAD.");
    2744:	8d e0       	ldi	r24, 0x0D	; 13
    2746:	91 e0       	ldi	r25, 0x01	; 1
    2748:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
							state=5;
    274c:	85 e0       	ldi	r24, 0x05	; 5
    274e:	90 e0       	ldi	r25, 0x00	; 0
    2750:	9a 83       	std	Y+2, r25	; 0x02
    2752:	89 83       	std	Y+1, r24	; 0x01
						}//end if-else time
						
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && successDate){
    2754:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2756:	98 a1       	lds	r25, 0x48
    2758:	0c 96       	adiw	r24, 0x0c	; 12
    275a:	89 31       	cpi	r24, 0x19	; 25
    275c:	91 05       	cpc	r25, r1
    275e:	10 f5       	brcc	.+68     	; 0x27a4 <_Z11ReceiveGAVRv+0x5bc>
    2760:	89 a1       	lds	r24, 0x49
    2762:	9a a1       	lds	r25, 0x4a
    2764:	4f 96       	adiw	r24, 0x1f	; 31
    2766:	8f 33       	cpi	r24, 0x3F	; 63
    2768:	91 05       	cpc	r25, r1
    276a:	e0 f4       	brcc	.+56     	; 0x27a4 <_Z11ReceiveGAVRv+0x5bc>
    276c:	8b a1       	lds	r24, 0x4b
    276e:	9c a1       	lds	r25, 0x4c
    2770:	f7 e0       	ldi	r31, 0x07	; 7
    2772:	80 3d       	cpi	r24, 0xD0	; 208
    2774:	9f 07       	cpc	r25, r31
    2776:	b4 f0       	brlt	.+44     	; 0x27a4 <_Z11ReceiveGAVRv+0x5bc>
    2778:	8f 81       	ldd	r24, Y+7	; 0x07
    277a:	88 23       	and	r24, r24
    277c:	99 f0       	breq	.+38     	; 0x27a4 <_Z11ReceiveGAVRv+0x5bc>
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
    277e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2780:	78 a1       	lds	r23, 0x48
    2782:	49 a1       	lds	r20, 0x49
    2784:	5a a1       	lds	r21, 0x4a
    2786:	2b a1       	lds	r18, 0x4b
    2788:	3c a1       	lds	r19, 0x4c
    278a:	82 e9       	ldi	r24, 0x92	; 146
    278c:	91 e0       	ldi	r25, 0x01	; 1
    278e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
							saveDateTime_eeprom(fFalse,fTrue);
    2792:	80 e0       	ldi	r24, 0x00	; 0
    2794:	61 e0       	ldi	r22, 0x01	; 1
    2796:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
							state=5;
							break;
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    279a:	80 91 c2 01 	lds	r24, 0x01C2
    279e:	88 23       	and	r24, r24
    27a0:	51 f4       	brne	.+20     	; 0x27b6 <_Z11ReceiveGAVRv+0x5ce>
    27a2:	18 c0       	rjmp	.+48     	; 0x27d4 <_Z11ReceiveGAVRv+0x5ec>
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && successDate){
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
							saveDateTime_eeprom(fFalse,fTrue);
						} else {
							PrintGAVR("ACKBAD.");
    27a4:	8d e0       	ldi	r24, 0x0D	; 13
    27a6:	91 e0       	ldi	r25, 0x01	; 1
    27a8:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
							state=5;
    27ac:	85 e0       	ldi	r24, 0x05	; 5
    27ae:	90 e0       	ldi	r25, 0x00	; 0
    27b0:	9a 83       	std	Y+2, r25	; 0x02
    27b2:	89 83       	std	Y+1, r24	; 0x01
							break;
    27b4:	76 c0       	rjmp	.+236    	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    27b6:	8f 81       	ldd	r24, Y+7	; 0x07
    27b8:	88 23       	and	r24, r24
    27ba:	61 f0       	breq	.+24     	; 0x27d4 <_Z11ReceiveGAVRv+0x5ec>
    27bc:	8e 81       	ldd	r24, Y+6	; 0x06
    27be:	88 23       	and	r24, r24
    27c0:	49 f0       	breq	.+18     	; 0x27d4 <_Z11ReceiveGAVRv+0x5ec>
							flagUserClock=fFalse;
    27c2:	10 92 c2 01 	sts	0x01C2, r1
							flagWaitingForReceiveGAVR=fFalse;
    27c6:	10 92 bd 01 	sts	0x01BD, r1
							state=7;					//Respond with correct string ACK
    27ca:	87 e0       	ldi	r24, 0x07	; 7
    27cc:	90 e0       	ldi	r25, 0x00	; 0
    27ce:	9a 83       	std	Y+2, r25	; 0x02
    27d0:	89 83       	std	Y+1, r24	; 0x01
						PrintGAVR("ACKNO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    27d2:	67 c0       	rjmp	.+206    	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
						if (flagUserClock && successDate && successTime){
							flagUserClock=fFalse;
							flagWaitingForReceiveGAVR=fFalse;
							state=7;					//Respond with correct string ACK
						} else {
							PrintGAVR("ACKBAD.");
    27d4:	8d e0       	ldi	r24, 0x0D	; 13
    27d6:	91 e0       	ldi	r25, 0x01	; 1
    27d8:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
							state=5;
    27dc:	85 e0       	ldi	r24, 0x05	; 5
    27de:	90 e0       	ldi	r25, 0x00	; 0
    27e0:	9a 83       	std	Y+2, r25	; 0x02
    27e2:	89 83       	std	Y+1, r24	; 0x01
						PrintGAVR("ACKNO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    27e4:	5e c0       	rjmp	.+188    	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
						} else {
							PrintGAVR("ACKBAD.");
							state=5;
						}																										
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("ACKNO.");
    27e6:	81 e7       	ldi	r24, 0x71	; 113
    27e8:	91 e0       	ldi	r25, 0x01	; 1
    27ea:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
						state=5;
    27ee:	85 e0       	ldi	r24, 0x05	; 5
    27f0:	90 e0       	ldi	r25, 0x00	; 0
    27f2:	9a 83       	std	Y+2, r25	; 0x02
    27f4:	89 83       	std	Y+1, r24	; 0x01
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    27f6:	55 c0       	rjmp	.+170    	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
					}//end case 3				
				case 4:{
					//Successful SYNNEED case.
					if (!flagUserClock){	//If we don't need the date or time, update with what we have.
    27f8:	80 91 c2 01 	lds	r24, 0x01C2
    27fc:	88 23       	and	r24, r24
    27fe:	41 f4       	brne	.+16     	; 0x2810 <_Z11ReceiveGAVRv+0x628>
						flagUpdateGAVRClock=fTrue;
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	80 93 c0 01 	sts	0x01C0, r24
						PrintGAVR("ACKNEED.");				//respond with correct ack
    2806:	88 e7       	ldi	r24, 0x78	; 120
    2808:	91 e0       	ldi	r25, 0x01	; 1
    280a:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
    280e:	04 c0       	rjmp	.+8      	; 0x2818 <_Z11ReceiveGAVRv+0x630>
					} else {
						PrintGAVR("ACKNO.");	//say we can't give you anything, ask the user.
    2810:	81 e7       	ldi	r24, 0x71	; 113
    2812:	91 e0       	ldi	r25, 0x01	; 1
    2814:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
						//Should be expecting something from the GAVR with user date and time, this reminds the GAVR.
					} //end if-else
					state=5;
    2818:	85 e0       	ldi	r24, 0x05	; 5
    281a:	90 e0       	ldi	r25, 0x00	; 0
    281c:	9a 83       	std	Y+2, r25	; 0x02
    281e:	89 83       	std	Y+1, r24	; 0x01
					break;					
    2820:	40 c0       	rjmp	.+128    	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				}//end case 4
				case 5:{
					//Exit case
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    2822:	1f 8a       	std	Y+23, r1	; 0x17
    2824:	1e 8a       	std	Y+22, r1	; 0x16
    2826:	0e c0       	rjmp	.+28     	; 0x2844 <_Z11ReceiveGAVRv+0x65c>
    2828:	9e 01       	movw	r18, r28
    282a:	26 5d       	subi	r18, 0xD6	; 214
    282c:	3f 4f       	sbci	r19, 0xFF	; 255
    282e:	8e 89       	ldd	r24, Y+22	; 0x16
    2830:	9f 89       	ldd	r25, Y+23	; 0x17
    2832:	82 0f       	add	r24, r18
    2834:	93 1f       	adc	r25, r19
    2836:	fc 01       	movw	r30, r24
    2838:	10 82       	st	Z, r1
    283a:	8e 89       	ldd	r24, Y+22	; 0x16
    283c:	9f 89       	ldd	r25, Y+23	; 0x17
    283e:	01 96       	adiw	r24, 0x01	; 1
    2840:	9f 8b       	std	Y+23, r25	; 0x17
    2842:	8e 8b       	std	Y+22, r24	; 0x16
    2844:	2e 89       	ldd	r18, Y+22	; 0x16
    2846:	3f 89       	ldd	r19, Y+23	; 0x17
    2848:	41 e0       	ldi	r20, 0x01	; 1
    284a:	8b 81       	ldd	r24, Y+3	; 0x03
    284c:	9c 81       	ldd	r25, Y+4	; 0x04
    284e:	28 17       	cp	r18, r24
    2850:	39 07       	cpc	r19, r25
    2852:	08 f0       	brcs	.+2      	; 0x2856 <_Z11ReceiveGAVRv+0x66e>
    2854:	40 e0       	ldi	r20, 0x00	; 0
    2856:	44 23       	and	r20, r20
    2858:	39 f7       	brne	.-50     	; 0x2828 <_Z11ReceiveGAVRv+0x640>
					flagReceivingGAVR=fFalse;
    285a:	10 92 bc 01 	sts	0x01BC, r1
					state=0;		//just in case
    285e:	1a 82       	std	Y+2, r1	; 0x02
    2860:	19 82       	std	Y+1, r1	; 0x01
					break;
    2862:	1f c0       	rjmp	.+62     	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				}//end case 5
				case 6:{
					//Error in ACK case
					PrintGAVR("ACKERROR.");
    2864:	8e e5       	ldi	r24, 0x5E	; 94
    2866:	91 e0       	ldi	r25, 0x01	; 1
    2868:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
					state=5;
    286c:	85 e0       	ldi	r24, 0x05	; 5
    286e:	90 e0       	ldi	r25, 0x00	; 0
    2870:	9a 83       	std	Y+2, r25	; 0x02
    2872:	89 83       	std	Y+1, r24	; 0x01
					break;
    2874:	16 c0       	rjmp	.+44     	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				}//end case 6
				case 7:{
					//Successful grab of date/time case
					recString[0]='A';
    2876:	81 e4       	ldi	r24, 0x41	; 65
    2878:	8a a7       	lds	r24, 0x7a
					recString[1]='C';
    287a:	83 e4       	ldi	r24, 0x43	; 67
    287c:	8b a7       	lds	r24, 0x7b
					recString[2]='K';
    287e:	8b e4       	ldi	r24, 0x4B	; 75
    2880:	8c a7       	lds	r24, 0x7c
					PrintGAVR(recString);
    2882:	ce 01       	movw	r24, r28
    2884:	8a 96       	adiw	r24, 0x2a	; 42
    2886:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
					state=5;
    288a:	85 e0       	ldi	r24, 0x05	; 5
    288c:	90 e0       	ldi	r25, 0x00	; 0
    288e:	9a 83       	std	Y+2, r25	; 0x02
    2890:	89 83       	std	Y+1, r24	; 0x01
					break;		
    2892:	07 c0       	rjmp	.+14     	; 0x28a2 <_Z11ReceiveGAVRv+0x6ba>
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
    2894:	1a 82       	std	Y+2, r1	; 0x02
    2896:	19 82       	std	Y+1, r1	; 0x01
    2898:	1c 82       	std	Y+4, r1	; 0x04
    289a:	1b 82       	std	Y+3, r1	; 0x03
    289c:	10 92 bc 01 	sts	0x01BC, r1
    28a0:	00 00       	nop
	char recChar, recString[40];
	unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	//While Loop
	while (flagReceivingGAVR){
    28a2:	90 91 bc 01 	lds	r25, 0x01BC
    28a6:	81 e0       	ldi	r24, 0x01	; 1
    28a8:	99 23       	and	r25, r25
    28aa:	09 f4       	brne	.+2      	; 0x28ae <_Z11ReceiveGAVRv+0x6c6>
    28ac:	80 e0       	ldi	r24, 0x00	; 0
    28ae:	88 23       	and	r24, r24
    28b0:	09 f0       	breq	.+2      	; 0x28b4 <_Z11ReceiveGAVRv+0x6cc>
    28b2:	ac cc       	rjmp	.-1704   	; 0x220c <_Z11ReceiveGAVRv+0x24>
					break;		
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
			}//end switch	
		}//end while flagReceivingGAVR	
}
    28b4:	cf 5a       	subi	r28, 0xAF	; 175
    28b6:	df 4f       	sbci	r29, 0xFF	; 255
    28b8:	0f b6       	in	r0, 0x3f	; 63
    28ba:	f8 94       	cli
    28bc:	de bf       	out	0x3e, r29	; 62
    28be:	0f be       	out	0x3f, r0	; 63
    28c0:	cd bf       	out	0x3d, r28	; 61
    28c2:	df 91       	pop	r29
    28c4:	cf 91       	pop	r28
    28c6:	08 95       	ret

000028c8 <_Z13printTimeDatehhh>:
/*************************************************************************************************************/
//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    28c8:	cf 93       	push	r28
    28ca:	df 93       	push	r29
    28cc:	cd b7       	in	r28, 0x3d	; 61
    28ce:	de b7       	in	r29, 0x3e	; 62
    28d0:	eb 97       	sbiw	r28, 0x3b	; 59
    28d2:	0f b6       	in	r0, 0x3f	; 63
    28d4:	f8 94       	cli
    28d6:	de bf       	out	0x3e, r29	; 62
    28d8:	0f be       	out	0x3f, r0	; 63
    28da:	cd bf       	out	0x3d, r28	; 61
    28dc:	89 af       	sts	0x79, r24
    28de:	6a af       	sts	0x7a, r22
    28e0:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    28e2:	89 ad       	sts	0x69, r24
    28e4:	88 23       	and	r24, r24
    28e6:	49 f1       	breq	.+82     	; 0x293a <_Z13printTimeDatehhh+0x72>
		if (pTime){
    28e8:	8a ad       	sts	0x6a, r24
    28ea:	88 23       	and	r24, r24
    28ec:	89 f0       	breq	.+34     	; 0x2910 <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    28ee:	82 e9       	ldi	r24, 0x92	; 146
    28f0:	91 e0       	ldi	r25, 0x01	; 1
    28f2:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    28f6:	9c 01       	movw	r18, r24
    28f8:	ce 01       	movw	r24, r28
    28fa:	01 96       	adiw	r24, 0x01	; 1
    28fc:	b9 01       	movw	r22, r18
    28fe:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <strcpy>
			PrintBone(tempTime);
    2902:	ce 01       	movw	r24, r28
    2904:	01 96       	adiw	r24, 0x01	; 1
    2906:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
			PutUartChBone('/');
    290a:	8f e2       	ldi	r24, 0x2F	; 47
    290c:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z13PutUartChBonec>
		}
		if (pDate){
    2910:	8b ad       	sts	0x6b, r24
    2912:	88 23       	and	r24, r24
    2914:	d1 f1       	breq	.+116    	; 0x298a <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    2916:	82 e9       	ldi	r24, 0x92	; 146
    2918:	91 e0       	ldi	r25, 0x01	; 1
    291a:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    291e:	9c 01       	movw	r18, r24
    2920:	ce 01       	movw	r24, r28
    2922:	0c 96       	adiw	r24, 0x0c	; 12
    2924:	b9 01       	movw	r22, r18
    2926:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <strcpy>
			PrintBone(tempDate);
    292a:	ce 01       	movw	r24, r28
    292c:	0c 96       	adiw	r24, 0x0c	; 12
    292e:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
			PutUartChGAVR('.');
    2932:	8e e2       	ldi	r24, 0x2E	; 46
    2934:	0e 94 73 09 	call	0x12e6	; 0x12e6 <_Z13PutUartChGAVRc>
    2938:	28 c0       	rjmp	.+80     	; 0x298a <_Z13printTimeDatehhh+0xc2>
		}
	} else { //Printing to GAVR
		if (pTime){
    293a:	8a ad       	sts	0x6a, r24
    293c:	88 23       	and	r24, r24
    293e:	89 f0       	breq	.+34     	; 0x2962 <_Z13printTimeDatehhh+0x9a>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    2940:	82 e9       	ldi	r24, 0x92	; 146
    2942:	91 e0       	ldi	r25, 0x01	; 1
    2944:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    2948:	9c 01       	movw	r18, r24
    294a:	ce 01       	movw	r24, r28
    294c:	4d 96       	adiw	r24, 0x1d	; 29
    294e:	b9 01       	movw	r22, r18
    2950:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <strcpy>
			PrintGAVR(tempTime);
    2954:	ce 01       	movw	r24, r28
    2956:	4d 96       	adiw	r24, 0x1d	; 29
    2958:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    295c:	8f e2       	ldi	r24, 0x2F	; 47
    295e:	0e 94 73 09 	call	0x12e6	; 0x12e6 <_Z13PutUartChGAVRc>
		}
		if (pDate){
    2962:	8b ad       	sts	0x6b, r24
    2964:	88 23       	and	r24, r24
    2966:	89 f0       	breq	.+34     	; 0x298a <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    2968:	82 e9       	ldi	r24, 0x92	; 146
    296a:	91 e0       	ldi	r25, 0x01	; 1
    296c:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    2970:	9c 01       	movw	r18, r24
    2972:	ce 01       	movw	r24, r28
    2974:	88 96       	adiw	r24, 0x28	; 40
    2976:	b9 01       	movw	r22, r18
    2978:	0e 94 01 1f 	call	0x3e02	; 0x3e02 <strcpy>
			PrintGAVR(tempDate);
    297c:	ce 01       	movw	r24, r28
    297e:	88 96       	adiw	r24, 0x28	; 40
    2980:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
			PutUartChGAVR('.');
    2984:	8e e2       	ldi	r24, 0x2E	; 46
    2986:	0e 94 73 09 	call	0x12e6	; 0x12e6 <_Z13PutUartChGAVRc>
		}
	}
}
    298a:	eb 96       	adiw	r28, 0x3b	; 59
    298c:	0f b6       	in	r0, 0x3f	; 63
    298e:	f8 94       	cli
    2990:	de bf       	out	0x3e, r29	; 62
    2992:	0f be       	out	0x3f, r0	; 63
    2994:	cd bf       	out	0x3d, r28	; 61
    2996:	df 91       	pop	r29
    2998:	cf 91       	pop	r28
    299a:	08 95       	ret

0000299c <__vector_6>:
/****************************************************************************************************************/


/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
//PCINT_17: Getting information from the GAVR
ISR(PCINT2_vect){
    299c:	1f 92       	push	r1
    299e:	0f 92       	push	r0
    29a0:	0f b6       	in	r0, 0x3f	; 63
    29a2:	0f 92       	push	r0
    29a4:	11 24       	eor	r1, r1
    29a6:	2f 93       	push	r18
    29a8:	3f 93       	push	r19
    29aa:	4f 93       	push	r20
    29ac:	5f 93       	push	r21
    29ae:	6f 93       	push	r22
    29b0:	7f 93       	push	r23
    29b2:	8f 93       	push	r24
    29b4:	9f 93       	push	r25
    29b6:	af 93       	push	r26
    29b8:	bf 93       	push	r27
    29ba:	ef 93       	push	r30
    29bc:	ff 93       	push	r31
    29be:	cf 93       	push	r28
    29c0:	df 93       	push	r29
    29c2:	cd b7       	in	r28, 0x3d	; 61
    29c4:	de b7       	in	r29, 0x3e	; 62
	cli();
    29c6:	f8 94       	cli
	if ((PINC & (1 << PCINT17)) && !flagShutdown){
    29c8:	86 e2       	ldi	r24, 0x26	; 38
    29ca:	90 e0       	ldi	r25, 0x00	; 0
    29cc:	fc 01       	movw	r30, r24
    29ce:	80 81       	ld	r24, Z
    29d0:	88 2f       	mov	r24, r24
    29d2:	90 e0       	ldi	r25, 0x00	; 0
    29d4:	82 70       	andi	r24, 0x02	; 2
    29d6:	90 70       	andi	r25, 0x00	; 0
    29d8:	00 97       	sbiw	r24, 0x00	; 0
    29da:	31 f0       	breq	.+12     	; 0x29e8 <__vector_6+0x4c>
    29dc:	80 91 c7 01 	lds	r24, 0x01C7
    29e0:	88 23       	and	r24, r24
    29e2:	11 f4       	brne	.+4      	; 0x29e8 <__vector_6+0x4c>
    29e4:	81 e0       	ldi	r24, 0x01	; 1
    29e6:	01 c0       	rjmp	.+2      	; 0x29ea <__vector_6+0x4e>
    29e8:	80 e0       	ldi	r24, 0x00	; 0
    29ea:	88 23       	and	r24, r24
    29ec:	d1 f0       	breq	.+52     	; 0x2a22 <__vector_6+0x86>
		//Do work, correct interrupt
		UCSR1B |= (1 << RXCIE1);
    29ee:	89 ec       	ldi	r24, 0xC9	; 201
    29f0:	90 e0       	ldi	r25, 0x00	; 0
    29f2:	29 ec       	ldi	r18, 0xC9	; 201
    29f4:	30 e0       	ldi	r19, 0x00	; 0
    29f6:	f9 01       	movw	r30, r18
    29f8:	20 81       	ld	r18, Z
    29fa:	20 68       	ori	r18, 0x80	; 128
    29fc:	fc 01       	movw	r30, r24
    29fe:	20 83       	st	Z, r18
		//flagGoToSleep=fFalse;
		flagNormalMode=fFalse;
    2a00:	10 92 bb 01 	sts	0x01BB, r1
		flagWaitingForSYNGAVR=fTrue;
    2a04:	81 e0       	ldi	r24, 0x01	; 1
    2a06:	80 93 be 01 	sts	0x01BE, r24
		__killCommINT();
    2a0a:	8d e3       	ldi	r24, 0x3D	; 61
    2a0c:	90 e0       	ldi	r25, 0x00	; 0
    2a0e:	fc 01       	movw	r30, r24
    2a10:	10 82       	st	Z, r1
    2a12:	8d e6       	ldi	r24, 0x6D	; 109
    2a14:	90 e0       	ldi	r25, 0x00	; 0
    2a16:	fc 01       	movw	r30, r24
    2a18:	10 82       	st	Z, r1
		//Acknowledge
		PrintGAVR("ACKG.");
    2a1a:	82 e8       	ldi	r24, 0x82	; 130
    2a1c:	91 e0       	ldi	r25, 0x01	; 1
    2a1e:	0e 94 91 09 	call	0x1322	; 0x1322 <_Z9PrintGAVRPc>
	}
	sei();
    2a22:	78 94       	sei
}	
    2a24:	df 91       	pop	r29
    2a26:	cf 91       	pop	r28
    2a28:	ff 91       	pop	r31
    2a2a:	ef 91       	pop	r30
    2a2c:	bf 91       	pop	r27
    2a2e:	af 91       	pop	r26
    2a30:	9f 91       	pop	r25
    2a32:	8f 91       	pop	r24
    2a34:	7f 91       	pop	r23
    2a36:	6f 91       	pop	r22
    2a38:	5f 91       	pop	r21
    2a3a:	4f 91       	pop	r20
    2a3c:	3f 91       	pop	r19
    2a3e:	2f 91       	pop	r18
    2a40:	0f 90       	pop	r0
    2a42:	0f be       	out	0x3f, r0	; 63
    2a44:	0f 90       	pop	r0
    2a46:	1f 90       	pop	r1
    2a48:	18 95       	reti

00002a4a <__vector_3>:
/********************************************************/
//INT2: Getting information from BeagleBone
ISR(INT2_vect){	//about to get time, get things ready
    2a4a:	1f 92       	push	r1
    2a4c:	0f 92       	push	r0
    2a4e:	0f b6       	in	r0, 0x3f	; 63
    2a50:	0f 92       	push	r0
    2a52:	11 24       	eor	r1, r1
    2a54:	2f 93       	push	r18
    2a56:	3f 93       	push	r19
    2a58:	4f 93       	push	r20
    2a5a:	5f 93       	push	r21
    2a5c:	6f 93       	push	r22
    2a5e:	7f 93       	push	r23
    2a60:	8f 93       	push	r24
    2a62:	9f 93       	push	r25
    2a64:	af 93       	push	r26
    2a66:	bf 93       	push	r27
    2a68:	ef 93       	push	r30
    2a6a:	ff 93       	push	r31
    2a6c:	cf 93       	push	r28
    2a6e:	df 93       	push	r29
    2a70:	cd b7       	in	r28, 0x3d	; 61
    2a72:	de b7       	in	r29, 0x3e	; 62
	cli();
    2a74:	f8 94       	cli
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    2a76:	80 91 c7 01 	lds	r24, 0x01C7
    2a7a:	88 23       	and	r24, r24
    2a7c:	e1 f4       	brne	.+56     	; 0x2ab6 <__vector_3+0x6c>
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    2a7e:	10 92 81 01 	sts	0x0181, r1
		flagNormalMode=fFalse;
    2a82:	10 92 bb 01 	sts	0x01BB, r1
		flagWaitingForSYNBone=fTrue;
    2a86:	81 e0       	ldi	r24, 0x01	; 1
    2a88:	80 93 bf 01 	sts	0x01BF, r24
		__killCommINT();
    2a8c:	8d e3       	ldi	r24, 0x3D	; 61
    2a8e:	90 e0       	ldi	r25, 0x00	; 0
    2a90:	fc 01       	movw	r30, r24
    2a92:	10 82       	st	Z, r1
    2a94:	8d e6       	ldi	r24, 0x6D	; 109
    2a96:	90 e0       	ldi	r25, 0x00	; 0
    2a98:	fc 01       	movw	r30, r24
    2a9a:	10 82       	st	Z, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("ACKB.");
    2a9c:	88 e8       	ldi	r24, 0x88	; 136
    2a9e:	91 e0       	ldi	r25, 0x01	; 1
    2aa0:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
		UCSR0B |= (1 << RXCIE0);
    2aa4:	81 ec       	ldi	r24, 0xC1	; 193
    2aa6:	90 e0       	ldi	r25, 0x00	; 0
    2aa8:	21 ec       	ldi	r18, 0xC1	; 193
    2aaa:	30 e0       	ldi	r19, 0x00	; 0
    2aac:	f9 01       	movw	r30, r18
    2aae:	20 81       	ld	r18, Z
    2ab0:	20 68       	ori	r18, 0x80	; 128
    2ab2:	fc 01       	movw	r30, r24
    2ab4:	20 83       	st	Z, r18
	}
	sei();
    2ab6:	78 94       	sei
}
    2ab8:	df 91       	pop	r29
    2aba:	cf 91       	pop	r28
    2abc:	ff 91       	pop	r31
    2abe:	ef 91       	pop	r30
    2ac0:	bf 91       	pop	r27
    2ac2:	af 91       	pop	r26
    2ac4:	9f 91       	pop	r25
    2ac6:	8f 91       	pop	r24
    2ac8:	7f 91       	pop	r23
    2aca:	6f 91       	pop	r22
    2acc:	5f 91       	pop	r21
    2ace:	4f 91       	pop	r20
    2ad0:	3f 91       	pop	r19
    2ad2:	2f 91       	pop	r18
    2ad4:	0f 90       	pop	r0
    2ad6:	0f be       	out	0x3f, r0	; 63
    2ad8:	0f 90       	pop	r0
    2ada:	1f 90       	pop	r1
    2adc:	18 95       	reti

00002ade <__vector_20>:
/********************************************************/
//UART Receive from BeagleBone
ISR(USART0_RX_vect){
    2ade:	1f 92       	push	r1
    2ae0:	0f 92       	push	r0
    2ae2:	0f b6       	in	r0, 0x3f	; 63
    2ae4:	0f 92       	push	r0
    2ae6:	11 24       	eor	r1, r1
    2ae8:	2f 93       	push	r18
    2aea:	3f 93       	push	r19
    2aec:	8f 93       	push	r24
    2aee:	9f 93       	push	r25
    2af0:	ef 93       	push	r30
    2af2:	ff 93       	push	r31
    2af4:	cf 93       	push	r28
    2af6:	df 93       	push	r29
    2af8:	cd b7       	in	r28, 0x3d	; 61
    2afa:	de b7       	in	r29, 0x3e	; 62
	cli();
    2afc:	f8 94       	cli
	if (flagWaitingForSYNBone){
    2afe:	80 91 bf 01 	lds	r24, 0x01BF
    2b02:	88 23       	and	r24, r24
    2b04:	31 f0       	breq	.+12     	; 0x2b12 <__vector_20+0x34>
		flagReceivingBone=fTrue;
    2b06:	81 e0       	ldi	r24, 0x01	; 1
    2b08:	80 93 ba 01 	sts	0x01BA, r24
		flagWaitingForSYNBone=fFalse;
    2b0c:	10 92 bf 01 	sts	0x01BF, r1
    2b10:	02 c0       	rjmp	.+4      	; 0x2b16 <__vector_20+0x38>
	} else {
		flagReceivingBone=fFalse;		//there was a timeout between the initial interrupt and when we are getting this.
    2b12:	10 92 ba 01 	sts	0x01BA, r1
	}	
	UCSR0B &= ~(1 << RXCIE0);
    2b16:	81 ec       	ldi	r24, 0xC1	; 193
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	21 ec       	ldi	r18, 0xC1	; 193
    2b1c:	30 e0       	ldi	r19, 0x00	; 0
    2b1e:	f9 01       	movw	r30, r18
    2b20:	20 81       	ld	r18, Z
    2b22:	2f 77       	andi	r18, 0x7F	; 127
    2b24:	fc 01       	movw	r30, r24
    2b26:	20 83       	st	Z, r18
	sei();
    2b28:	78 94       	sei
}
    2b2a:	df 91       	pop	r29
    2b2c:	cf 91       	pop	r28
    2b2e:	ff 91       	pop	r31
    2b30:	ef 91       	pop	r30
    2b32:	9f 91       	pop	r25
    2b34:	8f 91       	pop	r24
    2b36:	3f 91       	pop	r19
    2b38:	2f 91       	pop	r18
    2b3a:	0f 90       	pop	r0
    2b3c:	0f be       	out	0x3f, r0	; 63
    2b3e:	0f 90       	pop	r0
    2b40:	1f 90       	pop	r1
    2b42:	18 95       	reti

00002b44 <__vector_28>:
/********************************************************/
ISR(USART1_RX_vect){
    2b44:	1f 92       	push	r1
    2b46:	0f 92       	push	r0
    2b48:	0f b6       	in	r0, 0x3f	; 63
    2b4a:	0f 92       	push	r0
    2b4c:	11 24       	eor	r1, r1
    2b4e:	2f 93       	push	r18
    2b50:	3f 93       	push	r19
    2b52:	8f 93       	push	r24
    2b54:	9f 93       	push	r25
    2b56:	ef 93       	push	r30
    2b58:	ff 93       	push	r31
    2b5a:	cf 93       	push	r28
    2b5c:	df 93       	push	r29
    2b5e:	cd b7       	in	r28, 0x3d	; 61
    2b60:	de b7       	in	r29, 0x3e	; 62
	cli();
    2b62:	f8 94       	cli
	if (flagWaitingForSYNGAVR){
    2b64:	80 91 be 01 	lds	r24, 0x01BE
    2b68:	88 23       	and	r24, r24
    2b6a:	31 f0       	breq	.+12     	; 0x2b78 <__vector_28+0x34>
		flagReceivingGAVR=fTrue;
    2b6c:	81 e0       	ldi	r24, 0x01	; 1
    2b6e:	80 93 bc 01 	sts	0x01BC, r24
		flagWaitingForSYNGAVR=fFalse;
    2b72:	10 92 be 01 	sts	0x01BE, r1
    2b76:	02 c0       	rjmp	.+4      	; 0x2b7c <__vector_28+0x38>
	} else {
		flagReceivingGAVR=fFalse;
    2b78:	10 92 bc 01 	sts	0x01BC, r1
	}
	UCSR1B &= ~(1 <<RXCIE1);	//disable interrupt
    2b7c:	89 ec       	ldi	r24, 0xC9	; 201
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	29 ec       	ldi	r18, 0xC9	; 201
    2b82:	30 e0       	ldi	r19, 0x00	; 0
    2b84:	f9 01       	movw	r30, r18
    2b86:	20 81       	ld	r18, Z
    2b88:	2f 77       	andi	r18, 0x7F	; 127
    2b8a:	fc 01       	movw	r30, r24
    2b8c:	20 83       	st	Z, r18
	sei();
    2b8e:	78 94       	sei
}
    2b90:	df 91       	pop	r29
    2b92:	cf 91       	pop	r28
    2b94:	ff 91       	pop	r31
    2b96:	ef 91       	pop	r30
    2b98:	9f 91       	pop	r25
    2b9a:	8f 91       	pop	r24
    2b9c:	3f 91       	pop	r19
    2b9e:	2f 91       	pop	r18
    2ba0:	0f 90       	pop	r0
    2ba2:	0f be       	out	0x3f, r0	; 63
    2ba4:	0f 90       	pop	r0
    2ba6:	1f 90       	pop	r1
    2ba8:	18 95       	reti

00002baa <__vector_11>:

/********************************************************/
//RTC Timer.
ISR(TIMER2_OVF_vect){
    2baa:	1f 92       	push	r1
    2bac:	0f 92       	push	r0
    2bae:	0f b6       	in	r0, 0x3f	; 63
    2bb0:	0f 92       	push	r0
    2bb2:	11 24       	eor	r1, r1
    2bb4:	2f 93       	push	r18
    2bb6:	3f 93       	push	r19
    2bb8:	4f 93       	push	r20
    2bba:	5f 93       	push	r21
    2bbc:	6f 93       	push	r22
    2bbe:	7f 93       	push	r23
    2bc0:	8f 93       	push	r24
    2bc2:	9f 93       	push	r25
    2bc4:	af 93       	push	r26
    2bc6:	bf 93       	push	r27
    2bc8:	ef 93       	push	r30
    2bca:	ff 93       	push	r31
    2bcc:	cf 93       	push	r28
    2bce:	df 93       	push	r29
    2bd0:	cd b7       	in	r28, 0x3d	; 61
    2bd2:	de b7       	in	r29, 0x3e	; 62
	cli();
    2bd4:	f8 94       	cli
	prtSLEEPled ^= (1 << bnSLEEPled);
    2bd6:	8b e2       	ldi	r24, 0x2B	; 43
    2bd8:	90 e0       	ldi	r25, 0x00	; 0
    2bda:	2b e2       	ldi	r18, 0x2B	; 43
    2bdc:	30 e0       	ldi	r19, 0x00	; 0
    2bde:	f9 01       	movw	r30, r18
    2be0:	30 81       	ld	r19, Z
    2be2:	20 e8       	ldi	r18, 0x80	; 128
    2be4:	23 27       	eor	r18, r19
    2be6:	fc 01       	movw	r30, r24
    2be8:	20 83       	st	Z, r18
	static int gavrSendTimeout=0, boneReceiveTimeout=0, gavrReceiveTimeout=0, startupTimeout=0;
	
	currentTime.addSeconds(1);
    2bea:	82 e9       	ldi	r24, 0x92	; 146
    2bec:	91 e0       	ldi	r25, 0x01	; 1
    2bee:	61 e0       	ldi	r22, 0x01	; 1
    2bf0:	70 e0       	ldi	r23, 0x00	; 0
    2bf2:	0e 94 72 06 	call	0xce4	; 0xce4 <_ZN6myTime10addSecondsEi>
	
	//GAVR Transmission Timeout
	if (flagSendingGAVR && gavrSendTimeout <=COMM_TIMEOUT_SEC){gavrSendTimeout++;}
    2bf6:	80 91 c1 01 	lds	r24, 0x01C1
    2bfa:	88 23       	and	r24, r24
    2bfc:	89 f0       	breq	.+34     	; 0x2c20 <__vector_11+0x76>
    2bfe:	80 91 cc 01 	lds	r24, 0x01CC
    2c02:	90 91 cd 01 	lds	r25, 0x01CD
    2c06:	89 30       	cpi	r24, 0x09	; 9
    2c08:	91 05       	cpc	r25, r1
    2c0a:	54 f4       	brge	.+20     	; 0x2c20 <__vector_11+0x76>
    2c0c:	80 91 cc 01 	lds	r24, 0x01CC
    2c10:	90 91 cd 01 	lds	r25, 0x01CD
    2c14:	01 96       	adiw	r24, 0x01	; 1
    2c16:	90 93 cd 01 	sts	0x01CD, r25
    2c1a:	80 93 cc 01 	sts	0x01CC, r24
    2c1e:	32 c0       	rjmp	.+100    	; 0x2c84 <__vector_11+0xda>
	else if (flagSendingGAVR && gavrSendTimeout > COMM_TIMEOUT_SEC){flagSendingGAVR=fFalse;flagGoToSleep=fTrue; gavrSendTimeout=0; __enableCommINT();}
    2c20:	80 91 c1 01 	lds	r24, 0x01C1
    2c24:	88 23       	and	r24, r24
    2c26:	f9 f0       	breq	.+62     	; 0x2c66 <__vector_11+0xbc>
    2c28:	80 91 cc 01 	lds	r24, 0x01CC
    2c2c:	90 91 cd 01 	lds	r25, 0x01CD
    2c30:	89 30       	cpi	r24, 0x09	; 9
    2c32:	91 05       	cpc	r25, r1
    2c34:	c4 f0       	brlt	.+48     	; 0x2c66 <__vector_11+0xbc>
    2c36:	10 92 c1 01 	sts	0x01C1, r1
    2c3a:	81 e0       	ldi	r24, 0x01	; 1
    2c3c:	80 93 81 01 	sts	0x0181, r24
    2c40:	10 92 cd 01 	sts	0x01CD, r1
    2c44:	10 92 cc 01 	sts	0x01CC, r1
    2c48:	8d e3       	ldi	r24, 0x3D	; 61
    2c4a:	90 e0       	ldi	r25, 0x00	; 0
    2c4c:	2d e3       	ldi	r18, 0x3D	; 61
    2c4e:	30 e0       	ldi	r19, 0x00	; 0
    2c50:	f9 01       	movw	r30, r18
    2c52:	20 81       	ld	r18, Z
    2c54:	24 60       	ori	r18, 0x04	; 4
    2c56:	fc 01       	movw	r30, r24
    2c58:	20 83       	st	Z, r18
    2c5a:	8d e6       	ldi	r24, 0x6D	; 109
    2c5c:	90 e0       	ldi	r25, 0x00	; 0
    2c5e:	22 e0       	ldi	r18, 0x02	; 2
    2c60:	fc 01       	movw	r30, r24
    2c62:	20 83       	st	Z, r18
    2c64:	0f c0       	rjmp	.+30     	; 0x2c84 <__vector_11+0xda>
	else if (!flagSendingGAVR && gavrSendTimeout > 0){gavrSendTimeout=0;}
    2c66:	80 91 c1 01 	lds	r24, 0x01C1
    2c6a:	88 23       	and	r24, r24
    2c6c:	59 f4       	brne	.+22     	; 0x2c84 <__vector_11+0xda>
    2c6e:	80 91 cc 01 	lds	r24, 0x01CC
    2c72:	90 91 cd 01 	lds	r25, 0x01CD
    2c76:	18 16       	cp	r1, r24
    2c78:	19 06       	cpc	r1, r25
    2c7a:	24 f4       	brge	.+8      	; 0x2c84 <__vector_11+0xda>
    2c7c:	10 92 cd 01 	sts	0x01CD, r1
    2c80:	10 92 cc 01 	sts	0x01CC, r1
	else;
	
	//BeagleBone Reception Timeout
	if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout <=COMM_TIMEOUT_SEC)){boneReceiveTimeout++;}
    2c84:	80 91 ba 01 	lds	r24, 0x01BA
    2c88:	88 23       	and	r24, r24
    2c8a:	21 f4       	brne	.+8      	; 0x2c94 <__vector_11+0xea>
    2c8c:	80 91 bf 01 	lds	r24, 0x01BF
    2c90:	88 23       	and	r24, r24
    2c92:	89 f0       	breq	.+34     	; 0x2cb6 <__vector_11+0x10c>
    2c94:	80 91 ce 01 	lds	r24, 0x01CE
    2c98:	90 91 cf 01 	lds	r25, 0x01CF
    2c9c:	89 30       	cpi	r24, 0x09	; 9
    2c9e:	91 05       	cpc	r25, r1
    2ca0:	54 f4       	brge	.+20     	; 0x2cb6 <__vector_11+0x10c>
    2ca2:	80 91 ce 01 	lds	r24, 0x01CE
    2ca6:	90 91 cf 01 	lds	r25, 0x01CF
    2caa:	01 96       	adiw	r24, 0x01	; 1
    2cac:	90 93 cf 01 	sts	0x01CF, r25
    2cb0:	80 93 ce 01 	sts	0x01CE, r24
    2cb4:	3f c0       	rjmp	.+126    	; 0x2d34 <__vector_11+0x18a>
	else if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout > COMM_TIMEOUT_SEC)){flagReceivingBone=fFalse; flagWaitingForSYNBone=fFalse;flagGoToSleep=fTrue; flagNormalMode=fTrue; boneReceiveTimeout=0; __enableCommINT();}
    2cb6:	80 91 ba 01 	lds	r24, 0x01BA
    2cba:	88 23       	and	r24, r24
    2cbc:	21 f4       	brne	.+8      	; 0x2cc6 <__vector_11+0x11c>
    2cbe:	80 91 bf 01 	lds	r24, 0x01BF
    2cc2:	88 23       	and	r24, r24
    2cc4:	21 f1       	breq	.+72     	; 0x2d0e <__vector_11+0x164>
    2cc6:	80 91 ce 01 	lds	r24, 0x01CE
    2cca:	90 91 cf 01 	lds	r25, 0x01CF
    2cce:	89 30       	cpi	r24, 0x09	; 9
    2cd0:	91 05       	cpc	r25, r1
    2cd2:	ec f0       	brlt	.+58     	; 0x2d0e <__vector_11+0x164>
    2cd4:	10 92 ba 01 	sts	0x01BA, r1
    2cd8:	10 92 bf 01 	sts	0x01BF, r1
    2cdc:	81 e0       	ldi	r24, 0x01	; 1
    2cde:	80 93 81 01 	sts	0x0181, r24
    2ce2:	81 e0       	ldi	r24, 0x01	; 1
    2ce4:	80 93 bb 01 	sts	0x01BB, r24
    2ce8:	10 92 cf 01 	sts	0x01CF, r1
    2cec:	10 92 ce 01 	sts	0x01CE, r1
    2cf0:	8d e3       	ldi	r24, 0x3D	; 61
    2cf2:	90 e0       	ldi	r25, 0x00	; 0
    2cf4:	2d e3       	ldi	r18, 0x3D	; 61
    2cf6:	30 e0       	ldi	r19, 0x00	; 0
    2cf8:	f9 01       	movw	r30, r18
    2cfa:	20 81       	ld	r18, Z
    2cfc:	24 60       	ori	r18, 0x04	; 4
    2cfe:	fc 01       	movw	r30, r24
    2d00:	20 83       	st	Z, r18
    2d02:	8d e6       	ldi	r24, 0x6D	; 109
    2d04:	90 e0       	ldi	r25, 0x00	; 0
    2d06:	22 e0       	ldi	r18, 0x02	; 2
    2d08:	fc 01       	movw	r30, r24
    2d0a:	20 83       	st	Z, r18
    2d0c:	13 c0       	rjmp	.+38     	; 0x2d34 <__vector_11+0x18a>
	else if ((!flagReceivingBone && !flagWaitingForSYNBone) && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    2d0e:	80 91 ba 01 	lds	r24, 0x01BA
    2d12:	88 23       	and	r24, r24
    2d14:	79 f4       	brne	.+30     	; 0x2d34 <__vector_11+0x18a>
    2d16:	80 91 bf 01 	lds	r24, 0x01BF
    2d1a:	88 23       	and	r24, r24
    2d1c:	59 f4       	brne	.+22     	; 0x2d34 <__vector_11+0x18a>
    2d1e:	80 91 ce 01 	lds	r24, 0x01CE
    2d22:	90 91 cf 01 	lds	r25, 0x01CF
    2d26:	18 16       	cp	r1, r24
    2d28:	19 06       	cpc	r1, r25
    2d2a:	24 f4       	brge	.+8      	; 0x2d34 <__vector_11+0x18a>
    2d2c:	10 92 cf 01 	sts	0x01CF, r1
    2d30:	10 92 ce 01 	sts	0x01CE, r1
	else;

	//GAVR Reception Timeout
	if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout <= COMM_TIMEOUT_SEC){gavrReceiveTimeout++;}
    2d34:	80 91 bc 01 	lds	r24, 0x01BC
    2d38:	88 23       	and	r24, r24
    2d3a:	21 f4       	brne	.+8      	; 0x2d44 <__vector_11+0x19a>
    2d3c:	80 91 be 01 	lds	r24, 0x01BE
    2d40:	88 23       	and	r24, r24
    2d42:	89 f0       	breq	.+34     	; 0x2d66 <__vector_11+0x1bc>
    2d44:	80 91 d0 01 	lds	r24, 0x01D0
    2d48:	90 91 d1 01 	lds	r25, 0x01D1
    2d4c:	89 30       	cpi	r24, 0x09	; 9
    2d4e:	91 05       	cpc	r25, r1
    2d50:	54 f4       	brge	.+20     	; 0x2d66 <__vector_11+0x1bc>
    2d52:	80 91 d0 01 	lds	r24, 0x01D0
    2d56:	90 91 d1 01 	lds	r25, 0x01D1
    2d5a:	01 96       	adiw	r24, 0x01	; 1
    2d5c:	90 93 d1 01 	sts	0x01D1, r25
    2d60:	80 93 d0 01 	sts	0x01D0, r24
    2d64:	3f c0       	rjmp	.+126    	; 0x2de4 <__vector_11+0x23a>
	else if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout > COMM_TIMEOUT_SEC){flagReceivingGAVR=fFalse;flagGoToSleep=fTrue; flagWaitingForSYNGAVR=fFalse;flagNormalMode=fTrue;boneReceiveTimeout=0; __enableCommINT();}
    2d66:	80 91 bc 01 	lds	r24, 0x01BC
    2d6a:	88 23       	and	r24, r24
    2d6c:	21 f4       	brne	.+8      	; 0x2d76 <__vector_11+0x1cc>
    2d6e:	80 91 be 01 	lds	r24, 0x01BE
    2d72:	88 23       	and	r24, r24
    2d74:	21 f1       	breq	.+72     	; 0x2dbe <__vector_11+0x214>
    2d76:	80 91 d0 01 	lds	r24, 0x01D0
    2d7a:	90 91 d1 01 	lds	r25, 0x01D1
    2d7e:	89 30       	cpi	r24, 0x09	; 9
    2d80:	91 05       	cpc	r25, r1
    2d82:	ec f0       	brlt	.+58     	; 0x2dbe <__vector_11+0x214>
    2d84:	10 92 bc 01 	sts	0x01BC, r1
    2d88:	81 e0       	ldi	r24, 0x01	; 1
    2d8a:	80 93 81 01 	sts	0x0181, r24
    2d8e:	10 92 be 01 	sts	0x01BE, r1
    2d92:	81 e0       	ldi	r24, 0x01	; 1
    2d94:	80 93 bb 01 	sts	0x01BB, r24
    2d98:	10 92 cf 01 	sts	0x01CF, r1
    2d9c:	10 92 ce 01 	sts	0x01CE, r1
    2da0:	8d e3       	ldi	r24, 0x3D	; 61
    2da2:	90 e0       	ldi	r25, 0x00	; 0
    2da4:	2d e3       	ldi	r18, 0x3D	; 61
    2da6:	30 e0       	ldi	r19, 0x00	; 0
    2da8:	f9 01       	movw	r30, r18
    2daa:	20 81       	ld	r18, Z
    2dac:	24 60       	ori	r18, 0x04	; 4
    2dae:	fc 01       	movw	r30, r24
    2db0:	20 83       	st	Z, r18
    2db2:	8d e6       	ldi	r24, 0x6D	; 109
    2db4:	90 e0       	ldi	r25, 0x00	; 0
    2db6:	22 e0       	ldi	r18, 0x02	; 2
    2db8:	fc 01       	movw	r30, r24
    2dba:	20 83       	st	Z, r18
    2dbc:	13 c0       	rjmp	.+38     	; 0x2de4 <__vector_11+0x23a>
	else if ((!flagReceivingGAVR && !flagWaitingForSYNGAVR) && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    2dbe:	80 91 bc 01 	lds	r24, 0x01BC
    2dc2:	88 23       	and	r24, r24
    2dc4:	79 f4       	brne	.+30     	; 0x2de4 <__vector_11+0x23a>
    2dc6:	80 91 be 01 	lds	r24, 0x01BE
    2dca:	88 23       	and	r24, r24
    2dcc:	59 f4       	brne	.+22     	; 0x2de4 <__vector_11+0x23a>
    2dce:	80 91 ce 01 	lds	r24, 0x01CE
    2dd2:	90 91 cf 01 	lds	r25, 0x01CF
    2dd6:	18 16       	cp	r1, r24
    2dd8:	19 06       	cpc	r1, r25
    2dda:	24 f4       	brge	.+8      	; 0x2de4 <__vector_11+0x23a>
    2ddc:	10 92 cf 01 	sts	0x01CF, r1
    2de0:	10 92 ce 01 	sts	0x01CE, r1
	else;

	//Startup Tiemout for sending clock to GAVR
	if ((flagFreshStart || restart) && startupTimeout <= STARTUP_TIMEOUT_SEC){startupTimeout++;}
    2de4:	80 91 cb 01 	lds	r24, 0x01CB
    2de8:	88 23       	and	r24, r24
    2dea:	21 f4       	brne	.+8      	; 0x2df4 <__vector_11+0x24a>
    2dec:	80 91 ca 01 	lds	r24, 0x01CA
    2df0:	88 23       	and	r24, r24
    2df2:	89 f0       	breq	.+34     	; 0x2e16 <__vector_11+0x26c>
    2df4:	80 91 d2 01 	lds	r24, 0x01D2
    2df8:	90 91 d3 01 	lds	r25, 0x01D3
    2dfc:	89 32       	cpi	r24, 0x29	; 41
    2dfe:	91 05       	cpc	r25, r1
    2e00:	54 f4       	brge	.+20     	; 0x2e16 <__vector_11+0x26c>
    2e02:	80 91 d2 01 	lds	r24, 0x01D2
    2e06:	90 91 d3 01 	lds	r25, 0x01D3
    2e0a:	01 96       	adiw	r24, 0x01	; 1
    2e0c:	90 93 d3 01 	sts	0x01D3, r25
    2e10:	80 93 d2 01 	sts	0x01D2, r24
    2e14:	52 c0       	rjmp	.+164    	; 0x2eba <__vector_11+0x310>
	else if ((flagFreshStart || restart) && startupTimeout > STARTUP_TIMEOUT_SEC){
    2e16:	80 91 cb 01 	lds	r24, 0x01CB
    2e1a:	88 23       	and	r24, r24
    2e1c:	21 f4       	brne	.+8      	; 0x2e26 <__vector_11+0x27c>
    2e1e:	80 91 ca 01 	lds	r24, 0x01CA
    2e22:	88 23       	and	r24, r24
    2e24:	b9 f1       	breq	.+110    	; 0x2e94 <__vector_11+0x2ea>
    2e26:	80 91 d2 01 	lds	r24, 0x01D2
    2e2a:	90 91 d3 01 	lds	r25, 0x01D3
    2e2e:	89 32       	cpi	r24, 0x29	; 41
    2e30:	91 05       	cpc	r25, r1
    2e32:	84 f1       	brlt	.+96     	; 0x2e94 <__vector_11+0x2ea>
		if (flagFreshStart){flagFreshStart=fFalse; flagUserClock=fTrue; flagUpdateGAVRClock=fFalse;}	//The GPS didn't send valid data, get user clock.
    2e34:	80 91 cb 01 	lds	r24, 0x01CB
    2e38:	88 23       	and	r24, r24
    2e3a:	41 f0       	breq	.+16     	; 0x2e4c <__vector_11+0x2a2>
    2e3c:	10 92 cb 01 	sts	0x01CB, r1
    2e40:	81 e0       	ldi	r24, 0x01	; 1
    2e42:	80 93 c2 01 	sts	0x01C2, r24
    2e46:	10 92 c0 01 	sts	0x01C0, r1
    2e4a:	0b c0       	rjmp	.+22     	; 0x2e62 <__vector_11+0x2b8>
		else if (restart){restart=fFalse; flagUserClock=fFalse; flagUpdateGAVRClock=fTrue;}				//Gps didn't send valid data, we have valid data. This is redundant to the main
    2e4c:	80 91 ca 01 	lds	r24, 0x01CA
    2e50:	88 23       	and	r24, r24
    2e52:	39 f0       	breq	.+14     	; 0x2e62 <__vector_11+0x2b8>
    2e54:	10 92 ca 01 	sts	0x01CA, r1
    2e58:	10 92 c2 01 	sts	0x01C2, r1
    2e5c:	81 e0       	ldi	r24, 0x01	; 1
    2e5e:	80 93 c0 01 	sts	0x01C0, r24
		__enableCommINT();																				//--procedure that depends on "if (restart)"
    2e62:	8d e3       	ldi	r24, 0x3D	; 61
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	2d e3       	ldi	r18, 0x3D	; 61
    2e68:	30 e0       	ldi	r19, 0x00	; 0
    2e6a:	f9 01       	movw	r30, r18
    2e6c:	20 81       	ld	r18, Z
    2e6e:	24 60       	ori	r18, 0x04	; 4
    2e70:	fc 01       	movw	r30, r24
    2e72:	20 83       	st	Z, r18
    2e74:	8d e6       	ldi	r24, 0x6D	; 109
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	22 e0       	ldi	r18, 0x02	; 2
    2e7a:	fc 01       	movw	r30, r24
    2e7c:	20 83       	st	Z, r18
		startupTimeout=0;
    2e7e:	10 92 d3 01 	sts	0x01D3, r1
    2e82:	10 92 d2 01 	sts	0x01D2, r1
		flagGoToSleep=fTrue;
    2e86:	81 e0       	ldi	r24, 0x01	; 1
    2e88:	80 93 81 01 	sts	0x0181, r24
		flagNormalMode=fTrue;
    2e8c:	81 e0       	ldi	r24, 0x01	; 1
    2e8e:	80 93 bb 01 	sts	0x01BB, r24
    2e92:	13 c0       	rjmp	.+38     	; 0x2eba <__vector_11+0x310>
	} else if (!(flagFreshStart || restart) && startupTimeout > 0){startupTimeout=0;}
    2e94:	80 91 cb 01 	lds	r24, 0x01CB
    2e98:	88 23       	and	r24, r24
    2e9a:	79 f4       	brne	.+30     	; 0x2eba <__vector_11+0x310>
    2e9c:	80 91 ca 01 	lds	r24, 0x01CA
    2ea0:	88 23       	and	r24, r24
    2ea2:	59 f4       	brne	.+22     	; 0x2eba <__vector_11+0x310>
    2ea4:	80 91 d2 01 	lds	r24, 0x01D2
    2ea8:	90 91 d3 01 	lds	r25, 0x01D3
    2eac:	18 16       	cp	r1, r24
    2eae:	19 06       	cpc	r1, r25
    2eb0:	24 f4       	brge	.+8      	; 0x2eba <__vector_11+0x310>
    2eb2:	10 92 d3 01 	sts	0x01D3, r1
    2eb6:	10 92 d2 01 	sts	0x01D2, r1
	else;
	sei();
    2eba:	78 94       	sei
}//End timer 2 overflow.
    2ebc:	df 91       	pop	r29
    2ebe:	cf 91       	pop	r28
    2ec0:	ff 91       	pop	r31
    2ec2:	ef 91       	pop	r30
    2ec4:	bf 91       	pop	r27
    2ec6:	af 91       	pop	r26
    2ec8:	9f 91       	pop	r25
    2eca:	8f 91       	pop	r24
    2ecc:	7f 91       	pop	r23
    2ece:	6f 91       	pop	r22
    2ed0:	5f 91       	pop	r21
    2ed2:	4f 91       	pop	r20
    2ed4:	3f 91       	pop	r19
    2ed6:	2f 91       	pop	r18
    2ed8:	0f 90       	pop	r0
    2eda:	0f be       	out	0x3f, r0	; 63
    2edc:	0f 90       	pop	r0
    2ede:	1f 90       	pop	r1
    2ee0:	18 95       	reti

00002ee2 <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    2ee2:	cf 93       	push	r28
    2ee4:	df 93       	push	r29
    2ee6:	cd b7       	in	r28, 0x3d	; 61
    2ee8:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    2eea:	0e 94 c8 18 	call	0x3190	; 0x3190 <_Z10DeviceInitv>
	AppInit(MYUBRR);
    2eee:	83 e3       	ldi	r24, 0x33	; 51
    2ef0:	90 e0       	ldi	r25, 0x00	; 0
    2ef2:	0e 94 ef 18 	call	0x31de	; 0x31de <_Z7AppInitj>
	EnableRTCTimer();
    2ef6:	0e 94 4b 1a 	call	0x3496	; 0x3496 <_Z14EnableRTCTimerv>
	InitBools();
    2efa:	0e 94 20 1a 	call	0x3440	; 0x3440 <_Z9InitBoolsv>
	getDateTime_eeprom(fTrue,fTrue);
    2efe:	81 e0       	ldi	r24, 0x01	; 1
    2f00:	61 e0       	ldi	r22, 0x01	; 1
    2f02:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z18getDateTime_eepromhh>
	//Prep/make sure power/temp is good
	Wait_ms(2000);
    2f06:	80 ed       	ldi	r24, 0xD0	; 208
    2f08:	97 e0       	ldi	r25, 0x07	; 7
    2f0a:	0e 94 89 1a 	call	0x3512	; 0x3512 <_Z7Wait_msi>
	//GetTemp();
	TakeADC();
    2f0e:	0e 94 4f 1b 	call	0x369e	; 0x369e <_Z7TakeADCv>
	flagGoodTemp=fTrue;
    2f12:	81 e0       	ldi	r24, 0x01	; 1
    2f14:	80 93 c8 01 	sts	0x01C8, r24
	if (flagGoodVolts && flagGoodTemp){				//Good to power on system
    2f18:	80 91 c9 01 	lds	r24, 0x01C9
    2f1c:	88 23       	and	r24, r24
    2f1e:	e1 f0       	breq	.+56     	; 0x2f58 <main+0x76>
    2f20:	80 91 c8 01 	lds	r24, 0x01C8
    2f24:	88 23       	and	r24, r24
    2f26:	c1 f0       	breq	.+48     	; 0x2f58 <main+0x76>
		__enableCommINT();
    2f28:	8d e3       	ldi	r24, 0x3D	; 61
    2f2a:	90 e0       	ldi	r25, 0x00	; 0
    2f2c:	2d e3       	ldi	r18, 0x3D	; 61
    2f2e:	30 e0       	ldi	r19, 0x00	; 0
    2f30:	f9 01       	movw	r30, r18
    2f32:	20 81       	ld	r18, Z
    2f34:	24 60       	ori	r18, 0x04	; 4
    2f36:	fc 01       	movw	r30, r24
    2f38:	20 83       	st	Z, r18
    2f3a:	8d e6       	ldi	r24, 0x6D	; 109
    2f3c:	90 e0       	ldi	r25, 0x00	; 0
    2f3e:	22 e0       	ldi	r18, 0x02	; 2
    2f40:	fc 01       	movw	r30, r24
    2f42:	20 83       	st	Z, r18
		PowerUp(POWER_UP_INTERVAL);
    2f44:	83 e0       	ldi	r24, 0x03	; 3
    2f46:	90 e0       	ldi	r25, 0x00	; 0
    2f48:	0e 94 ba 1c 	call	0x3974	; 0x3974 <_Z7PowerUpj>
		flagFreshStart=fTrue;
    2f4c:	81 e0       	ldi	r24, 0x01	; 1
    2f4e:	80 93 cb 01 	sts	0x01CB, r24
		flagShutdown=fFalse;
    2f52:	10 92 c7 01 	sts	0x01C7, r1
    2f56:	0d c0       	rjmp	.+26     	; 0x2f72 <main+0x90>
	} else {										//Something isn't right, don't power on the system.
		__killCommINT();
    2f58:	8d e3       	ldi	r24, 0x3D	; 61
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	fc 01       	movw	r30, r24
    2f5e:	10 82       	st	Z, r1
    2f60:	8d e6       	ldi	r24, 0x6D	; 109
    2f62:	90 e0       	ldi	r25, 0x00	; 0
    2f64:	fc 01       	movw	r30, r24
    2f66:	10 82       	st	Z, r1
		flagShutdown=fTrue;
    2f68:	81 e0       	ldi	r24, 0x01	; 1
    2f6a:	80 93 c7 01 	sts	0x01C7, r24
		flagFreshStart=fFalse;
    2f6e:	10 92 cb 01 	sts	0x01CB, r1
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
    2f72:	88 e2       	ldi	r24, 0x28	; 40
    2f74:	90 e0       	ldi	r25, 0x00	; 0
    2f76:	28 e2       	ldi	r18, 0x28	; 40
    2f78:	30 e0       	ldi	r19, 0x00	; 0
    2f7a:	f9 01       	movw	r30, r18
    2f7c:	20 81       	ld	r18, Z
    2f7e:	24 60       	ori	r18, 0x04	; 4
    2f80:	fc 01       	movw	r30, r24
    2f82:	20 83       	st	Z, r18
    2f84:	01 c0       	rjmp	.+2      	; 0x2f88 <main+0xa6>
	//main programming loop
	while(fTrue)
    2f86:	00 00       	nop
	{		
		Wait_ms(2000);
    2f88:	80 ed       	ldi	r24, 0xD0	; 208
    2f8a:	97 e0       	ldi	r25, 0x07	; 7
    2f8c:	0e 94 89 1a 	call	0x3512	; 0x3512 <_Z7Wait_msi>
		//If receiving UART string, go get rest of it.
		if (flagReceivingBone){
    2f90:	80 91 ba 01 	lds	r24, 0x01BA
    2f94:	88 23       	and	r24, r24
    2f96:	b1 f0       	breq	.+44     	; 0x2fc4 <main+0xe2>
			ReceiveBone();
    2f98:	0e 94 c6 0c 	call	0x198c	; 0x198c <_Z11ReceiveBonev>
			__enableCommINT();
    2f9c:	8d e3       	ldi	r24, 0x3D	; 61
    2f9e:	90 e0       	ldi	r25, 0x00	; 0
    2fa0:	2d e3       	ldi	r18, 0x3D	; 61
    2fa2:	30 e0       	ldi	r19, 0x00	; 0
    2fa4:	f9 01       	movw	r30, r18
    2fa6:	20 81       	ld	r18, Z
    2fa8:	24 60       	ori	r18, 0x04	; 4
    2faa:	fc 01       	movw	r30, r24
    2fac:	20 83       	st	Z, r18
    2fae:	8d e6       	ldi	r24, 0x6D	; 109
    2fb0:	90 e0       	ldi	r25, 0x00	; 0
    2fb2:	22 e0       	ldi	r18, 0x02	; 2
    2fb4:	fc 01       	movw	r30, r24
    2fb6:	20 83       	st	Z, r18
			flagGoToSleep=fTrue;
    2fb8:	81 e0       	ldi	r24, 0x01	; 1
    2fba:	80 93 81 01 	sts	0x0181, r24
			flagNormalMode=fTrue;
    2fbe:	81 e0       	ldi	r24, 0x01	; 1
    2fc0:	80 93 bb 01 	sts	0x01BB, r24
		}//end flag Receiving from Bone 
		
		//Receiving Data/Signals from GAVR
		if (flagReceivingGAVR){
    2fc4:	80 91 bc 01 	lds	r24, 0x01BC
    2fc8:	88 23       	and	r24, r24
    2fca:	d1 f0       	breq	.+52     	; 0x3000 <main+0x11e>
			ReceiveGAVR();
    2fcc:	0e 94 f4 10 	call	0x21e8	; 0x21e8 <_Z11ReceiveGAVRv>
			__enableCommINT();
    2fd0:	8d e3       	ldi	r24, 0x3D	; 61
    2fd2:	90 e0       	ldi	r25, 0x00	; 0
    2fd4:	2d e3       	ldi	r18, 0x3D	; 61
    2fd6:	30 e0       	ldi	r19, 0x00	; 0
    2fd8:	f9 01       	movw	r30, r18
    2fda:	20 81       	ld	r18, Z
    2fdc:	24 60       	ori	r18, 0x04	; 4
    2fde:	fc 01       	movw	r30, r24
    2fe0:	20 83       	st	Z, r18
    2fe2:	8d e6       	ldi	r24, 0x6D	; 109
    2fe4:	90 e0       	ldi	r25, 0x00	; 0
    2fe6:	22 e0       	ldi	r18, 0x02	; 2
    2fe8:	fc 01       	movw	r30, r24
    2fea:	20 83       	st	Z, r18
			if (!flagReceivingBone){		//Just in case there was an interrupt IMMEDIATELY after the enabling of Communication interrupts
    2fec:	80 91 ba 01 	lds	r24, 0x01BA
    2ff0:	88 23       	and	r24, r24
    2ff2:	31 f4       	brne	.+12     	; 0x3000 <main+0x11e>
				flagGoToSleep=fTrue;
    2ff4:	81 e0       	ldi	r24, 0x01	; 1
    2ff6:	80 93 81 01 	sts	0x0181, r24
				flagNormalMode=fTrue;
    2ffa:	81 e0       	ldi	r24, 0x01	; 1
    2ffc:	80 93 bb 01 	sts	0x01BB, r24
			}			
		}//end flag Receiving from GAVR case
		
	
		//Communication with GAVR. Either updating the date/time on it or asking for date and time. The internal send machine deals with the flags.
		if ((flagUpdateGAVRClock  || flagUserClock) && !flagWaitingForReceiveGAVR){
    3000:	80 91 c0 01 	lds	r24, 0x01C0
    3004:	88 23       	and	r24, r24
    3006:	21 f4       	brne	.+8      	; 0x3010 <main+0x12e>
    3008:	80 91 c2 01 	lds	r24, 0x01C2
    300c:	88 23       	and	r24, r24
    300e:	e1 f0       	breq	.+56     	; 0x3048 <main+0x166>
    3010:	80 91 bd 01 	lds	r24, 0x01BD
    3014:	88 23       	and	r24, r24
    3016:	c1 f4       	brne	.+48     	; 0x3048 <main+0x166>
			__killCommINT();
    3018:	8d e3       	ldi	r24, 0x3D	; 61
    301a:	90 e0       	ldi	r25, 0x00	; 0
    301c:	fc 01       	movw	r30, r24
    301e:	10 82       	st	Z, r1
    3020:	8d e6       	ldi	r24, 0x6D	; 109
    3022:	90 e0       	ldi	r25, 0x00	; 0
    3024:	fc 01       	movw	r30, r24
    3026:	10 82       	st	Z, r1
			sendGAVR();
    3028:	0e 94 4e 0a 	call	0x149c	; 0x149c <_Z8sendGAVRv>
			__enableCommINT();
    302c:	8d e3       	ldi	r24, 0x3D	; 61
    302e:	90 e0       	ldi	r25, 0x00	; 0
    3030:	2d e3       	ldi	r18, 0x3D	; 61
    3032:	30 e0       	ldi	r19, 0x00	; 0
    3034:	f9 01       	movw	r30, r18
    3036:	20 81       	ld	r18, Z
    3038:	24 60       	ori	r18, 0x04	; 4
    303a:	fc 01       	movw	r30, r24
    303c:	20 83       	st	Z, r18
    303e:	8d e6       	ldi	r24, 0x6D	; 109
    3040:	90 e0       	ldi	r25, 0x00	; 0
    3042:	22 e0       	ldi	r18, 0x02	; 2
    3044:	fc 01       	movw	r30, r24
    3046:	20 83       	st	Z, r18
		}//end send to GAVR case

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    3048:	80 91 bb 01 	lds	r24, 0x01BB
    304c:	88 23       	and	r24, r24
    304e:	49 f1       	breq	.+82     	; 0x30a2 <main+0x1c0>
			if (currentTime.getMinutes()%30 == 0){
    3050:	82 e9       	ldi	r24, 0x92	; 146
    3052:	91 e0       	ldi	r25, 0x01	; 1
    3054:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    3058:	9e e1       	ldi	r25, 0x1E	; 30
    305a:	69 2f       	mov	r22, r25
    305c:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <__udivmodqi4>
    3060:	89 2f       	mov	r24, r25
    3062:	98 2f       	mov	r25, r24
    3064:	81 e0       	ldi	r24, 0x01	; 1
    3066:	99 23       	and	r25, r25
    3068:	09 f0       	breq	.+2      	; 0x306c <main+0x18a>
    306a:	80 e0       	ldi	r24, 0x00	; 0
    306c:	88 23       	and	r24, r24
    306e:	c9 f0       	breq	.+50     	; 0x30a2 <main+0x1c0>
				if (currentTime.getHours()%12 == 0){
    3070:	82 e9       	ldi	r24, 0x92	; 146
    3072:	91 e0       	ldi	r25, 0x01	; 1
    3074:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    3078:	9c e0       	ldi	r25, 0x0C	; 12
    307a:	69 2f       	mov	r22, r25
    307c:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <__udivmodqi4>
    3080:	89 2f       	mov	r24, r25
    3082:	98 2f       	mov	r25, r24
    3084:	81 e0       	ldi	r24, 0x01	; 1
    3086:	99 23       	and	r25, r25
    3088:	09 f0       	breq	.+2      	; 0x308c <main+0x1aa>
    308a:	80 e0       	ldi	r24, 0x00	; 0
    308c:	88 23       	and	r24, r24
    308e:	29 f0       	breq	.+10     	; 0x309a <main+0x1b8>
					saveDateTime_eeprom(fTrue,fTrue);
    3090:	81 e0       	ldi	r24, 0x01	; 1
    3092:	61 e0       	ldi	r22, 0x01	; 1
    3094:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    3098:	04 c0       	rjmp	.+8      	; 0x30a2 <main+0x1c0>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    309a:	81 e0       	ldi	r24, 0x01	; 1
    309c:	60 e0       	ldi	r22, 0x00	; 0
    309e:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}//end time capture/save

		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    30a2:	80 91 bb 01 	lds	r24, 0x01BB
    30a6:	88 23       	and	r24, r24
    30a8:	09 f1       	breq	.+66     	; 0x30ec <main+0x20a>
			TakeADC();
    30aa:	0e 94 4f 1b 	call	0x369e	; 0x369e <_Z7TakeADCv>
			//GetTemp();
			flagGoodTemp=fTrue;
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	80 93 c8 01 	sts	0x01C8, r24
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    30b4:	80 91 c9 01 	lds	r24, 0x01C9
    30b8:	88 23       	and	r24, r24
    30ba:	71 f0       	breq	.+28     	; 0x30d8 <main+0x1f6>
    30bc:	80 91 c8 01 	lds	r24, 0x01C8
    30c0:	88 23       	and	r24, r24
    30c2:	51 f0       	breq	.+20     	; 0x30d8 <main+0x1f6>
				if(flagShutdown){restart = fTrue; flagShutdown=fFalse;}
    30c4:	80 91 c7 01 	lds	r24, 0x01C7
    30c8:	88 23       	and	r24, r24
    30ca:	81 f0       	breq	.+32     	; 0x30ec <main+0x20a>
    30cc:	81 e0       	ldi	r24, 0x01	; 1
    30ce:	80 93 ca 01 	sts	0x01CA, r24
    30d2:	10 92 c7 01 	sts	0x01C7, r1
    30d6:	0a c0       	rjmp	.+20     	; 0x30ec <main+0x20a>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (!flagShutdown){
    30d8:	80 91 c7 01 	lds	r24, 0x01C7
    30dc:	88 23       	and	r24, r24
    30de:	31 f4       	brne	.+12     	; 0x30ec <main+0x20a>
					flagNewShutdown = fTrue;
    30e0:	81 e0       	ldi	r24, 0x01	; 1
    30e2:	80 93 c6 01 	sts	0x01C6, r24
					flagShutdown=fTrue;
    30e6:	81 e0       	ldi	r24, 0x01	; 1
    30e8:	80 93 c7 01 	sts	0x01C7, r24
		
		//Waiting...
		//Wait_sec(1);
				
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    30ec:	80 91 c6 01 	lds	r24, 0x01C6
    30f0:	88 23       	and	r24, r24
    30f2:	b9 f0       	breq	.+46     	; 0x3122 <main+0x240>
			//Make sure nothing messes with the routine that we care about
			__killCommINT();
    30f4:	8d e3       	ldi	r24, 0x3D	; 61
    30f6:	90 e0       	ldi	r25, 0x00	; 0
    30f8:	fc 01       	movw	r30, r24
    30fa:	10 82       	st	Z, r1
    30fc:	8d e6       	ldi	r24, 0x6D	; 109
    30fe:	90 e0       	ldi	r25, 0x00	; 0
    3100:	fc 01       	movw	r30, r24
    3102:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    3104:	81 e0       	ldi	r24, 0x01	; 1
    3106:	80 93 81 01 	sts	0x0181, r24
			flagReceivingBone = fFalse;
    310a:	10 92 ba 01 	sts	0x01BA, r1
			flagUserClock=fFalse;						//reset this so next boot is correct. Done in restart case as well for redundancy
    310e:	10 92 c2 01 	sts	0x01C2, r1
			saveDateTime_eeprom(fTrue,fTrue);
    3112:	81 e0       	ldi	r24, 0x01	; 1
    3114:	61 e0       	ldi	r22, 0x01	; 1
    3116:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
			
			//Kill power--Alert comes in that function
			PowerDown();
    311a:	0e 94 10 1d 	call	0x3a20	; 0x3a20 <_Z9PowerDownv>
			flagNewShutdown = fFalse;
    311e:	10 92 c6 01 	sts	0x01C6, r1
		}//end new shutdown
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    3122:	80 91 ca 01 	lds	r24, 0x01CA
    3126:	88 23       	and	r24, r24
    3128:	c9 f0       	breq	.+50     	; 0x315c <main+0x27a>
			//Enable COmmunication protocols and then power up. Power up specifies the timing for it to happen	
			PowerUp(POWER_UP_INTERVAL);
    312a:	83 e0       	ldi	r24, 0x03	; 3
    312c:	90 e0       	ldi	r25, 0x00	; 0
    312e:	0e 94 ba 1c 	call	0x3974	; 0x3974 <_Z7PowerUpj>
			__enableCommINT();
    3132:	8d e3       	ldi	r24, 0x3D	; 61
    3134:	90 e0       	ldi	r25, 0x00	; 0
    3136:	2d e3       	ldi	r18, 0x3D	; 61
    3138:	30 e0       	ldi	r19, 0x00	; 0
    313a:	f9 01       	movw	r30, r18
    313c:	20 81       	ld	r18, Z
    313e:	24 60       	ori	r18, 0x04	; 4
    3140:	fc 01       	movw	r30, r24
    3142:	20 83       	st	Z, r18
    3144:	8d e6       	ldi	r24, 0x6D	; 109
    3146:	90 e0       	ldi	r25, 0x00	; 0
    3148:	22 e0       	ldi	r18, 0x02	; 2
    314a:	fc 01       	movw	r30, r24
    314c:	20 83       	st	Z, r18
			//Update the GAVRClock since it's a restart, we have the correct date and time. If BeagleBone sends GPS data, use that to back it up.
			flagUpdateGAVRClock=fTrue;
    314e:	81 e0       	ldi	r24, 0x01	; 1
    3150:	80 93 c0 01 	sts	0x01C0, r24
			flagUserClock=fFalse;	
    3154:	10 92 c2 01 	sts	0x01C2, r1
			restart=fFalse;	
    3158:	10 92 ca 01 	sts	0x01CA, r1
		}//end restart		
		
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep){GoToSleep(flagShutdown);}
    315c:	80 91 81 01 	lds	r24, 0x0181
    3160:	88 23       	and	r24, r24
    3162:	21 f0       	breq	.+8      	; 0x316c <main+0x28a>
    3164:	80 91 c7 01 	lds	r24, 0x01C7
    3168:	0e 94 f1 1a 	call	0x35e2	; 0x35e2 <_Z9GoToSleeph>
		
		//Add logic for an invalid date and time somehow getting in here
		if (flagInvalidDateTime && !flagShutdown){
    316c:	80 91 c3 01 	lds	r24, 0x01C3
    3170:	88 23       	and	r24, r24
    3172:	09 f4       	brne	.+2      	; 0x3176 <main+0x294>
    3174:	08 cf       	rjmp	.-496    	; 0x2f86 <main+0xa4>
    3176:	80 91 c7 01 	lds	r24, 0x01C7
    317a:	88 23       	and	r24, r24
    317c:	09 f0       	breq	.+2      	; 0x3180 <main+0x29e>
    317e:	03 cf       	rjmp	.-506    	; 0x2f86 <main+0xa4>
			flagInvalidDateTime=fFalse;
    3180:	10 92 c3 01 	sts	0x01C3, r1
			flagUserClock=fTrue;
    3184:	81 e0       	ldi	r24, 0x01	; 1
    3186:	80 93 c2 01 	sts	0x01C2, r24
			flagUpdateGAVRClock=fFalse;
    318a:	10 92 c0 01 	sts	0x01C0, r1
		flagFreshStart=fFalse;
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
	//main programming loop
	while(fTrue)
    318e:	fb ce       	rjmp	.-522    	; 0x2f86 <main+0xa4>

00003190 <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    3190:	cf 93       	push	r28
    3192:	df 93       	push	r29
    3194:	cd b7       	in	r28, 0x3d	; 61
    3196:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    3198:	81 e2       	ldi	r24, 0x21	; 33
    319a:	90 e0       	ldi	r25, 0x00	; 0
    319c:	fc 01       	movw	r30, r24
    319e:	10 82       	st	Z, r1
	DDRB = 0;
    31a0:	84 e2       	ldi	r24, 0x24	; 36
    31a2:	90 e0       	ldi	r25, 0x00	; 0
    31a4:	fc 01       	movw	r30, r24
    31a6:	10 82       	st	Z, r1
	DDRC = 0;
    31a8:	87 e2       	ldi	r24, 0x27	; 39
    31aa:	90 e0       	ldi	r25, 0x00	; 0
    31ac:	fc 01       	movw	r30, r24
    31ae:	10 82       	st	Z, r1
	DDRD = 0;
    31b0:	8a e2       	ldi	r24, 0x2A	; 42
    31b2:	90 e0       	ldi	r25, 0x00	; 0
    31b4:	fc 01       	movw	r30, r24
    31b6:	10 82       	st	Z, r1
	
	PORTA = 0;
    31b8:	82 e2       	ldi	r24, 0x22	; 34
    31ba:	90 e0       	ldi	r25, 0x00	; 0
    31bc:	fc 01       	movw	r30, r24
    31be:	10 82       	st	Z, r1
	PORTB = 0;
    31c0:	85 e2       	ldi	r24, 0x25	; 37
    31c2:	90 e0       	ldi	r25, 0x00	; 0
    31c4:	fc 01       	movw	r30, r24
    31c6:	10 82       	st	Z, r1
	PORTC = 0;
    31c8:	88 e2       	ldi	r24, 0x28	; 40
    31ca:	90 e0       	ldi	r25, 0x00	; 0
    31cc:	fc 01       	movw	r30, r24
    31ce:	10 82       	st	Z, r1
	PORTD = 0;
    31d0:	8b e2       	ldi	r24, 0x2B	; 43
    31d2:	90 e0       	ldi	r25, 0x00	; 0
    31d4:	fc 01       	movw	r30, r24
    31d6:	10 82       	st	Z, r1
}
    31d8:	df 91       	pop	r29
    31da:	cf 91       	pop	r28
    31dc:	08 95       	ret

000031de <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    31de:	cf 93       	push	r28
    31e0:	df 93       	push	r29
    31e2:	00 d0       	rcall	.+0      	; 0x31e4 <_Z7AppInitj+0x6>
    31e4:	cd b7       	in	r28, 0x3d	; 61
    31e6:	de b7       	in	r29, 0x3e	; 62
    31e8:	9a 83       	std	Y+2, r25	; 0x02
    31ea:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    31ec:	84 ec       	ldi	r24, 0xC4	; 196
    31ee:	90 e0       	ldi	r25, 0x00	; 0
    31f0:	29 81       	ldd	r18, Y+1	; 0x01
    31f2:	fc 01       	movw	r30, r24
    31f4:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    31f6:	85 ec       	ldi	r24, 0xC5	; 197
    31f8:	90 e0       	ldi	r25, 0x00	; 0
    31fa:	29 81       	ldd	r18, Y+1	; 0x01
    31fc:	3a 81       	ldd	r19, Y+2	; 0x02
    31fe:	23 2f       	mov	r18, r19
    3200:	33 27       	eor	r19, r19
    3202:	fc 01       	movw	r30, r24
    3204:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    3206:	81 ec       	ldi	r24, 0xC1	; 193
    3208:	90 e0       	ldi	r25, 0x00	; 0
    320a:	28 e1       	ldi	r18, 0x18	; 24
    320c:	fc 01       	movw	r30, r24
    320e:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    3210:	82 ec       	ldi	r24, 0xC2	; 194
    3212:	90 e0       	ldi	r25, 0x00	; 0
    3214:	26 e0       	ldi	r18, 0x06	; 6
    3216:	fc 01       	movw	r30, r24
    3218:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Set BAUD for UART1
	UBRR1L = ubrr;
    321a:	8c ec       	ldi	r24, 0xCC	; 204
    321c:	90 e0       	ldi	r25, 0x00	; 0
    321e:	29 81       	ldd	r18, Y+1	; 0x01
    3220:	fc 01       	movw	r30, r24
    3222:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);
    3224:	85 ec       	ldi	r24, 0xC5	; 197
    3226:	90 e0       	ldi	r25, 0x00	; 0
    3228:	29 81       	ldd	r18, Y+1	; 0x01
    322a:	3a 81       	ldd	r19, Y+2	; 0x02
    322c:	23 2f       	mov	r18, r19
    322e:	33 27       	eor	r19, r19
    3230:	fc 01       	movw	r30, r24
    3232:	20 83       	st	Z, r18
	//UCSR1A |= (1 << U2X1);
	
	//Enable UART_TX1 and UART_RX1
	UCSR1B = (1 << TXEN1)|(1 << RXEN1);
    3234:	89 ec       	ldi	r24, 0xC9	; 201
    3236:	90 e0       	ldi	r25, 0x00	; 0
    3238:	28 e1       	ldi	r18, 0x18	; 24
    323a:	fc 01       	movw	r30, r24
    323c:	20 83       	st	Z, r18
	UCSR1C = (1 << UCSZ11)|(1 << UCSZ10);
    323e:	8a ec       	ldi	r24, 0xCA	; 202
    3240:	90 e0       	ldi	r25, 0x00	; 0
    3242:	26 e0       	ldi	r18, 0x06	; 6
    3244:	fc 01       	movw	r30, r24
    3246:	20 83       	st	Z, r18
	//UCSR1B |= (1 << RXCIE1);
	__killUARTrec();
    3248:	81 ec       	ldi	r24, 0xC1	; 193
    324a:	90 e0       	ldi	r25, 0x00	; 0
    324c:	21 ec       	ldi	r18, 0xC1	; 193
    324e:	30 e0       	ldi	r19, 0x00	; 0
    3250:	f9 01       	movw	r30, r18
    3252:	20 81       	ld	r18, Z
    3254:	20 68       	ori	r18, 0x80	; 128
    3256:	fc 01       	movw	r30, r24
    3258:	20 83       	st	Z, r18
    325a:	89 ec       	ldi	r24, 0xC9	; 201
    325c:	90 e0       	ldi	r25, 0x00	; 0
    325e:	29 ec       	ldi	r18, 0xC9	; 201
    3260:	30 e0       	ldi	r19, 0x00	; 0
    3262:	f9 01       	movw	r30, r18
    3264:	20 81       	ld	r18, Z
    3266:	20 68       	ori	r18, 0x80	; 128
    3268:	fc 01       	movw	r30, r24
    326a:	20 83       	st	Z, r18
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM0)|(1 << PRUSART1)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    326c:	84 e6       	ldi	r24, 0x64	; 100
    326e:	90 e0       	ldi	r25, 0x00	; 0
    3270:	24 e6       	ldi	r18, 0x64	; 100
    3272:	30 e0       	ldi	r19, 0x00	; 0
    3274:	f9 01       	movw	r30, r18
    3276:	20 81       	ld	r18, Z
    3278:	2d 6b       	ori	r18, 0xBD	; 189
    327a:	fc 01       	movw	r30, r24
    327c:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    327e:	8a e2       	ldi	r24, 0x2A	; 42
    3280:	90 e0       	ldi	r25, 0x00	; 0
    3282:	2a e2       	ldi	r18, 0x2A	; 42
    3284:	30 e0       	ldi	r19, 0x00	; 0
    3286:	f9 01       	movw	r30, r18
    3288:	20 81       	ld	r18, Z
    328a:	20 68       	ori	r18, 0x80	; 128
    328c:	fc 01       	movw	r30, r24
    328e:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    3290:	87 e2       	ldi	r24, 0x27	; 39
    3292:	90 e0       	ldi	r25, 0x00	; 0
    3294:	27 e2       	ldi	r18, 0x27	; 39
    3296:	30 e0       	ldi	r19, 0x00	; 0
    3298:	f9 01       	movw	r30, r18
    329a:	20 81       	ld	r18, Z
    329c:	24 60       	ori	r18, 0x04	; 4
    329e:	fc 01       	movw	r30, r24
    32a0:	20 83       	st	Z, r18
	prtSLEEPled |= (1 << bnSLEEPled);	//turn off initially
    32a2:	8b e2       	ldi	r24, 0x2B	; 43
    32a4:	90 e0       	ldi	r25, 0x00	; 0
    32a6:	2b e2       	ldi	r18, 0x2B	; 43
    32a8:	30 e0       	ldi	r19, 0x00	; 0
    32aa:	f9 01       	movw	r30, r18
    32ac:	20 81       	ld	r18, Z
    32ae:	20 68       	ori	r18, 0x80	; 128
    32b0:	fc 01       	movw	r30, r24
    32b2:	20 83       	st	Z, r18
	prtSTATUSled &= ~(1 << bnSTATUSled);	//turn on initially
    32b4:	88 e2       	ldi	r24, 0x28	; 40
    32b6:	90 e0       	ldi	r25, 0x00	; 0
    32b8:	28 e2       	ldi	r18, 0x28	; 40
    32ba:	30 e0       	ldi	r19, 0x00	; 0
    32bc:	f9 01       	movw	r30, r18
    32be:	20 81       	ld	r18, Z
    32c0:	2b 7f       	andi	r18, 0xFB	; 251
    32c2:	fc 01       	movw	r30, r24
    32c4:	20 83       	st	Z, r18
	
	//Enable BB and GAVR interrupts for COMMUNICATION
	ddrBONEINT |= (1 << bnBONEINT);
    32c6:	81 e2       	ldi	r24, 0x21	; 33
    32c8:	90 e0       	ldi	r25, 0x00	; 0
    32ca:	21 e2       	ldi	r18, 0x21	; 33
    32cc:	30 e0       	ldi	r19, 0x00	; 0
    32ce:	f9 01       	movw	r30, r18
    32d0:	20 81       	ld	r18, Z
    32d2:	22 60       	ori	r18, 0x02	; 2
    32d4:	fc 01       	movw	r30, r24
    32d6:	20 83       	st	Z, r18
	ddrGAVRINT |= (1 << bnGAVRINT);
    32d8:	84 e2       	ldi	r24, 0x24	; 36
    32da:	90 e0       	ldi	r25, 0x00	; 0
    32dc:	24 e2       	ldi	r18, 0x24	; 36
    32de:	30 e0       	ldi	r19, 0x00	; 0
    32e0:	f9 01       	movw	r30, r18
    32e2:	20 81       	ld	r18, Z
    32e4:	28 60       	ori	r18, 0x08	; 8
    32e6:	fc 01       	movw	r30, r24
    32e8:	20 83       	st	Z, r18
	prtBONEINT &= ~(1 << bnBONEINT);
    32ea:	82 e2       	ldi	r24, 0x22	; 34
    32ec:	90 e0       	ldi	r25, 0x00	; 0
    32ee:	22 e2       	ldi	r18, 0x22	; 34
    32f0:	30 e0       	ldi	r19, 0x00	; 0
    32f2:	f9 01       	movw	r30, r18
    32f4:	20 81       	ld	r18, Z
    32f6:	2d 7f       	andi	r18, 0xFD	; 253
    32f8:	fc 01       	movw	r30, r24
    32fa:	20 83       	st	Z, r18
	prtGAVRINT &= ~(1 << bnGAVRINT);
    32fc:	85 e2       	ldi	r24, 0x25	; 37
    32fe:	90 e0       	ldi	r25, 0x00	; 0
    3300:	25 e2       	ldi	r18, 0x25	; 37
    3302:	30 e0       	ldi	r19, 0x00	; 0
    3304:	f9 01       	movw	r30, r18
    3306:	20 81       	ld	r18, Z
    3308:	27 7f       	andi	r18, 0xF7	; 247
    330a:	fc 01       	movw	r30, r24
    330c:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrInterrupts |= (1 << bnGAVRint)|(1 << bnBBint);
    330e:	81 e2       	ldi	r24, 0x21	; 33
    3310:	90 e0       	ldi	r25, 0x00	; 0
    3312:	21 e2       	ldi	r18, 0x21	; 33
    3314:	30 e0       	ldi	r19, 0x00	; 0
    3316:	f9 01       	movw	r30, r18
    3318:	20 81       	ld	r18, Z
    331a:	2c 60       	ori	r18, 0x0C	; 12
    331c:	fc 01       	movw	r30, r24
    331e:	20 83       	st	Z, r18
	prtInterrupts &= ~((1 << bnGAVRint)|(1 << bnBBint));
    3320:	82 e2       	ldi	r24, 0x22	; 34
    3322:	90 e0       	ldi	r25, 0x00	; 0
    3324:	22 e2       	ldi	r18, 0x22	; 34
    3326:	30 e0       	ldi	r19, 0x00	; 0
    3328:	f9 01       	movw	r30, r18
    332a:	20 81       	ld	r18, Z
    332c:	23 7f       	andi	r18, 0xF3	; 243
    332e:	fc 01       	movw	r30, r24
    3330:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen)|(1 << bnBBen);
    3332:	81 e2       	ldi	r24, 0x21	; 33
    3334:	90 e0       	ldi	r25, 0x00	; 0
    3336:	21 e2       	ldi	r18, 0x21	; 33
    3338:	30 e0       	ldi	r19, 0x00	; 0
    333a:	f9 01       	movw	r30, r18
    333c:	20 81       	ld	r18, Z
    333e:	20 6f       	ori	r18, 0xF0	; 240
    3340:	fc 01       	movw	r30, r24
    3342:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    3344:	84 e2       	ldi	r24, 0x24	; 36
    3346:	90 e0       	ldi	r25, 0x00	; 0
    3348:	24 e2       	ldi	r18, 0x24	; 36
    334a:	30 e0       	ldi	r19, 0x00	; 0
    334c:	f9 01       	movw	r30, r18
    334e:	20 81       	ld	r18, Z
    3350:	21 60       	ori	r18, 0x01	; 1
    3352:	fc 01       	movw	r30, r24
    3354:	20 83       	st	Z, r18
	ddrMAINen |= (1 << bnMAINen);
    3356:	87 e2       	ldi	r24, 0x27	; 39
    3358:	90 e0       	ldi	r25, 0x00	; 0
    335a:	27 e2       	ldi	r18, 0x27	; 39
    335c:	30 e0       	ldi	r19, 0x00	; 0
    335e:	f9 01       	movw	r30, r18
    3360:	20 81       	ld	r18, Z
    3362:	21 60       	ori	r18, 0x01	; 1
    3364:	fc 01       	movw	r30, r24
    3366:	20 83       	st	Z, r18
	__killMain();
    3368:	88 e2       	ldi	r24, 0x28	; 40
    336a:	90 e0       	ldi	r25, 0x00	; 0
    336c:	28 e2       	ldi	r18, 0x28	; 40
    336e:	30 e0       	ldi	r19, 0x00	; 0
    3370:	f9 01       	movw	r30, r18
    3372:	20 81       	ld	r18, Z
    3374:	2e 7f       	andi	r18, 0xFE	; 254
    3376:	fc 01       	movw	r30, r24
    3378:	20 83       	st	Z, r18
	__killBeagleBone();
    337a:	82 e2       	ldi	r24, 0x22	; 34
    337c:	90 e0       	ldi	r25, 0x00	; 0
    337e:	22 e2       	ldi	r18, 0x22	; 34
    3380:	30 e0       	ldi	r19, 0x00	; 0
    3382:	f9 01       	movw	r30, r18
    3384:	20 81       	ld	r18, Z
    3386:	2f 7e       	andi	r18, 0xEF	; 239
    3388:	fc 01       	movw	r30, r24
    338a:	20 83       	st	Z, r18
	__enableTemp();
    338c:	85 e2       	ldi	r24, 0x25	; 37
    338e:	90 e0       	ldi	r25, 0x00	; 0
    3390:	25 e2       	ldi	r18, 0x25	; 37
    3392:	30 e0       	ldi	r19, 0x00	; 0
    3394:	f9 01       	movw	r30, r18
    3396:	20 81       	ld	r18, Z
    3398:	21 60       	ori	r18, 0x01	; 1
    339a:	fc 01       	movw	r30, r24
    339c:	20 83       	st	Z, r18
	__killLCD();
    339e:	82 e2       	ldi	r24, 0x22	; 34
    33a0:	90 e0       	ldi	r25, 0x00	; 0
    33a2:	22 e2       	ldi	r18, 0x22	; 34
    33a4:	30 e0       	ldi	r19, 0x00	; 0
    33a6:	f9 01       	movw	r30, r18
    33a8:	20 81       	ld	r18, Z
    33aa:	2f 7d       	andi	r18, 0xDF	; 223
    33ac:	fc 01       	movw	r30, r24
    33ae:	20 83       	st	Z, r18
	__killGPSandGAVR();
    33b0:	82 e2       	ldi	r24, 0x22	; 34
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	22 e2       	ldi	r18, 0x22	; 34
    33b6:	30 e0       	ldi	r19, 0x00	; 0
    33b8:	f9 01       	movw	r30, r18
    33ba:	20 81       	ld	r18, Z
    33bc:	2f 73       	andi	r18, 0x3F	; 63
    33be:	fc 01       	movw	r30, r24
    33c0:	20 83       	st	Z, r18

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	__killCommINT();
    33c2:	8d e3       	ldi	r24, 0x3D	; 61
    33c4:	90 e0       	ldi	r25, 0x00	; 0
    33c6:	fc 01       	movw	r30, r24
    33c8:	10 82       	st	Z, r1
    33ca:	8d e6       	ldi	r24, 0x6D	; 109
    33cc:	90 e0       	ldi	r25, 0x00	; 0
    33ce:	fc 01       	movw	r30, r24
    33d0:	10 82       	st	Z, r1
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    33d2:	89 e6       	ldi	r24, 0x69	; 105
    33d4:	90 e0       	ldi	r25, 0x00	; 0
    33d6:	20 e3       	ldi	r18, 0x30	; 48
    33d8:	fc 01       	movw	r30, r24
    33da:	20 83       	st	Z, r18
	//Enable PCINT17
	PCICR |= (1 << PCIE0);
    33dc:	88 e6       	ldi	r24, 0x68	; 104
    33de:	90 e0       	ldi	r25, 0x00	; 0
    33e0:	28 e6       	ldi	r18, 0x68	; 104
    33e2:	30 e0       	ldi	r19, 0x00	; 0
    33e4:	f9 01       	movw	r30, r18
    33e6:	20 81       	ld	r18, Z
    33e8:	21 60       	ori	r18, 0x01	; 1
    33ea:	fc 01       	movw	r30, r24
    33ec:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    33ee:	84 e2       	ldi	r24, 0x24	; 36
    33f0:	90 e0       	ldi	r25, 0x00	; 0
    33f2:	24 e2       	ldi	r18, 0x24	; 36
    33f4:	30 e0       	ldi	r19, 0x00	; 0
    33f6:	f9 01       	movw	r30, r18
    33f8:	20 81       	ld	r18, Z
    33fa:	20 6b       	ori	r18, 0xB0	; 176
    33fc:	fc 01       	movw	r30, r24
    33fe:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    3400:	84 e2       	ldi	r24, 0x24	; 36
    3402:	90 e0       	ldi	r25, 0x00	; 0
    3404:	24 e2       	ldi	r18, 0x24	; 36
    3406:	30 e0       	ldi	r19, 0x00	; 0
    3408:	f9 01       	movw	r30, r18
    340a:	20 81       	ld	r18, Z
    340c:	2f 7b       	andi	r18, 0xBF	; 191
    340e:	fc 01       	movw	r30, r24
    3410:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    3412:	85 e2       	ldi	r24, 0x25	; 37
    3414:	90 e0       	ldi	r25, 0x00	; 0
    3416:	25 e2       	ldi	r18, 0x25	; 37
    3418:	30 e0       	ldi	r19, 0x00	; 0
    341a:	f9 01       	movw	r30, r18
    341c:	20 81       	ld	r18, Z
    341e:	20 69       	ori	r18, 0x90	; 144
    3420:	fc 01       	movw	r30, r24
    3422:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    3424:	85 e2       	ldi	r24, 0x25	; 37
    3426:	90 e0       	ldi	r25, 0x00	; 0
    3428:	25 e2       	ldi	r18, 0x25	; 37
    342a:	30 e0       	ldi	r19, 0x00	; 0
    342c:	f9 01       	movw	r30, r18
    342e:	20 81       	ld	r18, Z
    3430:	2f 7d       	andi	r18, 0xDF	; 223
    3432:	fc 01       	movw	r30, r24
    3434:	20 83       	st	Z, r18
	
}
    3436:	0f 90       	pop	r0
    3438:	0f 90       	pop	r0
    343a:	df 91       	pop	r29
    343c:	cf 91       	pop	r28
    343e:	08 95       	ret

00003440 <_Z9InitBoolsv>:
/*************************************************************************************************************/
void InitBools(){
    3440:	cf 93       	push	r28
    3442:	df 93       	push	r29
    3444:	cd b7       	in	r28, 0x3d	; 61
    3446:	de b7       	in	r29, 0x3e	; 62
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    3448:	81 e0       	ldi	r24, 0x01	; 1
    344a:	80 93 81 01 	sts	0x0181, r24
	flagReceivingBone = fFalse;
    344e:	10 92 ba 01 	sts	0x01BA, r1
	flagNormalMode=fTrue;
    3452:	81 e0       	ldi	r24, 0x01	; 1
    3454:	80 93 bb 01 	sts	0x01BB, r24
	flagReceivingGAVR=fFalse;
    3458:	10 92 bc 01 	sts	0x01BC, r1
	flagWaitingForReceiveGAVR=fFalse;
    345c:	10 92 bd 01 	sts	0x01BD, r1
	flagWaitingForSYNGAVR=fFalse;
    3460:	10 92 be 01 	sts	0x01BE, r1
	flagWaitingForSYNBone=fFalse;
    3464:	10 92 bf 01 	sts	0x01BF, r1

	flagUpdateGAVRClock=fFalse;
    3468:	10 92 c0 01 	sts	0x01C0, r1
	flagSendingGAVR=fFalse;
    346c:	10 92 c1 01 	sts	0x01C1, r1
	flagUserClock=fFalse;
    3470:	10 92 c2 01 	sts	0x01C2, r1
	flagInvalidDateTime=fFalse;
    3474:	10 92 c3 01 	sts	0x01C3, r1
	flagWaitingToSendGAVR=fFalse;
    3478:	10 92 c4 01 	sts	0x01C4, r1
	flagGPSTime=fFalse;
    347c:	10 92 c5 01 	sts	0x01C5, r1
	
	restart=fFalse;
    3480:	10 92 ca 01 	sts	0x01CA, r1
	//flagNewShutdown=fFalse;
	flagShutdown=fFalse;		//Initialized in startup procedure in beginning of "main"
    3484:	10 92 c7 01 	sts	0x01C7, r1
	flagGoodVolts=fFalse;
    3488:	10 92 c9 01 	sts	0x01C9, r1
	flagGoodTemp=fFalse;
    348c:	10 92 c8 01 	sts	0x01C8, r1
	//flagFreshStart=fTrue;		//Initialized in startup procedure in beginning of "main"
}
    3490:	df 91       	pop	r29
    3492:	cf 91       	pop	r28
    3494:	08 95       	ret

00003496 <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    3496:	cf 93       	push	r28
    3498:	df 93       	push	r29
    349a:	cd b7       	in	r28, 0x3d	; 61
    349c:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    349e:	84 e6       	ldi	r24, 0x64	; 100
    34a0:	90 e0       	ldi	r25, 0x00	; 0
    34a2:	24 e6       	ldi	r18, 0x64	; 100
    34a4:	30 e0       	ldi	r19, 0x00	; 0
    34a6:	f9 01       	movw	r30, r18
    34a8:	20 81       	ld	r18, Z
    34aa:	2f 7b       	andi	r18, 0xBF	; 191
    34ac:	fc 01       	movw	r30, r24
    34ae:	20 83       	st	Z, r18
	Wait_ms(5);	//give it time to power on
    34b0:	85 e0       	ldi	r24, 0x05	; 5
    34b2:	90 e0       	ldi	r25, 0x00	; 0
    34b4:	0e 94 89 1a 	call	0x3512	; 0x3512 <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    34b8:	86 eb       	ldi	r24, 0xB6	; 182
    34ba:	90 e0       	ldi	r25, 0x00	; 0
    34bc:	26 eb       	ldi	r18, 0xB6	; 182
    34be:	30 e0       	ldi	r19, 0x00	; 0
    34c0:	f9 01       	movw	r30, r18
    34c2:	20 81       	ld	r18, Z
    34c4:	20 62       	ori	r18, 0x20	; 32
    34c6:	fc 01       	movw	r30, r24
    34c8:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    34ca:	81 eb       	ldi	r24, 0xB1	; 177
    34cc:	90 e0       	ldi	r25, 0x00	; 0
    34ce:	21 eb       	ldi	r18, 0xB1	; 177
    34d0:	30 e0       	ldi	r19, 0x00	; 0
    34d2:	f9 01       	movw	r30, r18
    34d4:	20 81       	ld	r18, Z
    34d6:	25 60       	ori	r18, 0x05	; 5
    34d8:	fc 01       	movw	r30, r24
    34da:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    34dc:	86 eb       	ldi	r24, 0xB6	; 182
    34de:	90 e0       	ldi	r25, 0x00	; 0
    34e0:	fc 01       	movw	r30, r24
    34e2:	80 81       	ld	r24, Z
    34e4:	88 2f       	mov	r24, r24
    34e6:	90 e0       	ldi	r25, 0x00	; 0
    34e8:	81 71       	andi	r24, 0x11	; 17
    34ea:	90 70       	andi	r25, 0x00	; 0
    34ec:	21 e0       	ldi	r18, 0x01	; 1
    34ee:	00 97       	sbiw	r24, 0x00	; 0
    34f0:	09 f4       	brne	.+2      	; 0x34f4 <_Z14EnableRTCTimerv+0x5e>
    34f2:	20 e0       	ldi	r18, 0x00	; 0
    34f4:	22 23       	and	r18, r18
    34f6:	91 f7       	brne	.-28     	; 0x34dc <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    34f8:	87 e3       	ldi	r24, 0x37	; 55
    34fa:	90 e0       	ldi	r25, 0x00	; 0
    34fc:	21 e0       	ldi	r18, 0x01	; 1
    34fe:	fc 01       	movw	r30, r24
    3500:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    3502:	80 e7       	ldi	r24, 0x70	; 112
    3504:	90 e0       	ldi	r25, 0x00	; 0
    3506:	21 e0       	ldi	r18, 0x01	; 1
    3508:	fc 01       	movw	r30, r24
    350a:	20 83       	st	Z, r18
	
	//Away we go
}
    350c:	df 91       	pop	r29
    350e:	cf 91       	pop	r28
    3510:	08 95       	ret

00003512 <_Z7Wait_msi>:
/*************************************************************************************************************/
void Wait_ms(int delay)
{
    3512:	cf 93       	push	r28
    3514:	df 93       	push	r29
    3516:	00 d0       	rcall	.+0      	; 0x3518 <_Z7Wait_msi+0x6>
    3518:	00 d0       	rcall	.+0      	; 0x351a <_Z7Wait_msi+0x8>
    351a:	cd b7       	in	r28, 0x3d	; 61
    351c:	de b7       	in	r29, 0x3e	; 62
    351e:	9c 83       	std	Y+4, r25	; 0x04
    3520:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    3522:	17 c0       	rjmp	.+46     	; 0x3552 <_Z7Wait_msi+0x40>
		for(i = 0; i < 200; i++){
    3524:	1a 82       	std	Y+2, r1	; 0x02
    3526:	19 82       	std	Y+1, r1	; 0x01
    3528:	06 c0       	rjmp	.+12     	; 0x3536 <_Z7Wait_msi+0x24>
			asm volatile("nop");
    352a:	00 00       	nop
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 200; i++){
    352c:	89 81       	ldd	r24, Y+1	; 0x01
    352e:	9a 81       	ldd	r25, Y+2	; 0x02
    3530:	01 96       	adiw	r24, 0x01	; 1
    3532:	9a 83       	std	Y+2, r25	; 0x02
    3534:	89 83       	std	Y+1, r24	; 0x01
    3536:	89 81       	ldd	r24, Y+1	; 0x01
    3538:	9a 81       	ldd	r25, Y+2	; 0x02
    353a:	21 e0       	ldi	r18, 0x01	; 1
    353c:	88 3c       	cpi	r24, 0xC8	; 200
    353e:	91 05       	cpc	r25, r1
    3540:	0c f0       	brlt	.+2      	; 0x3544 <_Z7Wait_msi+0x32>
    3542:	20 e0       	ldi	r18, 0x00	; 0
    3544:	22 23       	and	r18, r18
    3546:	89 f7       	brne	.-30     	; 0x352a <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    3548:	8b 81       	ldd	r24, Y+3	; 0x03
    354a:	9c 81       	ldd	r25, Y+4	; 0x04
    354c:	01 97       	sbiw	r24, 0x01	; 1
    354e:	9c 83       	std	Y+4, r25	; 0x04
    3550:	8b 83       	std	Y+3, r24	; 0x03
/*************************************************************************************************************/
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
    3552:	21 e0       	ldi	r18, 0x01	; 1
    3554:	8b 81       	ldd	r24, Y+3	; 0x03
    3556:	9c 81       	ldd	r25, Y+4	; 0x04
    3558:	18 16       	cp	r1, r24
    355a:	19 06       	cpc	r1, r25
    355c:	0c f0       	brlt	.+2      	; 0x3560 <_Z7Wait_msi+0x4e>
    355e:	20 e0       	ldi	r18, 0x00	; 0
    3560:	22 23       	and	r18, r18
    3562:	01 f7       	brne	.-64     	; 0x3524 <_Z7Wait_msi+0x12>
		for(i = 0; i < 200; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    3564:	0f 90       	pop	r0
    3566:	0f 90       	pop	r0
    3568:	0f 90       	pop	r0
    356a:	0f 90       	pop	r0
    356c:	df 91       	pop	r29
    356e:	cf 91       	pop	r28
    3570:	08 95       	ret

00003572 <_Z8Wait_seci>:
/************************************************************************************************************/
void Wait_sec(int sec){
    3572:	cf 93       	push	r28
    3574:	df 93       	push	r29
    3576:	00 d0       	rcall	.+0      	; 0x3578 <_Z8Wait_seci+0x6>
    3578:	00 d0       	rcall	.+0      	; 0x357a <_Z8Wait_seci+0x8>
    357a:	00 d0       	rcall	.+0      	; 0x357c <_Z8Wait_seci+0xa>
    357c:	cd b7       	in	r28, 0x3d	; 61
    357e:	de b7       	in	r29, 0x3e	; 62
    3580:	9e 83       	std	Y+6, r25	; 0x06
    3582:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    3584:	82 e9       	ldi	r24, 0x92	; 146
    3586:	91 e0       	ldi	r25, 0x01	; 1
    3588:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    358c:	88 2f       	mov	r24, r24
    358e:	90 e0       	ldi	r25, 0x00	; 0
    3590:	9a 83       	std	Y+2, r25	; 0x02
    3592:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    3594:	29 81       	ldd	r18, Y+1	; 0x01
    3596:	3a 81       	ldd	r19, Y+2	; 0x02
    3598:	8d 81       	ldd	r24, Y+5	; 0x05
    359a:	9e 81       	ldd	r25, Y+6	; 0x06
    359c:	82 0f       	add	r24, r18
    359e:	93 1f       	adc	r25, r19
    35a0:	2c e3       	ldi	r18, 0x3C	; 60
    35a2:	30 e0       	ldi	r19, 0x00	; 0
    35a4:	b9 01       	movw	r22, r18
    35a6:	0e 94 a2 1e 	call	0x3d44	; 0x3d44 <__divmodhi4>
    35aa:	9c 83       	std	Y+4, r25	; 0x04
    35ac:	8b 83       	std	Y+3, r24	; 0x03
	while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    35ae:	01 c0       	rjmp	.+2      	; 0x35b2 <_Z8Wait_seci+0x40>
    35b0:	00 00       	nop
    35b2:	82 e9       	ldi	r24, 0x92	; 146
    35b4:	91 e0       	ldi	r25, 0x01	; 1
    35b6:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    35ba:	28 2f       	mov	r18, r24
    35bc:	30 e0       	ldi	r19, 0x00	; 0
    35be:	8b 81       	ldd	r24, Y+3	; 0x03
    35c0:	9c 81       	ldd	r25, Y+4	; 0x04
    35c2:	41 e0       	ldi	r20, 0x01	; 1
    35c4:	28 17       	cp	r18, r24
    35c6:	39 07       	cpc	r19, r25
    35c8:	09 f4       	brne	.+2      	; 0x35cc <_Z8Wait_seci+0x5a>
    35ca:	40 e0       	ldi	r20, 0x00	; 0
    35cc:	44 23       	and	r20, r20
    35ce:	81 f7       	brne	.-32     	; 0x35b0 <_Z8Wait_seci+0x3e>
}
    35d0:	26 96       	adiw	r28, 0x06	; 6
    35d2:	0f b6       	in	r0, 0x3f	; 63
    35d4:	f8 94       	cli
    35d6:	de bf       	out	0x3e, r29	; 62
    35d8:	0f be       	out	0x3f, r0	; 63
    35da:	cd bf       	out	0x3d, r28	; 61
    35dc:	df 91       	pop	r29
    35de:	cf 91       	pop	r28
    35e0:	08 95       	ret

000035e2 <_Z9GoToSleeph>:

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    35e2:	cf 93       	push	r28
    35e4:	df 93       	push	r29
    35e6:	00 d0       	rcall	.+0      	; 0x35e8 <_Z9GoToSleeph+0x6>
    35e8:	00 d0       	rcall	.+0      	; 0x35ea <_Z9GoToSleeph+0x8>
    35ea:	0f 92       	push	r0
    35ec:	cd b7       	in	r28, 0x3d	; 61
    35ee:	de b7       	in	r29, 0x3e	; 62
    35f0:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    35f2:	78 94       	sei
		int sleepTime, sleepTicks = 0;
    35f4:	1c 82       	std	Y+4, r1	; 0x04
    35f6:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong){
    35f8:	8d 81       	ldd	r24, Y+5	; 0x05
    35fa:	88 23       	and	r24, r24
    35fc:	29 f0       	breq	.+10     	; 0x3608 <_Z9GoToSleeph+0x26>
			sleepTime = SLEEP_TICKS_LOWV;
    35fe:	8c e0       	ldi	r24, 0x0C	; 12
    3600:	90 e0       	ldi	r25, 0x00	; 0
    3602:	9a 83       	std	Y+2, r25	; 0x02
    3604:	89 83       	std	Y+1, r24	; 0x01
    3606:	04 c0       	rjmp	.+8      	; 0x3610 <_Z9GoToSleeph+0x2e>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    3608:	8a e0       	ldi	r24, 0x0A	; 10
    360a:	90 e0       	ldi	r25, 0x00	; 0
    360c:	9a 83       	std	Y+2, r25	; 0x02
    360e:	89 83       	std	Y+1, r24	; 0x01
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    3610:	88 e2       	ldi	r24, 0x28	; 40
    3612:	90 e0       	ldi	r25, 0x00	; 0
    3614:	28 e2       	ldi	r18, 0x28	; 40
    3616:	30 e0       	ldi	r19, 0x00	; 0
    3618:	f9 01       	movw	r30, r18
    361a:	20 81       	ld	r18, Z
    361c:	2b 7f       	andi	r18, 0xFB	; 251
    361e:	fc 01       	movw	r30, r24
    3620:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    3622:	83 e5       	ldi	r24, 0x53	; 83
    3624:	90 e0       	ldi	r25, 0x00	; 0
    3626:	26 e0       	ldi	r18, 0x06	; 6
    3628:	fc 01       	movw	r30, r24
    362a:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    362c:	83 e5       	ldi	r24, 0x53	; 83
    362e:	90 e0       	ldi	r25, 0x00	; 0
    3630:	23 e5       	ldi	r18, 0x53	; 83
    3632:	30 e0       	ldi	r19, 0x00	; 0
    3634:	f9 01       	movw	r30, r18
    3636:	20 81       	ld	r18, Z
    3638:	21 60       	ori	r18, 0x01	; 1
    363a:	fc 01       	movw	r30, r24
    363c:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    363e:	81 e0       	ldi	r24, 0x01	; 1
    3640:	90 e0       	ldi	r25, 0x00	; 0
    3642:	0e 94 89 1a 	call	0x3512	; 0x3512 <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3646:	06 c0       	rjmp	.+12     	; 0x3654 <_Z9GoToSleeph+0x72>
			asm volatile("SLEEP");
    3648:	88 95       	sleep
			sleepTicks++;
    364a:	8b 81       	ldd	r24, Y+3	; 0x03
    364c:	9c 81       	ldd	r25, Y+4	; 0x04
    364e:	01 96       	adiw	r24, 0x01	; 1
    3650:	9c 83       	std	Y+4, r25	; 0x04
    3652:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3654:	2b 81       	ldd	r18, Y+3	; 0x03
    3656:	3c 81       	ldd	r19, Y+4	; 0x04
    3658:	89 81       	ldd	r24, Y+1	; 0x01
    365a:	9a 81       	ldd	r25, Y+2	; 0x02
    365c:	28 17       	cp	r18, r24
    365e:	39 07       	cpc	r19, r25
    3660:	34 f4       	brge	.+12     	; 0x366e <_Z9GoToSleeph+0x8c>
    3662:	80 91 81 01 	lds	r24, 0x0181
    3666:	88 23       	and	r24, r24
    3668:	11 f0       	breq	.+4      	; 0x366e <_Z9GoToSleeph+0x8c>
    366a:	81 e0       	ldi	r24, 0x01	; 1
    366c:	01 c0       	rjmp	.+2      	; 0x3670 <_Z9GoToSleeph+0x8e>
    366e:	80 e0       	ldi	r24, 0x00	; 0
    3670:	88 23       	and	r24, r24
    3672:	51 f7       	brne	.-44     	; 0x3648 <_Z9GoToSleeph+0x66>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(1);
    3674:	81 e0       	ldi	r24, 0x01	; 1
    3676:	90 e0       	ldi	r25, 0x00	; 0
    3678:	0e 94 89 1a 	call	0x3512	; 0x3512 <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSTATUSled |= (1 << bnSTATUSled);
    367c:	88 e2       	ldi	r24, 0x28	; 40
    367e:	90 e0       	ldi	r25, 0x00	; 0
    3680:	28 e2       	ldi	r18, 0x28	; 40
    3682:	30 e0       	ldi	r19, 0x00	; 0
    3684:	f9 01       	movw	r30, r18
    3686:	20 81       	ld	r18, Z
    3688:	24 60       	ori	r18, 0x04	; 4
    368a:	fc 01       	movw	r30, r24
    368c:	20 83       	st	Z, r18
}
    368e:	0f 90       	pop	r0
    3690:	0f 90       	pop	r0
    3692:	0f 90       	pop	r0
    3694:	0f 90       	pop	r0
    3696:	0f 90       	pop	r0
    3698:	df 91       	pop	r29
    369a:	cf 91       	pop	r28
    369c:	08 95       	ret

0000369e <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    369e:	cf 93       	push	r28
    36a0:	df 93       	push	r29
    36a2:	cd b7       	in	r28, 0x3d	; 61
    36a4:	de b7       	in	r29, 0x3e	; 62
    36a6:	2e 97       	sbiw	r28, 0x0e	; 14
    36a8:	0f b6       	in	r0, 0x3f	; 63
    36aa:	f8 94       	cli
    36ac:	de bf       	out	0x3e, r29	; 62
    36ae:	0f be       	out	0x3f, r0	; 63
    36b0:	cd bf       	out	0x3d, r28	; 61
	WORD adcReading = 0;
    36b2:	1c 82       	std	Y+4, r1	; 0x04
    36b4:	1b 82       	std	Y+3, r1	; 0x03
	
	prtInterrupts |= (1 << bnBBint);
    36b6:	82 e2       	ldi	r24, 0x22	; 34
    36b8:	90 e0       	ldi	r25, 0x00	; 0
    36ba:	22 e2       	ldi	r18, 0x22	; 34
    36bc:	30 e0       	ldi	r19, 0x00	; 0
    36be:	f9 01       	movw	r30, r18
    36c0:	20 81       	ld	r18, Z
    36c2:	24 60       	ori	r18, 0x04	; 4
    36c4:	fc 01       	movw	r30, r24
    36c6:	20 83       	st	Z, r18
	
	__killCommINT();
    36c8:	8d e3       	ldi	r24, 0x3D	; 61
    36ca:	90 e0       	ldi	r25, 0x00	; 0
    36cc:	fc 01       	movw	r30, r24
    36ce:	10 82       	st	Z, r1
    36d0:	8d e6       	ldi	r24, 0x6D	; 109
    36d2:	90 e0       	ldi	r25, 0x00	; 0
    36d4:	fc 01       	movw	r30, r24
    36d6:	10 82       	st	Z, r1
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    36d8:	84 e6       	ldi	r24, 0x64	; 100
    36da:	90 e0       	ldi	r25, 0x00	; 0
    36dc:	24 e6       	ldi	r18, 0x64	; 100
    36de:	30 e0       	ldi	r19, 0x00	; 0
    36e0:	f9 01       	movw	r30, r18
    36e2:	20 81       	ld	r18, Z
    36e4:	2e 7f       	andi	r18, 0xFE	; 254
    36e6:	fc 01       	movw	r30, r24
    36e8:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    36ea:	8c e7       	ldi	r24, 0x7C	; 124
    36ec:	90 e0       	ldi	r25, 0x00	; 0
    36ee:	2c e7       	ldi	r18, 0x7C	; 124
    36f0:	30 e0       	ldi	r19, 0x00	; 0
    36f2:	f9 01       	movw	r30, r18
    36f4:	20 81       	ld	r18, Z
    36f6:	20 68       	ori	r18, 0x80	; 128
    36f8:	fc 01       	movw	r30, r24
    36fa:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    36fc:	8a e7       	ldi	r24, 0x7A	; 122
    36fe:	90 e0       	ldi	r25, 0x00	; 0
    3700:	2a e7       	ldi	r18, 0x7A	; 122
    3702:	30 e0       	ldi	r19, 0x00	; 0
    3704:	f9 01       	movw	r30, r18
    3706:	20 81       	ld	r18, Z
    3708:	24 68       	ori	r18, 0x84	; 132
    370a:	fc 01       	movw	r30, r24
    370c:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    370e:	8e e7       	ldi	r24, 0x7E	; 126
    3710:	90 e0       	ldi	r25, 0x00	; 0
    3712:	2e ef       	ldi	r18, 0xFE	; 254
    3714:	fc 01       	movw	r30, r24
    3716:	20 83       	st	Z, r18
	Wait_ms(100);									//Tim for registers to setup
    3718:	84 e6       	ldi	r24, 0x64	; 100
    371a:	90 e0       	ldi	r25, 0x00	; 0
    371c:	0e 94 89 1a 	call	0x3512	; 0x3512 <_Z7Wait_msi>
	
	//cli();
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    3720:	1a 82       	std	Y+2, r1	; 0x02
    3722:	19 82       	std	Y+1, r1	; 0x01
    3724:	1c c0       	rjmp	.+56     	; 0x375e <_Z7TakeADCv+0xc0>
    3726:	8a e7       	ldi	r24, 0x7A	; 122
    3728:	90 e0       	ldi	r25, 0x00	; 0
    372a:	2a e7       	ldi	r18, 0x7A	; 122
    372c:	30 e0       	ldi	r19, 0x00	; 0
    372e:	f9 01       	movw	r30, r18
    3730:	20 81       	ld	r18, Z
    3732:	20 64       	ori	r18, 0x40	; 64
    3734:	fc 01       	movw	r30, r24
    3736:	20 83       	st	Z, r18
    3738:	8a e7       	ldi	r24, 0x7A	; 122
    373a:	90 e0       	ldi	r25, 0x00	; 0
    373c:	fc 01       	movw	r30, r24
    373e:	80 81       	ld	r24, Z
    3740:	88 2f       	mov	r24, r24
    3742:	90 e0       	ldi	r25, 0x00	; 0
    3744:	80 74       	andi	r24, 0x40	; 64
    3746:	90 70       	andi	r25, 0x00	; 0
    3748:	21 e0       	ldi	r18, 0x01	; 1
    374a:	00 97       	sbiw	r24, 0x00	; 0
    374c:	09 f4       	brne	.+2      	; 0x3750 <_Z7TakeADCv+0xb2>
    374e:	20 e0       	ldi	r18, 0x00	; 0
    3750:	22 23       	and	r18, r18
    3752:	91 f7       	brne	.-28     	; 0x3738 <_Z7TakeADCv+0x9a>
    3754:	89 81       	ldd	r24, Y+1	; 0x01
    3756:	9a 81       	ldd	r25, Y+2	; 0x02
    3758:	01 96       	adiw	r24, 0x01	; 1
    375a:	9a 83       	std	Y+2, r25	; 0x02
    375c:	89 83       	std	Y+1, r24	; 0x01
    375e:	21 e0       	ldi	r18, 0x01	; 1
    3760:	89 81       	ldd	r24, Y+1	; 0x01
    3762:	9a 81       	ldd	r25, Y+2	; 0x02
    3764:	82 30       	cpi	r24, 0x02	; 2
    3766:	91 05       	cpc	r25, r1
    3768:	0c f0       	brlt	.+2      	; 0x376c <_Z7TakeADCv+0xce>
    376a:	20 e0       	ldi	r18, 0x00	; 0
    376c:	22 23       	and	r18, r18
    376e:	d9 f6       	brne	.-74     	; 0x3726 <_Z7TakeADCv+0x88>
	
	//Re-enable interrupts	
	//sei();
	
	//Put conversion into buffer
	adcReading = ADCL;
    3770:	88 e7       	ldi	r24, 0x78	; 120
    3772:	90 e0       	ldi	r25, 0x00	; 0
    3774:	fc 01       	movw	r30, r24
    3776:	80 81       	ld	r24, Z
    3778:	88 2f       	mov	r24, r24
    377a:	90 e0       	ldi	r25, 0x00	; 0
    377c:	9c 83       	std	Y+4, r25	; 0x04
    377e:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    3780:	89 e7       	ldi	r24, 0x79	; 121
    3782:	90 e0       	ldi	r25, 0x00	; 0
    3784:	fc 01       	movw	r30, r24
    3786:	80 81       	ld	r24, Z
    3788:	88 2f       	mov	r24, r24
    378a:	90 e0       	ldi	r25, 0x00	; 0
    378c:	98 2f       	mov	r25, r24
    378e:	88 27       	eor	r24, r24
    3790:	2b 81       	ldd	r18, Y+3	; 0x03
    3792:	3c 81       	ldd	r19, Y+4	; 0x04
    3794:	82 2b       	or	r24, r18
    3796:	93 2b       	or	r25, r19
    3798:	9c 83       	std	Y+4, r25	; 0x04
    379a:	8b 83       	std	Y+3, r24	; 0x03
		
	//Assign global reading and set flag
	globalADC=adcReading;
    379c:	8b 81       	ldd	r24, Y+3	; 0x03
    379e:	9c 81       	ldd	r25, Y+4	; 0x04
    37a0:	90 93 8f 01 	sts	0x018F, r25
    37a4:	80 93 8e 01 	sts	0x018E, r24
	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    37a8:	21 e0       	ldi	r18, 0x01	; 1
    37aa:	8b 81       	ldd	r24, Y+3	; 0x03
    37ac:	9c 81       	ldd	r25, Y+4	; 0x04
    37ae:	f3 e0       	ldi	r31, 0x03	; 3
    37b0:	82 37       	cpi	r24, 0x72	; 114
    37b2:	9f 07       	cpc	r25, r31
    37b4:	08 f4       	brcc	.+2      	; 0x37b8 <_Z7TakeADCv+0x11a>
    37b6:	20 e0       	ldi	r18, 0x00	; 0
    37b8:	20 93 c9 01 	sts	0x01C9, r18
		
	//Disable ADC hardware/registers
	ADCSRA = 0;
    37bc:	8a e7       	ldi	r24, 0x7A	; 122
    37be:	90 e0       	ldi	r25, 0x00	; 0
    37c0:	fc 01       	movw	r30, r24
    37c2:	10 82       	st	Z, r1
	ADMUX = 0;
    37c4:	8c e7       	ldi	r24, 0x7C	; 124
    37c6:	90 e0       	ldi	r25, 0x00	; 0
    37c8:	fc 01       	movw	r30, r24
    37ca:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    37cc:	8e e7       	ldi	r24, 0x7E	; 126
    37ce:	90 e0       	ldi	r25, 0x00	; 0
    37d0:	2e e7       	ldi	r18, 0x7E	; 126
    37d2:	30 e0       	ldi	r19, 0x00	; 0
    37d4:	f9 01       	movw	r30, r18
    37d6:	20 81       	ld	r18, Z
    37d8:	21 60       	ori	r18, 0x01	; 1
    37da:	fc 01       	movw	r30, r24
    37dc:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    37de:	84 e6       	ldi	r24, 0x64	; 100
    37e0:	90 e0       	ldi	r25, 0x00	; 0
    37e2:	24 e6       	ldi	r18, 0x64	; 100
    37e4:	30 e0       	ldi	r19, 0x00	; 0
    37e6:	f9 01       	movw	r30, r18
    37e8:	20 81       	ld	r18, Z
    37ea:	21 60       	ori	r18, 0x01	; 1
    37ec:	fc 01       	movw	r30, r24
    37ee:	20 83       	st	Z, r18

	char tempString[10];
	itoa(globalADC,tempString,10);
    37f0:	80 91 8e 01 	lds	r24, 0x018E
    37f4:	90 91 8f 01 	lds	r25, 0x018F
    37f8:	9e 01       	movw	r18, r28
    37fa:	2b 5f       	subi	r18, 0xFB	; 251
    37fc:	3f 4f       	sbci	r19, 0xFF	; 255
    37fe:	b9 01       	movw	r22, r18
    3800:	4a e0       	ldi	r20, 0x0A	; 10
    3802:	50 e0       	ldi	r21, 0x00	; 0
    3804:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <itoa>
	tempString[9]='\0';
    3808:	1e 86       	std	Y+14, r1	; 0x0e
	//PrintBone("ADC: ");
	//PrintBone(tempString);
	prtInterrupts &= ~(1 << bnBBint);
    380a:	82 e2       	ldi	r24, 0x22	; 34
    380c:	90 e0       	ldi	r25, 0x00	; 0
    380e:	22 e2       	ldi	r18, 0x22	; 34
    3810:	30 e0       	ldi	r19, 0x00	; 0
    3812:	f9 01       	movw	r30, r18
    3814:	20 81       	ld	r18, Z
    3816:	2b 7f       	andi	r18, 0xFB	; 251
    3818:	fc 01       	movw	r30, r24
    381a:	20 83       	st	Z, r18
	__enableCommINT();
    381c:	8d e3       	ldi	r24, 0x3D	; 61
    381e:	90 e0       	ldi	r25, 0x00	; 0
    3820:	2d e3       	ldi	r18, 0x3D	; 61
    3822:	30 e0       	ldi	r19, 0x00	; 0
    3824:	f9 01       	movw	r30, r18
    3826:	20 81       	ld	r18, Z
    3828:	24 60       	ori	r18, 0x04	; 4
    382a:	fc 01       	movw	r30, r24
    382c:	20 83       	st	Z, r18
    382e:	8d e6       	ldi	r24, 0x6D	; 109
    3830:	90 e0       	ldi	r25, 0x00	; 0
    3832:	22 e0       	ldi	r18, 0x02	; 2
    3834:	fc 01       	movw	r30, r24
    3836:	20 83       	st	Z, r18
}
    3838:	2e 96       	adiw	r28, 0x0e	; 14
    383a:	0f b6       	in	r0, 0x3f	; 63
    383c:	f8 94       	cli
    383e:	de bf       	out	0x3e, r29	; 62
    3840:	0f be       	out	0x3f, r0	; 63
    3842:	cd bf       	out	0x3d, r28	; 61
    3844:	df 91       	pop	r29
    3846:	cf 91       	pop	r28
    3848:	08 95       	ret

0000384a <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    384a:	cf 93       	push	r28
    384c:	df 93       	push	r29
    384e:	cd b7       	in	r28, 0x3d	; 61
    3850:	de b7       	in	r29, 0x3e	; 62
    3852:	2b 97       	sbiw	r28, 0x0b	; 11
    3854:	0f b6       	in	r0, 0x3f	; 63
    3856:	f8 94       	cli
    3858:	de bf       	out	0x3e, r29	; 62
    385a:	0f be       	out	0x3f, r0	; 63
    385c:	cd bf       	out	0x3d, r28	; 61
	WORD rawTemp = 0;
    385e:	1a 82       	std	Y+2, r1	; 0x02
    3860:	19 82       	std	Y+1, r1	; 0x01

	__killCommINT();
    3862:	8d e3       	ldi	r24, 0x3D	; 61
    3864:	90 e0       	ldi	r25, 0x00	; 0
    3866:	fc 01       	movw	r30, r24
    3868:	10 82       	st	Z, r1
    386a:	8d e6       	ldi	r24, 0x6D	; 109
    386c:	90 e0       	ldi	r25, 0x00	; 0
    386e:	fc 01       	movw	r30, r24
    3870:	10 82       	st	Z, r1

	PRR0 &= ~(1 << PRSPI);	
    3872:	84 e6       	ldi	r24, 0x64	; 100
    3874:	90 e0       	ldi	r25, 0x00	; 0
    3876:	24 e6       	ldi	r18, 0x64	; 100
    3878:	30 e0       	ldi	r19, 0x00	; 0
    387a:	f9 01       	movw	r30, r18
    387c:	20 81       	ld	r18, Z
    387e:	2b 7f       	andi	r18, 0xFB	; 251
    3880:	fc 01       	movw	r30, r24
    3882:	20 83       	st	Z, r18
	SPCR |= (1 << MSTR)|(1 << SPE)|(1 << SPR0);			//enables SPI, master, fck/64
    3884:	8c e4       	ldi	r24, 0x4C	; 76
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	2c e4       	ldi	r18, 0x4C	; 76
    388a:	30 e0       	ldi	r19, 0x00	; 0
    388c:	f9 01       	movw	r30, r18
    388e:	20 81       	ld	r18, Z
    3890:	21 65       	ori	r18, 0x51	; 81
    3892:	fc 01       	movw	r30, r24
    3894:	20 83       	st	Z, r18
	Wait_sec(2);
    3896:	82 e0       	ldi	r24, 0x02	; 2
    3898:	90 e0       	ldi	r25, 0x00	; 0
    389a:	0e 94 b9 1a 	call	0x3572	; 0x3572 <_Z8Wait_seci>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    389e:	85 e2       	ldi	r24, 0x25	; 37
    38a0:	90 e0       	ldi	r25, 0x00	; 0
    38a2:	25 e2       	ldi	r18, 0x25	; 37
    38a4:	30 e0       	ldi	r19, 0x00	; 0
    38a6:	f9 01       	movw	r30, r18
    38a8:	20 81       	ld	r18, Z
    38aa:	2f 76       	andi	r18, 0x6F	; 111
    38ac:	fc 01       	movw	r30, r24
    38ae:	20 83       	st	Z, r18
	
	cli();
    38b0:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR = 0x00;
    38b2:	8e e4       	ldi	r24, 0x4E	; 78
    38b4:	90 e0       	ldi	r25, 0x00	; 0
    38b6:	fc 01       	movw	r30, r24
    38b8:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR & (1 << SPIF)));
    38ba:	00 00       	nop
    38bc:	8d e4       	ldi	r24, 0x4D	; 77
    38be:	90 e0       	ldi	r25, 0x00	; 0
    38c0:	fc 01       	movw	r30, r24
    38c2:	80 81       	ld	r24, Z
    38c4:	80 95       	com	r24
    38c6:	88 1f       	adc	r24, r24
    38c8:	88 27       	eor	r24, r24
    38ca:	88 1f       	adc	r24, r24
    38cc:	88 23       	and	r24, r24
    38ce:	b1 f7       	brne	.-20     	; 0x38bc <_Z7GetTempv+0x72>
	rawTemp = (SPDR0 << 8);
    38d0:	1a 82       	std	Y+2, r1	; 0x02
    38d2:	19 82       	std	Y+1, r1	; 0x01
	SPDR = 0x00;
    38d4:	8e e4       	ldi	r24, 0x4E	; 78
    38d6:	90 e0       	ldi	r25, 0x00	; 0
    38d8:	fc 01       	movw	r30, r24
    38da:	10 82       	st	Z, r1
	while (!(SPSR & (1 << SPIF)));
    38dc:	00 00       	nop
    38de:	8d e4       	ldi	r24, 0x4D	; 77
    38e0:	90 e0       	ldi	r25, 0x00	; 0
    38e2:	fc 01       	movw	r30, r24
    38e4:	80 81       	ld	r24, Z
    38e6:	80 95       	com	r24
    38e8:	88 1f       	adc	r24, r24
    38ea:	88 27       	eor	r24, r24
    38ec:	88 1f       	adc	r24, r24
    38ee:	88 23       	and	r24, r24
    38f0:	b1 f7       	brne	.-20     	; 0x38de <_Z7GetTempv+0x94>
	rawTemp |= SPDR0;
	
	//Set flag to correct value, update global value
	//flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
	globalTemp=rawTemp;
    38f2:	89 81       	ldd	r24, Y+1	; 0x01
    38f4:	9a 81       	ldd	r25, Y+2	; 0x02
    38f6:	90 93 91 01 	sts	0x0191, r25
    38fa:	80 93 90 01 	sts	0x0190, r24
	
	//re enable interrupts
	sei();
    38fe:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    3900:	85 e2       	ldi	r24, 0x25	; 37
    3902:	90 e0       	ldi	r25, 0x00	; 0
    3904:	25 e2       	ldi	r18, 0x25	; 37
    3906:	30 e0       	ldi	r19, 0x00	; 0
    3908:	f9 01       	movw	r30, r18
    390a:	20 81       	ld	r18, Z
    390c:	20 69       	ori	r18, 0x90	; 144
    390e:	fc 01       	movw	r30, r24
    3910:	20 83       	st	Z, r18
	SPCR=0x00;	
    3912:	8c e4       	ldi	r24, 0x4C	; 76
    3914:	90 e0       	ldi	r25, 0x00	; 0
    3916:	fc 01       	movw	r30, r24
    3918:	10 82       	st	Z, r1
	//__killTemp();
	PRR0 |= (1 << PRSPI);
    391a:	84 e6       	ldi	r24, 0x64	; 100
    391c:	90 e0       	ldi	r25, 0x00	; 0
    391e:	24 e6       	ldi	r18, 0x64	; 100
    3920:	30 e0       	ldi	r19, 0x00	; 0
    3922:	f9 01       	movw	r30, r18
    3924:	20 81       	ld	r18, Z
    3926:	24 60       	ori	r18, 0x04	; 4
    3928:	fc 01       	movw	r30, r24
    392a:	20 83       	st	Z, r18
	
	char tempString[9];
	itoa(globalTemp,tempString,10);
    392c:	80 91 90 01 	lds	r24, 0x0190
    3930:	90 91 91 01 	lds	r25, 0x0191
    3934:	9e 01       	movw	r18, r28
    3936:	2d 5f       	subi	r18, 0xFD	; 253
    3938:	3f 4f       	sbci	r19, 0xFF	; 255
    393a:	b9 01       	movw	r22, r18
    393c:	4a e0       	ldi	r20, 0x0A	; 10
    393e:	50 e0       	ldi	r21, 0x00	; 0
    3940:	0e 94 16 1f 	call	0x3e2c	; 0x3e2c <itoa>
	tempString[8]='\0';
    3944:	1b 86       	std	Y+11, r1	; 0x0b

	__enableCommINT();
    3946:	8d e3       	ldi	r24, 0x3D	; 61
    3948:	90 e0       	ldi	r25, 0x00	; 0
    394a:	2d e3       	ldi	r18, 0x3D	; 61
    394c:	30 e0       	ldi	r19, 0x00	; 0
    394e:	f9 01       	movw	r30, r18
    3950:	20 81       	ld	r18, Z
    3952:	24 60       	ori	r18, 0x04	; 4
    3954:	fc 01       	movw	r30, r24
    3956:	20 83       	st	Z, r18
    3958:	8d e6       	ldi	r24, 0x6D	; 109
    395a:	90 e0       	ldi	r25, 0x00	; 0
    395c:	22 e0       	ldi	r18, 0x02	; 2
    395e:	fc 01       	movw	r30, r24
    3960:	20 83       	st	Z, r18
}
    3962:	2b 96       	adiw	r28, 0x0b	; 11
    3964:	0f b6       	in	r0, 0x3f	; 63
    3966:	f8 94       	cli
    3968:	de bf       	out	0x3e, r29	; 62
    396a:	0f be       	out	0x3f, r0	; 63
    396c:	cd bf       	out	0x3d, r28	; 61
    396e:	df 91       	pop	r29
    3970:	cf 91       	pop	r28
    3972:	08 95       	ret

00003974 <_Z7PowerUpj>:
/*************************************************************************************************************/
void PowerUp(WORD interval){
    3974:	cf 93       	push	r28
    3976:	df 93       	push	r29
    3978:	00 d0       	rcall	.+0      	; 0x397a <_Z7PowerUpj+0x6>
    397a:	cd b7       	in	r28, 0x3d	; 61
    397c:	de b7       	in	r29, 0x3e	; 62
    397e:	9a 83       	std	Y+2, r25	; 0x02
    3980:	89 83       	std	Y+1, r24	; 0x01
	__killCommINT();
    3982:	8d e3       	ldi	r24, 0x3D	; 61
    3984:	90 e0       	ldi	r25, 0x00	; 0
    3986:	fc 01       	movw	r30, r24
    3988:	10 82       	st	Z, r1
    398a:	8d e6       	ldi	r24, 0x6D	; 109
    398c:	90 e0       	ldi	r25, 0x00	; 0
    398e:	fc 01       	movw	r30, r24
    3990:	10 82       	st	Z, r1
	
	//First power on main regulator
	__enableMain();
    3992:	88 e2       	ldi	r24, 0x28	; 40
    3994:	90 e0       	ldi	r25, 0x00	; 0
    3996:	28 e2       	ldi	r18, 0x28	; 40
    3998:	30 e0       	ldi	r19, 0x00	; 0
    399a:	f9 01       	movw	r30, r18
    399c:	20 81       	ld	r18, Z
    399e:	21 60       	ori	r18, 0x01	; 1
    39a0:	fc 01       	movw	r30, r24
    39a2:	20 83       	st	Z, r18
	Wait_sec(interval);
    39a4:	89 81       	ldd	r24, Y+1	; 0x01
    39a6:	9a 81       	ldd	r25, Y+2	; 0x02
    39a8:	0e 94 b9 1a 	call	0x3572	; 0x3572 <_Z8Wait_seci>
	//__enableBeagleBone();
	//Wait_sec(interval);
	//while (!(pinBBio & (1 << bnW0B9)));	//Wait for GPIO line to go high
	
	//Power on GAVR and Enable GPS
	__enableGPSandGAVR();
    39ac:	82 e2       	ldi	r24, 0x22	; 34
    39ae:	90 e0       	ldi	r25, 0x00	; 0
    39b0:	22 e2       	ldi	r18, 0x22	; 34
    39b2:	30 e0       	ldi	r19, 0x00	; 0
    39b4:	f9 01       	movw	r30, r18
    39b6:	20 81       	ld	r18, Z
    39b8:	20 6c       	ori	r18, 0xC0	; 192
    39ba:	fc 01       	movw	r30, r24
    39bc:	20 83       	st	Z, r18
	//Wait_sec(interval);
	//while (!(pinGAVRio & (1 << bnW3G0)));	//Wait for GPIO line to go high signifying correct boot
	if (restart){
    39be:	80 91 ca 01 	lds	r24, 0x01CA
    39c2:	88 23       	and	r24, r24
    39c4:	b1 f0       	breq	.+44     	; 0x39f2 <_Z7PowerUpj+0x7e>
		prtInterrupts |= (1 << bnGAVRint);
    39c6:	82 e2       	ldi	r24, 0x22	; 34
    39c8:	90 e0       	ldi	r25, 0x00	; 0
    39ca:	22 e2       	ldi	r18, 0x22	; 34
    39cc:	30 e0       	ldi	r19, 0x00	; 0
    39ce:	f9 01       	movw	r30, r18
    39d0:	20 81       	ld	r18, Z
    39d2:	28 60       	ori	r18, 0x08	; 8
    39d4:	fc 01       	movw	r30, r24
    39d6:	20 83       	st	Z, r18
		Wait_ms(200); 
    39d8:	88 ec       	ldi	r24, 0xC8	; 200
    39da:	90 e0       	ldi	r25, 0x00	; 0
    39dc:	0e 94 89 1a 	call	0x3512	; 0x3512 <_Z7Wait_msi>
		prtInterrupts  &= ~(1 << bnGAVRint);	//sends interrupt to come out of power-down, waits, goes forward.
    39e0:	82 e2       	ldi	r24, 0x22	; 34
    39e2:	90 e0       	ldi	r25, 0x00	; 0
    39e4:	22 e2       	ldi	r18, 0x22	; 34
    39e6:	30 e0       	ldi	r19, 0x00	; 0
    39e8:	f9 01       	movw	r30, r18
    39ea:	20 81       	ld	r18, Z
    39ec:	27 7f       	andi	r18, 0xF7	; 247
    39ee:	fc 01       	movw	r30, r24
    39f0:	20 83       	st	Z, r18
	}
	//Power on LCD
	//__enableLCD();
	Wait_sec(interval);
    39f2:	89 81       	ldd	r24, Y+1	; 0x01
    39f4:	9a 81       	ldd	r25, Y+2	; 0x02
    39f6:	0e 94 b9 1a 	call	0x3572	; 0x3572 <_Z8Wait_seci>
	
	__enableCommINT();
    39fa:	8d e3       	ldi	r24, 0x3D	; 61
    39fc:	90 e0       	ldi	r25, 0x00	; 0
    39fe:	2d e3       	ldi	r18, 0x3D	; 61
    3a00:	30 e0       	ldi	r19, 0x00	; 0
    3a02:	f9 01       	movw	r30, r18
    3a04:	20 81       	ld	r18, Z
    3a06:	24 60       	ori	r18, 0x04	; 4
    3a08:	fc 01       	movw	r30, r24
    3a0a:	20 83       	st	Z, r18
    3a0c:	8d e6       	ldi	r24, 0x6D	; 109
    3a0e:	90 e0       	ldi	r25, 0x00	; 0
    3a10:	22 e0       	ldi	r18, 0x02	; 2
    3a12:	fc 01       	movw	r30, r24
    3a14:	20 83       	st	Z, r18
	
}
    3a16:	0f 90       	pop	r0
    3a18:	0f 90       	pop	r0
    3a1a:	df 91       	pop	r29
    3a1c:	cf 91       	pop	r28
    3a1e:	08 95       	ret

00003a20 <_Z9PowerDownv>:
/*************************************************************************************************************/
void PowerDown(){
    3a20:	cf 93       	push	r28
    3a22:	df 93       	push	r29
    3a24:	cd b7       	in	r28, 0x3d	; 61
    3a26:	de b7       	in	r29, 0x3e	; 62
	__killCommINT();
    3a28:	8d e3       	ldi	r24, 0x3D	; 61
    3a2a:	90 e0       	ldi	r25, 0x00	; 0
    3a2c:	fc 01       	movw	r30, r24
    3a2e:	10 82       	st	Z, r1
    3a30:	8d e6       	ldi	r24, 0x6D	; 109
    3a32:	90 e0       	ldi	r25, 0x00	; 0
    3a34:	fc 01       	movw	r30, r24
    3a36:	10 82       	st	Z, r1

	//Signify interrupts, wait 6 seconds for all processing to stop.
	prtInterrupts |= (1 << bnBBint)|(1 << bnGAVRint);
    3a38:	82 e2       	ldi	r24, 0x22	; 34
    3a3a:	90 e0       	ldi	r25, 0x00	; 0
    3a3c:	22 e2       	ldi	r18, 0x22	; 34
    3a3e:	30 e0       	ldi	r19, 0x00	; 0
    3a40:	f9 01       	movw	r30, r18
    3a42:	20 81       	ld	r18, Z
    3a44:	2c 60       	ori	r18, 0x0C	; 12
    3a46:	fc 01       	movw	r30, r24
    3a48:	20 83       	st	Z, r18
	Wait_sec(6);
    3a4a:	86 e0       	ldi	r24, 0x06	; 6
    3a4c:	90 e0       	ldi	r25, 0x00	; 0
    3a4e:	0e 94 b9 1a 	call	0x3572	; 0x3572 <_Z8Wait_seci>
	prtInterrupts &= ~((1 << bnBBint)|(1 << bnGAVRint));
    3a52:	82 e2       	ldi	r24, 0x22	; 34
    3a54:	90 e0       	ldi	r25, 0x00	; 0
    3a56:	22 e2       	ldi	r18, 0x22	; 34
    3a58:	30 e0       	ldi	r19, 0x00	; 0
    3a5a:	f9 01       	movw	r30, r18
    3a5c:	20 81       	ld	r18, Z
    3a5e:	23 7f       	andi	r18, 0xF3	; 243
    3a60:	fc 01       	movw	r30, r24
    3a62:	20 83       	st	Z, r18
	__killLCD();
    3a64:	82 e2       	ldi	r24, 0x22	; 34
    3a66:	90 e0       	ldi	r25, 0x00	; 0
    3a68:	22 e2       	ldi	r18, 0x22	; 34
    3a6a:	30 e0       	ldi	r19, 0x00	; 0
    3a6c:	f9 01       	movw	r30, r18
    3a6e:	20 81       	ld	r18, Z
    3a70:	2f 7d       	andi	r18, 0xDF	; 223
    3a72:	fc 01       	movw	r30, r24
    3a74:	20 83       	st	Z, r18
	__killGPSandGAVR();
    3a76:	82 e2       	ldi	r24, 0x22	; 34
    3a78:	90 e0       	ldi	r25, 0x00	; 0
    3a7a:	22 e2       	ldi	r18, 0x22	; 34
    3a7c:	30 e0       	ldi	r19, 0x00	; 0
    3a7e:	f9 01       	movw	r30, r18
    3a80:	20 81       	ld	r18, Z
    3a82:	2f 73       	andi	r18, 0x3F	; 63
    3a84:	fc 01       	movw	r30, r24
    3a86:	20 83       	st	Z, r18
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
    3a88:	86 e0       	ldi	r24, 0x06	; 6
    3a8a:	90 e0       	ldi	r25, 0x00	; 0
    3a8c:	0e 94 b9 1a 	call	0x3572	; 0x3572 <_Z8Wait_seci>
	__killBeagleBone();
    3a90:	82 e2       	ldi	r24, 0x22	; 34
    3a92:	90 e0       	ldi	r25, 0x00	; 0
    3a94:	22 e2       	ldi	r18, 0x22	; 34
    3a96:	30 e0       	ldi	r19, 0x00	; 0
    3a98:	f9 01       	movw	r30, r18
    3a9a:	20 81       	ld	r18, Z
    3a9c:	2f 7e       	andi	r18, 0xEF	; 239
    3a9e:	fc 01       	movw	r30, r24
    3aa0:	20 83       	st	Z, r18
	__killMain();
    3aa2:	88 e2       	ldi	r24, 0x28	; 40
    3aa4:	90 e0       	ldi	r25, 0x00	; 0
    3aa6:	28 e2       	ldi	r18, 0x28	; 40
    3aa8:	30 e0       	ldi	r19, 0x00	; 0
    3aaa:	f9 01       	movw	r30, r18
    3aac:	20 81       	ld	r18, Z
    3aae:	2e 7f       	andi	r18, 0xFE	; 254
    3ab0:	fc 01       	movw	r30, r24
    3ab2:	20 83       	st	Z, r18
}
    3ab4:	df 91       	pop	r29
    3ab6:	cf 91       	pop	r28
    3ab8:	08 95       	ret

00003aba <_Z41__static_initialization_and_destruction_0ii>:
    3aba:	cf 93       	push	r28
    3abc:	df 93       	push	r29
    3abe:	00 d0       	rcall	.+0      	; 0x3ac0 <_Z41__static_initialization_and_destruction_0ii+0x6>
    3ac0:	00 d0       	rcall	.+0      	; 0x3ac2 <_Z41__static_initialization_and_destruction_0ii+0x8>
    3ac2:	cd b7       	in	r28, 0x3d	; 61
    3ac4:	de b7       	in	r29, 0x3e	; 62
    3ac6:	9a 83       	std	Y+2, r25	; 0x02
    3ac8:	89 83       	std	Y+1, r24	; 0x01
    3aca:	7c 83       	std	Y+4, r23	; 0x04
    3acc:	6b 83       	std	Y+3, r22	; 0x03
    3ace:	89 81       	ldd	r24, Y+1	; 0x01
    3ad0:	9a 81       	ldd	r25, Y+2	; 0x02
    3ad2:	81 30       	cpi	r24, 0x01	; 1
    3ad4:	91 05       	cpc	r25, r1
    3ad6:	51 f4       	brne	.+20     	; 0x3aec <_Z41__static_initialization_and_destruction_0ii+0x32>
    3ad8:	8b 81       	ldd	r24, Y+3	; 0x03
    3ada:	9c 81       	ldd	r25, Y+4	; 0x04
    3adc:	2f ef       	ldi	r18, 0xFF	; 255
    3ade:	8f 3f       	cpi	r24, 0xFF	; 255
    3ae0:	92 07       	cpc	r25, r18
    3ae2:	21 f4       	brne	.+8      	; 0x3aec <_Z41__static_initialization_and_destruction_0ii+0x32>

/*********************************************GLOBAL VARIABLES***************************************************/
/****************************************************************************************************************/
WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    3ae4:	82 e9       	ldi	r24, 0x92	; 146
    3ae6:	91 e0       	ldi	r25, 0x01	; 1
    3ae8:	0e 94 10 04 	call	0x820	; 0x820 <_ZN6myTimeC1Ev>
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
	__killBeagleBone();
	__killMain();
}
    3aec:	0f 90       	pop	r0
    3aee:	0f 90       	pop	r0
    3af0:	0f 90       	pop	r0
    3af2:	0f 90       	pop	r0
    3af4:	df 91       	pop	r29
    3af6:	cf 91       	pop	r28
    3af8:	08 95       	ret

00003afa <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    3afa:	cf 93       	push	r28
    3afc:	df 93       	push	r29
    3afe:	cd b7       	in	r28, 0x3d	; 61
    3b00:	de b7       	in	r29, 0x3e	; 62
    3b02:	81 e0       	ldi	r24, 0x01	; 1
    3b04:	90 e0       	ldi	r25, 0x00	; 0
    3b06:	6f ef       	ldi	r22, 0xFF	; 255
    3b08:	7f ef       	ldi	r23, 0xFF	; 255
    3b0a:	0e 94 5d 1d 	call	0x3aba	; 0x3aba <_Z41__static_initialization_and_destruction_0ii>
    3b0e:	df 91       	pop	r29
    3b10:	cf 91       	pop	r28
    3b12:	08 95       	ret

00003b14 <__cmpsf2>:
    3b14:	2f d0       	rcall	.+94     	; 0x3b74 <__fp_cmp>
    3b16:	08 f4       	brcc	.+2      	; 0x3b1a <__cmpsf2+0x6>
    3b18:	81 e0       	ldi	r24, 0x01	; 1
    3b1a:	08 95       	ret

00003b1c <__fixunssfsi>:
    3b1c:	57 d0       	rcall	.+174    	; 0x3bcc <__fp_splitA>
    3b1e:	88 f0       	brcs	.+34     	; 0x3b42 <__fixunssfsi+0x26>
    3b20:	9f 57       	subi	r25, 0x7F	; 127
    3b22:	90 f0       	brcs	.+36     	; 0x3b48 <__fixunssfsi+0x2c>
    3b24:	b9 2f       	mov	r27, r25
    3b26:	99 27       	eor	r25, r25
    3b28:	b7 51       	subi	r27, 0x17	; 23
    3b2a:	a0 f0       	brcs	.+40     	; 0x3b54 <__fixunssfsi+0x38>
    3b2c:	d1 f0       	breq	.+52     	; 0x3b62 <__fixunssfsi+0x46>
    3b2e:	66 0f       	add	r22, r22
    3b30:	77 1f       	adc	r23, r23
    3b32:	88 1f       	adc	r24, r24
    3b34:	99 1f       	adc	r25, r25
    3b36:	1a f0       	brmi	.+6      	; 0x3b3e <__fixunssfsi+0x22>
    3b38:	ba 95       	dec	r27
    3b3a:	c9 f7       	brne	.-14     	; 0x3b2e <__fixunssfsi+0x12>
    3b3c:	12 c0       	rjmp	.+36     	; 0x3b62 <__fixunssfsi+0x46>
    3b3e:	b1 30       	cpi	r27, 0x01	; 1
    3b40:	81 f0       	breq	.+32     	; 0x3b62 <__fixunssfsi+0x46>
    3b42:	5e d0       	rcall	.+188    	; 0x3c00 <__fp_zero>
    3b44:	b1 e0       	ldi	r27, 0x01	; 1
    3b46:	08 95       	ret
    3b48:	5b c0       	rjmp	.+182    	; 0x3c00 <__fp_zero>
    3b4a:	67 2f       	mov	r22, r23
    3b4c:	78 2f       	mov	r23, r24
    3b4e:	88 27       	eor	r24, r24
    3b50:	b8 5f       	subi	r27, 0xF8	; 248
    3b52:	39 f0       	breq	.+14     	; 0x3b62 <__fixunssfsi+0x46>
    3b54:	b9 3f       	cpi	r27, 0xF9	; 249
    3b56:	cc f3       	brlt	.-14     	; 0x3b4a <__fixunssfsi+0x2e>
    3b58:	86 95       	lsr	r24
    3b5a:	77 95       	ror	r23
    3b5c:	67 95       	ror	r22
    3b5e:	b3 95       	inc	r27
    3b60:	d9 f7       	brne	.-10     	; 0x3b58 <__fixunssfsi+0x3c>
    3b62:	3e f4       	brtc	.+14     	; 0x3b72 <__fixunssfsi+0x56>
    3b64:	90 95       	com	r25
    3b66:	80 95       	com	r24
    3b68:	70 95       	com	r23
    3b6a:	61 95       	neg	r22
    3b6c:	7f 4f       	sbci	r23, 0xFF	; 255
    3b6e:	8f 4f       	sbci	r24, 0xFF	; 255
    3b70:	9f 4f       	sbci	r25, 0xFF	; 255
    3b72:	08 95       	ret

00003b74 <__fp_cmp>:
    3b74:	99 0f       	add	r25, r25
    3b76:	00 08       	sbc	r0, r0
    3b78:	55 0f       	add	r21, r21
    3b7a:	aa 0b       	sbc	r26, r26
    3b7c:	e0 e8       	ldi	r30, 0x80	; 128
    3b7e:	fe ef       	ldi	r31, 0xFE	; 254
    3b80:	16 16       	cp	r1, r22
    3b82:	17 06       	cpc	r1, r23
    3b84:	e8 07       	cpc	r30, r24
    3b86:	f9 07       	cpc	r31, r25
    3b88:	c0 f0       	brcs	.+48     	; 0x3bba <__fp_cmp+0x46>
    3b8a:	12 16       	cp	r1, r18
    3b8c:	13 06       	cpc	r1, r19
    3b8e:	e4 07       	cpc	r30, r20
    3b90:	f5 07       	cpc	r31, r21
    3b92:	98 f0       	brcs	.+38     	; 0x3bba <__fp_cmp+0x46>
    3b94:	62 1b       	sub	r22, r18
    3b96:	73 0b       	sbc	r23, r19
    3b98:	84 0b       	sbc	r24, r20
    3b9a:	95 0b       	sbc	r25, r21
    3b9c:	39 f4       	brne	.+14     	; 0x3bac <__fp_cmp+0x38>
    3b9e:	0a 26       	eor	r0, r26
    3ba0:	61 f0       	breq	.+24     	; 0x3bba <__fp_cmp+0x46>
    3ba2:	23 2b       	or	r18, r19
    3ba4:	24 2b       	or	r18, r20
    3ba6:	25 2b       	or	r18, r21
    3ba8:	21 f4       	brne	.+8      	; 0x3bb2 <__fp_cmp+0x3e>
    3baa:	08 95       	ret
    3bac:	0a 26       	eor	r0, r26
    3bae:	09 f4       	brne	.+2      	; 0x3bb2 <__fp_cmp+0x3e>
    3bb0:	a1 40       	sbci	r26, 0x01	; 1
    3bb2:	a6 95       	lsr	r26
    3bb4:	8f ef       	ldi	r24, 0xFF	; 255
    3bb6:	81 1d       	adc	r24, r1
    3bb8:	81 1d       	adc	r24, r1
    3bba:	08 95       	ret

00003bbc <__fp_split3>:
    3bbc:	57 fd       	sbrc	r21, 7
    3bbe:	90 58       	subi	r25, 0x80	; 128
    3bc0:	44 0f       	add	r20, r20
    3bc2:	55 1f       	adc	r21, r21
    3bc4:	59 f0       	breq	.+22     	; 0x3bdc <__fp_splitA+0x10>
    3bc6:	5f 3f       	cpi	r21, 0xFF	; 255
    3bc8:	71 f0       	breq	.+28     	; 0x3be6 <__fp_splitA+0x1a>
    3bca:	47 95       	ror	r20

00003bcc <__fp_splitA>:
    3bcc:	88 0f       	add	r24, r24
    3bce:	97 fb       	bst	r25, 7
    3bd0:	99 1f       	adc	r25, r25
    3bd2:	61 f0       	breq	.+24     	; 0x3bec <__fp_splitA+0x20>
    3bd4:	9f 3f       	cpi	r25, 0xFF	; 255
    3bd6:	79 f0       	breq	.+30     	; 0x3bf6 <__fp_splitA+0x2a>
    3bd8:	87 95       	ror	r24
    3bda:	08 95       	ret
    3bdc:	12 16       	cp	r1, r18
    3bde:	13 06       	cpc	r1, r19
    3be0:	14 06       	cpc	r1, r20
    3be2:	55 1f       	adc	r21, r21
    3be4:	f2 cf       	rjmp	.-28     	; 0x3bca <__fp_split3+0xe>
    3be6:	46 95       	lsr	r20
    3be8:	f1 df       	rcall	.-30     	; 0x3bcc <__fp_splitA>
    3bea:	08 c0       	rjmp	.+16     	; 0x3bfc <__fp_splitA+0x30>
    3bec:	16 16       	cp	r1, r22
    3bee:	17 06       	cpc	r1, r23
    3bf0:	18 06       	cpc	r1, r24
    3bf2:	99 1f       	adc	r25, r25
    3bf4:	f1 cf       	rjmp	.-30     	; 0x3bd8 <__fp_splitA+0xc>
    3bf6:	86 95       	lsr	r24
    3bf8:	71 05       	cpc	r23, r1
    3bfa:	61 05       	cpc	r22, r1
    3bfc:	08 94       	sec
    3bfe:	08 95       	ret

00003c00 <__fp_zero>:
    3c00:	e8 94       	clt

00003c02 <__fp_szero>:
    3c02:	bb 27       	eor	r27, r27
    3c04:	66 27       	eor	r22, r22
    3c06:	77 27       	eor	r23, r23
    3c08:	cb 01       	movw	r24, r22
    3c0a:	97 f9       	bld	r25, 7
    3c0c:	08 95       	ret

00003c0e <__gesf2>:
    3c0e:	b2 df       	rcall	.-156    	; 0x3b74 <__fp_cmp>
    3c10:	08 f4       	brcc	.+2      	; 0x3c14 <__gesf2+0x6>
    3c12:	8f ef       	ldi	r24, 0xFF	; 255
    3c14:	08 95       	ret

00003c16 <__mulsf3>:
    3c16:	0b d0       	rcall	.+22     	; 0x3c2e <__mulsf3x>
    3c18:	78 c0       	rjmp	.+240    	; 0x3d0a <__fp_round>
    3c1a:	69 d0       	rcall	.+210    	; 0x3cee <__fp_pscA>
    3c1c:	28 f0       	brcs	.+10     	; 0x3c28 <__mulsf3+0x12>
    3c1e:	6e d0       	rcall	.+220    	; 0x3cfc <__fp_pscB>
    3c20:	18 f0       	brcs	.+6      	; 0x3c28 <__mulsf3+0x12>
    3c22:	95 23       	and	r25, r21
    3c24:	09 f0       	breq	.+2      	; 0x3c28 <__mulsf3+0x12>
    3c26:	5a c0       	rjmp	.+180    	; 0x3cdc <__fp_inf>
    3c28:	5f c0       	rjmp	.+190    	; 0x3ce8 <__fp_nan>
    3c2a:	11 24       	eor	r1, r1
    3c2c:	ea cf       	rjmp	.-44     	; 0x3c02 <__fp_szero>

00003c2e <__mulsf3x>:
    3c2e:	c6 df       	rcall	.-116    	; 0x3bbc <__fp_split3>
    3c30:	a0 f3       	brcs	.-24     	; 0x3c1a <__mulsf3+0x4>

00003c32 <__mulsf3_pse>:
    3c32:	95 9f       	mul	r25, r21
    3c34:	d1 f3       	breq	.-12     	; 0x3c2a <__mulsf3+0x14>
    3c36:	95 0f       	add	r25, r21
    3c38:	50 e0       	ldi	r21, 0x00	; 0
    3c3a:	55 1f       	adc	r21, r21
    3c3c:	62 9f       	mul	r22, r18
    3c3e:	f0 01       	movw	r30, r0
    3c40:	72 9f       	mul	r23, r18
    3c42:	bb 27       	eor	r27, r27
    3c44:	f0 0d       	add	r31, r0
    3c46:	b1 1d       	adc	r27, r1
    3c48:	63 9f       	mul	r22, r19
    3c4a:	aa 27       	eor	r26, r26
    3c4c:	f0 0d       	add	r31, r0
    3c4e:	b1 1d       	adc	r27, r1
    3c50:	aa 1f       	adc	r26, r26
    3c52:	64 9f       	mul	r22, r20
    3c54:	66 27       	eor	r22, r22
    3c56:	b0 0d       	add	r27, r0
    3c58:	a1 1d       	adc	r26, r1
    3c5a:	66 1f       	adc	r22, r22
    3c5c:	82 9f       	mul	r24, r18
    3c5e:	22 27       	eor	r18, r18
    3c60:	b0 0d       	add	r27, r0
    3c62:	a1 1d       	adc	r26, r1
    3c64:	62 1f       	adc	r22, r18
    3c66:	73 9f       	mul	r23, r19
    3c68:	b0 0d       	add	r27, r0
    3c6a:	a1 1d       	adc	r26, r1
    3c6c:	62 1f       	adc	r22, r18
    3c6e:	83 9f       	mul	r24, r19
    3c70:	a0 0d       	add	r26, r0
    3c72:	61 1d       	adc	r22, r1
    3c74:	22 1f       	adc	r18, r18
    3c76:	74 9f       	mul	r23, r20
    3c78:	33 27       	eor	r19, r19
    3c7a:	a0 0d       	add	r26, r0
    3c7c:	61 1d       	adc	r22, r1
    3c7e:	23 1f       	adc	r18, r19
    3c80:	84 9f       	mul	r24, r20
    3c82:	60 0d       	add	r22, r0
    3c84:	21 1d       	adc	r18, r1
    3c86:	82 2f       	mov	r24, r18
    3c88:	76 2f       	mov	r23, r22
    3c8a:	6a 2f       	mov	r22, r26
    3c8c:	11 24       	eor	r1, r1
    3c8e:	9f 57       	subi	r25, 0x7F	; 127
    3c90:	50 40       	sbci	r21, 0x00	; 0
    3c92:	8a f0       	brmi	.+34     	; 0x3cb6 <__mulsf3_pse+0x84>
    3c94:	e1 f0       	breq	.+56     	; 0x3cce <__mulsf3_pse+0x9c>
    3c96:	88 23       	and	r24, r24
    3c98:	4a f0       	brmi	.+18     	; 0x3cac <__mulsf3_pse+0x7a>
    3c9a:	ee 0f       	add	r30, r30
    3c9c:	ff 1f       	adc	r31, r31
    3c9e:	bb 1f       	adc	r27, r27
    3ca0:	66 1f       	adc	r22, r22
    3ca2:	77 1f       	adc	r23, r23
    3ca4:	88 1f       	adc	r24, r24
    3ca6:	91 50       	subi	r25, 0x01	; 1
    3ca8:	50 40       	sbci	r21, 0x00	; 0
    3caa:	a9 f7       	brne	.-22     	; 0x3c96 <__mulsf3_pse+0x64>
    3cac:	9e 3f       	cpi	r25, 0xFE	; 254
    3cae:	51 05       	cpc	r21, r1
    3cb0:	70 f0       	brcs	.+28     	; 0x3cce <__mulsf3_pse+0x9c>
    3cb2:	14 c0       	rjmp	.+40     	; 0x3cdc <__fp_inf>
    3cb4:	a6 cf       	rjmp	.-180    	; 0x3c02 <__fp_szero>
    3cb6:	5f 3f       	cpi	r21, 0xFF	; 255
    3cb8:	ec f3       	brlt	.-6      	; 0x3cb4 <__mulsf3_pse+0x82>
    3cba:	98 3e       	cpi	r25, 0xE8	; 232
    3cbc:	dc f3       	brlt	.-10     	; 0x3cb4 <__mulsf3_pse+0x82>
    3cbe:	86 95       	lsr	r24
    3cc0:	77 95       	ror	r23
    3cc2:	67 95       	ror	r22
    3cc4:	b7 95       	ror	r27
    3cc6:	f7 95       	ror	r31
    3cc8:	e7 95       	ror	r30
    3cca:	9f 5f       	subi	r25, 0xFF	; 255
    3ccc:	c1 f7       	brne	.-16     	; 0x3cbe <__mulsf3_pse+0x8c>
    3cce:	fe 2b       	or	r31, r30
    3cd0:	88 0f       	add	r24, r24
    3cd2:	91 1d       	adc	r25, r1
    3cd4:	96 95       	lsr	r25
    3cd6:	87 95       	ror	r24
    3cd8:	97 f9       	bld	r25, 7
    3cda:	08 95       	ret

00003cdc <__fp_inf>:
    3cdc:	97 f9       	bld	r25, 7
    3cde:	9f 67       	ori	r25, 0x7F	; 127
    3ce0:	80 e8       	ldi	r24, 0x80	; 128
    3ce2:	70 e0       	ldi	r23, 0x00	; 0
    3ce4:	60 e0       	ldi	r22, 0x00	; 0
    3ce6:	08 95       	ret

00003ce8 <__fp_nan>:
    3ce8:	9f ef       	ldi	r25, 0xFF	; 255
    3cea:	80 ec       	ldi	r24, 0xC0	; 192
    3cec:	08 95       	ret

00003cee <__fp_pscA>:
    3cee:	00 24       	eor	r0, r0
    3cf0:	0a 94       	dec	r0
    3cf2:	16 16       	cp	r1, r22
    3cf4:	17 06       	cpc	r1, r23
    3cf6:	18 06       	cpc	r1, r24
    3cf8:	09 06       	cpc	r0, r25
    3cfa:	08 95       	ret

00003cfc <__fp_pscB>:
    3cfc:	00 24       	eor	r0, r0
    3cfe:	0a 94       	dec	r0
    3d00:	12 16       	cp	r1, r18
    3d02:	13 06       	cpc	r1, r19
    3d04:	14 06       	cpc	r1, r20
    3d06:	05 06       	cpc	r0, r21
    3d08:	08 95       	ret

00003d0a <__fp_round>:
    3d0a:	09 2e       	mov	r0, r25
    3d0c:	03 94       	inc	r0
    3d0e:	00 0c       	add	r0, r0
    3d10:	11 f4       	brne	.+4      	; 0x3d16 <__fp_round+0xc>
    3d12:	88 23       	and	r24, r24
    3d14:	52 f0       	brmi	.+20     	; 0x3d2a <__fp_round+0x20>
    3d16:	bb 0f       	add	r27, r27
    3d18:	40 f4       	brcc	.+16     	; 0x3d2a <__fp_round+0x20>
    3d1a:	bf 2b       	or	r27, r31
    3d1c:	11 f4       	brne	.+4      	; 0x3d22 <__fp_round+0x18>
    3d1e:	60 ff       	sbrs	r22, 0
    3d20:	04 c0       	rjmp	.+8      	; 0x3d2a <__fp_round+0x20>
    3d22:	6f 5f       	subi	r22, 0xFF	; 255
    3d24:	7f 4f       	sbci	r23, 0xFF	; 255
    3d26:	8f 4f       	sbci	r24, 0xFF	; 255
    3d28:	9f 4f       	sbci	r25, 0xFF	; 255
    3d2a:	08 95       	ret

00003d2c <__udivmodqi4>:
    3d2c:	99 1b       	sub	r25, r25
    3d2e:	79 e0       	ldi	r23, 0x09	; 9
    3d30:	04 c0       	rjmp	.+8      	; 0x3d3a <__udivmodqi4_ep>

00003d32 <__udivmodqi4_loop>:
    3d32:	99 1f       	adc	r25, r25
    3d34:	96 17       	cp	r25, r22
    3d36:	08 f0       	brcs	.+2      	; 0x3d3a <__udivmodqi4_ep>
    3d38:	96 1b       	sub	r25, r22

00003d3a <__udivmodqi4_ep>:
    3d3a:	88 1f       	adc	r24, r24
    3d3c:	7a 95       	dec	r23
    3d3e:	c9 f7       	brne	.-14     	; 0x3d32 <__udivmodqi4_loop>
    3d40:	80 95       	com	r24
    3d42:	08 95       	ret

00003d44 <__divmodhi4>:
    3d44:	97 fb       	bst	r25, 7
    3d46:	09 2e       	mov	r0, r25
    3d48:	07 26       	eor	r0, r23
    3d4a:	0a d0       	rcall	.+20     	; 0x3d60 <__divmodhi4_neg1>
    3d4c:	77 fd       	sbrc	r23, 7
    3d4e:	04 d0       	rcall	.+8      	; 0x3d58 <__divmodhi4_neg2>
    3d50:	0c d0       	rcall	.+24     	; 0x3d6a <__udivmodhi4>
    3d52:	06 d0       	rcall	.+12     	; 0x3d60 <__divmodhi4_neg1>
    3d54:	00 20       	and	r0, r0
    3d56:	1a f4       	brpl	.+6      	; 0x3d5e <__divmodhi4_exit>

00003d58 <__divmodhi4_neg2>:
    3d58:	70 95       	com	r23
    3d5a:	61 95       	neg	r22
    3d5c:	7f 4f       	sbci	r23, 0xFF	; 255

00003d5e <__divmodhi4_exit>:
    3d5e:	08 95       	ret

00003d60 <__divmodhi4_neg1>:
    3d60:	f6 f7       	brtc	.-4      	; 0x3d5e <__divmodhi4_exit>
    3d62:	90 95       	com	r25
    3d64:	81 95       	neg	r24
    3d66:	9f 4f       	sbci	r25, 0xFF	; 255
    3d68:	08 95       	ret

00003d6a <__udivmodhi4>:
    3d6a:	aa 1b       	sub	r26, r26
    3d6c:	bb 1b       	sub	r27, r27
    3d6e:	51 e1       	ldi	r21, 0x11	; 17
    3d70:	07 c0       	rjmp	.+14     	; 0x3d80 <__udivmodhi4_ep>

00003d72 <__udivmodhi4_loop>:
    3d72:	aa 1f       	adc	r26, r26
    3d74:	bb 1f       	adc	r27, r27
    3d76:	a6 17       	cp	r26, r22
    3d78:	b7 07       	cpc	r27, r23
    3d7a:	10 f0       	brcs	.+4      	; 0x3d80 <__udivmodhi4_ep>
    3d7c:	a6 1b       	sub	r26, r22
    3d7e:	b7 0b       	sbc	r27, r23

00003d80 <__udivmodhi4_ep>:
    3d80:	88 1f       	adc	r24, r24
    3d82:	99 1f       	adc	r25, r25
    3d84:	5a 95       	dec	r21
    3d86:	a9 f7       	brne	.-22     	; 0x3d72 <__udivmodhi4_loop>
    3d88:	80 95       	com	r24
    3d8a:	90 95       	com	r25
    3d8c:	bc 01       	movw	r22, r24
    3d8e:	cd 01       	movw	r24, r26
    3d90:	08 95       	ret

00003d92 <__tablejump2__>:
    3d92:	ee 0f       	add	r30, r30
    3d94:	ff 1f       	adc	r31, r31

00003d96 <__tablejump__>:
    3d96:	05 90       	lpm	r0, Z+
    3d98:	f4 91       	lpm	r31, Z
    3d9a:	e0 2d       	mov	r30, r0
    3d9c:	09 94       	ijmp

00003d9e <atoi>:
    3d9e:	fc 01       	movw	r30, r24
    3da0:	88 27       	eor	r24, r24
    3da2:	99 27       	eor	r25, r25
    3da4:	e8 94       	clt
    3da6:	21 91       	ld	r18, Z+
    3da8:	20 32       	cpi	r18, 0x20	; 32
    3daa:	e9 f3       	breq	.-6      	; 0x3da6 <atoi+0x8>
    3dac:	29 30       	cpi	r18, 0x09	; 9
    3dae:	10 f0       	brcs	.+4      	; 0x3db4 <atoi+0x16>
    3db0:	2e 30       	cpi	r18, 0x0E	; 14
    3db2:	c8 f3       	brcs	.-14     	; 0x3da6 <atoi+0x8>
    3db4:	2b 32       	cpi	r18, 0x2B	; 43
    3db6:	41 f0       	breq	.+16     	; 0x3dc8 <atoi+0x2a>
    3db8:	2d 32       	cpi	r18, 0x2D	; 45
    3dba:	39 f4       	brne	.+14     	; 0x3dca <atoi+0x2c>
    3dbc:	68 94       	set
    3dbe:	04 c0       	rjmp	.+8      	; 0x3dc8 <atoi+0x2a>
    3dc0:	0e 94 37 1f 	call	0x3e6e	; 0x3e6e <__mulhi_const_10>
    3dc4:	82 0f       	add	r24, r18
    3dc6:	91 1d       	adc	r25, r1
    3dc8:	21 91       	ld	r18, Z+
    3dca:	20 53       	subi	r18, 0x30	; 48
    3dcc:	2a 30       	cpi	r18, 0x0A	; 10
    3dce:	c0 f3       	brcs	.-16     	; 0x3dc0 <atoi+0x22>
    3dd0:	1e f4       	brtc	.+6      	; 0x3dd8 <atoi+0x3a>
    3dd2:	90 95       	com	r25
    3dd4:	81 95       	neg	r24
    3dd6:	9f 4f       	sbci	r25, 0xFF	; 255
    3dd8:	08 95       	ret

00003dda <strcat>:
    3dda:	fb 01       	movw	r30, r22
    3ddc:	dc 01       	movw	r26, r24
    3dde:	0d 90       	ld	r0, X+
    3de0:	00 20       	and	r0, r0
    3de2:	e9 f7       	brne	.-6      	; 0x3dde <strcat+0x4>
    3de4:	11 97       	sbiw	r26, 0x01	; 1
    3de6:	01 90       	ld	r0, Z+
    3de8:	0d 92       	st	X+, r0
    3dea:	00 20       	and	r0, r0
    3dec:	e1 f7       	brne	.-8      	; 0x3de6 <strcat+0xc>
    3dee:	08 95       	ret

00003df0 <strcmp>:
    3df0:	fb 01       	movw	r30, r22
    3df2:	dc 01       	movw	r26, r24
    3df4:	8d 91       	ld	r24, X+
    3df6:	01 90       	ld	r0, Z+
    3df8:	80 19       	sub	r24, r0
    3dfa:	01 10       	cpse	r0, r1
    3dfc:	d9 f3       	breq	.-10     	; 0x3df4 <strcmp+0x4>
    3dfe:	99 0b       	sbc	r25, r25
    3e00:	08 95       	ret

00003e02 <strcpy>:
    3e02:	fb 01       	movw	r30, r22
    3e04:	dc 01       	movw	r26, r24
    3e06:	01 90       	ld	r0, Z+
    3e08:	0d 92       	st	X+, r0
    3e0a:	00 20       	and	r0, r0
    3e0c:	e1 f7       	brne	.-8      	; 0x3e06 <strcpy+0x4>
    3e0e:	08 95       	ret

00003e10 <strncmp>:
    3e10:	fb 01       	movw	r30, r22
    3e12:	dc 01       	movw	r26, r24
    3e14:	41 50       	subi	r20, 0x01	; 1
    3e16:	50 40       	sbci	r21, 0x00	; 0
    3e18:	30 f0       	brcs	.+12     	; 0x3e26 <strncmp+0x16>
    3e1a:	8d 91       	ld	r24, X+
    3e1c:	01 90       	ld	r0, Z+
    3e1e:	80 19       	sub	r24, r0
    3e20:	19 f4       	brne	.+6      	; 0x3e28 <strncmp+0x18>
    3e22:	00 20       	and	r0, r0
    3e24:	b9 f7       	brne	.-18     	; 0x3e14 <strncmp+0x4>
    3e26:	88 1b       	sub	r24, r24
    3e28:	99 0b       	sbc	r25, r25
    3e2a:	08 95       	ret

00003e2c <itoa>:
    3e2c:	fb 01       	movw	r30, r22
    3e2e:	9f 01       	movw	r18, r30
    3e30:	e8 94       	clt
    3e32:	42 30       	cpi	r20, 0x02	; 2
    3e34:	c4 f0       	brlt	.+48     	; 0x3e66 <itoa+0x3a>
    3e36:	45 32       	cpi	r20, 0x25	; 37
    3e38:	b4 f4       	brge	.+44     	; 0x3e66 <itoa+0x3a>
    3e3a:	4a 30       	cpi	r20, 0x0A	; 10
    3e3c:	29 f4       	brne	.+10     	; 0x3e48 <itoa+0x1c>
    3e3e:	97 fb       	bst	r25, 7
    3e40:	1e f4       	brtc	.+6      	; 0x3e48 <itoa+0x1c>
    3e42:	90 95       	com	r25
    3e44:	81 95       	neg	r24
    3e46:	9f 4f       	sbci	r25, 0xFF	; 255
    3e48:	64 2f       	mov	r22, r20
    3e4a:	77 27       	eor	r23, r23
    3e4c:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <__udivmodhi4>
    3e50:	80 5d       	subi	r24, 0xD0	; 208
    3e52:	8a 33       	cpi	r24, 0x3A	; 58
    3e54:	0c f0       	brlt	.+2      	; 0x3e58 <itoa+0x2c>
    3e56:	89 5d       	subi	r24, 0xD9	; 217
    3e58:	81 93       	st	Z+, r24
    3e5a:	cb 01       	movw	r24, r22
    3e5c:	00 97       	sbiw	r24, 0x00	; 0
    3e5e:	a1 f7       	brne	.-24     	; 0x3e48 <itoa+0x1c>
    3e60:	16 f4       	brtc	.+4      	; 0x3e66 <itoa+0x3a>
    3e62:	5d e2       	ldi	r21, 0x2D	; 45
    3e64:	51 93       	st	Z+, r21
    3e66:	10 82       	st	Z, r1
    3e68:	c9 01       	movw	r24, r18
    3e6a:	0c 94 76 1f 	jmp	0x3eec	; 0x3eec <strrev>

00003e6e <__mulhi_const_10>:
    3e6e:	7a e0       	ldi	r23, 0x0A	; 10
    3e70:	97 9f       	mul	r25, r23
    3e72:	90 2d       	mov	r25, r0
    3e74:	87 9f       	mul	r24, r23
    3e76:	80 2d       	mov	r24, r0
    3e78:	91 0d       	add	r25, r1
    3e7a:	11 24       	eor	r1, r1
    3e7c:	08 95       	ret

00003e7e <utoa>:
    3e7e:	fb 01       	movw	r30, r22
    3e80:	9f 01       	movw	r18, r30
    3e82:	42 30       	cpi	r20, 0x02	; 2
    3e84:	74 f0       	brlt	.+28     	; 0x3ea2 <utoa+0x24>
    3e86:	45 32       	cpi	r20, 0x25	; 37
    3e88:	64 f4       	brge	.+24     	; 0x3ea2 <utoa+0x24>
    3e8a:	64 2f       	mov	r22, r20
    3e8c:	77 27       	eor	r23, r23
    3e8e:	0e 94 b5 1e 	call	0x3d6a	; 0x3d6a <__udivmodhi4>
    3e92:	80 5d       	subi	r24, 0xD0	; 208
    3e94:	8a 33       	cpi	r24, 0x3A	; 58
    3e96:	0c f0       	brlt	.+2      	; 0x3e9a <utoa+0x1c>
    3e98:	89 5d       	subi	r24, 0xD9	; 217
    3e9a:	81 93       	st	Z+, r24
    3e9c:	cb 01       	movw	r24, r22
    3e9e:	00 97       	sbiw	r24, 0x00	; 0
    3ea0:	a1 f7       	brne	.-24     	; 0x3e8a <utoa+0xc>
    3ea2:	10 82       	st	Z, r1
    3ea4:	c9 01       	movw	r24, r18
    3ea6:	0c 94 76 1f 	jmp	0x3eec	; 0x3eec <strrev>

00003eaa <__eerd_byte_m644pa>:
    3eaa:	f9 99       	sbic	0x1f, 1	; 31
    3eac:	fe cf       	rjmp	.-4      	; 0x3eaa <__eerd_byte_m644pa>
    3eae:	92 bd       	out	0x22, r25	; 34
    3eb0:	81 bd       	out	0x21, r24	; 33
    3eb2:	f8 9a       	sbi	0x1f, 0	; 31
    3eb4:	99 27       	eor	r25, r25
    3eb6:	80 b5       	in	r24, 0x20	; 32
    3eb8:	08 95       	ret

00003eba <__eerd_word_m644pa>:
    3eba:	a8 e1       	ldi	r26, 0x18	; 24
    3ebc:	b0 e0       	ldi	r27, 0x00	; 0
    3ebe:	42 e0       	ldi	r20, 0x02	; 2
    3ec0:	50 e0       	ldi	r21, 0x00	; 0
    3ec2:	0c 94 88 1f 	jmp	0x3f10	; 0x3f10 <__eerd_blraw_m644pa>

00003ec6 <__eewr_byte_m644pa>:
    3ec6:	26 2f       	mov	r18, r22

00003ec8 <__eewr_r18_m644pa>:
    3ec8:	f9 99       	sbic	0x1f, 1	; 31
    3eca:	fe cf       	rjmp	.-4      	; 0x3ec8 <__eewr_r18_m644pa>
    3ecc:	1f ba       	out	0x1f, r1	; 31
    3ece:	92 bd       	out	0x22, r25	; 34
    3ed0:	81 bd       	out	0x21, r24	; 33
    3ed2:	20 bd       	out	0x20, r18	; 32
    3ed4:	0f b6       	in	r0, 0x3f	; 63
    3ed6:	f8 94       	cli
    3ed8:	fa 9a       	sbi	0x1f, 2	; 31
    3eda:	f9 9a       	sbi	0x1f, 1	; 31
    3edc:	0f be       	out	0x3f, r0	; 63
    3ede:	01 96       	adiw	r24, 0x01	; 1
    3ee0:	08 95       	ret

00003ee2 <__eewr_word_m644pa>:
    3ee2:	0e 94 63 1f 	call	0x3ec6	; 0x3ec6 <__eewr_byte_m644pa>
    3ee6:	27 2f       	mov	r18, r23
    3ee8:	0c 94 64 1f 	jmp	0x3ec8	; 0x3ec8 <__eewr_r18_m644pa>

00003eec <strrev>:
    3eec:	dc 01       	movw	r26, r24
    3eee:	fc 01       	movw	r30, r24
    3ef0:	67 2f       	mov	r22, r23
    3ef2:	71 91       	ld	r23, Z+
    3ef4:	77 23       	and	r23, r23
    3ef6:	e1 f7       	brne	.-8      	; 0x3ef0 <strrev+0x4>
    3ef8:	32 97       	sbiw	r30, 0x02	; 2
    3efa:	04 c0       	rjmp	.+8      	; 0x3f04 <strrev+0x18>
    3efc:	7c 91       	ld	r23, X
    3efe:	6d 93       	st	X+, r22
    3f00:	70 83       	st	Z, r23
    3f02:	62 91       	ld	r22, -Z
    3f04:	ae 17       	cp	r26, r30
    3f06:	bf 07       	cpc	r27, r31
    3f08:	c8 f3       	brcs	.-14     	; 0x3efc <strrev+0x10>
    3f0a:	08 95       	ret

00003f0c <__eerd_block_m644pa>:
    3f0c:	dc 01       	movw	r26, r24
    3f0e:	cb 01       	movw	r24, r22

00003f10 <__eerd_blraw_m644pa>:
    3f10:	fc 01       	movw	r30, r24
    3f12:	f9 99       	sbic	0x1f, 1	; 31
    3f14:	fe cf       	rjmp	.-4      	; 0x3f12 <__eerd_blraw_m644pa+0x2>
    3f16:	06 c0       	rjmp	.+12     	; 0x3f24 <__eerd_blraw_m644pa+0x14>
    3f18:	f2 bd       	out	0x22, r31	; 34
    3f1a:	e1 bd       	out	0x21, r30	; 33
    3f1c:	f8 9a       	sbi	0x1f, 0	; 31
    3f1e:	31 96       	adiw	r30, 0x01	; 1
    3f20:	00 b4       	in	r0, 0x20	; 32
    3f22:	0d 92       	st	X+, r0
    3f24:	41 50       	subi	r20, 0x01	; 1
    3f26:	50 40       	sbci	r21, 0x00	; 0
    3f28:	b8 f7       	brcc	.-18     	; 0x3f18 <__eerd_blraw_m644pa+0x8>
    3f2a:	08 95       	ret

00003f2c <_exit>:
    3f2c:	f8 94       	cli

00003f2e <__stop_program>:
    3f2e:	ff cf       	rjmp	.-2      	; 0x3f2e <__stop_program>
