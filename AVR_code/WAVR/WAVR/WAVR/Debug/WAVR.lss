
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008e  00800100  00004748  000047fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004748  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000048  0080018e  0080018e  0000488a  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  0000488a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00002160  00000000  00000000  00004894  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000ae4  00000000  00000000  000069f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  000074d8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00002643  00000000  00000000  000075f8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000040c  00000000  00000000  00009c3b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011ca  00000000  00000000  0000a047  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008e4  00000000  00000000  0000b214  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b72  00000000  00000000  0000baf8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000012c4  00000000  00000000  0000c66a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  0000d92e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 31 19 	jmp	0x3262	; 0x3262 <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 d8 18 	jmp	0x31b0	; 0x31b0 <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 e1 19 	jmp	0x33c2	; 0x33c2 <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 7b 19 	jmp	0x32f6	; 0x32f6 <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 ae 19 	jmp	0x335c	; 0x335c <__vector_28>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	89 21       	and	r24, r9

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d0 e1       	ldi	r29, 0x10	; 16
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	e8 e4       	ldi	r30, 0x48	; 72
      92:	f7 e4       	ldi	r31, 0x47	; 71
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	ae 38       	cpi	r26, 0x8E	; 142
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	ae e8       	ldi	r26, 0x8E	; 142
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	a6 3d       	cpi	r26, 0xD6	; 214
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 d7 22 	call	0x45ae	; 0x45ae <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 7d 1b 	call	0x36fa	; 0x36fa <main>
      ca:	0c 94 a2 23 	jmp	0x4744	; 0x4744 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate17checkValidityDateEv>:

BOOL myDate::checkValidityDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	00 d0       	rcall	.+0      	; 0x60a <_ZN6myDate17checkValidityDateEv+0x6>
     60a:	0f 92       	push	r0
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	9b 83       	std	Y+3, r25	; 0x03
     612:	8a 83       	std	Y+2, r24	; 0x02
	BOOL checkYear=fFalse;
     614:	19 82       	std	Y+1, r1	; 0x01
	if (month/13==0){
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	9b 81       	ldd	r25, Y+3	; 0x03
     61a:	fc 01       	movw	r30, r24
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	0c 96       	adiw	r24, 0x0c	; 12
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	89 31       	cpi	r24, 0x19	; 25
     626:	91 05       	cpc	r25, r1
     628:	08 f0       	brcs	.+2      	; 0x62c <_ZN6myDate17checkValidityDateEv+0x28>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	22 23       	and	r18, r18
     62e:	09 f4       	brne	.+2      	; 0x632 <_ZN6myDate17checkValidityDateEv+0x2e>
     630:	66 c0       	rjmp	.+204    	; 0x6fe <_ZN6myDate17checkValidityDateEv+0xfa>
			if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	89 30       	cpi	r24, 0x09	; 9
     63e:	91 05       	cpc	r25, r1
     640:	81 f0       	breq	.+32     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     642:	8a 81       	ldd	r24, Y+2	; 0x02
     644:	9b 81       	ldd	r25, Y+3	; 0x03
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
     64a:	91 81       	ldd	r25, Z+1	; 0x01
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	91 05       	cpc	r25, r1
     650:	41 f0       	breq	.+16     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	9b 81       	ldd	r25, Y+3	; 0x03
     656:	fc 01       	movw	r30, r24
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	86 30       	cpi	r24, 0x06	; 6
     65e:	91 05       	cpc	r25, r1
     660:	59 f4       	brne	.+22     	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	4e 96       	adiw	r24, 0x1e	; 30
     66e:	8d 33       	cpi	r24, 0x3D	; 61
     670:	91 05       	cpc	r25, r1
     672:	10 f4       	brcc	.+4      	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	01 c0       	rjmp	.+2      	; 0x67a <_ZN6myDate17checkValidityDateEv+0x76>
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	88 23       	and	r24, r24
     67c:	19 f0       	breq	.+6      	; 0x684 <_ZN6myDate17checkValidityDateEv+0x80>
				checkYear=fTrue;
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	89 83       	std	Y+1, r24	; 0x01
     682:	28 c0       	rjmp	.+80     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else if (month == 2 && day/29 == 0){
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	fc 01       	movw	r30, r24
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	91 05       	cpc	r25, r1
     692:	59 f4       	brne	.+22     	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     694:	8a 81       	ldd	r24, Y+2	; 0x02
     696:	9b 81       	ldd	r25, Y+3	; 0x03
     698:	fc 01       	movw	r30, r24
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	4c 96       	adiw	r24, 0x1c	; 28
     6a0:	89 33       	cpi	r24, 0x39	; 57
     6a2:	91 05       	cpc	r25, r1
     6a4:	10 f4       	brcc	.+4      	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_ZN6myDate17checkValidityDateEv+0xa8>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	88 23       	and	r24, r24
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_ZN6myDate17checkValidityDateEv+0xb2>
				checkYear=fTrue;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	89 83       	std	Y+1, r24	; 0x01
     6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else{
				if (day/32 == 0){
     6b6:	8a 81       	ldd	r24, Y+2	; 0x02
     6b8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ba:	fc 01       	movw	r30, r24
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	4f 96       	adiw	r24, 0x1f	; 31
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	8f 33       	cpi	r24, 0x3F	; 63
     6c6:	91 05       	cpc	r25, r1
     6c8:	08 f0       	brcs	.+2      	; 0x6cc <_ZN6myDate17checkValidityDateEv+0xc8>
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	22 23       	and	r18, r18
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
					checkYear=fTrue;
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
			
			//Check year
			if (checkYear && year>=2013){return fTrue;}
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	88 23       	and	r24, r24
     6d8:	59 f0       	breq	.+22     	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	84 81       	ldd	r24, Z+4	; 0x04
     6e2:	95 81       	ldd	r25, Z+5	; 0x05
     6e4:	f7 e0       	ldi	r31, 0x07	; 7
     6e6:	8d 3d       	cpi	r24, 0xDD	; 221
     6e8:	9f 07       	cpc	r25, r31
     6ea:	14 f0       	brlt	.+4      	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <_ZN6myDate17checkValidityDateEv+0xee>
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	88 23       	and	r24, r24
     6f4:	11 f0       	breq	.+4      	; 0x6fa <_ZN6myDate17checkValidityDateEv+0xf6>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	03 c0       	rjmp	.+6      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
			else {return fFalse;}
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
	} else {return fFalse;}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	cd b7       	in	r28, 0x3d	; 61
     712:	de b7       	in	r29, 0x3e	; 62
     714:	2d 97       	sbiw	r28, 0x0d	; 13
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	9d 87       	std	Y+13, r25	; 0x0d
     722:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     724:	8c 85       	ldd	r24, Y+12	; 0x0c
     726:	9d 85       	ldd	r25, Y+13	; 0x0d
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	91 81       	ldd	r25, Z+1	; 0x01
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 22 23 	call	0x4644	; 0x4644 <itoa>
	itoa(day,dayString,10);
     73e:	8c 85       	ldd	r24, Y+12	; 0x0c
     740:	9d 85       	ldd	r25, Y+13	; 0x0d
     742:	fc 01       	movw	r30, r24
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9e 01       	movw	r18, r28
     74a:	2c 5f       	subi	r18, 0xFC	; 252
     74c:	3f 4f       	sbci	r19, 0xFF	; 255
     74e:	b9 01       	movw	r22, r18
     750:	4a e0       	ldi	r20, 0x0A	; 10
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	0e 94 22 23 	call	0x4644	; 0x4644 <itoa>
	itoa(year,yearString,10);
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	fc 01       	movw	r30, r24
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9e 01       	movw	r18, r28
     764:	29 5f       	subi	r18, 0xF9	; 249
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	4a e0       	ldi	r20, 0x0A	; 10
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	0e 94 22 23 	call	0x4644	; 0x4644 <itoa>
	strcpy(dateString,monthString);
     772:	8c 85       	ldd	r24, Y+12	; 0x0c
     774:	9d 85       	ldd	r25, Y+13	; 0x0d
     776:	06 96       	adiw	r24, 0x06	; 6
     778:	9e 01       	movw	r18, r28
     77a:	2f 5f       	subi	r18, 0xFF	; 255
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	0e 94 0d 23 	call	0x461a	; 0x461a <strcpy>
	strcat(dateString,",");
     784:	8c 85       	ldd	r24, Y+12	; 0x0c
     786:	9d 85       	ldd	r25, Y+13	; 0x0d
     788:	9c 01       	movw	r18, r24
     78a:	2a 5f       	subi	r18, 0xFA	; 250
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	c9 01       	movw	r24, r18
     790:	ac 01       	movw	r20, r24
     792:	fa 01       	movw	r30, r20
     794:	01 90       	ld	r0, Z+
     796:	00 20       	and	r0, r0
     798:	e9 f7       	brne	.-6      	; 0x794 <_ZN6myDate7getDateEv+0x88>
     79a:	cf 01       	movw	r24, r30
     79c:	01 97       	sbiw	r24, 0x01	; 1
     79e:	84 1b       	sub	r24, r20
     7a0:	95 0b       	sbc	r25, r21
     7a2:	82 0f       	add	r24, r18
     7a4:	93 1f       	adc	r25, r19
     7a6:	2c e2       	ldi	r18, 0x2C	; 44
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	fc 01       	movw	r30, r24
     7ac:	31 83       	std	Z+1, r19	; 0x01
     7ae:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     7b0:	8c 85       	ldd	r24, Y+12	; 0x0c
     7b2:	9d 85       	ldd	r25, Y+13	; 0x0d
     7b4:	06 96       	adiw	r24, 0x06	; 6
     7b6:	9e 01       	movw	r18, r28
     7b8:	2c 5f       	subi	r18, 0xFC	; 252
     7ba:	3f 4f       	sbci	r19, 0xFF	; 255
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <strcat>
	strcat(dateString,",");
     7c2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7c4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7c6:	9c 01       	movw	r18, r24
     7c8:	2a 5f       	subi	r18, 0xFA	; 250
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	c9 01       	movw	r24, r18
     7ce:	ac 01       	movw	r20, r24
     7d0:	fa 01       	movw	r30, r20
     7d2:	01 90       	ld	r0, Z+
     7d4:	00 20       	and	r0, r0
     7d6:	e9 f7       	brne	.-6      	; 0x7d2 <_ZN6myDate7getDateEv+0xc6>
     7d8:	cf 01       	movw	r24, r30
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	84 1b       	sub	r24, r20
     7de:	95 0b       	sbc	r25, r21
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	2c e2       	ldi	r18, 0x2C	; 44
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	fc 01       	movw	r30, r24
     7ea:	31 83       	std	Z+1, r19	; 0x01
     7ec:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     7ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     7f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f2:	06 96       	adiw	r24, 0x06	; 6
     7f4:	9e 01       	movw	r18, r28
     7f6:	29 5f       	subi	r18, 0xF9	; 249
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <strcat>
	dateString[16] = '\0';
     800:	8c 85       	ldd	r24, Y+12	; 0x0c
     802:	9d 85       	ldd	r25, Y+13	; 0x0d
     804:	fc 01       	movw	r30, r24
     806:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     808:	8c 85       	ldd	r24, Y+12	; 0x0c
     80a:	9d 85       	ldd	r25, Y+13	; 0x0d
     80c:	06 96       	adiw	r24, 0x06	; 6
     80e:	2d 96       	adiw	r28, 0x0d	; 13
     810:	0f b6       	in	r0, 0x3f	; 63
     812:	f8 94       	cli
     814:	de bf       	out	0x3e, r29	; 62
     816:	0f be       	out	0x3f, r0	; 63
     818:	cd bf       	out	0x3d, r28	; 61
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	08 95       	ret

00000820 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	00 d0       	rcall	.+0      	; 0x826 <_ZN6myTimeC1Ev+0x6>
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	9a 83       	std	Y+2, r25	; 0x02
     82c:	89 83       	std	Y+1, r24	; 0x01
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     836:	89 81       	ldd	r24, Y+1	; 0x01
     838:	9a 81       	ldd	r25, Y+2	; 0x02
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	40 e0       	ldi	r20, 0x00	; 0
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	08 95       	ret

00000854 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	28 97       	sbiw	r28, 0x08	; 8
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 83       	std	Y+2, r25	; 0x02
     86a:	89 83       	std	Y+1, r24	; 0x01
     86c:	7c 83       	std	Y+4, r23	; 0x04
     86e:	6b 83       	std	Y+3, r22	; 0x03
     870:	5e 83       	std	Y+6, r21	; 0x06
     872:	4d 83       	std	Y+5, r20	; 0x05
     874:	38 87       	std	Y+8, r19	; 0x08
     876:	2f 83       	std	Y+7, r18	; 0x07
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	9a 81       	ldd	r25, Y+2	; 0x02
     87c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	9a 81       	ldd	r25, Y+2	; 0x02
     884:	6b 81       	ldd	r22, Y+3	; 0x03
     886:	7c 81       	ldd	r23, Y+4	; 0x04
     888:	4d 81       	ldd	r20, Y+5	; 0x05
     88a:	5e 81       	ldd	r21, Y+6	; 0x06
     88c:	2f 81       	ldd	r18, Y+7	; 0x07
     88e:	38 85       	ldd	r19, Y+8	; 0x08
     890:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     894:	28 96       	adiw	r28, 0x08	; 8
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	de bf       	out	0x3e, r29	; 62
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	cd bf       	out	0x3d, r28	; 61
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	08 95       	ret

000008a6 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     8a6:	cf 92       	push	r12
     8a8:	df 92       	push	r13
     8aa:	ef 92       	push	r14
     8ac:	ff 92       	push	r15
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
     8ba:	2e 97       	sbiw	r28, 0x0e	; 14
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	f8 94       	cli
     8c0:	de bf       	out	0x3e, r29	; 62
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	cd bf       	out	0x3d, r28	; 61
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01
     8ca:	7c 83       	std	Y+4, r23	; 0x04
     8cc:	6b 83       	std	Y+3, r22	; 0x03
     8ce:	5e 83       	std	Y+6, r21	; 0x06
     8d0:	4d 83       	std	Y+5, r20	; 0x05
     8d2:	38 87       	std	Y+8, r19	; 0x08
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	1a 87       	std	Y+10, r17	; 0x0a
     8d8:	09 87       	std	Y+9, r16	; 0x09
     8da:	fc 86       	std	Y+12, r15	; 0x0c
     8dc:	eb 86       	std	Y+11, r14	; 0x0b
     8de:	de 86       	std	Y+14, r13	; 0x0e
     8e0:	cd 86       	std	Y+13, r12	; 0x0d
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	69 85       	ldd	r22, Y+9	; 0x09
     8e8:	7a 85       	ldd	r23, Y+10	; 0x0a
     8ea:	4b 85       	ldd	r20, Y+11	; 0x0b
     8ec:	5c 85       	ldd	r21, Y+12	; 0x0c
     8ee:	2d 85       	ldd	r18, Y+13	; 0x0d
     8f0:	3e 85       	ldd	r19, Y+14	; 0x0e
     8f2:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	9a 81       	ldd	r25, Y+2	; 0x02
     8fa:	6b 81       	ldd	r22, Y+3	; 0x03
     8fc:	7c 81       	ldd	r23, Y+4	; 0x04
     8fe:	4d 81       	ldd	r20, Y+5	; 0x05
     900:	5e 81       	ldd	r21, Y+6	; 0x06
     902:	2f 81       	ldd	r18, Y+7	; 0x07
     904:	38 85       	ldd	r19, Y+8	; 0x08
     906:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     90a:	2e 96       	adiw	r28, 0x0e	; 14
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	de bf       	out	0x3e, r29	; 62
     912:	0f be       	out	0x3f, r0	; 63
     914:	cd bf       	out	0x3d, r28	; 61
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	08 95       	ret

00000928 <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	00 d0       	rcall	.+0      	; 0x92e <_ZN6myTime10getSecondsEv+0x6>
     92e:	cd b7       	in	r28, 0x3d	; 61
     930:	de b7       	in	r29, 0x3e	; 62
     932:	9a 83       	std	Y+2, r25	; 0x02
     934:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     936:	89 81       	ldd	r24, Y+1	; 0x01
     938:	9a 81       	ldd	r25, Y+2	; 0x02
     93a:	fc 01       	movw	r30, r24
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	00 d0       	rcall	.+0      	; 0x950 <_ZN6myTime10getMinutesEv+0x6>
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	9a 83       	std	Y+2, r25	; 0x02
     956:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	9a 81       	ldd	r25, Y+2	; 0x02
     95c:	fc 01       	movw	r30, r24
     95e:	81 8d       	ldd	r24, Z+25	; 0x19
     960:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	00 d0       	rcall	.+0      	; 0x972 <_ZN6myTime8getHoursEv+0x6>
     972:	cd b7       	in	r28, 0x3d	; 61
     974:	de b7       	in	r29, 0x3e	; 62
     976:	9a 83       	std	Y+2, r25	; 0x02
     978:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	87 89       	ldd	r24, Z+23	; 0x17
     982:	90 8d       	ldd	r25, Z+24	; 0x18
}
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
     996:	a2 97       	sbiw	r28, 0x22	; 34
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	f8 94       	cli
     99c:	de bf       	out	0x3e, r29	; 62
     99e:	0f be       	out	0x3f, r0	; 63
     9a0:	cd bf       	out	0x3d, r28	; 61
     9a2:	98 a3       	lds	r25, 0x58
     9a4:	8f 8f       	std	Y+31, r24	; 0x1f
     9a6:	7a a3       	lds	r23, 0x5a
     9a8:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     9aa:	ce 01       	movw	r24, r28
     9ac:	0b 96       	adiw	r24, 0x0b	; 11
     9ae:	29 a1       	lds	r18, 0x49
     9b0:	3a a1       	lds	r19, 0x4a
     9b2:	b9 01       	movw	r22, r18
     9b4:	0e 94 0d 23 	call	0x461a	; 0x461a <strcpy>
	for (int j=0; j<3; j++){
     9b8:	1a 82       	std	Y+2, r1	; 0x02
     9ba:	19 82       	std	Y+1, r1	; 0x01
     9bc:	43 c0       	rjmp	.+134    	; 0xa44 <_ZN6myTime7setTimeEPc+0xb6>
		for (int i=0; i<2; i++){
     9be:	1c 82       	std	Y+4, r1	; 0x04
     9c0:	1b 82       	std	Y+3, r1	; 0x03
     9c2:	20 c0       	rjmp	.+64     	; 0xa04 <_ZN6myTime7setTimeEPc+0x76>
				tempString[i]=currentString[i+j*3];
     9c4:	29 81       	ldd	r18, Y+1	; 0x01
     9c6:	3a 81       	ldd	r19, Y+2	; 0x02
     9c8:	c9 01       	movw	r24, r18
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	28 0f       	add	r18, r24
     9d0:	39 1f       	adc	r19, r25
     9d2:	8b 81       	ldd	r24, Y+3	; 0x03
     9d4:	9c 81       	ldd	r25, Y+4	; 0x04
     9d6:	82 0f       	add	r24, r18
     9d8:	93 1f       	adc	r25, r19
     9da:	9e 01       	movw	r18, r28
     9dc:	25 5f       	subi	r18, 0xF5	; 245
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	fc 01       	movw	r30, r24
     9e6:	40 81       	ld	r20, Z
     9e8:	9e 01       	movw	r18, r28
     9ea:	2b 5e       	subi	r18, 0xEB	; 235
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	8b 81       	ldd	r24, Y+3	; 0x03
     9f0:	9c 81       	ldd	r25, Y+4	; 0x04
     9f2:	82 0f       	add	r24, r18
     9f4:	93 1f       	adc	r25, r19
     9f6:	fc 01       	movw	r30, r24
     9f8:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
     9fc:	9c 81       	ldd	r25, Y+4	; 0x04
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	9c 83       	std	Y+4, r25	; 0x04
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	21 e0       	ldi	r18, 0x01	; 1
     a06:	8b 81       	ldd	r24, Y+3	; 0x03
     a08:	9c 81       	ldd	r25, Y+4	; 0x04
     a0a:	82 30       	cpi	r24, 0x02	; 2
     a0c:	91 05       	cpc	r25, r1
     a0e:	0c f0       	brlt	.+2      	; 0xa12 <_ZN6myTime7setTimeEPc+0x84>
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	22 23       	and	r18, r18
     a14:	b9 f6       	brne	.-82     	; 0x9c4 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     a16:	ce 01       	movw	r24, r28
     a18:	45 96       	adiw	r24, 0x15	; 21
     a1a:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
     a1e:	9c 01       	movw	r18, r24
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	ae 01       	movw	r20, r28
     a2a:	4f 5f       	subi	r20, 0xFF	; 255
     a2c:	5f 4f       	sbci	r21, 0xFF	; 255
     a2e:	84 0f       	add	r24, r20
     a30:	95 1f       	adc	r25, r21
     a32:	04 96       	adiw	r24, 0x04	; 4
     a34:	fc 01       	movw	r30, r24
     a36:	31 83       	std	Z+1, r19	; 0x01
     a38:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	9a 81       	ldd	r25, Y+2	; 0x02
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	9a 83       	std	Y+2, r25	; 0x02
     a42:	89 83       	std	Y+1, r24	; 0x01
     a44:	21 e0       	ldi	r18, 0x01	; 1
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	9a 81       	ldd	r25, Y+2	; 0x02
     a4a:	83 30       	cpi	r24, 0x03	; 3
     a4c:	91 05       	cpc	r25, r1
     a4e:	0c f0       	brlt	.+2      	; 0xa52 <_ZN6myTime7setTimeEPc+0xc4>
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	22 23       	and	r18, r18
     a54:	09 f0       	breq	.+2      	; 0xa58 <_ZN6myTime7setTimeEPc+0xca>
     a56:	b3 cf       	rjmp	.-154    	; 0x9be <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	9e 81       	ldd	r25, Y+6	; 0x06
     a5c:	47 96       	adiw	r24, 0x17	; 23
     a5e:	8f 32       	cpi	r24, 0x2F	; 47
     a60:	91 05       	cpc	r25, r1
     a62:	c0 f4       	brcc	.+48     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a64:	8f 81       	ldd	r24, Y+7	; 0x07
     a66:	98 85       	ldd	r25, Y+8	; 0x08
     a68:	cb 96       	adiw	r24, 0x3b	; 59
     a6a:	87 37       	cpi	r24, 0x77	; 119
     a6c:	91 05       	cpc	r25, r1
     a6e:	90 f4       	brcc	.+36     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a70:	89 85       	ldd	r24, Y+9	; 0x09
     a72:	9a 85       	ldd	r25, Y+10	; 0x0a
     a74:	cb 96       	adiw	r24, 0x3b	; 59
     a76:	87 37       	cpi	r24, 0x77	; 119
     a78:	91 05       	cpc	r25, r1
     a7a:	60 f4       	brcc	.+24     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     a7c:	6d 81       	ldd	r22, Y+5	; 0x05
     a7e:	7e 81       	ldd	r23, Y+6	; 0x06
     a80:	4f 81       	ldd	r20, Y+7	; 0x07
     a82:	58 85       	ldd	r21, Y+8	; 0x08
     a84:	29 85       	ldd	r18, Y+9	; 0x09
     a86:	3a 85       	ldd	r19, Y+10	; 0x0a
     a88:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a8a:	98 a1       	lds	r25, 0x48
     a8c:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
		return fTrue;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	01 c0       	rjmp	.+2      	; 0xa96 <_ZN6myTime7setTimeEPc+0x108>
	} 
	return fFalse;
     a94:	80 e0       	ldi	r24, 0x00	; 0
}
     a96:	a2 96       	adiw	r28, 0x22	; 34
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	cd bf       	out	0x3d, r28	; 61
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	cd b7       	in	r28, 0x3d	; 61
     aae:	de b7       	in	r29, 0x3e	; 62
     ab0:	28 97       	sbiw	r28, 0x08	; 8
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	9a 83       	std	Y+2, r25	; 0x02
     abe:	89 83       	std	Y+1, r24	; 0x01
     ac0:	7c 83       	std	Y+4, r23	; 0x04
     ac2:	6b 83       	std	Y+3, r22	; 0x03
     ac4:	5e 83       	std	Y+6, r21	; 0x06
     ac6:	4d 83       	std	Y+5, r20	; 0x05
     ac8:	38 87       	std	Y+8, r19	; 0x08
     aca:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
     ad0:	2b 81       	ldd	r18, Y+3	; 0x03
     ad2:	3c 81       	ldd	r19, Y+4	; 0x04
     ad4:	b9 01       	movw	r22, r18
     ad6:	0e 94 84 05 	call	0xb08	; 0xb08 <_ZN6myTime7setHourEi>
	setMinute(minute);
     ada:	89 81       	ldd	r24, Y+1	; 0x01
     adc:	9a 81       	ldd	r25, Y+2	; 0x02
     ade:	2d 81       	ldd	r18, Y+5	; 0x05
     ae0:	3e 81       	ldd	r19, Y+6	; 0x06
     ae2:	b9 01       	movw	r22, r18
     ae4:	0e 94 a2 05 	call	0xb44	; 0xb44 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     ae8:	89 81       	ldd	r24, Y+1	; 0x01
     aea:	9a 81       	ldd	r25, Y+2	; 0x02
     aec:	2f 81       	ldd	r18, Y+7	; 0x07
     aee:	38 85       	ldd	r19, Y+8	; 0x08
     af0:	b9 01       	movw	r22, r18
     af2:	0e 94 c0 05 	call	0xb80	; 0xb80 <_ZN6myTime9setSecondEi>
}
     af6:	28 96       	adiw	r28, 0x08	; 8
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	de bf       	out	0x3e, r29	; 62
     afe:	0f be       	out	0x3f, r0	; 63
     b00:	cd bf       	out	0x3d, r28	; 61
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     b08:	cf 93       	push	r28
     b0a:	df 93       	push	r29
     b0c:	00 d0       	rcall	.+0      	; 0xb0e <_ZN6myTime7setHourEi+0x6>
     b0e:	00 d0       	rcall	.+0      	; 0xb10 <_ZN6myTime7setHourEi+0x8>
     b10:	cd b7       	in	r28, 0x3d	; 61
     b12:	de b7       	in	r29, 0x3e	; 62
     b14:	9a 83       	std	Y+2, r25	; 0x02
     b16:	89 83       	std	Y+1, r24	; 0x01
     b18:	7c 83       	std	Y+4, r23	; 0x04
     b1a:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     b1c:	8b 81       	ldd	r24, Y+3	; 0x03
     b1e:	9c 81       	ldd	r25, Y+4	; 0x04
     b20:	47 96       	adiw	r24, 0x17	; 23
     b22:	8f 32       	cpi	r24, 0x2F	; 47
     b24:	91 05       	cpc	r25, r1
     b26:	38 f4       	brcc	.+14     	; 0xb36 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     b28:	89 81       	ldd	r24, Y+1	; 0x01
     b2a:	9a 81       	ldd	r25, Y+2	; 0x02
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	3c 81       	ldd	r19, Y+4	; 0x04
     b30:	fc 01       	movw	r30, r24
     b32:	30 8f       	std	Z+24, r19	; 0x18
     b34:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	0f 90       	pop	r0
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <_ZN6myTime9setMinuteEi+0x6>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <_ZN6myTime9setMinuteEi+0x8>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01
     b54:	7c 83       	std	Y+4, r23	; 0x04
     b56:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	cb 96       	adiw	r24, 0x3b	; 59
     b5e:	87 37       	cpi	r24, 0x77	; 119
     b60:	91 05       	cpc	r25, r1
     b62:	38 f4       	brcc	.+14     	; 0xb72 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	2b 81       	ldd	r18, Y+3	; 0x03
     b6a:	3c 81       	ldd	r19, Y+4	; 0x04
     b6c:	fc 01       	movw	r30, r24
     b6e:	32 8f       	std	Z+26, r19	; 0x1a
     b70:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     b72:	0f 90       	pop	r0
     b74:	0f 90       	pop	r0
     b76:	0f 90       	pop	r0
     b78:	0f 90       	pop	r0
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	00 d0       	rcall	.+0      	; 0xb86 <_ZN6myTime9setSecondEi+0x6>
     b86:	00 d0       	rcall	.+0      	; 0xb88 <_ZN6myTime9setSecondEi+0x8>
     b88:	cd b7       	in	r28, 0x3d	; 61
     b8a:	de b7       	in	r29, 0x3e	; 62
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
     b90:	7c 83       	std	Y+4, r23	; 0x04
     b92:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	cb 96       	adiw	r24, 0x3b	; 59
     b9a:	87 37       	cpi	r24, 0x77	; 119
     b9c:	91 05       	cpc	r25, r1
     b9e:	38 f4       	brcc	.+14     	; 0xbae <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	9a 81       	ldd	r25, Y+2	; 0x02
     ba4:	2b 81       	ldd	r18, Y+3	; 0x03
     ba6:	3c 81       	ldd	r19, Y+4	; 0x04
     ba8:	fc 01       	movw	r30, r24
     baa:	34 8f       	std	Z+28, r19	; 0x1c
     bac:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	28 97       	sbiw	r28, 0x08	; 8
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	de bf       	out	0x3e, r29	; 62
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	cd bf       	out	0x3d, r28	; 61
     bd0:	9e 83       	std	Y+6, r25	; 0x06
     bd2:	8d 83       	std	Y+5, r24	; 0x05
     bd4:	78 87       	std	Y+8, r23	; 0x08
     bd6:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     bd8:	8d 81       	ldd	r24, Y+5	; 0x05
     bda:	9e 81       	ldd	r25, Y+6	; 0x06
     bdc:	fc 01       	movw	r30, r24
     bde:	27 89       	ldd	r18, Z+23	; 0x17
     be0:	30 8d       	ldd	r19, Z+24	; 0x18
     be2:	8f 81       	ldd	r24, Y+7	; 0x07
     be4:	98 85       	ldd	r25, Y+8	; 0x08
     be6:	82 0f       	add	r24, r18
     be8:	93 1f       	adc	r25, r19
     bea:	9a 83       	std	Y+2, r25	; 0x02
     bec:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	9a 81       	ldd	r25, Y+2	; 0x02
     bf2:	28 e1       	ldi	r18, 0x18	; 24
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	b9 01       	movw	r22, r18
     bf8:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     bfc:	9c 01       	movw	r18, r24
     bfe:	8d 81       	ldd	r24, Y+5	; 0x05
     c00:	9e 81       	ldd	r25, Y+6	; 0x06
     c02:	fc 01       	movw	r30, r24
     c04:	30 8f       	std	Z+24, r19	; 0x18
     c06:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a 81       	ldd	r25, Y+2	; 0x02
     c0c:	21 e0       	ldi	r18, 0x01	; 1
     c0e:	88 31       	cpi	r24, 0x18	; 24
     c10:	91 05       	cpc	r25, r1
     c12:	0c f4       	brge	.+2      	; 0xc16 <_ZN6myTime8addHoursEi+0x5a>
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	22 23       	and	r18, r18
     c18:	91 f0       	breq	.+36     	; 0xc3e <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	28 e1       	ldi	r18, 0x18	; 24
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	b9 01       	movw	r22, r18
     c24:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     c28:	9b 01       	movw	r18, r22
     c2a:	c9 01       	movw	r24, r18
     c2c:	9c 83       	std	Y+4, r25	; 0x04
     c2e:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     c30:	8d 81       	ldd	r24, Y+5	; 0x05
     c32:	9e 81       	ldd	r25, Y+6	; 0x06
     c34:	2b 81       	ldd	r18, Y+3	; 0x03
     c36:	3c 81       	ldd	r19, Y+4	; 0x04
     c38:	b9 01       	movw	r22, r18
     c3a:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     c3e:	28 96       	adiw	r28, 0x08	; 8
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	08 95       	ret

00000c50 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
     c58:	28 97       	sbiw	r28, 0x08	; 8
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	9e 83       	std	Y+6, r25	; 0x06
     c66:	8d 83       	std	Y+5, r24	; 0x05
     c68:	78 87       	std	Y+8, r23	; 0x08
     c6a:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     c6c:	8d 81       	ldd	r24, Y+5	; 0x05
     c6e:	9e 81       	ldd	r25, Y+6	; 0x06
     c70:	fc 01       	movw	r30, r24
     c72:	21 8d       	ldd	r18, Z+25	; 0x19
     c74:	32 8d       	ldd	r19, Z+26	; 0x1a
     c76:	8f 81       	ldd	r24, Y+7	; 0x07
     c78:	98 85       	ldd	r25, Y+8	; 0x08
     c7a:	82 0f       	add	r24, r18
     c7c:	93 1f       	adc	r25, r19
     c7e:	9a 83       	std	Y+2, r25	; 0x02
     c80:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	9a 81       	ldd	r25, Y+2	; 0x02
     c86:	2c e3       	ldi	r18, 0x3C	; 60
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	b9 01       	movw	r22, r18
     c8c:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     c90:	9c 01       	movw	r18, r24
     c92:	8d 81       	ldd	r24, Y+5	; 0x05
     c94:	9e 81       	ldd	r25, Y+6	; 0x06
     c96:	fc 01       	movw	r30, r24
     c98:	32 8f       	std	Z+26, r19	; 0x1a
     c9a:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ca0:	21 e0       	ldi	r18, 0x01	; 1
     ca2:	8c 33       	cpi	r24, 0x3C	; 60
     ca4:	91 05       	cpc	r25, r1
     ca6:	0c f4       	brge	.+2      	; 0xcaa <_ZN6myTime10addMinutesEi+0x5a>
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	22 23       	and	r18, r18
     cac:	91 f0       	breq	.+36     	; 0xcd2 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	2c e3       	ldi	r18, 0x3C	; 60
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	b9 01       	movw	r22, r18
     cb8:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     cbc:	9b 01       	movw	r18, r22
     cbe:	c9 01       	movw	r24, r18
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     cc4:	2b 81       	ldd	r18, Y+3	; 0x03
     cc6:	3c 81       	ldd	r19, Y+4	; 0x04
     cc8:	8d 81       	ldd	r24, Y+5	; 0x05
     cca:	9e 81       	ldd	r25, Y+6	; 0x06
     ccc:	b9 01       	movw	r22, r18
     cce:	0e 94 de 05 	call	0xbbc	; 0xbbc <_ZN6myTime8addHoursEi>
	}
}
     cd2:	28 96       	adiw	r28, 0x08	; 8
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	cd b7       	in	r28, 0x3d	; 61
     cea:	de b7       	in	r29, 0x3e	; 62
     cec:	28 97       	sbiw	r28, 0x08	; 8
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	de bf       	out	0x3e, r29	; 62
     cf4:	0f be       	out	0x3f, r0	; 63
     cf6:	cd bf       	out	0x3d, r28	; 61
     cf8:	9e 83       	std	Y+6, r25	; 0x06
     cfa:	8d 83       	std	Y+5, r24	; 0x05
     cfc:	78 87       	std	Y+8, r23	; 0x08
     cfe:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	9e 81       	ldd	r25, Y+6	; 0x06
     d04:	fc 01       	movw	r30, r24
     d06:	23 8d       	ldd	r18, Z+27	; 0x1b
     d08:	34 8d       	ldd	r19, Z+28	; 0x1c
     d0a:	8f 81       	ldd	r24, Y+7	; 0x07
     d0c:	98 85       	ldd	r25, Y+8	; 0x08
     d0e:	82 0f       	add	r24, r18
     d10:	93 1f       	adc	r25, r19
     d12:	9a 83       	std	Y+2, r25	; 0x02
     d14:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     d16:	89 81       	ldd	r24, Y+1	; 0x01
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	2c e3       	ldi	r18, 0x3C	; 60
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	b9 01       	movw	r22, r18
     d20:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     d24:	9c 01       	movw	r18, r24
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	fc 01       	movw	r30, r24
     d2c:	34 8f       	std	Z+28, r19	; 0x1c
     d2e:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	9a 81       	ldd	r25, Y+2	; 0x02
     d34:	21 e0       	ldi	r18, 0x01	; 1
     d36:	8c 33       	cpi	r24, 0x3C	; 60
     d38:	91 05       	cpc	r25, r1
     d3a:	0c f4       	brge	.+2      	; 0xd3e <_ZN6myTime10addSecondsEi+0x5a>
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	22 23       	and	r18, r18
     d40:	91 f0       	breq	.+36     	; 0xd66 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     d42:	89 81       	ldd	r24, Y+1	; 0x01
     d44:	9a 81       	ldd	r25, Y+2	; 0x02
     d46:	2c e3       	ldi	r18, 0x3C	; 60
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	b9 01       	movw	r22, r18
     d4c:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
     d50:	9b 01       	movw	r18, r22
     d52:	c9 01       	movw	r24, r18
     d54:	9c 83       	std	Y+4, r25	; 0x04
     d56:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     d58:	2b 81       	ldd	r18, Y+3	; 0x03
     d5a:	3c 81       	ldd	r19, Y+4	; 0x04
     d5c:	8d 81       	ldd	r24, Y+5	; 0x05
     d5e:	9e 81       	ldd	r25, Y+6	; 0x06
     d60:	b9 01       	movw	r22, r18
     d62:	0e 94 28 06 	call	0xc50	; 0xc50 <_ZN6myTime10addMinutesEi>
	}
}
     d66:	28 96       	adiw	r28, 0x08	; 8
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	08 95       	ret

00000d78 <_ZN6myTime13checkValidityEv>:

BOOL myTime::checkValidity(){
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	00 d0       	rcall	.+0      	; 0xd7e <_ZN6myTime13checkValidityEv+0x6>
     d7e:	0f 92       	push	r0
     d80:	cd b7       	in	r28, 0x3d	; 61
     d82:	de b7       	in	r29, 0x3e	; 62
     d84:	9b 83       	std	Y+3, r25	; 0x03
     d86:	8a 83       	std	Y+2, r24	; 0x02
	BOOL stillValid=fTrue;
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	89 83       	std	Y+1, r24	; 0x01
	if (second/60==0 && minute/60==0 && hour/24==0){
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	fc 01       	movw	r30, r24
     d92:	83 8d       	ldd	r24, Z+27	; 0x1b
     d94:	94 8d       	ldd	r25, Z+28	; 0x1c
     d96:	cb 96       	adiw	r24, 0x3b	; 59
     d98:	87 37       	cpi	r24, 0x77	; 119
     d9a:	91 05       	cpc	r25, r1
     d9c:	a0 f4       	brcc	.+40     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	fc 01       	movw	r30, r24
     da4:	81 8d       	ldd	r24, Z+25	; 0x19
     da6:	92 8d       	ldd	r25, Z+26	; 0x1a
     da8:	cb 96       	adiw	r24, 0x3b	; 59
     daa:	87 37       	cpi	r24, 0x77	; 119
     dac:	91 05       	cpc	r25, r1
     dae:	58 f4       	brcc	.+22     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	9b 81       	ldd	r25, Y+3	; 0x03
     db4:	fc 01       	movw	r30, r24
     db6:	87 89       	ldd	r24, Z+23	; 0x17
     db8:	90 8d       	ldd	r25, Z+24	; 0x18
     dba:	47 96       	adiw	r24, 0x17	; 23
     dbc:	8f 32       	cpi	r24, 0x2F	; 47
     dbe:	91 05       	cpc	r25, r1
     dc0:	10 f4       	brcc	.+4      	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <_ZN6myTime13checkValidityEv+0x50>
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	88 23       	and	r24, r24
     dca:	69 f0       	breq	.+26     	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
		if (checkValidityDate()){return fTrue;}
     dcc:	8a 81       	ldd	r24, Y+2	; 0x02
     dce:	9b 81       	ldd	r25, Y+3	; 0x03
     dd0:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate17checkValidityDateEv>
     dd4:	98 2f       	mov	r25, r24
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	99 23       	and	r25, r25
     dda:	09 f4       	brne	.+2      	; 0xdde <_ZN6myTime13checkValidityEv+0x66>
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	88 23       	and	r24, r24
     de0:	11 f0       	breq	.+4      	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	01 c0       	rjmp	.+2      	; 0xde8 <_ZN6myTime13checkValidityEv+0x70>
	}
	return fFalse;
     de6:	80 e0       	ldi	r24, 0x00	; 0
}
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	cd b7       	in	r28, 0x3d	; 61
     dfa:	de b7       	in	r29, 0x3e	; 62
     dfc:	2b 97       	sbiw	r28, 0x0b	; 11
     dfe:	0f b6       	in	r0, 0x3f	; 63
     e00:	f8 94       	cli
     e02:	de bf       	out	0x3e, r29	; 62
     e04:	0f be       	out	0x3f, r0	; 63
     e06:	cd bf       	out	0x3d, r28	; 61
     e08:	9b 87       	std	Y+11, r25	; 0x0b
     e0a:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e10:	fc 01       	movw	r30, r24
     e12:	87 89       	ldd	r24, Z+23	; 0x17
     e14:	90 8d       	ldd	r25, Z+24	; 0x18
     e16:	9e 01       	movw	r18, r28
     e18:	2f 5f       	subi	r18, 0xFF	; 255
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	b9 01       	movw	r22, r18
     e1e:	4a e0       	ldi	r20, 0x0A	; 10
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	0e 94 22 23 	call	0x4644	; 0x4644 <itoa>
	itoa(minute,minuteString,10);
     e26:	8a 85       	ldd	r24, Y+10	; 0x0a
     e28:	9b 85       	ldd	r25, Y+11	; 0x0b
     e2a:	fc 01       	movw	r30, r24
     e2c:	81 8d       	ldd	r24, Z+25	; 0x19
     e2e:	92 8d       	ldd	r25, Z+26	; 0x1a
     e30:	9e 01       	movw	r18, r28
     e32:	2c 5f       	subi	r18, 0xFC	; 252
     e34:	3f 4f       	sbci	r19, 0xFF	; 255
     e36:	b9 01       	movw	r22, r18
     e38:	4a e0       	ldi	r20, 0x0A	; 10
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 22 23 	call	0x4644	; 0x4644 <itoa>
	itoa(second,secondString,10);
     e40:	8a 85       	ldd	r24, Y+10	; 0x0a
     e42:	9b 85       	ldd	r25, Y+11	; 0x0b
     e44:	fc 01       	movw	r30, r24
     e46:	83 8d       	ldd	r24, Z+27	; 0x1b
     e48:	94 8d       	ldd	r25, Z+28	; 0x1c
     e4a:	9e 01       	movw	r18, r28
     e4c:	29 5f       	subi	r18, 0xF9	; 249
     e4e:	3f 4f       	sbci	r19, 0xFF	; 255
     e50:	b9 01       	movw	r22, r18
     e52:	4a e0       	ldi	r20, 0x0A	; 10
     e54:	50 e0       	ldi	r21, 0x00	; 0
     e56:	0e 94 22 23 	call	0x4644	; 0x4644 <itoa>
	strcpy(timeString,hourString);
     e5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e5e:	4d 96       	adiw	r24, 0x1d	; 29
     e60:	9e 01       	movw	r18, r28
     e62:	2f 5f       	subi	r18, 0xFF	; 255
     e64:	3f 4f       	sbci	r19, 0xFF	; 255
     e66:	b9 01       	movw	r22, r18
     e68:	0e 94 0d 23 	call	0x461a	; 0x461a <strcpy>
	strcat(timeString,":");
     e6c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e6e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e70:	9c 01       	movw	r18, r24
     e72:	23 5e       	subi	r18, 0xE3	; 227
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	c9 01       	movw	r24, r18
     e78:	ac 01       	movw	r20, r24
     e7a:	fa 01       	movw	r30, r20
     e7c:	01 90       	ld	r0, Z+
     e7e:	00 20       	and	r0, r0
     e80:	e9 f7       	brne	.-6      	; 0xe7c <_ZN6myTime7getTimeEv+0x88>
     e82:	cf 01       	movw	r24, r30
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	84 1b       	sub	r24, r20
     e88:	95 0b       	sbc	r25, r21
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	2a e3       	ldi	r18, 0x3A	; 58
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	fc 01       	movw	r30, r24
     e94:	31 83       	std	Z+1, r19	; 0x01
     e96:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     e98:	8a 85       	ldd	r24, Y+10	; 0x0a
     e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9c:	4d 96       	adiw	r24, 0x1d	; 29
     e9e:	9e 01       	movw	r18, r28
     ea0:	2c 5f       	subi	r18, 0xFC	; 252
     ea2:	3f 4f       	sbci	r19, 0xFF	; 255
     ea4:	b9 01       	movw	r22, r18
     ea6:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <strcat>
	strcat(timeString,":");
     eaa:	8a 85       	ldd	r24, Y+10	; 0x0a
     eac:	9b 85       	ldd	r25, Y+11	; 0x0b
     eae:	9c 01       	movw	r18, r24
     eb0:	23 5e       	subi	r18, 0xE3	; 227
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	c9 01       	movw	r24, r18
     eb6:	ac 01       	movw	r20, r24
     eb8:	fa 01       	movw	r30, r20
     eba:	01 90       	ld	r0, Z+
     ebc:	00 20       	and	r0, r0
     ebe:	e9 f7       	brne	.-6      	; 0xeba <_ZN6myTime7getTimeEv+0xc6>
     ec0:	cf 01       	movw	r24, r30
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	84 1b       	sub	r24, r20
     ec6:	95 0b       	sbc	r25, r21
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	2a e3       	ldi	r18, 0x3A	; 58
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	fc 01       	movw	r30, r24
     ed2:	31 83       	std	Z+1, r19	; 0x01
     ed4:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
     eda:	4d 96       	adiw	r24, 0x1d	; 29
     edc:	9e 01       	movw	r18, r28
     ede:	29 5f       	subi	r18, 0xF9	; 249
     ee0:	3f 4f       	sbci	r19, 0xFF	; 255
     ee2:	b9 01       	movw	r22, r18
     ee4:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <strcat>
	timeString[11] = '\0';
     ee8:	8a 85       	ldd	r24, Y+10	; 0x0a
     eea:	9b 85       	ldd	r25, Y+11	; 0x0b
     eec:	fc 01       	movw	r30, r24
     eee:	10 a6       	lds	r17, 0xb0
	return timeString;
     ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ef4:	4d 96       	adiw	r24, 0x1d	; 29
     ef6:	2b 96       	adiw	r28, 0x0b	; 11
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 31;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	2f 97       	sbiw	r28, 0x0f	; 15
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	8e 87       	std	Y+14, r24	; 0x0e
     f1e:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     f20:	f8 94       	cli
	if (gTime){
     f22:	8e 85       	ldd	r24, Y+14	; 0x0e
     f24:	88 23       	and	r24, r24
     f26:	09 f4       	brne	.+2      	; 0xf2a <_Z18getDateTime_eepromhh+0x22>
     f28:	4b c0       	rjmp	.+150    	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     f2a:	1a 82       	std	Y+2, r1	; 0x02
     f2c:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     f32:	2c c0       	rjmp	.+88     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__eerd_byte_m644pa>
     f3c:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__eerd_byte_m644pa>
     f46:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__eerd_byte_m644pa>
     f50:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     f52:	8f 81       	ldd	r24, Y+7	; 0x07
     f54:	8c 33       	cpi	r24, 0x3C	; 60
     f56:	a8 f4       	brcc	.+42     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f58:	88 85       	ldd	r24, Y+8	; 0x08
     f5a:	8c 33       	cpi	r24, 0x3C	; 60
     f5c:	90 f4       	brcc	.+36     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f5e:	89 85       	ldd	r24, Y+9	; 0x09
     f60:	88 31       	cpi	r24, 0x18	; 24
     f62:	78 f4       	brcc	.+30     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	68 2f       	mov	r22, r24
     f68:	70 e0       	ldi	r23, 0x00	; 0
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	48 2f       	mov	r20, r24
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	8f 81       	ldd	r24, Y+7	; 0x07
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	82 e9       	ldi	r24, 0x92	; 146
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
     f7e:	1b 82       	std	Y+3, r1	; 0x03
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	9a 81       	ldd	r25, Y+2	; 0x02
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     f8c:	8b 81       	ldd	r24, Y+3	; 0x03
     f8e:	88 23       	and	r24, r24
     f90:	39 f0       	breq	.+14     	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	9a 81       	ldd	r25, Y+2	; 0x02
     f96:	83 30       	cpi	r24, 0x03	; 3
     f98:	91 05       	cpc	r25, r1
     f9a:	14 f4       	brge	.+4      	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <_Z18getDateTime_eepromhh+0x9a>
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	88 23       	and	r24, r24
     fa4:	39 f6       	brne	.-114    	; 0xf34 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     fa6:	8b 81       	ldd	r24, Y+3	; 0x03
     fa8:	88 23       	and	r24, r24
     faa:	51 f0       	breq	.+20     	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
     fac:	82 e9       	ldi	r24, 0x92	; 146
     fae:	91 e0       	ldi	r25, 0x01	; 1
     fb0:	61 e0       	ldi	r22, 0x01	; 1
     fb2:	70 e0       	ldi	r23, 0x00	; 0
     fb4:	41 e0       	ldi	r20, 0x01	; 1
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	21 e0       	ldi	r18, 0x01	; 1
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
     fc2:	88 23       	and	r24, r24
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <_Z18getDateTime_eepromhh+0xc0>
     fc6:	4e c0       	rjmp	.+156    	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     fc8:	1d 82       	std	Y+5, r1	; 0x05
     fca:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     fcc:	81 e0       	ldi	r24, 0x01	; 1
     fce:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     fd0:	2f c0       	rjmp	.+94     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     fd2:	84 e0       	ldi	r24, 0x04	; 4
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__eerd_byte_m644pa>
     fda:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 61 23 	call	0x46c2	; 0x46c2 <__eerd_byte_m644pa>
     fe4:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     fe6:	85 e0       	ldi	r24, 0x05	; 5
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	0e 94 69 23 	call	0x46d2	; 0x46d2 <__eerd_word_m644pa>
     fee:	9d 87       	std	Y+13, r25	; 0x0d
     ff0:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     ff2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff4:	8f 31       	cpi	r24, 0x1F	; 31
     ff6:	b8 f4       	brcc	.+46     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ff8:	8b 85       	ldd	r24, Y+11	; 0x0b
     ffa:	8d 30       	cpi	r24, 0x0D	; 13
     ffc:	a0 f4       	brcc	.+40     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ffe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1000:	9d 85       	ldd	r25, Y+13	; 0x0d
    1002:	27 e2       	ldi	r18, 0x27	; 39
    1004:	80 31       	cpi	r24, 0x10	; 16
    1006:	92 07       	cpc	r25, r18
    1008:	70 f4       	brcc	.+28     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
    100a:	8b 85       	ldd	r24, Y+11	; 0x0b
    100c:	68 2f       	mov	r22, r24
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	8a 85       	ldd	r24, Y+10	; 0x0a
    1012:	48 2f       	mov	r20, r24
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	2c 85       	ldd	r18, Y+12	; 0x0c
    1018:	3d 85       	ldd	r19, Y+13	; 0x0d
    101a:	82 e9       	ldi	r24, 0x92	; 146
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
    1022:	1e 82       	std	Y+6, r1	; 0x06
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
    1026:	8c 81       	ldd	r24, Y+4	; 0x04
    1028:	9d 81       	ldd	r25, Y+5	; 0x05
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	9d 83       	std	Y+5, r25	; 0x05
    102e:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
    1030:	8e 81       	ldd	r24, Y+6	; 0x06
    1032:	88 23       	and	r24, r24
    1034:	39 f0       	breq	.+14     	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	9d 81       	ldd	r25, Y+5	; 0x05
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	91 05       	cpc	r25, r1
    103e:	14 f4       	brge	.+4      	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <_Z18getDateTime_eepromhh+0x13e>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	88 23       	and	r24, r24
    1048:	21 f6       	brne	.-120    	; 0xfd2 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	88 23       	and	r24, r24
    104e:	51 f0       	breq	.+20     	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
    1050:	82 e9       	ldi	r24, 0x92	; 146
    1052:	91 e0       	ldi	r25, 0x01	; 1
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	70 e0       	ldi	r23, 0x00	; 0
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	21 ed       	ldi	r18, 0xD1	; 209
    105e:	37 e0       	ldi	r19, 0x07	; 7
    1060:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
    1064:	78 94       	sei
}
    1066:	2f 96       	adiw	r28, 0x0f	; 15
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	29 97       	sbiw	r28, 0x09	; 9
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	88 87       	std	Y+8, r24	; 0x08
    108e:	69 87       	std	Y+9, r22	; 0x09
	cli();
    1090:	f8 94       	cli
	if (sTime){
    1092:	88 85       	ldd	r24, Y+8	; 0x08
    1094:	88 23       	and	r24, r24
    1096:	f1 f0       	breq	.+60     	; 0x10d4 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
    1098:	82 e9       	ldi	r24, 0x92	; 146
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    10a0:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
    10a2:	82 e9       	ldi	r24, 0x92	; 146
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    10aa:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
    10ac:	82 e9       	ldi	r24, 0x92	; 146
    10ae:	91 e0       	ldi	r25, 0x01	; 1
    10b0:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    10b4:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	6b 81       	ldd	r22, Y+3	; 0x03
    10bc:	0e 94 6f 23 	call	0x46de	; 0x46de <__eewr_byte_m644pa>
		eeprom_write_byte(&eeMinute,tempMin);
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	6a 81       	ldd	r22, Y+2	; 0x02
    10c6:	0e 94 6f 23 	call	0x46de	; 0x46de <__eewr_byte_m644pa>
		eeprom_write_byte(&eeHour,tempHour);
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	69 81       	ldd	r22, Y+1	; 0x01
    10d0:	0e 94 6f 23 	call	0x46de	; 0x46de <__eewr_byte_m644pa>
	}
	if (sDate){
    10d4:	89 85       	ldd	r24, Y+9	; 0x09
    10d6:	88 23       	and	r24, r24
    10d8:	09 f1       	breq	.+66     	; 0x111c <__stack+0x1d>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
    10da:	82 e9       	ldi	r24, 0x92	; 146
    10dc:	91 e0       	ldi	r25, 0x01	; 1
    10de:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
    10e2:	9d 83       	std	Y+5, r25	; 0x05
    10e4:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
    10e6:	82 e9       	ldi	r24, 0x92	; 146
    10e8:	91 e0       	ldi	r25, 0x01	; 1
    10ea:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
    10ee:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
    10f0:	82 e9       	ldi	r24, 0x92	; 146
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
    10f8:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
    10fa:	85 e0       	ldi	r24, 0x05	; 5
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1100:	3d 81       	ldd	r19, Y+5	; 0x05
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 7d 23 	call	0x46fa	; 0x46fa <__eewr_word_m644pa>
		eeprom_write_byte(&eeMonth,tempMonth);
    1108:	83 e0       	ldi	r24, 0x03	; 3
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	6e 81       	ldd	r22, Y+6	; 0x06
    110e:	0e 94 6f 23 	call	0x46de	; 0x46de <__eewr_byte_m644pa>
		eeprom_write_byte(&eeDay,tempDay);
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	6f 81       	ldd	r22, Y+7	; 0x07
    1118:	0e 94 6f 23 	call	0x46de	; 0x46de <__eewr_byte_m644pa>
	}
	sei();
    111c:	78 94       	sei
}
    111e:	29 96       	adiw	r28, 0x09	; 9
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	cd bf       	out	0x3d, r28	; 61
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	08 95       	ret

00001130 <_Z8Wait_ms2i>:
extern BOOL flagReceivingBone, flagFreshStart, restart, flagReceivingGAVR,flagWaitingForReceiveGAVR;
extern WORD globalADC, globalTemp;
extern myTime currentTime;

void Wait_ms2(int delay)
{
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	00 d0       	rcall	.+0      	; 0x1136 <_Z8Wait_ms2i+0x6>
    1136:	00 d0       	rcall	.+0      	; 0x1138 <_Z8Wait_ms2i+0x8>
    1138:	cd b7       	in	r28, 0x3d	; 61
    113a:	de b7       	in	r29, 0x3e	; 62
    113c:	9c 83       	std	Y+4, r25	; 0x04
    113e:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    1140:	17 c0       	rjmp	.+46     	; 0x1170 <_Z8Wait_ms2i+0x40>
		for(i = 0; i < 200; i++){
    1142:	1a 82       	std	Y+2, r1	; 0x02
    1144:	19 82       	std	Y+1, r1	; 0x01
    1146:	06 c0       	rjmp	.+12     	; 0x1154 <_Z8Wait_ms2i+0x24>
			asm volatile("nop");
    1148:	00 00       	nop
void Wait_ms2(int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 200; i++){
    114a:	89 81       	ldd	r24, Y+1	; 0x01
    114c:	9a 81       	ldd	r25, Y+2	; 0x02
    114e:	01 96       	adiw	r24, 0x01	; 1
    1150:	9a 83       	std	Y+2, r25	; 0x02
    1152:	89 83       	std	Y+1, r24	; 0x01
    1154:	89 81       	ldd	r24, Y+1	; 0x01
    1156:	9a 81       	ldd	r25, Y+2	; 0x02
    1158:	21 e0       	ldi	r18, 0x01	; 1
    115a:	88 3c       	cpi	r24, 0xC8	; 200
    115c:	91 05       	cpc	r25, r1
    115e:	0c f0       	brlt	.+2      	; 0x1162 <_Z8Wait_ms2i+0x32>
    1160:	20 e0       	ldi	r18, 0x00	; 0
    1162:	22 23       	and	r18, r18
    1164:	89 f7       	brne	.-30     	; 0x1148 <_Z8Wait_ms2i+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    1166:	8b 81       	ldd	r24, Y+3	; 0x03
    1168:	9c 81       	ldd	r25, Y+4	; 0x04
    116a:	01 97       	sbiw	r24, 0x01	; 1
    116c:	9c 83       	std	Y+4, r25	; 0x04
    116e:	8b 83       	std	Y+3, r24	; 0x03

void Wait_ms2(int delay)
{
	volatile int i;

	while(delay > 0){
    1170:	21 e0       	ldi	r18, 0x01	; 1
    1172:	8b 81       	ldd	r24, Y+3	; 0x03
    1174:	9c 81       	ldd	r25, Y+4	; 0x04
    1176:	18 16       	cp	r1, r24
    1178:	19 06       	cpc	r1, r25
    117a:	0c f0       	brlt	.+2      	; 0x117e <_Z8Wait_ms2i+0x4e>
    117c:	20 e0       	ldi	r18, 0x00	; 0
    117e:	22 23       	and	r18, r18
    1180:	01 f7       	brne	.-64     	; 0x1142 <_Z8Wait_ms2i+0x12>
		for(i = 0; i < 200; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    1182:	0f 90       	pop	r0
    1184:	0f 90       	pop	r0
    1186:	0f 90       	pop	r0
    1188:	0f 90       	pop	r0
    118a:	df 91       	pop	r29
    118c:	cf 91       	pop	r28
    118e:	08 95       	ret

00001190 <_Z13PutUartChBonec>:
/**************************************************************************************************************/
void PutUartChBone(char ch){
    1190:	cf 93       	push	r28
    1192:	df 93       	push	r29
    1194:	0f 92       	push	r0
    1196:	cd b7       	in	r28, 0x3d	; 61
    1198:	de b7       	in	r29, 0x3e	; 62
    119a:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
    119c:	00 00       	nop
    119e:	80 ec       	ldi	r24, 0xC0	; 192
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	fc 01       	movw	r30, r24
    11a4:	80 81       	ld	r24, Z
    11a6:	88 2f       	mov	r24, r24
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	80 72       	andi	r24, 0x20	; 32
    11ac:	90 70       	andi	r25, 0x00	; 0
    11ae:	21 e0       	ldi	r18, 0x01	; 1
    11b0:	00 97       	sbiw	r24, 0x00	; 0
    11b2:	09 f0       	breq	.+2      	; 0x11b6 <_Z13PutUartChBonec+0x26>
    11b4:	20 e0       	ldi	r18, 0x00	; 0
    11b6:	22 23       	and	r18, r18
    11b8:	91 f7       	brne	.-28     	; 0x119e <_Z13PutUartChBonec+0xe>
	UDR0=ch;
    11ba:	86 ec       	ldi	r24, 0xC6	; 198
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	29 81       	ldd	r18, Y+1	; 0x01
    11c0:	fc 01       	movw	r30, r24
    11c2:	20 83       	st	Z, r18
}
    11c4:	0f 90       	pop	r0
    11c6:	df 91       	pop	r29
    11c8:	cf 91       	pop	r28
    11ca:	08 95       	ret

000011cc <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
    11cc:	cf 93       	push	r28
    11ce:	df 93       	push	r29
    11d0:	00 d0       	rcall	.+0      	; 0x11d2 <_Z9PrintBonePc+0x6>
    11d2:	0f 92       	push	r0
    11d4:	cd b7       	in	r28, 0x3d	; 61
    11d6:	de b7       	in	r29, 0x3e	; 62
    11d8:	9b 83       	std	Y+3, r25	; 0x03
    11da:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    11dc:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    11de:	12 c0       	rjmp	.+36     	; 0x1204 <_Z9PrintBonePc+0x38>
		PutUartChBone(string[i++]);
    11e0:	89 81       	ldd	r24, Y+1	; 0x01
    11e2:	88 2f       	mov	r24, r24
    11e4:	90 e0       	ldi	r25, 0x00	; 0
    11e6:	2a 81       	ldd	r18, Y+2	; 0x02
    11e8:	3b 81       	ldd	r19, Y+3	; 0x03
    11ea:	82 0f       	add	r24, r18
    11ec:	93 1f       	adc	r25, r19
    11ee:	fc 01       	movw	r30, r24
    11f0:	80 81       	ld	r24, Z
    11f2:	99 81       	ldd	r25, Y+1	; 0x01
    11f4:	9f 5f       	subi	r25, 0xFF	; 255
    11f6:	99 83       	std	Y+1, r25	; 0x01
    11f8:	0e 94 c8 08 	call	0x1190	; 0x1190 <_Z13PutUartChBonec>
		Wait_ms2(100);
    11fc:	84 e6       	ldi	r24, 0x64	; 100
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_ms2i>
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    1204:	89 81       	ldd	r24, Y+1	; 0x01
    1206:	88 2f       	mov	r24, r24
    1208:	90 e0       	ldi	r25, 0x00	; 0
    120a:	2a 81       	ldd	r18, Y+2	; 0x02
    120c:	3b 81       	ldd	r19, Y+3	; 0x03
    120e:	82 0f       	add	r24, r18
    1210:	93 1f       	adc	r25, r19
    1212:	fc 01       	movw	r30, r24
    1214:	90 81       	ld	r25, Z
    1216:	81 e0       	ldi	r24, 0x01	; 1
    1218:	99 23       	and	r25, r25
    121a:	09 f4       	brne	.+2      	; 0x121e <_Z9PrintBonePc+0x52>
    121c:	80 e0       	ldi	r24, 0x00	; 0
    121e:	88 23       	and	r24, r24
    1220:	f9 f6       	brne	.-66     	; 0x11e0 <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i++]);
		Wait_ms2(100);
	}
}
    1222:	0f 90       	pop	r0
    1224:	0f 90       	pop	r0
    1226:	0f 90       	pop	r0
    1228:	df 91       	pop	r29
    122a:	cf 91       	pop	r28
    122c:	08 95       	ret

0000122e <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    122e:	cf 93       	push	r28
    1230:	df 93       	push	r29
    1232:	0f 92       	push	r0
    1234:	cd b7       	in	r28, 0x3d	; 61
    1236:	de b7       	in	r29, 0x3e	; 62
    1238:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    123a:	00 00       	nop
    123c:	88 ec       	ldi	r24, 0xC8	; 200
    123e:	90 e0       	ldi	r25, 0x00	; 0
    1240:	fc 01       	movw	r30, r24
    1242:	80 81       	ld	r24, Z
    1244:	88 2f       	mov	r24, r24
    1246:	90 e0       	ldi	r25, 0x00	; 0
    1248:	80 72       	andi	r24, 0x20	; 32
    124a:	90 70       	andi	r25, 0x00	; 0
    124c:	21 e0       	ldi	r18, 0x01	; 1
    124e:	00 97       	sbiw	r24, 0x00	; 0
    1250:	09 f0       	breq	.+2      	; 0x1254 <_Z13PutUartChGAVRc+0x26>
    1252:	20 e0       	ldi	r18, 0x00	; 0
    1254:	22 23       	and	r18, r18
    1256:	91 f7       	brne	.-28     	; 0x123c <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    1258:	8e ec       	ldi	r24, 0xCE	; 206
    125a:	90 e0       	ldi	r25, 0x00	; 0
    125c:	29 81       	ldd	r18, Y+1	; 0x01
    125e:	fc 01       	movw	r30, r24
    1260:	20 83       	st	Z, r18
}
    1262:	0f 90       	pop	r0
    1264:	df 91       	pop	r29
    1266:	cf 91       	pop	r28
    1268:	08 95       	ret

0000126a <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    126a:	cf 93       	push	r28
    126c:	df 93       	push	r29
    126e:	00 d0       	rcall	.+0      	; 0x1270 <_Z9PrintGAVRPc+0x6>
    1270:	0f 92       	push	r0
    1272:	cd b7       	in	r28, 0x3d	; 61
    1274:	de b7       	in	r29, 0x3e	; 62
    1276:	9b 83       	std	Y+3, r25	; 0x03
    1278:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    127a:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    127c:	12 c0       	rjmp	.+36     	; 0x12a2 <_Z9PrintGAVRPc+0x38>
		PutUartChGAVR(string[i++]);
    127e:	89 81       	ldd	r24, Y+1	; 0x01
    1280:	88 2f       	mov	r24, r24
    1282:	90 e0       	ldi	r25, 0x00	; 0
    1284:	2a 81       	ldd	r18, Y+2	; 0x02
    1286:	3b 81       	ldd	r19, Y+3	; 0x03
    1288:	82 0f       	add	r24, r18
    128a:	93 1f       	adc	r25, r19
    128c:	fc 01       	movw	r30, r24
    128e:	80 81       	ld	r24, Z
    1290:	99 81       	ldd	r25, Y+1	; 0x01
    1292:	9f 5f       	subi	r25, 0xFF	; 255
    1294:	99 83       	std	Y+1, r25	; 0x01
    1296:	0e 94 17 09 	call	0x122e	; 0x122e <_Z13PutUartChGAVRc>
		Wait_ms2(100);
    129a:	84 e6       	ldi	r24, 0x64	; 100
    129c:	90 e0       	ldi	r25, 0x00	; 0
    129e:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_ms2i>
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    12a2:	89 81       	ldd	r24, Y+1	; 0x01
    12a4:	88 2f       	mov	r24, r24
    12a6:	90 e0       	ldi	r25, 0x00	; 0
    12a8:	2a 81       	ldd	r18, Y+2	; 0x02
    12aa:	3b 81       	ldd	r19, Y+3	; 0x03
    12ac:	82 0f       	add	r24, r18
    12ae:	93 1f       	adc	r25, r19
    12b0:	fc 01       	movw	r30, r24
    12b2:	90 81       	ld	r25, Z
    12b4:	81 e0       	ldi	r24, 0x01	; 1
    12b6:	99 23       	and	r25, r25
    12b8:	09 f4       	brne	.+2      	; 0x12bc <_Z9PrintGAVRPc+0x52>
    12ba:	80 e0       	ldi	r24, 0x00	; 0
    12bc:	88 23       	and	r24, r24
    12be:	f9 f6       	brne	.-66     	; 0x127e <_Z9PrintGAVRPc+0x14>
		PutUartChGAVR(string[i++]);
		Wait_ms2(100);
	}
}
    12c0:	0f 90       	pop	r0
    12c2:	0f 90       	pop	r0
    12c4:	0f 90       	pop	r0
    12c6:	df 91       	pop	r29
    12c8:	cf 91       	pop	r28
    12ca:	08 95       	ret

000012cc <_Z8sendGAVRv>:
/*************************************************************************************************************/
void sendGAVR(){
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	cd b7       	in	r28, 0x3d	; 61
    12d2:	de b7       	in	r29, 0x3e	; 62
    12d4:	cd 55       	subi	r28, 0x5D	; 93
    12d6:	d0 40       	sbci	r29, 0x00	; 0
    12d8:	0f b6       	in	r0, 0x3f	; 63
    12da:	f8 94       	cli
    12dc:	de bf       	out	0x3e, r29	; 62
    12de:	0f be       	out	0x3f, r0	; 63
    12e0:	cd bf       	out	0x3d, r28	; 61
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	8d 87       	std	Y+13, r24	; 0x0d
	char recChar, recString[40], sentString[40];
	unsigned int strLoc=0;
    12e6:	1a 82       	std	Y+2, r1	; 0x02
    12e8:	19 82       	std	Y+1, r1	; 0x01
	
	//Set sending flag
	flagSendingGAVR=fTrue;
    12ea:	81 e0       	ldi	r24, 0x01	; 1
    12ec:	80 93 c1 01 	sts	0x01C1, r24
	
	//Transmission protocol
	while (flagSendingGAVR){
    12f0:	42 c2       	rjmp	.+1156   	; 0x1776 <_Z8sendGAVRv+0x4aa>
		/* State 5: Successful transmission and reception. Kill sending flag, reset state, exit.					 */
		/* State 6: ACKBAD received, check to see if we have an invalid date/time in our clock or it was just noisy  */
		/*			and had error in transmission/reception. If valid, go to waiting state. Else exit and set flag.	 */
		/* State 7: Got the wrong ack for something, set a flag to let the WAVR do its thing then try again.		 */
		/*************************************************************************************************************/
		switch (state){
    12f2:	80 91 d4 01 	lds	r24, 0x01D4
    12f6:	90 91 d5 01 	lds	r25, 0x01D5
    12fa:	83 30       	cpi	r24, 0x03	; 3
    12fc:	91 05       	cpc	r25, r1
    12fe:	09 f4       	brne	.+2      	; 0x1302 <_Z8sendGAVRv+0x36>
    1300:	23 c1       	rjmp	.+582    	; 0x1548 <_Z8sendGAVRv+0x27c>
    1302:	84 30       	cpi	r24, 0x04	; 4
    1304:	91 05       	cpc	r25, r1
    1306:	48 f4       	brcc	.+18     	; 0x131a <_Z8sendGAVRv+0x4e>
    1308:	81 30       	cpi	r24, 0x01	; 1
    130a:	91 05       	cpc	r25, r1
    130c:	09 f4       	brne	.+2      	; 0x1310 <_Z8sendGAVRv+0x44>
    130e:	41 c0       	rjmp	.+130    	; 0x1392 <_Z8sendGAVRv+0xc6>
    1310:	82 30       	cpi	r24, 0x02	; 2
    1312:	91 05       	cpc	r25, r1
    1314:	08 f0       	brcs	.+2      	; 0x1318 <_Z8sendGAVRv+0x4c>
    1316:	a7 c0       	rjmp	.+334    	; 0x1466 <_Z8sendGAVRv+0x19a>
    1318:	11 c0       	rjmp	.+34     	; 0x133c <_Z8sendGAVRv+0x70>
    131a:	85 30       	cpi	r24, 0x05	; 5
    131c:	91 05       	cpc	r25, r1
    131e:	09 f4       	brne	.+2      	; 0x1322 <_Z8sendGAVRv+0x56>
    1320:	be c1       	rjmp	.+892    	; 0x169e <_Z8sendGAVRv+0x3d2>
    1322:	85 30       	cpi	r24, 0x05	; 5
    1324:	91 05       	cpc	r25, r1
    1326:	08 f4       	brcc	.+2      	; 0x132a <_Z8sendGAVRv+0x5e>
    1328:	ab c1       	rjmp	.+854    	; 0x1680 <_Z8sendGAVRv+0x3b4>
    132a:	86 30       	cpi	r24, 0x06	; 6
    132c:	91 05       	cpc	r25, r1
    132e:	09 f4       	brne	.+2      	; 0x1332 <_Z8sendGAVRv+0x66>
    1330:	db c1       	rjmp	.+950    	; 0x16e8 <_Z8sendGAVRv+0x41c>
    1332:	87 30       	cpi	r24, 0x07	; 7
    1334:	91 05       	cpc	r25, r1
    1336:	09 f4       	brne	.+2      	; 0x133a <_Z8sendGAVRv+0x6e>
    1338:	f0 c1       	rjmp	.+992    	; 0x171a <_Z8sendGAVRv+0x44e>
    133a:	15 c2       	rjmp	.+1066   	; 0x1766 <_Z8sendGAVRv+0x49a>
			case 0: {
				//Raise interrupts to GAVR for three ish clock cycles.
				prtGAVRINT |= (1 << bnGAVRINT);
    133c:	85 e2       	ldi	r24, 0x25	; 37
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	25 e2       	ldi	r18, 0x25	; 37
    1342:	30 e0       	ldi	r19, 0x00	; 0
    1344:	f9 01       	movw	r30, r18
    1346:	20 81       	ld	r18, Z
    1348:	28 60       	ori	r18, 0x08	; 8
    134a:	fc 01       	movw	r30, r24
    134c:	20 83       	st	Z, r18
				for (int i=0; i<2; i++){asm volatile("nop");}
    134e:	1c 82       	std	Y+4, r1	; 0x04
    1350:	1b 82       	std	Y+3, r1	; 0x03
    1352:	06 c0       	rjmp	.+12     	; 0x1360 <_Z8sendGAVRv+0x94>
    1354:	00 00       	nop
    1356:	8b 81       	ldd	r24, Y+3	; 0x03
    1358:	9c 81       	ldd	r25, Y+4	; 0x04
    135a:	01 96       	adiw	r24, 0x01	; 1
    135c:	9c 83       	std	Y+4, r25	; 0x04
    135e:	8b 83       	std	Y+3, r24	; 0x03
    1360:	21 e0       	ldi	r18, 0x01	; 1
    1362:	8b 81       	ldd	r24, Y+3	; 0x03
    1364:	9c 81       	ldd	r25, Y+4	; 0x04
    1366:	82 30       	cpi	r24, 0x02	; 2
    1368:	91 05       	cpc	r25, r1
    136a:	0c f0       	brlt	.+2      	; 0x136e <_Z8sendGAVRv+0xa2>
    136c:	20 e0       	ldi	r18, 0x00	; 0
    136e:	22 23       	and	r18, r18
    1370:	89 f7       	brne	.-30     	; 0x1354 <_Z8sendGAVRv+0x88>
				prtGAVRINT &= ~(1 << bnGAVRINT);
    1372:	85 e2       	ldi	r24, 0x25	; 37
    1374:	90 e0       	ldi	r25, 0x00	; 0
    1376:	25 e2       	ldi	r18, 0x25	; 37
    1378:	30 e0       	ldi	r19, 0x00	; 0
    137a:	f9 01       	movw	r30, r18
    137c:	20 81       	ld	r18, Z
    137e:	27 7f       	andi	r18, 0xF7	; 247
    1380:	fc 01       	movw	r30, r24
    1382:	20 83       	st	Z, r18
				state=1;
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	90 93 d5 01 	sts	0x01D5, r25
    138c:	80 93 d4 01 	sts	0x01D4, r24
				break;
    1390:	f2 c1       	rjmp	.+996    	; 0x1776 <_Z8sendGAVRv+0x4aa>
			}//end case 0
			case 1: {
				Wait_ms2(500);			
    1392:	84 ef       	ldi	r24, 0xF4	; 244
    1394:	91 e0       	ldi	r25, 0x01	; 1
    1396:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_ms2i>
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    139a:	57 c0       	rjmp	.+174    	; 0x144a <_Z8sendGAVRv+0x17e>
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
    139c:	00 00       	nop
    139e:	88 ec       	ldi	r24, 0xC8	; 200
    13a0:	90 e0       	ldi	r25, 0x00	; 0
    13a2:	fc 01       	movw	r30, r24
    13a4:	80 81       	ld	r24, Z
    13a6:	88 23       	and	r24, r24
    13a8:	34 f0       	brlt	.+12     	; 0x13b6 <_Z8sendGAVRv+0xea>
    13aa:	80 91 c1 01 	lds	r24, 0x01C1
    13ae:	88 23       	and	r24, r24
    13b0:	11 f0       	breq	.+4      	; 0x13b6 <_Z8sendGAVRv+0xea>
    13b2:	81 e0       	ldi	r24, 0x01	; 1
    13b4:	01 c0       	rjmp	.+2      	; 0x13b8 <_Z8sendGAVRv+0xec>
    13b6:	80 e0       	ldi	r24, 0x00	; 0
    13b8:	88 23       	and	r24, r24
    13ba:	89 f7       	brne	.-30     	; 0x139e <_Z8sendGAVRv+0xd2>
					if (!flagSendingGAVR){state=7; break;}		//if timeout is why we broke, just exit
    13bc:	80 91 c1 01 	lds	r24, 0x01C1
    13c0:	88 23       	and	r24, r24
    13c2:	41 f4       	brne	.+16     	; 0x13d4 <_Z8sendGAVRv+0x108>
    13c4:	87 e0       	ldi	r24, 0x07	; 7
    13c6:	90 e0       	ldi	r25, 0x00	; 0
    13c8:	90 93 d5 01 	sts	0x01D5, r25
    13cc:	80 93 d4 01 	sts	0x01D4, r24
    13d0:	00 00       	nop
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    13d2:	d1 c1       	rjmp	.+930    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				Wait_ms2(500);			
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
					if (!flagSendingGAVR){state=7; break;}		//if timeout is why we broke, just exit
					recChar=UDR1;
    13d4:	8e ec       	ldi	r24, 0xCE	; 206
    13d6:	90 e0       	ldi	r25, 0x00	; 0
    13d8:	fc 01       	movw	r30, r24
    13da:	80 81       	ld	r24, Z
    13dc:	8b 87       	std	Y+11, r24	; 0x0b
					recString[strLoc++]=recChar;
    13de:	9e 01       	movw	r18, r28
    13e0:	2a 5c       	subi	r18, 0xCA	; 202
    13e2:	3f 4f       	sbci	r19, 0xFF	; 255
    13e4:	89 81       	ldd	r24, Y+1	; 0x01
    13e6:	9a 81       	ldd	r25, Y+2	; 0x02
    13e8:	82 0f       	add	r24, r18
    13ea:	93 1f       	adc	r25, r19
    13ec:	2b 85       	ldd	r18, Y+11	; 0x0b
    13ee:	fc 01       	movw	r30, r24
    13f0:	20 83       	st	Z, r18
    13f2:	89 81       	ldd	r24, Y+1	; 0x01
    13f4:	9a 81       	ldd	r25, Y+2	; 0x02
    13f6:	01 96       	adiw	r24, 0x01	; 1
    13f8:	9a 83       	std	Y+2, r25	; 0x02
    13fa:	89 83       	std	Y+1, r24	; 0x01
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
    13fc:	8b 85       	ldd	r24, Y+11	; 0x0b
    13fe:	8e 32       	cpi	r24, 0x2E	; 46
    1400:	b1 f4       	brne	.+44     	; 0x142e <_Z8sendGAVRv+0x162>
    1402:	9e 01       	movw	r18, r28
    1404:	2a 5c       	subi	r18, 0xCA	; 202
    1406:	3f 4f       	sbci	r19, 0xFF	; 255
    1408:	89 81       	ldd	r24, Y+1	; 0x01
    140a:	9a 81       	ldd	r25, Y+2	; 0x02
    140c:	82 0f       	add	r24, r18
    140e:	93 1f       	adc	r25, r19
    1410:	fc 01       	movw	r30, r24
    1412:	10 82       	st	Z, r1
    1414:	89 81       	ldd	r24, Y+1	; 0x01
    1416:	9a 81       	ldd	r25, Y+2	; 0x02
    1418:	01 96       	adiw	r24, 0x01	; 1
    141a:	9a 83       	std	Y+2, r25	; 0x02
    141c:	89 83       	std	Y+1, r24	; 0x01
    141e:	82 e0       	ldi	r24, 0x02	; 2
    1420:	90 e0       	ldi	r25, 0x00	; 0
    1422:	90 93 d5 01 	sts	0x01D5, r25
    1426:	80 93 d4 01 	sts	0x01D4, r24
    142a:	1d 86       	std	Y+13, r1	; 0x0d
    142c:	0e c0       	rjmp	.+28     	; 0x144a <_Z8sendGAVRv+0x17e>
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
    142e:	89 81       	ldd	r24, Y+1	; 0x01
    1430:	9a 81       	ldd	r25, Y+2	; 0x02
    1432:	87 32       	cpi	r24, 0x27	; 39
    1434:	91 05       	cpc	r25, r1
    1436:	48 f0       	brcs	.+18     	; 0x144a <_Z8sendGAVRv+0x17e>
    1438:	1a 82       	std	Y+2, r1	; 0x02
    143a:	19 82       	std	Y+1, r1	; 0x01
    143c:	1d 86       	std	Y+13, r1	; 0x0d
    143e:	87 e0       	ldi	r24, 0x07	; 7
    1440:	90 e0       	ldi	r25, 0x00	; 0
    1442:	90 93 d5 01 	sts	0x01D5, r25
    1446:	80 93 d4 01 	sts	0x01D4, r24
				break;
			}//end case 0
			case 1: {
				Wait_ms2(500);			
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    144a:	8d 85       	ldd	r24, Y+13	; 0x0d
    144c:	88 23       	and	r24, r24
    144e:	31 f0       	breq	.+12     	; 0x145c <_Z8sendGAVRv+0x190>
    1450:	80 91 c1 01 	lds	r24, 0x01C1
    1454:	88 23       	and	r24, r24
    1456:	11 f0       	breq	.+4      	; 0x145c <_Z8sendGAVRv+0x190>
    1458:	81 e0       	ldi	r24, 0x01	; 1
    145a:	01 c0       	rjmp	.+2      	; 0x145e <_Z8sendGAVRv+0x192>
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	88 23       	and	r24, r24
    1460:	09 f0       	breq	.+2      	; 0x1464 <_Z8sendGAVRv+0x198>
    1462:	9c cf       	rjmp	.-200    	; 0x139c <_Z8sendGAVRv+0xd0>
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    1464:	88 c1       	rjmp	.+784    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
    1466:	ce 01       	movw	r24, r28
    1468:	c6 96       	adiw	r24, 0x36	; 54
    146a:	20 e0       	ldi	r18, 0x00	; 0
    146c:	31 e0       	ldi	r19, 0x01	; 1
    146e:	b9 01       	movw	r22, r18
    1470:	45 e0       	ldi	r20, 0x05	; 5
    1472:	50 e0       	ldi	r21, 0x00	; 0
    1474:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    1478:	00 97       	sbiw	r24, 0x00	; 0
    147a:	39 f4       	brne	.+14     	; 0x148a <_Z8sendGAVRv+0x1be>
    147c:	83 e0       	ldi	r24, 0x03	; 3
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	90 93 d5 01 	sts	0x01D5, r25
    1484:	80 93 d4 01 	sts	0x01D4, r24
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1488:	76 c1       	rjmp	.+748    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
    148a:	ce 01       	movw	r24, r28
    148c:	c6 96       	adiw	r24, 0x36	; 54
    148e:	26 e0       	ldi	r18, 0x06	; 6
    1490:	31 e0       	ldi	r19, 0x01	; 1
    1492:	b9 01       	movw	r22, r18
    1494:	46 e0       	ldi	r20, 0x06	; 6
    1496:	50 e0       	ldi	r21, 0x00	; 0
    1498:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    149c:	00 97       	sbiw	r24, 0x00	; 0
    149e:	39 f4       	brne	.+14     	; 0x14ae <_Z8sendGAVRv+0x1e2>
    14a0:	84 e0       	ldi	r24, 0x04	; 4
    14a2:	90 e0       	ldi	r25, 0x00	; 0
    14a4:	90 93 d5 01 	sts	0x01D5, r25
    14a8:	80 93 d4 01 	sts	0x01D4, r24
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    14ac:	64 c1       	rjmp	.+712    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
    14ae:	ce 01       	movw	r24, r28
    14b0:	c6 96       	adiw	r24, 0x36	; 54
    14b2:	2d e0       	ldi	r18, 0x0D	; 13
    14b4:	31 e0       	ldi	r19, 0x01	; 1
    14b6:	b9 01       	movw	r22, r18
    14b8:	47 e0       	ldi	r20, 0x07	; 7
    14ba:	50 e0       	ldi	r21, 0x00	; 0
    14bc:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    14c0:	00 97       	sbiw	r24, 0x00	; 0
    14c2:	39 f4       	brne	.+14     	; 0x14d2 <_Z8sendGAVRv+0x206>
    14c4:	86 e0       	ldi	r24, 0x06	; 6
    14c6:	90 e0       	ldi	r25, 0x00	; 0
    14c8:	90 93 d5 01 	sts	0x01D5, r25
    14cc:	80 93 d4 01 	sts	0x01D4, r24
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    14d0:	52 c1       	rjmp	.+676    	; 0x1776 <_Z8sendGAVRv+0x4aa>
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
    14d2:	80 91 c0 01 	lds	r24, 0x01C0
    14d6:	88 23       	and	r24, r24
    14d8:	89 f0       	breq	.+34     	; 0x14fc <_Z8sendGAVRv+0x230>
    14da:	ce 01       	movw	r24, r28
    14dc:	c6 96       	adiw	r24, 0x36	; 54
    14de:	9e 01       	movw	r18, r28
    14e0:	22 5f       	subi	r18, 0xF2	; 242
    14e2:	3f 4f       	sbci	r19, 0xFF	; 255
    14e4:	b9 01       	movw	r22, r18
    14e6:	0e 94 04 23 	call	0x4608	; 0x4608 <strcmp>
    14ea:	00 97       	sbiw	r24, 0x00	; 0
    14ec:	39 f4       	brne	.+14     	; 0x14fc <_Z8sendGAVRv+0x230>
    14ee:	85 e0       	ldi	r24, 0x05	; 5
    14f0:	90 e0       	ldi	r25, 0x00	; 0
    14f2:	90 93 d5 01 	sts	0x01D5, r25
    14f6:	80 93 d4 01 	sts	0x01D4, r24
    14fa:	25 c0       	rjmp	.+74     	; 0x1546 <_Z8sendGAVRv+0x27a>
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
    14fc:	80 91 c0 01 	lds	r24, 0x01C0
    1500:	88 23       	and	r24, r24
    1502:	d1 f0       	breq	.+52     	; 0x1538 <_Z8sendGAVRv+0x26c>
    1504:	ce 01       	movw	r24, r28
    1506:	c6 96       	adiw	r24, 0x36	; 54
    1508:	9e 01       	movw	r18, r28
    150a:	22 5f       	subi	r18, 0xF2	; 242
    150c:	3f 4f       	sbci	r19, 0xFF	; 255
    150e:	b9 01       	movw	r22, r18
    1510:	0e 94 04 23 	call	0x4608	; 0x4608 <strcmp>
    1514:	00 97       	sbiw	r24, 0x00	; 0
    1516:	81 f0       	breq	.+32     	; 0x1538 <_Z8sendGAVRv+0x26c>
    1518:	ce 01       	movw	r24, r28
    151a:	c6 96       	adiw	r24, 0x36	; 54
    151c:	2d e0       	ldi	r18, 0x0D	; 13
    151e:	31 e0       	ldi	r19, 0x01	; 1
    1520:	b9 01       	movw	r22, r18
    1522:	0e 94 04 23 	call	0x4608	; 0x4608 <strcmp>
    1526:	00 97       	sbiw	r24, 0x00	; 0
    1528:	39 f0       	breq	.+14     	; 0x1538 <_Z8sendGAVRv+0x26c>
    152a:	87 e0       	ldi	r24, 0x07	; 7
    152c:	90 e0       	ldi	r25, 0x00	; 0
    152e:	90 93 d5 01 	sts	0x01D5, r25
    1532:	80 93 d4 01 	sts	0x01D4, r24
    1536:	07 c0       	rjmp	.+14     	; 0x1546 <_Z8sendGAVRv+0x27a>
				else{state=7;} //invalid ack. ACKERROR goes here.
    1538:	87 e0       	ldi	r24, 0x07	; 7
    153a:	90 e0       	ldi	r25, 0x00	; 0
    153c:	90 93 d5 01 	sts	0x01D5, r25
    1540:	80 93 d4 01 	sts	0x01D4, r24
				break;
    1544:	18 c1       	rjmp	.+560    	; 0x1776 <_Z8sendGAVRv+0x4aa>
    1546:	17 c1       	rjmp	.+558    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end case 2
			case 3:{
				if (flagUserClock && !flagUpdateGAVRClock){
    1548:	80 91 c2 01 	lds	r24, 0x01C2
    154c:	88 23       	and	r24, r24
    154e:	61 f0       	breq	.+24     	; 0x1568 <_Z8sendGAVRv+0x29c>
    1550:	80 91 c0 01 	lds	r24, 0x01C0
    1554:	88 23       	and	r24, r24
    1556:	41 f4       	brne	.+16     	; 0x1568 <_Z8sendGAVRv+0x29c>
					PrintGAVR("SYNGB.");
    1558:	85 e1       	ldi	r24, 0x15	; 21
    155a:	91 e0       	ldi	r25, 0x01	; 1
    155c:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
					flagWaitingForReceiveGAVR=fTrue;				
    1560:	81 e0       	ldi	r24, 0x01	; 1
    1562:	80 93 bd 01 	sts	0x01BD, r24
    1566:	65 c0       	rjmp	.+202    	; 0x1632 <_Z8sendGAVRv+0x366>
				//If we are updating the gavr, send the time and date together regardless. preface with SYN
				} else if (flagUpdateGAVRClock && !flagUserClock){
    1568:	80 91 c0 01 	lds	r24, 0x01C0
    156c:	88 23       	and	r24, r24
    156e:	09 f4       	brne	.+2      	; 0x1572 <_Z8sendGAVRv+0x2a6>
    1570:	59 c0       	rjmp	.+178    	; 0x1624 <_Z8sendGAVRv+0x358>
    1572:	80 91 c2 01 	lds	r24, 0x01C2
    1576:	88 23       	and	r24, r24
    1578:	09 f0       	breq	.+2      	; 0x157c <_Z8sendGAVRv+0x2b0>
    157a:	54 c0       	rjmp	.+168    	; 0x1624 <_Z8sendGAVRv+0x358>
					strcpy(sentString,"ACK");			//this is a syn, not ack to save logic in GAVR code. Can change if we want.
    157c:	9e 01       	movw	r18, r28
    157e:	22 5f       	subi	r18, 0xF2	; 242
    1580:	3f 4f       	sbci	r19, 0xFF	; 255
    1582:	81 e4       	ldi	r24, 0x41	; 65
    1584:	93 e4       	ldi	r25, 0x43	; 67
    1586:	ab e4       	ldi	r26, 0x4B	; 75
    1588:	b0 e0       	ldi	r27, 0x00	; 0
    158a:	f9 01       	movw	r30, r18
    158c:	80 83       	st	Z, r24
    158e:	91 83       	std	Z+1, r25	; 0x01
    1590:	a2 83       	std	Z+2, r26	; 0x02
    1592:	b3 83       	std	Z+3, r27	; 0x03
					strcat(sentString,currentTime.getTime());
    1594:	82 e9       	ldi	r24, 0x92	; 146
    1596:	91 e0       	ldi	r25, 0x01	; 1
    1598:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    159c:	9c 01       	movw	r18, r24
    159e:	ce 01       	movw	r24, r28
    15a0:	0e 96       	adiw	r24, 0x0e	; 14
    15a2:	b9 01       	movw	r22, r18
    15a4:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <strcat>
					strcat(sentString,"/");	//add delimiter.
    15a8:	ce 01       	movw	r24, r28
    15aa:	0e 96       	adiw	r24, 0x0e	; 14
    15ac:	9c 01       	movw	r18, r24
    15ae:	f9 01       	movw	r30, r18
    15b0:	01 90       	ld	r0, Z+
    15b2:	00 20       	and	r0, r0
    15b4:	e9 f7       	brne	.-6      	; 0x15b0 <_Z8sendGAVRv+0x2e4>
    15b6:	cf 01       	movw	r24, r30
    15b8:	01 97       	sbiw	r24, 0x01	; 1
    15ba:	82 1b       	sub	r24, r18
    15bc:	93 0b       	sbc	r25, r19
    15be:	9e 01       	movw	r18, r28
    15c0:	22 5f       	subi	r18, 0xF2	; 242
    15c2:	3f 4f       	sbci	r19, 0xFF	; 255
    15c4:	82 0f       	add	r24, r18
    15c6:	93 1f       	adc	r25, r19
    15c8:	2f e2       	ldi	r18, 0x2F	; 47
    15ca:	30 e0       	ldi	r19, 0x00	; 0
    15cc:	fc 01       	movw	r30, r24
    15ce:	31 83       	std	Z+1, r19	; 0x01
    15d0:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getDate());
    15d2:	82 e9       	ldi	r24, 0x92	; 146
    15d4:	91 e0       	ldi	r25, 0x01	; 1
    15d6:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    15da:	9c 01       	movw	r18, r24
    15dc:	ce 01       	movw	r24, r28
    15de:	0e 96       	adiw	r24, 0x0e	; 14
    15e0:	b9 01       	movw	r22, r18
    15e2:	0e 94 f9 22 	call	0x45f2	; 0x45f2 <strcat>
					strcat(sentString,".\0");
    15e6:	ce 01       	movw	r24, r28
    15e8:	0e 96       	adiw	r24, 0x0e	; 14
    15ea:	9c 01       	movw	r18, r24
    15ec:	f9 01       	movw	r30, r18
    15ee:	01 90       	ld	r0, Z+
    15f0:	00 20       	and	r0, r0
    15f2:	e9 f7       	brne	.-6      	; 0x15ee <_Z8sendGAVRv+0x322>
    15f4:	cf 01       	movw	r24, r30
    15f6:	01 97       	sbiw	r24, 0x01	; 1
    15f8:	82 1b       	sub	r24, r18
    15fa:	93 0b       	sbc	r25, r19
    15fc:	9e 01       	movw	r18, r28
    15fe:	22 5f       	subi	r18, 0xF2	; 242
    1600:	3f 4f       	sbci	r19, 0xFF	; 255
    1602:	82 0f       	add	r24, r18
    1604:	93 1f       	adc	r25, r19
    1606:	2e e2       	ldi	r18, 0x2E	; 46
    1608:	30 e0       	ldi	r19, 0x00	; 0
    160a:	fc 01       	movw	r30, r24
    160c:	31 83       	std	Z+1, r19	; 0x01
    160e:	20 83       	st	Z, r18
					PrintGAVR("SYN");
    1610:	8c e1       	ldi	r24, 0x1C	; 28
    1612:	91 e0       	ldi	r25, 0x01	; 1
    1614:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
    1618:	80 e0       	ldi	r24, 0x00	; 0
    161a:	61 e0       	ldi	r22, 0x01	; 1
    161c:	41 e0       	ldi	r20, 0x01	; 1
    161e:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_Z13printTimeDatehhh>
    1622:	07 c0       	rjmp	.+14     	; 0x1632 <_Z8sendGAVRv+0x366>
				} else {state=5; break;}	//end if-else (what we are doing).
    1624:	85 e0       	ldi	r24, 0x05	; 5
    1626:	90 e0       	ldi	r25, 0x00	; 0
    1628:	90 93 d5 01 	sts	0x01D5, r25
    162c:	80 93 d4 01 	sts	0x01D4, r24
    1630:	a2 c0       	rjmp	.+324    	; 0x1776 <_Z8sendGAVRv+0x4aa>
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1632:	1e 82       	std	Y+6, r1	; 0x06
    1634:	1d 82       	std	Y+5, r1	; 0x05
    1636:	0e c0       	rjmp	.+28     	; 0x1654 <_Z8sendGAVRv+0x388>
    1638:	9e 01       	movw	r18, r28
    163a:	2a 5c       	subi	r18, 0xCA	; 202
    163c:	3f 4f       	sbci	r19, 0xFF	; 255
    163e:	8d 81       	ldd	r24, Y+5	; 0x05
    1640:	9e 81       	ldd	r25, Y+6	; 0x06
    1642:	82 0f       	add	r24, r18
    1644:	93 1f       	adc	r25, r19
    1646:	fc 01       	movw	r30, r24
    1648:	10 82       	st	Z, r1
    164a:	8d 81       	ldd	r24, Y+5	; 0x05
    164c:	9e 81       	ldd	r25, Y+6	; 0x06
    164e:	01 96       	adiw	r24, 0x01	; 1
    1650:	9e 83       	std	Y+6, r25	; 0x06
    1652:	8d 83       	std	Y+5, r24	; 0x05
    1654:	2d 81       	ldd	r18, Y+5	; 0x05
    1656:	3e 81       	ldd	r19, Y+6	; 0x06
    1658:	41 e0       	ldi	r20, 0x01	; 1
    165a:	89 81       	ldd	r24, Y+1	; 0x01
    165c:	9a 81       	ldd	r25, Y+2	; 0x02
    165e:	28 17       	cp	r18, r24
    1660:	39 07       	cpc	r19, r25
    1662:	08 f0       	brcs	.+2      	; 0x1666 <_Z8sendGAVRv+0x39a>
    1664:	40 e0       	ldi	r20, 0x00	; 0
    1666:	44 23       	and	r20, r20
    1668:	39 f7       	brne	.-50     	; 0x1638 <_Z8sendGAVRv+0x36c>
					
				//Reset the carriage feature, string location and go back to the receiving state.
				noCarriage=fTrue;
    166a:	81 e0       	ldi	r24, 0x01	; 1
    166c:	8d 87       	std	Y+13, r24	; 0x0d
				strLoc=0;
    166e:	1a 82       	std	Y+2, r1	; 0x02
    1670:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    1672:	81 e0       	ldi	r24, 0x01	; 1
    1674:	90 e0       	ldi	r25, 0x00	; 0
    1676:	90 93 d5 01 	sts	0x01D5, r25
    167a:	80 93 d4 01 	sts	0x01D4, r24
				break;
    167e:	7b c0       	rjmp	.+246    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end case 3
			case 4:{
				//Successful communication with just flags
				Wait_ms2(200);
    1680:	88 ec       	ldi	r24, 0xC8	; 200
    1682:	90 e0       	ldi	r25, 0x00	; 0
    1684:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_ms2i>
				PrintGAVR("SYNDONE.");	//end the communication
    1688:	80 e2       	ldi	r24, 0x20	; 32
    168a:	91 e0       	ldi	r25, 0x01	; 1
    168c:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
				state=5;
    1690:	85 e0       	ldi	r24, 0x05	; 5
    1692:	90 e0       	ldi	r25, 0x00	; 0
    1694:	90 93 d5 01 	sts	0x01D5, r25
    1698:	80 93 d4 01 	sts	0x01D4, r24
				break;				
    169c:	6c c0       	rjmp	.+216    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end case 4	
			case 5:{
				//Successful communications overall
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    169e:	18 86       	std	Y+8, r1	; 0x08
    16a0:	1f 82       	std	Y+7, r1	; 0x07
    16a2:	0e c0       	rjmp	.+28     	; 0x16c0 <_Z8sendGAVRv+0x3f4>
    16a4:	9e 01       	movw	r18, r28
    16a6:	2a 5c       	subi	r18, 0xCA	; 202
    16a8:	3f 4f       	sbci	r19, 0xFF	; 255
    16aa:	8f 81       	ldd	r24, Y+7	; 0x07
    16ac:	98 85       	ldd	r25, Y+8	; 0x08
    16ae:	82 0f       	add	r24, r18
    16b0:	93 1f       	adc	r25, r19
    16b2:	fc 01       	movw	r30, r24
    16b4:	10 82       	st	Z, r1
    16b6:	8f 81       	ldd	r24, Y+7	; 0x07
    16b8:	98 85       	ldd	r25, Y+8	; 0x08
    16ba:	01 96       	adiw	r24, 0x01	; 1
    16bc:	98 87       	std	Y+8, r25	; 0x08
    16be:	8f 83       	std	Y+7, r24	; 0x07
    16c0:	2f 81       	ldd	r18, Y+7	; 0x07
    16c2:	38 85       	ldd	r19, Y+8	; 0x08
    16c4:	41 e0       	ldi	r20, 0x01	; 1
    16c6:	89 81       	ldd	r24, Y+1	; 0x01
    16c8:	9a 81       	ldd	r25, Y+2	; 0x02
    16ca:	28 17       	cp	r18, r24
    16cc:	39 07       	cpc	r19, r25
    16ce:	08 f0       	brcs	.+2      	; 0x16d2 <_Z8sendGAVRv+0x406>
    16d0:	40 e0       	ldi	r20, 0x00	; 0
    16d2:	44 23       	and	r20, r20
    16d4:	39 f7       	brne	.-50     	; 0x16a4 <_Z8sendGAVRv+0x3d8>
				flagSendingGAVR=fFalse;
    16d6:	10 92 c1 01 	sts	0x01C1, r1
				flagWaitingToSendGAVR=fFalse;
    16da:	10 92 c4 01 	sts	0x01C4, r1
				state=0;
    16de:	10 92 d5 01 	sts	0x01D5, r1
    16e2:	10 92 d4 01 	sts	0x01D4, r1
				break;
    16e6:	47 c0       	rjmp	.+142    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
    16e8:	82 e9       	ldi	r24, 0x92	; 146
    16ea:	91 e0       	ldi	r25, 0x01	; 1
    16ec:	0e 94 bc 06 	call	0xd78	; 0xd78 <_ZN6myTime13checkValidityEv>
    16f0:	8c 87       	std	Y+12, r24	; 0x0c
				if (dateOK){state=7;}
    16f2:	8c 85       	ldd	r24, Y+12	; 0x0c
    16f4:	88 23       	and	r24, r24
    16f6:	39 f0       	breq	.+14     	; 0x1706 <_Z8sendGAVRv+0x43a>
    16f8:	87 e0       	ldi	r24, 0x07	; 7
    16fa:	90 e0       	ldi	r25, 0x00	; 0
    16fc:	90 93 d5 01 	sts	0x01D5, r25
    1700:	80 93 d4 01 	sts	0x01D4, r24
				else {state=5; flagInvalidDateTime=fTrue;}
				break;
    1704:	38 c0       	rjmp	.+112    	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
				if (dateOK){state=7;}
				else {state=5; flagInvalidDateTime=fTrue;}
    1706:	85 e0       	ldi	r24, 0x05	; 5
    1708:	90 e0       	ldi	r25, 0x00	; 0
    170a:	90 93 d5 01 	sts	0x01D5, r25
    170e:	80 93 d4 01 	sts	0x01D4, r24
    1712:	81 e0       	ldi	r24, 0x01	; 1
    1714:	80 93 c3 01 	sts	0x01C3, r24
				break;
    1718:	2e c0       	rjmp	.+92     	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end case 6
			case 7:{
				//Got the wrong ACK back, or invalid ACK. Wait for next cycle then resend. Keep all the flags the same
				flagWaitingToSendGAVR=fTrue;
    171a:	81 e0       	ldi	r24, 0x01	; 1
    171c:	80 93 c4 01 	sts	0x01C4, r24
				flagSendingGAVR=fFalse;
    1720:	10 92 c1 01 	sts	0x01C1, r1
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1724:	1a 86       	std	Y+10, r1	; 0x0a
    1726:	19 86       	std	Y+9, r1	; 0x09
    1728:	0e c0       	rjmp	.+28     	; 0x1746 <_Z8sendGAVRv+0x47a>
    172a:	9e 01       	movw	r18, r28
    172c:	2a 5c       	subi	r18, 0xCA	; 202
    172e:	3f 4f       	sbci	r19, 0xFF	; 255
    1730:	89 85       	ldd	r24, Y+9	; 0x09
    1732:	9a 85       	ldd	r25, Y+10	; 0x0a
    1734:	82 0f       	add	r24, r18
    1736:	93 1f       	adc	r25, r19
    1738:	fc 01       	movw	r30, r24
    173a:	10 82       	st	Z, r1
    173c:	89 85       	ldd	r24, Y+9	; 0x09
    173e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1740:	01 96       	adiw	r24, 0x01	; 1
    1742:	9a 87       	std	Y+10, r25	; 0x0a
    1744:	89 87       	std	Y+9, r24	; 0x09
    1746:	29 85       	ldd	r18, Y+9	; 0x09
    1748:	3a 85       	ldd	r19, Y+10	; 0x0a
    174a:	41 e0       	ldi	r20, 0x01	; 1
    174c:	89 81       	ldd	r24, Y+1	; 0x01
    174e:	9a 81       	ldd	r25, Y+2	; 0x02
    1750:	28 17       	cp	r18, r24
    1752:	39 07       	cpc	r19, r25
    1754:	08 f0       	brcs	.+2      	; 0x1758 <_Z8sendGAVRv+0x48c>
    1756:	40 e0       	ldi	r20, 0x00	; 0
    1758:	44 23       	and	r20, r20
    175a:	39 f7       	brne	.-50     	; 0x172a <_Z8sendGAVRv+0x45e>
				state=0;
    175c:	10 92 d5 01 	sts	0x01D5, r1
    1760:	10 92 d4 01 	sts	0x01D4, r1
				break;
    1764:	08 c0       	rjmp	.+16     	; 0x1776 <_Z8sendGAVRv+0x4aa>
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; break;}
    1766:	10 92 d5 01 	sts	0x01D5, r1
    176a:	10 92 d4 01 	sts	0x01D4, r1
    176e:	10 92 c1 01 	sts	0x01C1, r1
    1772:	1d 86       	std	Y+13, r1	; 0x0d
    1774:	00 00       	nop
	
	//Set sending flag
	flagSendingGAVR=fTrue;
	
	//Transmission protocol
	while (flagSendingGAVR){
    1776:	90 91 c1 01 	lds	r25, 0x01C1
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	99 23       	and	r25, r25
    177e:	09 f4       	brne	.+2      	; 0x1782 <_Z8sendGAVRv+0x4b6>
    1780:	80 e0       	ldi	r24, 0x00	; 0
    1782:	88 23       	and	r24, r24
    1784:	09 f0       	breq	.+2      	; 0x1788 <_Z8sendGAVRv+0x4bc>
    1786:	b5 cd       	rjmp	.-1174   	; 0x12f2 <_Z8sendGAVRv+0x26>
		}//end switch
	}//end while
		
	//If we aren't waiting for the next round, don't reset the flags. If we are waiting, just reset the waiting flag->the UserCLock and GAVRClcok flags
	//will still be at the values they were before.
	if (!flagWaitingToSendGAVR){
    1788:	80 91 c4 01 	lds	r24, 0x01C4
    178c:	88 23       	and	r24, r24
    178e:	29 f4       	brne	.+10     	; 0x179a <_Z8sendGAVRv+0x4ce>
		flagUserClock=fFalse;
    1790:	10 92 c2 01 	sts	0x01C2, r1
		flagUpdateGAVRClock=fFalse;	
    1794:	10 92 c0 01 	sts	0x01C0, r1
    1798:	02 c0       	rjmp	.+4      	; 0x179e <_Z8sendGAVRv+0x4d2>
	} else {flagWaitingToSendGAVR=fFalse;}
    179a:	10 92 c4 01 	sts	0x01C4, r1
}//end function 	
    179e:	c3 5a       	subi	r28, 0xA3	; 163
    17a0:	df 4f       	sbci	r29, 0xFF	; 255
    17a2:	0f b6       	in	r0, 0x3f	; 63
    17a4:	f8 94       	cli
    17a6:	de bf       	out	0x3e, r29	; 62
    17a8:	0f be       	out	0x3f, r0	; 63
    17aa:	cd bf       	out	0x3d, r28	; 61
    17ac:	df 91       	pop	r29
    17ae:	cf 91       	pop	r28
    17b0:	08 95       	ret

000017b2 <_Z11ReceiveBonev>:
	
/*************************************************************************************************************/
void ReceiveBone(){
    17b2:	0f 93       	push	r16
    17b4:	1f 93       	push	r17
    17b6:	cf 93       	push	r28
    17b8:	df 93       	push	r29
    17ba:	cd b7       	in	r28, 0x3d	; 61
    17bc:	de b7       	in	r29, 0x3e	; 62
    17be:	cf 58       	subi	r28, 0x8F	; 143
    17c0:	d0 40       	sbci	r29, 0x00	; 0
    17c2:	0f b6       	in	r0, 0x3f	; 63
    17c4:	f8 94       	cli
    17c6:	de bf       	out	0x3e, r29	; 62
    17c8:	0f be       	out	0x3f, r0	; 63
    17ca:	cd bf       	out	0x3d, r28	; 61
	unsigned int state=0;
    17cc:	1a 82       	std	Y+2, r1	; 0x02
    17ce:	19 82       	std	Y+1, r1	; 0x01
	char recChar, recString[40];
	unsigned int strLoc=0;
    17d0:	1c 82       	std	Y+4, r1	; 0x04
    17d2:	1b 82       	std	Y+3, r1	; 0x03
	BOOL noCarriage=fTrue;
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	8d 83       	std	Y+5, r24	; 0x05
	
	while (flagReceivingBone){
    17d8:	23 c6       	rjmp	.+3142   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
			/* State 6: Graceful exit. Exit from a command like adc or temp.																*/
			/* State 7: Parse the input string for the time and date. Should be time(:)'/'date(,) where : and , are the delimiters. Term by */
			/*			'.'																													*/
			/********************************************************************************************************************************/
			
			switch(state){
    17da:	89 81       	ldd	r24, Y+1	; 0x01
    17dc:	9a 81       	ldd	r25, Y+2	; 0x02
    17de:	83 30       	cpi	r24, 0x03	; 3
    17e0:	91 05       	cpc	r25, r1
    17e2:	09 f4       	brne	.+2      	; 0x17e6 <_Z11ReceiveBonev+0x34>
    17e4:	74 c1       	rjmp	.+744    	; 0x1ace <_Z11ReceiveBonev+0x31c>
    17e6:	84 30       	cpi	r24, 0x04	; 4
    17e8:	91 05       	cpc	r25, r1
    17ea:	48 f4       	brcc	.+18     	; 0x17fe <_Z11ReceiveBonev+0x4c>
    17ec:	81 30       	cpi	r24, 0x01	; 1
    17ee:	91 05       	cpc	r25, r1
    17f0:	09 f4       	brne	.+2      	; 0x17f4 <_Z11ReceiveBonev+0x42>
    17f2:	81 c0       	rjmp	.+258    	; 0x18f6 <_Z11ReceiveBonev+0x144>
    17f4:	82 30       	cpi	r24, 0x02	; 2
    17f6:	91 05       	cpc	r25, r1
    17f8:	08 f0       	brcs	.+2      	; 0x17fc <_Z11ReceiveBonev+0x4a>
    17fa:	8b c0       	rjmp	.+278    	; 0x1912 <_Z11ReceiveBonev+0x160>
    17fc:	11 c0       	rjmp	.+34     	; 0x1820 <_Z11ReceiveBonev+0x6e>
    17fe:	85 30       	cpi	r24, 0x05	; 5
    1800:	91 05       	cpc	r25, r1
    1802:	09 f4       	brne	.+2      	; 0x1806 <_Z11ReceiveBonev+0x54>
    1804:	c9 c2       	rjmp	.+1426   	; 0x1d98 <_Z11ReceiveBonev+0x5e6>
    1806:	85 30       	cpi	r24, 0x05	; 5
    1808:	91 05       	cpc	r25, r1
    180a:	08 f4       	brcc	.+2      	; 0x180e <_Z11ReceiveBonev+0x5c>
    180c:	1c c2       	rjmp	.+1080   	; 0x1c46 <_Z11ReceiveBonev+0x494>
    180e:	86 30       	cpi	r24, 0x06	; 6
    1810:	91 05       	cpc	r25, r1
    1812:	09 f4       	brne	.+2      	; 0x1816 <_Z11ReceiveBonev+0x64>
    1814:	ad c3       	rjmp	.+1882   	; 0x1f70 <_Z11ReceiveBonev+0x7be>
    1816:	87 30       	cpi	r24, 0x07	; 7
    1818:	91 05       	cpc	r25, r1
    181a:	09 f4       	brne	.+2      	; 0x181e <_Z11ReceiveBonev+0x6c>
    181c:	ca c3       	rjmp	.+1940   	; 0x1fb2 <_Z11ReceiveBonev+0x800>
    181e:	fb c5       	rjmp	.+3062   	; 0x2416 <_Z11ReceiveBonev+0xc64>
				case 0:{
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
    1820:	1c 82       	std	Y+4, r1	; 0x04
    1822:	1b 82       	std	Y+3, r1	; 0x03
					recChar = UDR0;
    1824:	86 ec       	ldi	r24, 0xC6	; 198
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	fc 01       	movw	r30, r24
    182a:	80 81       	ld	r24, Z
    182c:	8e 8f       	std	Y+30, r24	; 0x1e
					if (recChar=='.'){
    182e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1830:	8e 32       	cpi	r24, 0x2E	; 46
    1832:	29 f4       	brne	.+10     	; 0x183e <_Z11ReceiveBonev+0x8c>
						state=5;
    1834:	85 e0       	ldi	r24, 0x05	; 5
    1836:	90 e0       	ldi	r25, 0x00	; 0
    1838:	9a 83       	std	Y+2, r25	; 0x02
    183a:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
    183c:	f1 c5       	rjmp	.+3042   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
					recChar = UDR0;
					if (recChar=='.'){
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
    183e:	9e 01       	movw	r18, r28
    1840:	28 59       	subi	r18, 0x98	; 152
    1842:	3f 4f       	sbci	r19, 0xFF	; 255
    1844:	8b 81       	ldd	r24, Y+3	; 0x03
    1846:	9c 81       	ldd	r25, Y+4	; 0x04
    1848:	82 0f       	add	r24, r18
    184a:	93 1f       	adc	r25, r19
    184c:	2e 8d       	ldd	r18, Y+30	; 0x1e
    184e:	fc 01       	movw	r30, r24
    1850:	20 83       	st	Z, r18
    1852:	8b 81       	ldd	r24, Y+3	; 0x03
    1854:	9c 81       	ldd	r25, Y+4	; 0x04
    1856:	01 96       	adiw	r24, 0x01	; 1
    1858:	9c 83       	std	Y+4, r25	; 0x04
    185a:	8b 83       	std	Y+3, r24	; 0x03
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	90 e0       	ldi	r25, 0x00	; 0
    1860:	9a 83       	std	Y+2, r25	; 0x02
    1862:	89 83       	std	Y+1, r24	; 0x01
					break;				
    1864:	dd c5       	rjmp	.+3002   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while ((!(UCSR0A & (1 << RXC0))) && flagReceivingBone);		//get the next character
    1866:	00 00       	nop
    1868:	80 ec       	ldi	r24, 0xC0	; 192
    186a:	90 e0       	ldi	r25, 0x00	; 0
    186c:	fc 01       	movw	r30, r24
    186e:	80 81       	ld	r24, Z
    1870:	88 23       	and	r24, r24
    1872:	34 f0       	brlt	.+12     	; 0x1880 <_Z11ReceiveBonev+0xce>
    1874:	80 91 ba 01 	lds	r24, 0x01BA
    1878:	88 23       	and	r24, r24
    187a:	11 f0       	breq	.+4      	; 0x1880 <_Z11ReceiveBonev+0xce>
    187c:	81 e0       	ldi	r24, 0x01	; 1
    187e:	01 c0       	rjmp	.+2      	; 0x1882 <_Z11ReceiveBonev+0xd0>
    1880:	80 e0       	ldi	r24, 0x00	; 0
    1882:	88 23       	and	r24, r24
    1884:	89 f7       	brne	.-30     	; 0x1868 <_Z11ReceiveBonev+0xb6>
						if (!flagReceivingBone){state=6;}					//if there was a timeout, break out and reset state
    1886:	80 91 ba 01 	lds	r24, 0x01BA
    188a:	88 23       	and	r24, r24
    188c:	21 f4       	brne	.+8      	; 0x1896 <_Z11ReceiveBonev+0xe4>
    188e:	86 e0       	ldi	r24, 0x06	; 6
    1890:	90 e0       	ldi	r25, 0x00	; 0
    1892:	9a 83       	std	Y+2, r25	; 0x02
    1894:	89 83       	std	Y+1, r24	; 0x01
						recChar=UDR0;
    1896:	86 ec       	ldi	r24, 0xC6	; 198
    1898:	90 e0       	ldi	r25, 0x00	; 0
    189a:	fc 01       	movw	r30, r24
    189c:	80 81       	ld	r24, Z
    189e:	8e 8f       	std	Y+30, r24	; 0x1e
						recString[strLoc++]=recChar;
    18a0:	9e 01       	movw	r18, r28
    18a2:	28 59       	subi	r18, 0x98	; 152
    18a4:	3f 4f       	sbci	r19, 0xFF	; 255
    18a6:	8b 81       	ldd	r24, Y+3	; 0x03
    18a8:	9c 81       	ldd	r25, Y+4	; 0x04
    18aa:	82 0f       	add	r24, r18
    18ac:	93 1f       	adc	r25, r19
    18ae:	2e 8d       	ldd	r18, Y+30	; 0x1e
    18b0:	fc 01       	movw	r30, r24
    18b2:	20 83       	st	Z, r18
    18b4:	8b 81       	ldd	r24, Y+3	; 0x03
    18b6:	9c 81       	ldd	r25, Y+4	; 0x04
    18b8:	01 96       	adiw	r24, 0x01	; 1
    18ba:	9c 83       	std	Y+4, r25	; 0x04
    18bc:	8b 83       	std	Y+3, r24	; 0x03
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    18be:	8e 8d       	ldd	r24, Y+30	; 0x1e
    18c0:	8e 32       	cpi	r24, 0x2E	; 46
    18c2:	79 f4       	brne	.+30     	; 0x18e2 <_Z11ReceiveBonev+0x130>
    18c4:	9e 01       	movw	r18, r28
    18c6:	28 59       	subi	r18, 0x98	; 152
    18c8:	3f 4f       	sbci	r19, 0xFF	; 255
    18ca:	8b 81       	ldd	r24, Y+3	; 0x03
    18cc:	9c 81       	ldd	r25, Y+4	; 0x04
    18ce:	82 0f       	add	r24, r18
    18d0:	93 1f       	adc	r25, r19
    18d2:	fc 01       	movw	r30, r24
    18d4:	10 82       	st	Z, r1
    18d6:	1d 82       	std	Y+5, r1	; 0x05
    18d8:	82 e0       	ldi	r24, 0x02	; 2
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	9a 83       	std	Y+2, r25	; 0x02
    18de:	89 83       	std	Y+1, r24	; 0x01
    18e0:	0a c0       	rjmp	.+20     	; 0x18f6 <_Z11ReceiveBonev+0x144>
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
    18e2:	8b 81       	ldd	r24, Y+3	; 0x03
    18e4:	9c 81       	ldd	r25, Y+4	; 0x04
    18e6:	87 32       	cpi	r24, 0x27	; 39
    18e8:	91 05       	cpc	r25, r1
    18ea:	28 f0       	brcs	.+10     	; 0x18f6 <_Z11ReceiveBonev+0x144>
    18ec:	85 e0       	ldi	r24, 0x05	; 5
    18ee:	90 e0       	ldi	r25, 0x00	; 0
    18f0:	9a 83       	std	Y+2, r25	; 0x02
    18f2:	89 83       	std	Y+1, r24	; 0x01
    18f4:	1d 82       	std	Y+5, r1	; 0x05
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    18f6:	8d 81       	ldd	r24, Y+5	; 0x05
    18f8:	88 23       	and	r24, r24
    18fa:	31 f0       	breq	.+12     	; 0x1908 <_Z11ReceiveBonev+0x156>
    18fc:	80 91 ba 01 	lds	r24, 0x01BA
    1900:	88 23       	and	r24, r24
    1902:	11 f0       	breq	.+4      	; 0x1908 <_Z11ReceiveBonev+0x156>
    1904:	81 e0       	ldi	r24, 0x01	; 1
    1906:	01 c0       	rjmp	.+2      	; 0x190a <_Z11ReceiveBonev+0x158>
    1908:	80 e0       	ldi	r24, 0x00	; 0
    190a:	88 23       	and	r24, r24
    190c:	09 f0       	breq	.+2      	; 0x1910 <_Z11ReceiveBonev+0x15e>
    190e:	ab cf       	rjmp	.-170    	; 0x1866 <_Z11ReceiveBonev+0xb4>
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    1910:	87 c5       	rjmp	.+2830   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
    1912:	ce 01       	movw	r24, r28
    1914:	88 59       	subi	r24, 0x98	; 152
    1916:	9f 4f       	sbci	r25, 0xFF	; 255
    1918:	29 e2       	ldi	r18, 0x29	; 41
    191a:	31 e0       	ldi	r19, 0x01	; 1
    191c:	b9 01       	movw	r22, r18
    191e:	45 e0       	ldi	r20, 0x05	; 5
    1920:	50 e0       	ldi	r21, 0x00	; 0
    1922:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    1926:	00 97       	sbiw	r24, 0x00	; 0
    1928:	51 f4       	brne	.+20     	; 0x193e <_Z11ReceiveBonev+0x18c>
    192a:	81 e0       	ldi	r24, 0x01	; 1
    192c:	60 e0       	ldi	r22, 0x00	; 0
    192e:	41 e0       	ldi	r20, 0x01	; 1
    1930:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_Z13printTimeDatehhh>
    1934:	86 e0       	ldi	r24, 0x06	; 6
    1936:	90 e0       	ldi	r25, 0x00	; 0
    1938:	9a 83       	std	Y+2, r25	; 0x02
    193a:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    193c:	71 c5       	rjmp	.+2786   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					}//end while
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
    193e:	ce 01       	movw	r24, r28
    1940:	88 59       	subi	r24, 0x98	; 152
    1942:	9f 4f       	sbci	r25, 0xFF	; 255
    1944:	2f e2       	ldi	r18, 0x2F	; 47
    1946:	31 e0       	ldi	r19, 0x01	; 1
    1948:	b9 01       	movw	r22, r18
    194a:	45 e0       	ldi	r20, 0x05	; 5
    194c:	50 e0       	ldi	r21, 0x00	; 0
    194e:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    1952:	00 97       	sbiw	r24, 0x00	; 0
    1954:	51 f4       	brne	.+20     	; 0x196a <_Z11ReceiveBonev+0x1b8>
    1956:	81 e0       	ldi	r24, 0x01	; 1
    1958:	61 e0       	ldi	r22, 0x01	; 1
    195a:	40 e0       	ldi	r20, 0x00	; 0
    195c:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_Z13printTimeDatehhh>
    1960:	86 e0       	ldi	r24, 0x06	; 6
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	9a 83       	std	Y+2, r25	; 0x02
    1966:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1968:	5b c5       	rjmp	.+2742   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
    196a:	ce 01       	movw	r24, r28
    196c:	88 59       	subi	r24, 0x98	; 152
    196e:	9f 4f       	sbci	r25, 0xFF	; 255
    1970:	25 e3       	ldi	r18, 0x35	; 53
    1972:	31 e0       	ldi	r19, 0x01	; 1
    1974:	b9 01       	movw	r22, r18
    1976:	45 e0       	ldi	r20, 0x05	; 5
    1978:	50 e0       	ldi	r21, 0x00	; 0
    197a:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    197e:	00 97       	sbiw	r24, 0x00	; 0
    1980:	51 f4       	brne	.+20     	; 0x1996 <_Z11ReceiveBonev+0x1e4>
    1982:	81 e0       	ldi	r24, 0x01	; 1
    1984:	61 e0       	ldi	r22, 0x01	; 1
    1986:	41 e0       	ldi	r20, 0x01	; 1
    1988:	0e 94 6e 18 	call	0x30dc	; 0x30dc <_Z13printTimeDatehhh>
    198c:	86 e0       	ldi	r24, 0x06	; 6
    198e:	90 e0       	ldi	r25, 0x00	; 0
    1990:	9a 83       	std	Y+2, r25	; 0x02
    1992:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1994:	45 c5       	rjmp	.+2698   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
    1996:	ce 01       	movw	r24, r28
    1998:	88 59       	subi	r24, 0x98	; 152
    199a:	9f 4f       	sbci	r25, 0xFF	; 255
    199c:	2b e3       	ldi	r18, 0x3B	; 59
    199e:	31 e0       	ldi	r19, 0x01	; 1
    19a0:	b9 01       	movw	r22, r18
    19a2:	45 e0       	ldi	r20, 0x05	; 5
    19a4:	50 e0       	ldi	r21, 0x00	; 0
    19a6:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    19aa:	00 97       	sbiw	r24, 0x00	; 0
    19ac:	71 f4       	brne	.+28     	; 0x19ca <_Z11ReceiveBonev+0x218>
    19ae:	81 e0       	ldi	r24, 0x01	; 1
    19b0:	60 e0       	ldi	r22, 0x00	; 0
    19b2:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    19b6:	ce 01       	movw	r24, r28
    19b8:	88 59       	subi	r24, 0x98	; 152
    19ba:	9f 4f       	sbci	r25, 0xFF	; 255
    19bc:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
    19c0:	86 e0       	ldi	r24, 0x06	; 6
    19c2:	90 e0       	ldi	r25, 0x00	; 0
    19c4:	9a 83       	std	Y+2, r25	; 0x02
    19c6:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    19c8:	2b c5       	rjmp	.+2646   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    19ca:	ce 01       	movw	r24, r28
    19cc:	88 59       	subi	r24, 0x98	; 152
    19ce:	9f 4f       	sbci	r25, 0xFF	; 255
    19d0:	21 e4       	ldi	r18, 0x41	; 65
    19d2:	31 e0       	ldi	r19, 0x01	; 1
    19d4:	b9 01       	movw	r22, r18
    19d6:	44 e0       	ldi	r20, 0x04	; 4
    19d8:	50 e0       	ldi	r21, 0x00	; 0
    19da:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    19de:	00 97       	sbiw	r24, 0x00	; 0
    19e0:	d9 f4       	brne	.+54     	; 0x1a18 <_Z11ReceiveBonev+0x266>
    19e2:	80 91 8e 01 	lds	r24, 0x018E
    19e6:	90 91 8f 01 	lds	r25, 0x018F
    19ea:	9e 01       	movw	r18, r28
    19ec:	27 5b       	subi	r18, 0xB7	; 183
    19ee:	3f 4f       	sbci	r19, 0xFF	; 255
    19f0:	b9 01       	movw	r22, r18
    19f2:	4a e0       	ldi	r20, 0x0A	; 10
    19f4:	50 e0       	ldi	r21, 0x00	; 0
    19f6:	0e 94 4b 23 	call	0x4696	; 0x4696 <utoa>
    19fa:	ce 01       	movw	r24, r28
    19fc:	87 5b       	subi	r24, 0xB7	; 183
    19fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1a00:	fc 01       	movw	r30, r24
    1a02:	16 82       	std	Z+6, r1	; 0x06
    1a04:	ce 01       	movw	r24, r28
    1a06:	87 5b       	subi	r24, 0xB7	; 183
    1a08:	9f 4f       	sbci	r25, 0xFF	; 255
    1a0a:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
    1a0e:	86 e0       	ldi	r24, 0x06	; 6
    1a10:	90 e0       	ldi	r25, 0x00	; 0
    1a12:	9a 83       	std	Y+2, r25	; 0x02
    1a14:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1a16:	04 c5       	rjmp	.+2568   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    1a18:	ce 01       	movw	r24, r28
    1a1a:	88 59       	subi	r24, 0x98	; 152
    1a1c:	9f 4f       	sbci	r25, 0xFF	; 255
    1a1e:	26 e4       	ldi	r18, 0x46	; 70
    1a20:	31 e0       	ldi	r19, 0x01	; 1
    1a22:	b9 01       	movw	r22, r18
    1a24:	45 e0       	ldi	r20, 0x05	; 5
    1a26:	50 e0       	ldi	r21, 0x00	; 0
    1a28:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    1a2c:	00 97       	sbiw	r24, 0x00	; 0
    1a2e:	d9 f4       	brne	.+54     	; 0x1a66 <_Z11ReceiveBonev+0x2b4>
    1a30:	80 91 90 01 	lds	r24, 0x0190
    1a34:	90 91 91 01 	lds	r25, 0x0191
    1a38:	9e 01       	movw	r18, r28
    1a3a:	20 5b       	subi	r18, 0xB0	; 176
    1a3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1a3e:	b9 01       	movw	r22, r18
    1a40:	4a e0       	ldi	r20, 0x0A	; 10
    1a42:	50 e0       	ldi	r21, 0x00	; 0
    1a44:	0e 94 4b 23 	call	0x4696	; 0x4696 <utoa>
    1a48:	ce 01       	movw	r24, r28
    1a4a:	80 5b       	subi	r24, 0xB0	; 176
    1a4c:	9f 4f       	sbci	r25, 0xFF	; 255
    1a4e:	fc 01       	movw	r30, r24
    1a50:	16 82       	std	Z+6, r1	; 0x06
    1a52:	ce 01       	movw	r24, r28
    1a54:	80 5b       	subi	r24, 0xB0	; 176
    1a56:	9f 4f       	sbci	r25, 0xFF	; 255
    1a58:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
    1a5c:	86 e0       	ldi	r24, 0x06	; 6
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	9a 83       	std	Y+2, r25	; 0x02
    1a62:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1a64:	dd c4       	rjmp	.+2490   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
    1a66:	ce 01       	movw	r24, r28
    1a68:	88 59       	subi	r24, 0x98	; 152
    1a6a:	9f 4f       	sbci	r25, 0xFF	; 255
    1a6c:	fc 01       	movw	r30, r24
    1a6e:	84 81       	ldd	r24, Z+4	; 0x04
    1a70:	21 e0       	ldi	r18, 0x01	; 1
    1a72:	8a 33       	cpi	r24, 0x3A	; 58
    1a74:	09 f0       	breq	.+2      	; 0x1a78 <_Z11ReceiveBonev+0x2c6>
    1a76:	20 e0       	ldi	r18, 0x00	; 0
    1a78:	ce 01       	movw	r24, r28
    1a7a:	88 59       	subi	r24, 0x98	; 152
    1a7c:	9f 4f       	sbci	r25, 0xFF	; 255
    1a7e:	fc 01       	movw	r30, r24
    1a80:	95 81       	ldd	r25, Z+5	; 0x05
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	9a 33       	cpi	r25, 0x3A	; 58
    1a86:	09 f0       	breq	.+2      	; 0x1a8a <_Z11ReceiveBonev+0x2d8>
    1a88:	80 e0       	ldi	r24, 0x00	; 0
    1a8a:	82 27       	eor	r24, r18
    1a8c:	88 23       	and	r24, r24
    1a8e:	29 f0       	breq	.+10     	; 0x1a9a <_Z11ReceiveBonev+0x2e8>
						state=7;	
    1a90:	87 e0       	ldi	r24, 0x07	; 7
    1a92:	90 e0       	ldi	r25, 0x00	; 0
    1a94:	9a 83       	std	Y+2, r25	; 0x02
    1a96:	89 83       	std	Y+1, r24	; 0x01
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1a98:	c3 c4       	rjmp	.+2438   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
    1a9a:	ce 01       	movw	r24, r28
    1a9c:	88 59       	subi	r24, 0x98	; 152
    1a9e:	9f 4f       	sbci	r25, 0xFF	; 255
    1aa0:	2c e4       	ldi	r18, 0x4C	; 76
    1aa2:	31 e0       	ldi	r19, 0x01	; 1
    1aa4:	b9 01       	movw	r22, r18
    1aa6:	48 e0       	ldi	r20, 0x08	; 8
    1aa8:	50 e0       	ldi	r21, 0x00	; 0
    1aaa:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    1aae:	00 97       	sbiw	r24, 0x00	; 0
    1ab0:	49 f4       	brne	.+18     	; 0x1ac4 <_Z11ReceiveBonev+0x312>
    1ab2:	85 e5       	ldi	r24, 0x55	; 85
    1ab4:	91 e0       	ldi	r25, 0x01	; 1
    1ab6:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
    1aba:	86 e0       	ldi	r24, 0x06	; 6
    1abc:	90 e0       	ldi	r25, 0x00	; 0
    1abe:	9a 83       	std	Y+2, r25	; 0x02
    1ac0:	89 83       	std	Y+1, r24	; 0x01
					else {state=5;}						
					break;
    1ac2:	ae c4       	rjmp	.+2396   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
    1ac4:	85 e0       	ldi	r24, 0x05	; 5
    1ac6:	90 e0       	ldi	r25, 0x00	; 0
    1ac8:	9a 83       	std	Y+2, r25	; 0x02
    1aca:	89 83       	std	Y+1, r24	; 0x01
					break;
    1acc:	a9 c4       	rjmp	.+2386   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
    1ace:	80 e0       	ldi	r24, 0x00	; 0
    1ad0:	90 e0       	ldi	r25, 0x00	; 0
    1ad2:	a8 ec       	ldi	r26, 0xC8	; 200
    1ad4:	b2 e4       	ldi	r27, 0x42	; 66
    1ad6:	8f 8f       	std	Y+31, r24	; 0x1f
    1ad8:	98 a3       	lds	r25, 0x58
    1ada:	a9 a3       	lds	r26, 0x59
    1adc:	ba a3       	lds	r27, 0x5a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    1ade:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1ae0:	78 a1       	lds	r23, 0x48
    1ae2:	89 a1       	lds	r24, 0x49
    1ae4:	9a a1       	lds	r25, 0x4a
    1ae6:	20 e0       	ldi	r18, 0x00	; 0
    1ae8:	30 e0       	ldi	r19, 0x00	; 0
    1aea:	4a e7       	ldi	r20, 0x7A	; 122
    1aec:	53 e4       	ldi	r21, 0x43	; 67
    1aee:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    1af2:	dc 01       	movw	r26, r24
    1af4:	cb 01       	movw	r24, r22
    1af6:	8b a3       	lds	r24, 0x5b
    1af8:	9c a3       	lds	r25, 0x5c
    1afa:	ad a3       	lds	r26, 0x5d
    1afc:	be a3       	lds	r27, 0x5e
	if (__tmp < 1.0)
    1afe:	11 e0       	ldi	r17, 0x01	; 1
    1b00:	6b a1       	lds	r22, 0x4b
    1b02:	7c a1       	lds	r23, 0x4c
    1b04:	8d a1       	lds	r24, 0x4d
    1b06:	9e a1       	lds	r25, 0x4e
    1b08:	20 e0       	ldi	r18, 0x00	; 0
    1b0a:	30 e0       	ldi	r19, 0x00	; 0
    1b0c:	40 e8       	ldi	r20, 0x80	; 128
    1b0e:	5f e3       	ldi	r21, 0x3F	; 63
    1b10:	0e 94 96 21 	call	0x432c	; 0x432c <__cmpsf2>
    1b14:	88 23       	and	r24, r24
    1b16:	0c f0       	brlt	.+2      	; 0x1b1a <_Z11ReceiveBonev+0x368>
    1b18:	10 e0       	ldi	r17, 0x00	; 0
    1b1a:	11 23       	and	r17, r17
    1b1c:	29 f0       	breq	.+10     	; 0x1b28 <_Z11ReceiveBonev+0x376>
		__ticks = 1;
    1b1e:	81 e0       	ldi	r24, 0x01	; 1
    1b20:	90 e0       	ldi	r25, 0x00	; 0
    1b22:	98 a7       	lds	r25, 0x78
    1b24:	8f a3       	lds	r24, 0x5f
    1b26:	4a c0       	rjmp	.+148    	; 0x1bbc <_Z11ReceiveBonev+0x40a>
	else if (__tmp > 65535)
    1b28:	11 e0       	ldi	r17, 0x01	; 1
    1b2a:	6b a1       	lds	r22, 0x4b
    1b2c:	7c a1       	lds	r23, 0x4c
    1b2e:	8d a1       	lds	r24, 0x4d
    1b30:	9e a1       	lds	r25, 0x4e
    1b32:	20 e0       	ldi	r18, 0x00	; 0
    1b34:	3f ef       	ldi	r19, 0xFF	; 255
    1b36:	4f e7       	ldi	r20, 0x7F	; 127
    1b38:	57 e4       	ldi	r21, 0x47	; 71
    1b3a:	0e 94 13 22 	call	0x4426	; 0x4426 <__gesf2>
    1b3e:	18 16       	cp	r1, r24
    1b40:	0c f0       	brlt	.+2      	; 0x1b44 <_Z11ReceiveBonev+0x392>
    1b42:	10 e0       	ldi	r17, 0x00	; 0
    1b44:	11 23       	and	r17, r17
    1b46:	81 f1       	breq	.+96     	; 0x1ba8 <_Z11ReceiveBonev+0x3f6>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1b48:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1b4a:	78 a1       	lds	r23, 0x48
    1b4c:	89 a1       	lds	r24, 0x49
    1b4e:	9a a1       	lds	r25, 0x4a
    1b50:	20 e0       	ldi	r18, 0x00	; 0
    1b52:	30 e0       	ldi	r19, 0x00	; 0
    1b54:	40 e2       	ldi	r20, 0x20	; 32
    1b56:	51 e4       	ldi	r21, 0x41	; 65
    1b58:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    1b5c:	dc 01       	movw	r26, r24
    1b5e:	cb 01       	movw	r24, r22
    1b60:	bc 01       	movw	r22, r24
    1b62:	cd 01       	movw	r24, r26
    1b64:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    1b68:	dc 01       	movw	r26, r24
    1b6a:	cb 01       	movw	r24, r22
    1b6c:	98 a7       	lds	r25, 0x78
    1b6e:	8f a3       	lds	r24, 0x5f
    1b70:	12 c0       	rjmp	.+36     	; 0x1b96 <_Z11ReceiveBonev+0x3e4>
    1b72:	89 e1       	ldi	r24, 0x19	; 25
    1b74:	90 e0       	ldi	r25, 0x00	; 0
    1b76:	9a a7       	lds	r25, 0x7a
    1b78:	89 a7       	lds	r24, 0x79
	__asm__ volatile (
		"1: sbiw %0,1" "\n\t"
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
    1b7a:	89 a5       	lds	r24, 0x69
    1b7c:	9a a5       	lds	r25, 0x6a
    1b7e:	8c 01       	movw	r16, r24
    1b80:	c8 01       	movw	r24, r16
    1b82:	01 97       	sbiw	r24, 0x01	; 1
    1b84:	f1 f7       	brne	.-4      	; 0x1b82 <_Z11ReceiveBonev+0x3d0>
    1b86:	8c 01       	movw	r16, r24
    1b88:	1a a7       	lds	r17, 0x7a
    1b8a:	09 a7       	lds	r16, 0x79
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1b8c:	8f a1       	lds	r24, 0x4f
    1b8e:	98 a5       	lds	r25, 0x68
    1b90:	01 97       	sbiw	r24, 0x01	; 1
    1b92:	98 a7       	lds	r25, 0x78
    1b94:	8f a3       	lds	r24, 0x5f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1b96:	21 e0       	ldi	r18, 0x01	; 1
    1b98:	8f a1       	lds	r24, 0x4f
    1b9a:	98 a5       	lds	r25, 0x68
    1b9c:	00 97       	sbiw	r24, 0x00	; 0
    1b9e:	09 f4       	brne	.+2      	; 0x1ba2 <_Z11ReceiveBonev+0x3f0>
    1ba0:	20 e0       	ldi	r18, 0x00	; 0
    1ba2:	22 23       	and	r18, r18
    1ba4:	31 f7       	brne	.-52     	; 0x1b72 <_Z11ReceiveBonev+0x3c0>
    1ba6:	17 c0       	rjmp	.+46     	; 0x1bd6 <_Z11ReceiveBonev+0x424>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ba8:	6b a1       	lds	r22, 0x4b
    1baa:	7c a1       	lds	r23, 0x4c
    1bac:	8d a1       	lds	r24, 0x4d
    1bae:	9e a1       	lds	r25, 0x4e
    1bb0:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    1bb4:	dc 01       	movw	r26, r24
    1bb6:	cb 01       	movw	r24, r22
    1bb8:	98 a7       	lds	r25, 0x78
    1bba:	8f a3       	lds	r24, 0x5f
    1bbc:	8f a1       	lds	r24, 0x4f
    1bbe:	98 a5       	lds	r25, 0x68
    1bc0:	9c a7       	lds	r25, 0x7c
    1bc2:	8b a7       	lds	r24, 0x7b
    1bc4:	8b a5       	lds	r24, 0x6b
    1bc6:	9c a5       	lds	r25, 0x6c
    1bc8:	8c 01       	movw	r16, r24
    1bca:	f8 01       	movw	r30, r16
    1bcc:	31 97       	sbiw	r30, 0x01	; 1
    1bce:	f1 f7       	brne	.-4      	; 0x1bcc <_Z11ReceiveBonev+0x41a>
    1bd0:	8f 01       	movw	r16, r30
    1bd2:	1c a7       	lds	r17, 0x7c
    1bd4:	0b a7       	lds	r16, 0x7b
					}//end case 2
				case 3:{
					_delay_ms(100);
					//Successful receive state of time, change SYN to ACK, then print what we got.
					recString[0]='A';
    1bd6:	ce 01       	movw	r24, r28
    1bd8:	88 59       	subi	r24, 0x98	; 152
    1bda:	9f 4f       	sbci	r25, 0xFF	; 255
    1bdc:	21 e4       	ldi	r18, 0x41	; 65
    1bde:	fc 01       	movw	r30, r24
    1be0:	20 83       	st	Z, r18
					recString[1]='C';
    1be2:	ce 01       	movw	r24, r28
    1be4:	88 59       	subi	r24, 0x98	; 152
    1be6:	9f 4f       	sbci	r25, 0xFF	; 255
    1be8:	23 e4       	ldi	r18, 0x43	; 67
    1bea:	fc 01       	movw	r30, r24
    1bec:	21 83       	std	Z+1, r18	; 0x01
					recString[2]='K';
    1bee:	ce 01       	movw	r24, r28
    1bf0:	88 59       	subi	r24, 0x98	; 152
    1bf2:	9f 4f       	sbci	r25, 0xFF	; 255
    1bf4:	2b e4       	ldi	r18, 0x4B	; 75
    1bf6:	fc 01       	movw	r30, r24
    1bf8:	22 83       	std	Z+2, r18	; 0x02
					PrintBone(recString);
    1bfa:	ce 01       	movw	r24, r28
    1bfc:	88 59       	subi	r24, 0x98	; 152
    1bfe:	9f 4f       	sbci	r25, 0xFF	; 255
    1c00:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
					state=0;
    1c04:	1a 82       	std	Y+2, r1	; 0x02
    1c06:	19 82       	std	Y+1, r1	; 0x01
					flagReceivingBone=fFalse;
    1c08:	10 92 ba 01 	sts	0x01BA, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1c0c:	1f 82       	std	Y+7, r1	; 0x07
    1c0e:	1e 82       	std	Y+6, r1	; 0x06
    1c10:	0e c0       	rjmp	.+28     	; 0x1c2e <_Z11ReceiveBonev+0x47c>
    1c12:	9e 01       	movw	r18, r28
    1c14:	28 59       	subi	r18, 0x98	; 152
    1c16:	3f 4f       	sbci	r19, 0xFF	; 255
    1c18:	8e 81       	ldd	r24, Y+6	; 0x06
    1c1a:	9f 81       	ldd	r25, Y+7	; 0x07
    1c1c:	82 0f       	add	r24, r18
    1c1e:	93 1f       	adc	r25, r19
    1c20:	fc 01       	movw	r30, r24
    1c22:	10 82       	st	Z, r1
    1c24:	8e 81       	ldd	r24, Y+6	; 0x06
    1c26:	9f 81       	ldd	r25, Y+7	; 0x07
    1c28:	01 96       	adiw	r24, 0x01	; 1
    1c2a:	9f 83       	std	Y+7, r25	; 0x07
    1c2c:	8e 83       	std	Y+6, r24	; 0x06
    1c2e:	2e 81       	ldd	r18, Y+6	; 0x06
    1c30:	3f 81       	ldd	r19, Y+7	; 0x07
    1c32:	41 e0       	ldi	r20, 0x01	; 1
    1c34:	8b 81       	ldd	r24, Y+3	; 0x03
    1c36:	9c 81       	ldd	r25, Y+4	; 0x04
    1c38:	28 17       	cp	r18, r24
    1c3a:	39 07       	cpc	r19, r25
    1c3c:	08 f0       	brcs	.+2      	; 0x1c40 <_Z11ReceiveBonev+0x48e>
    1c3e:	40 e0       	ldi	r20, 0x00	; 0
    1c40:	44 23       	and	r20, r20
    1c42:	39 f7       	brne	.-50     	; 0x1c12 <_Z11ReceiveBonev+0x460>
					break;
    1c44:	ed c3       	rjmp	.+2010   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
    1c46:	80 e0       	ldi	r24, 0x00	; 0
    1c48:	90 e0       	ldi	r25, 0x00	; 0
    1c4a:	a8 ec       	ldi	r26, 0xC8	; 200
    1c4c:	b2 e4       	ldi	r27, 0x42	; 66
    1c4e:	8d a7       	lds	r24, 0x7d
    1c50:	9e a7       	lds	r25, 0x7e
    1c52:	af a7       	lds	r26, 0x7f
    1c54:	b8 ab       	sts	0x58, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    1c56:	6d a5       	lds	r22, 0x6d
    1c58:	7e a5       	lds	r23, 0x6e
    1c5a:	8f a5       	lds	r24, 0x6f
    1c5c:	98 a9       	sts	0x48, r25
    1c5e:	20 e0       	ldi	r18, 0x00	; 0
    1c60:	30 e0       	ldi	r19, 0x00	; 0
    1c62:	4a e7       	ldi	r20, 0x7A	; 122
    1c64:	53 e4       	ldi	r21, 0x43	; 67
    1c66:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    1c6a:	dc 01       	movw	r26, r24
    1c6c:	cb 01       	movw	r24, r22
    1c6e:	89 ab       	sts	0x59, r24
    1c70:	9a ab       	sts	0x5a, r25
    1c72:	ab ab       	sts	0x5b, r26
    1c74:	bc ab       	sts	0x5c, r27
	if (__tmp < 1.0)
    1c76:	11 e0       	ldi	r17, 0x01	; 1
    1c78:	69 a9       	sts	0x49, r22
    1c7a:	7a a9       	sts	0x4a, r23
    1c7c:	8b a9       	sts	0x4b, r24
    1c7e:	9c a9       	sts	0x4c, r25
    1c80:	20 e0       	ldi	r18, 0x00	; 0
    1c82:	30 e0       	ldi	r19, 0x00	; 0
    1c84:	40 e8       	ldi	r20, 0x80	; 128
    1c86:	5f e3       	ldi	r21, 0x3F	; 63
    1c88:	0e 94 96 21 	call	0x432c	; 0x432c <__cmpsf2>
    1c8c:	88 23       	and	r24, r24
    1c8e:	0c f0       	brlt	.+2      	; 0x1c92 <_Z11ReceiveBonev+0x4e0>
    1c90:	10 e0       	ldi	r17, 0x00	; 0
    1c92:	11 23       	and	r17, r17
    1c94:	29 f0       	breq	.+10     	; 0x1ca0 <_Z11ReceiveBonev+0x4ee>
		__ticks = 1;
    1c96:	81 e0       	ldi	r24, 0x01	; 1
    1c98:	90 e0       	ldi	r25, 0x00	; 0
    1c9a:	9e ab       	sts	0x5e, r25
    1c9c:	8d ab       	sts	0x5d, r24
    1c9e:	4a c0       	rjmp	.+148    	; 0x1d34 <_Z11ReceiveBonev+0x582>
	else if (__tmp > 65535)
    1ca0:	11 e0       	ldi	r17, 0x01	; 1
    1ca2:	69 a9       	sts	0x49, r22
    1ca4:	7a a9       	sts	0x4a, r23
    1ca6:	8b a9       	sts	0x4b, r24
    1ca8:	9c a9       	sts	0x4c, r25
    1caa:	20 e0       	ldi	r18, 0x00	; 0
    1cac:	3f ef       	ldi	r19, 0xFF	; 255
    1cae:	4f e7       	ldi	r20, 0x7F	; 127
    1cb0:	57 e4       	ldi	r21, 0x47	; 71
    1cb2:	0e 94 13 22 	call	0x4426	; 0x4426 <__gesf2>
    1cb6:	18 16       	cp	r1, r24
    1cb8:	0c f0       	brlt	.+2      	; 0x1cbc <_Z11ReceiveBonev+0x50a>
    1cba:	10 e0       	ldi	r17, 0x00	; 0
    1cbc:	11 23       	and	r17, r17
    1cbe:	81 f1       	breq	.+96     	; 0x1d20 <_Z11ReceiveBonev+0x56e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1cc0:	6d a5       	lds	r22, 0x6d
    1cc2:	7e a5       	lds	r23, 0x6e
    1cc4:	8f a5       	lds	r24, 0x6f
    1cc6:	98 a9       	sts	0x48, r25
    1cc8:	20 e0       	ldi	r18, 0x00	; 0
    1cca:	30 e0       	ldi	r19, 0x00	; 0
    1ccc:	40 e2       	ldi	r20, 0x20	; 32
    1cce:	51 e4       	ldi	r21, 0x41	; 65
    1cd0:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    1cd4:	dc 01       	movw	r26, r24
    1cd6:	cb 01       	movw	r24, r22
    1cd8:	bc 01       	movw	r22, r24
    1cda:	cd 01       	movw	r24, r26
    1cdc:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    1ce0:	dc 01       	movw	r26, r24
    1ce2:	cb 01       	movw	r24, r22
    1ce4:	9e ab       	sts	0x5e, r25
    1ce6:	8d ab       	sts	0x5d, r24
    1ce8:	12 c0       	rjmp	.+36     	; 0x1d0e <_Z11ReceiveBonev+0x55c>
    1cea:	89 e1       	ldi	r24, 0x19	; 25
    1cec:	90 e0       	ldi	r25, 0x00	; 0
    1cee:	98 af       	sts	0x78, r25
    1cf0:	8f ab       	sts	0x5f, r24
    1cf2:	8f a9       	sts	0x4f, r24
    1cf4:	98 ad       	sts	0x68, r25
    1cf6:	8c 01       	movw	r16, r24
    1cf8:	c8 01       	movw	r24, r16
    1cfa:	01 97       	sbiw	r24, 0x01	; 1
    1cfc:	f1 f7       	brne	.-4      	; 0x1cfa <_Z11ReceiveBonev+0x548>
    1cfe:	8c 01       	movw	r16, r24
    1d00:	18 af       	sts	0x78, r17
    1d02:	0f ab       	sts	0x5f, r16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1d04:	8d a9       	sts	0x4d, r24
    1d06:	9e a9       	sts	0x4e, r25
    1d08:	01 97       	sbiw	r24, 0x01	; 1
    1d0a:	9e ab       	sts	0x5e, r25
    1d0c:	8d ab       	sts	0x5d, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1d0e:	21 e0       	ldi	r18, 0x01	; 1
    1d10:	8d a9       	sts	0x4d, r24
    1d12:	9e a9       	sts	0x4e, r25
    1d14:	00 97       	sbiw	r24, 0x00	; 0
    1d16:	09 f4       	brne	.+2      	; 0x1d1a <_Z11ReceiveBonev+0x568>
    1d18:	20 e0       	ldi	r18, 0x00	; 0
    1d1a:	22 23       	and	r18, r18
    1d1c:	31 f7       	brne	.-52     	; 0x1cea <_Z11ReceiveBonev+0x538>
    1d1e:	17 c0       	rjmp	.+46     	; 0x1d4e <_Z11ReceiveBonev+0x59c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1d20:	69 a9       	sts	0x49, r22
    1d22:	7a a9       	sts	0x4a, r23
    1d24:	8b a9       	sts	0x4b, r24
    1d26:	9c a9       	sts	0x4c, r25
    1d28:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    1d2c:	dc 01       	movw	r26, r24
    1d2e:	cb 01       	movw	r24, r22
    1d30:	9e ab       	sts	0x5e, r25
    1d32:	8d ab       	sts	0x5d, r24
    1d34:	8d a9       	sts	0x4d, r24
    1d36:	9e a9       	sts	0x4e, r25
    1d38:	9a af       	sts	0x7a, r25
    1d3a:	89 af       	sts	0x79, r24
    1d3c:	89 ad       	sts	0x69, r24
    1d3e:	9a ad       	sts	0x6a, r25
    1d40:	8c 01       	movw	r16, r24
    1d42:	f8 01       	movw	r30, r16
    1d44:	31 97       	sbiw	r30, 0x01	; 1
    1d46:	f1 f7       	brne	.-4      	; 0x1d44 <_Z11ReceiveBonev+0x592>
    1d48:	8f 01       	movw	r16, r30
    1d4a:	1a af       	sts	0x7a, r17
    1d4c:	09 af       	sts	0x79, r16
					}//end case 3
				case 4:{
					//Bad time string.
					_delay_ms(100);
					PrintBone("ACKBAD.");
    1d4e:	8d e0       	ldi	r24, 0x0D	; 13
    1d50:	91 e0       	ldi	r25, 0x01	; 1
    1d52:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1d56:	10 92 ba 01 	sts	0x01BA, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1d5a:	19 86       	std	Y+9, r1	; 0x09
    1d5c:	18 86       	std	Y+8, r1	; 0x08
    1d5e:	0e c0       	rjmp	.+28     	; 0x1d7c <_Z11ReceiveBonev+0x5ca>
    1d60:	9e 01       	movw	r18, r28
    1d62:	28 59       	subi	r18, 0x98	; 152
    1d64:	3f 4f       	sbci	r19, 0xFF	; 255
    1d66:	88 85       	ldd	r24, Y+8	; 0x08
    1d68:	99 85       	ldd	r25, Y+9	; 0x09
    1d6a:	82 0f       	add	r24, r18
    1d6c:	93 1f       	adc	r25, r19
    1d6e:	fc 01       	movw	r30, r24
    1d70:	10 82       	st	Z, r1
    1d72:	88 85       	ldd	r24, Y+8	; 0x08
    1d74:	99 85       	ldd	r25, Y+9	; 0x09
    1d76:	01 96       	adiw	r24, 0x01	; 1
    1d78:	99 87       	std	Y+9, r25	; 0x09
    1d7a:	88 87       	std	Y+8, r24	; 0x08
    1d7c:	28 85       	ldd	r18, Y+8	; 0x08
    1d7e:	39 85       	ldd	r19, Y+9	; 0x09
    1d80:	41 e0       	ldi	r20, 0x01	; 1
    1d82:	8b 81       	ldd	r24, Y+3	; 0x03
    1d84:	9c 81       	ldd	r25, Y+4	; 0x04
    1d86:	28 17       	cp	r18, r24
    1d88:	39 07       	cpc	r19, r25
    1d8a:	08 f0       	brcs	.+2      	; 0x1d8e <_Z11ReceiveBonev+0x5dc>
    1d8c:	40 e0       	ldi	r20, 0x00	; 0
    1d8e:	44 23       	and	r20, r20
    1d90:	39 f7       	brne	.-50     	; 0x1d60 <_Z11ReceiveBonev+0x5ae>
					state=0;
    1d92:	1a 82       	std	Y+2, r1	; 0x02
    1d94:	19 82       	std	Y+1, r1	; 0x01
					break;
    1d96:	44 c3       	rjmp	.+1672   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
    1d98:	80 e0       	ldi	r24, 0x00	; 0
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	a8 ec       	ldi	r26, 0xC8	; 200
    1d9e:	b2 e4       	ldi	r27, 0x42	; 66
    1da0:	8b af       	sts	0x7b, r24
    1da2:	9c af       	sts	0x7c, r25
    1da4:	ad af       	sts	0x7d, r26
    1da6:	be af       	sts	0x7e, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    1da8:	8e 01       	movw	r16, r28
    1daa:	01 5c       	subi	r16, 0xC1	; 193
    1dac:	1f 4f       	sbci	r17, 0xFF	; 255
    1dae:	6b ad       	sts	0x6b, r22
    1db0:	7c ad       	sts	0x6c, r23
    1db2:	8d ad       	sts	0x6d, r24
    1db4:	9e ad       	sts	0x6e, r25
    1db6:	20 e0       	ldi	r18, 0x00	; 0
    1db8:	30 e0       	ldi	r19, 0x00	; 0
    1dba:	4a e7       	ldi	r20, 0x7A	; 122
    1dbc:	53 e4       	ldi	r21, 0x43	; 67
    1dbe:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    1dc2:	dc 01       	movw	r26, r24
    1dc4:	cb 01       	movw	r24, r22
    1dc6:	f8 01       	movw	r30, r16
    1dc8:	80 83       	st	Z, r24
    1dca:	91 83       	std	Z+1, r25	; 0x01
    1dcc:	a2 83       	std	Z+2, r26	; 0x02
    1dce:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    1dd0:	ce 01       	movw	r24, r28
    1dd2:	cf 96       	adiw	r24, 0x3f	; 63
    1dd4:	11 e0       	ldi	r17, 0x01	; 1
    1dd6:	fc 01       	movw	r30, r24
    1dd8:	60 81       	ld	r22, Z
    1dda:	71 81       	ldd	r23, Z+1	; 0x01
    1ddc:	82 81       	ldd	r24, Z+2	; 0x02
    1dde:	93 81       	ldd	r25, Z+3	; 0x03
    1de0:	20 e0       	ldi	r18, 0x00	; 0
    1de2:	30 e0       	ldi	r19, 0x00	; 0
    1de4:	40 e8       	ldi	r20, 0x80	; 128
    1de6:	5f e3       	ldi	r21, 0x3F	; 63
    1de8:	0e 94 96 21 	call	0x432c	; 0x432c <__cmpsf2>
    1dec:	88 23       	and	r24, r24
    1dee:	0c f0       	brlt	.+2      	; 0x1df2 <_Z11ReceiveBonev+0x640>
    1df0:	10 e0       	ldi	r17, 0x00	; 0
    1df2:	11 23       	and	r17, r17
    1df4:	49 f0       	breq	.+18     	; 0x1e08 <_Z11ReceiveBonev+0x656>
		__ticks = 1;
    1df6:	ce 01       	movw	r24, r28
    1df8:	8d 5b       	subi	r24, 0xBD	; 189
    1dfa:	9f 4f       	sbci	r25, 0xFF	; 255
    1dfc:	21 e0       	ldi	r18, 0x01	; 1
    1dfe:	30 e0       	ldi	r19, 0x00	; 0
    1e00:	fc 01       	movw	r30, r24
    1e02:	31 83       	std	Z+1, r19	; 0x01
    1e04:	20 83       	st	Z, r18
    1e06:	72 c0       	rjmp	.+228    	; 0x1eec <_Z11ReceiveBonev+0x73a>
	else if (__tmp > 65535)
    1e08:	ce 01       	movw	r24, r28
    1e0a:	cf 96       	adiw	r24, 0x3f	; 63
    1e0c:	11 e0       	ldi	r17, 0x01	; 1
    1e0e:	fc 01       	movw	r30, r24
    1e10:	60 81       	ld	r22, Z
    1e12:	71 81       	ldd	r23, Z+1	; 0x01
    1e14:	82 81       	ldd	r24, Z+2	; 0x02
    1e16:	93 81       	ldd	r25, Z+3	; 0x03
    1e18:	20 e0       	ldi	r18, 0x00	; 0
    1e1a:	3f ef       	ldi	r19, 0xFF	; 255
    1e1c:	4f e7       	ldi	r20, 0x7F	; 127
    1e1e:	57 e4       	ldi	r21, 0x47	; 71
    1e20:	0e 94 13 22 	call	0x4426	; 0x4426 <__gesf2>
    1e24:	18 16       	cp	r1, r24
    1e26:	0c f0       	brlt	.+2      	; 0x1e2a <_Z11ReceiveBonev+0x678>
    1e28:	10 e0       	ldi	r17, 0x00	; 0
    1e2a:	11 23       	and	r17, r17
    1e2c:	09 f4       	brne	.+2      	; 0x1e30 <_Z11ReceiveBonev+0x67e>
    1e2e:	4d c0       	rjmp	.+154    	; 0x1eca <_Z11ReceiveBonev+0x718>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e30:	6b ad       	sts	0x6b, r22
    1e32:	7c ad       	sts	0x6c, r23
    1e34:	8d ad       	sts	0x6d, r24
    1e36:	9e ad       	sts	0x6e, r25
    1e38:	20 e0       	ldi	r18, 0x00	; 0
    1e3a:	30 e0       	ldi	r19, 0x00	; 0
    1e3c:	40 e2       	ldi	r20, 0x20	; 32
    1e3e:	51 e4       	ldi	r21, 0x41	; 65
    1e40:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    1e44:	dc 01       	movw	r26, r24
    1e46:	cb 01       	movw	r24, r22
    1e48:	8e 01       	movw	r16, r28
    1e4a:	0d 5b       	subi	r16, 0xBD	; 189
    1e4c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e4e:	bc 01       	movw	r22, r24
    1e50:	cd 01       	movw	r24, r26
    1e52:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    1e56:	dc 01       	movw	r26, r24
    1e58:	cb 01       	movw	r24, r22
    1e5a:	f8 01       	movw	r30, r16
    1e5c:	91 83       	std	Z+1, r25	; 0x01
    1e5e:	80 83       	st	Z, r24
    1e60:	27 c0       	rjmp	.+78     	; 0x1eb0 <_Z11ReceiveBonev+0x6fe>
    1e62:	ce 01       	movw	r24, r28
    1e64:	8b 5b       	subi	r24, 0xBB	; 187
    1e66:	9f 4f       	sbci	r25, 0xFF	; 255
    1e68:	29 e1       	ldi	r18, 0x19	; 25
    1e6a:	30 e0       	ldi	r19, 0x00	; 0
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	31 83       	std	Z+1, r19	; 0x01
    1e70:	20 83       	st	Z, r18
    1e72:	ce 01       	movw	r24, r28
    1e74:	8b 5b       	subi	r24, 0xBB	; 187
    1e76:	9f 4f       	sbci	r25, 0xFF	; 255
    1e78:	fc 01       	movw	r30, r24
    1e7a:	80 81       	ld	r24, Z
    1e7c:	91 81       	ldd	r25, Z+1	; 0x01
    1e7e:	8c 01       	movw	r16, r24
    1e80:	c8 01       	movw	r24, r16
    1e82:	01 97       	sbiw	r24, 0x01	; 1
    1e84:	f1 f7       	brne	.-4      	; 0x1e82 <_Z11ReceiveBonev+0x6d0>
    1e86:	8c 01       	movw	r16, r24
    1e88:	ce 01       	movw	r24, r28
    1e8a:	8b 5b       	subi	r24, 0xBB	; 187
    1e8c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e8e:	fc 01       	movw	r30, r24
    1e90:	11 83       	std	Z+1, r17	; 0x01
    1e92:	00 83       	st	Z, r16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e94:	ce 01       	movw	r24, r28
    1e96:	8d 5b       	subi	r24, 0xBD	; 189
    1e98:	9f 4f       	sbci	r25, 0xFF	; 255
    1e9a:	9e 01       	movw	r18, r28
    1e9c:	2d 5b       	subi	r18, 0xBD	; 189
    1e9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1ea0:	f9 01       	movw	r30, r18
    1ea2:	20 81       	ld	r18, Z
    1ea4:	31 81       	ldd	r19, Z+1	; 0x01
    1ea6:	21 50       	subi	r18, 0x01	; 1
    1ea8:	30 40       	sbci	r19, 0x00	; 0
    1eaa:	fc 01       	movw	r30, r24
    1eac:	31 83       	std	Z+1, r19	; 0x01
    1eae:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1eb0:	ce 01       	movw	r24, r28
    1eb2:	8d 5b       	subi	r24, 0xBD	; 189
    1eb4:	9f 4f       	sbci	r25, 0xFF	; 255
    1eb6:	21 e0       	ldi	r18, 0x01	; 1
    1eb8:	fc 01       	movw	r30, r24
    1eba:	80 81       	ld	r24, Z
    1ebc:	91 81       	ldd	r25, Z+1	; 0x01
    1ebe:	00 97       	sbiw	r24, 0x00	; 0
    1ec0:	09 f4       	brne	.+2      	; 0x1ec4 <_Z11ReceiveBonev+0x712>
    1ec2:	20 e0       	ldi	r18, 0x00	; 0
    1ec4:	22 23       	and	r18, r18
    1ec6:	69 f6       	brne	.-102    	; 0x1e62 <_Z11ReceiveBonev+0x6b0>
    1ec8:	2e c0       	rjmp	.+92     	; 0x1f26 <_Z11ReceiveBonev+0x774>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1eca:	8e 01       	movw	r16, r28
    1ecc:	0d 5b       	subi	r16, 0xBD	; 189
    1ece:	1f 4f       	sbci	r17, 0xFF	; 255
    1ed0:	ce 01       	movw	r24, r28
    1ed2:	cf 96       	adiw	r24, 0x3f	; 63
    1ed4:	fc 01       	movw	r30, r24
    1ed6:	60 81       	ld	r22, Z
    1ed8:	71 81       	ldd	r23, Z+1	; 0x01
    1eda:	82 81       	ldd	r24, Z+2	; 0x02
    1edc:	93 81       	ldd	r25, Z+3	; 0x03
    1ede:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    1ee2:	dc 01       	movw	r26, r24
    1ee4:	cb 01       	movw	r24, r22
    1ee6:	f8 01       	movw	r30, r16
    1ee8:	91 83       	std	Z+1, r25	; 0x01
    1eea:	80 83       	st	Z, r24
    1eec:	ce 01       	movw	r24, r28
    1eee:	89 5b       	subi	r24, 0xB9	; 185
    1ef0:	9f 4f       	sbci	r25, 0xFF	; 255
    1ef2:	9e 01       	movw	r18, r28
    1ef4:	2d 5b       	subi	r18, 0xBD	; 189
    1ef6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef8:	f9 01       	movw	r30, r18
    1efa:	20 81       	ld	r18, Z
    1efc:	31 81       	ldd	r19, Z+1	; 0x01
    1efe:	fc 01       	movw	r30, r24
    1f00:	31 83       	std	Z+1, r19	; 0x01
    1f02:	20 83       	st	Z, r18
    1f04:	ce 01       	movw	r24, r28
    1f06:	89 5b       	subi	r24, 0xB9	; 185
    1f08:	9f 4f       	sbci	r25, 0xFF	; 255
    1f0a:	fc 01       	movw	r30, r24
    1f0c:	80 81       	ld	r24, Z
    1f0e:	91 81       	ldd	r25, Z+1	; 0x01
    1f10:	8c 01       	movw	r16, r24
    1f12:	c8 01       	movw	r24, r16
    1f14:	01 97       	sbiw	r24, 0x01	; 1
    1f16:	f1 f7       	brne	.-4      	; 0x1f14 <_Z11ReceiveBonev+0x762>
    1f18:	8c 01       	movw	r16, r24
    1f1a:	ce 01       	movw	r24, r28
    1f1c:	89 5b       	subi	r24, 0xB9	; 185
    1f1e:	9f 4f       	sbci	r25, 0xFF	; 255
    1f20:	fc 01       	movw	r30, r24
    1f22:	11 83       	std	Z+1, r17	; 0x01
    1f24:	00 83       	st	Z, r16
					}//end case 4
				case 5:{
					//Didn't get a good ack or there was an error.
					_delay_ms(100);
					PrintBone("ACKERROR.");
    1f26:	8e e5       	ldi	r24, 0x5E	; 94
    1f28:	91 e0       	ldi	r25, 0x01	; 1
    1f2a:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1f2e:	10 92 ba 01 	sts	0x01BA, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1f32:	1b 86       	std	Y+11, r1	; 0x0b
    1f34:	1a 86       	std	Y+10, r1	; 0x0a
    1f36:	0e c0       	rjmp	.+28     	; 0x1f54 <_Z11ReceiveBonev+0x7a2>
    1f38:	9e 01       	movw	r18, r28
    1f3a:	28 59       	subi	r18, 0x98	; 152
    1f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f3e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f40:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f42:	82 0f       	add	r24, r18
    1f44:	93 1f       	adc	r25, r19
    1f46:	fc 01       	movw	r30, r24
    1f48:	10 82       	st	Z, r1
    1f4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f4c:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f4e:	01 96       	adiw	r24, 0x01	; 1
    1f50:	9b 87       	std	Y+11, r25	; 0x0b
    1f52:	8a 87       	std	Y+10, r24	; 0x0a
    1f54:	2a 85       	ldd	r18, Y+10	; 0x0a
    1f56:	3b 85       	ldd	r19, Y+11	; 0x0b
    1f58:	41 e0       	ldi	r20, 0x01	; 1
    1f5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f5e:	28 17       	cp	r18, r24
    1f60:	39 07       	cpc	r19, r25
    1f62:	08 f0       	brcs	.+2      	; 0x1f66 <_Z11ReceiveBonev+0x7b4>
    1f64:	40 e0       	ldi	r20, 0x00	; 0
    1f66:	44 23       	and	r20, r20
    1f68:	39 f7       	brne	.-50     	; 0x1f38 <_Z11ReceiveBonev+0x786>
					state=0;
    1f6a:	1a 82       	std	Y+2, r1	; 0x02
    1f6c:	19 82       	std	Y+1, r1	; 0x01
					break;
    1f6e:	58 c2       	rjmp	.+1200   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					}//end case 5
				case 6:{
					//Graceful exit.
					flagReceivingBone=fFalse;
    1f70:	10 92 ba 01 	sts	0x01BA, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1f74:	1d 86       	std	Y+13, r1	; 0x0d
    1f76:	1c 86       	std	Y+12, r1	; 0x0c
    1f78:	0e c0       	rjmp	.+28     	; 0x1f96 <_Z11ReceiveBonev+0x7e4>
    1f7a:	9e 01       	movw	r18, r28
    1f7c:	28 59       	subi	r18, 0x98	; 152
    1f7e:	3f 4f       	sbci	r19, 0xFF	; 255
    1f80:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f82:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f84:	82 0f       	add	r24, r18
    1f86:	93 1f       	adc	r25, r19
    1f88:	fc 01       	movw	r30, r24
    1f8a:	10 82       	st	Z, r1
    1f8c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f8e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1f90:	01 96       	adiw	r24, 0x01	; 1
    1f92:	9d 87       	std	Y+13, r25	; 0x0d
    1f94:	8c 87       	std	Y+12, r24	; 0x0c
    1f96:	2c 85       	ldd	r18, Y+12	; 0x0c
    1f98:	3d 85       	ldd	r19, Y+13	; 0x0d
    1f9a:	41 e0       	ldi	r20, 0x01	; 1
    1f9c:	8b 81       	ldd	r24, Y+3	; 0x03
    1f9e:	9c 81       	ldd	r25, Y+4	; 0x04
    1fa0:	28 17       	cp	r18, r24
    1fa2:	39 07       	cpc	r19, r25
    1fa4:	08 f0       	brcs	.+2      	; 0x1fa8 <_Z11ReceiveBonev+0x7f6>
    1fa6:	40 e0       	ldi	r20, 0x00	; 0
    1fa8:	44 23       	and	r20, r20
    1faa:	39 f7       	brne	.-50     	; 0x1f7a <_Z11ReceiveBonev+0x7c8>
					state=0;
    1fac:	1a 82       	std	Y+2, r1	; 0x02
    1fae:	19 82       	std	Y+1, r1	; 0x01
					break;
    1fb0:	37 c2       	rjmp	.+1134   	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					}//end case 6
				case 7:{
					//Parse the string
					//Go through the string and parse for the time. Must go through the time to get the date.
					BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    1fb2:	1e 86       	std	Y+14, r1	; 0x0e
    1fb4:	1f 86       	std	Y+15, r1	; 0x0f
					int counter=3;
    1fb6:	83 e0       	ldi	r24, 0x03	; 3
    1fb8:	90 e0       	ldi	r25, 0x00	; 0
    1fba:	99 8b       	std	Y+17, r25	; 0x11
    1fbc:	88 8b       	std	Y+16, r24	; 0x10
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    1fbe:	ce 01       	movw	r24, r28
    1fc0:	89 5a       	subi	r24, 0xA9	; 169
    1fc2:	9f 4f       	sbci	r25, 0xFF	; 255
    1fc4:	fc 01       	movw	r30, r24
    1fc6:	11 82       	std	Z+1, r1	; 0x01
    1fc8:	10 82       	st	Z, r1
    1fca:	ce 01       	movw	r24, r28
    1fcc:	89 5a       	subi	r24, 0xA9	; 169
    1fce:	9f 4f       	sbci	r25, 0xFF	; 255
    1fd0:	fc 01       	movw	r30, r24
    1fd2:	13 82       	std	Z+3, r1	; 0x03
    1fd4:	12 82       	std	Z+2, r1	; 0x02
    1fd6:	ce 01       	movw	r24, r28
    1fd8:	89 5a       	subi	r24, 0xA9	; 169
    1fda:	9f 4f       	sbci	r25, 0xFF	; 255
    1fdc:	fc 01       	movw	r30, r24
    1fde:	15 82       	std	Z+5, r1	; 0x05
    1fe0:	14 82       	std	Z+4, r1	; 0x04
    1fe2:	ce 01       	movw	r24, r28
    1fe4:	83 5a       	subi	r24, 0xA3	; 163
    1fe6:	9f 4f       	sbci	r25, 0xFF	; 255
    1fe8:	fc 01       	movw	r30, r24
    1fea:	11 82       	std	Z+1, r1	; 0x01
    1fec:	10 82       	st	Z, r1
    1fee:	ce 01       	movw	r24, r28
    1ff0:	83 5a       	subi	r24, 0xA3	; 163
    1ff2:	9f 4f       	sbci	r25, 0xFF	; 255
    1ff4:	fc 01       	movw	r30, r24
    1ff6:	13 82       	std	Z+3, r1	; 0x03
    1ff8:	12 82       	std	Z+2, r1	; 0x02
    1ffa:	ce 01       	movw	r24, r28
    1ffc:	83 5a       	subi	r24, 0xA3	; 163
    1ffe:	9f 4f       	sbci	r25, 0xFF	; 255
    2000:	fc 01       	movw	r30, r24
    2002:	15 82       	std	Z+5, r1	; 0x05
    2004:	14 82       	std	Z+4, r1	; 0x04
    2006:	1b 8a       	std	Y+19, r1	; 0x13
    2008:	1a 8a       	std	Y+18, r1	; 0x12
    200a:	1d 8a       	std	Y+21, r1	; 0x15
    200c:	1c 8a       	std	Y+20, r1	; 0x14
    200e:	1f 8a       	std	Y+23, r1	; 0x17
    2010:	1e 8a       	std	Y+22, r1	; 0x16
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    2012:	73 c0       	rjmp	.+230    	; 0x20fa <_Z11ReceiveBonev+0x948>
						//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
						if (recString[counter]!=':' && hms<3){
    2014:	9e 01       	movw	r18, r28
    2016:	28 59       	subi	r18, 0x98	; 152
    2018:	3f 4f       	sbci	r19, 0xFF	; 255
    201a:	88 89       	ldd	r24, Y+16	; 0x10
    201c:	99 89       	ldd	r25, Y+17	; 0x11
    201e:	82 0f       	add	r24, r18
    2020:	93 1f       	adc	r25, r19
    2022:	fc 01       	movw	r30, r24
    2024:	80 81       	ld	r24, Z
    2026:	8a 33       	cpi	r24, 0x3A	; 58
    2028:	e9 f0       	breq	.+58     	; 0x2064 <_Z11ReceiveBonev+0x8b2>
    202a:	8c 89       	ldd	r24, Y+20	; 0x14
    202c:	9d 89       	ldd	r25, Y+21	; 0x15
    202e:	83 30       	cpi	r24, 0x03	; 3
    2030:	91 05       	cpc	r25, r1
    2032:	c4 f4       	brge	.+48     	; 0x2064 <_Z11ReceiveBonev+0x8b2>
							tempStringNum[placement++]=recString[counter];
    2034:	9e 01       	movw	r18, r28
    2036:	28 59       	subi	r18, 0x98	; 152
    2038:	3f 4f       	sbci	r19, 0xFF	; 255
    203a:	88 89       	ldd	r24, Y+16	; 0x10
    203c:	99 89       	ldd	r25, Y+17	; 0x11
    203e:	82 0f       	add	r24, r18
    2040:	93 1f       	adc	r25, r19
    2042:	fc 01       	movw	r30, r24
    2044:	40 81       	ld	r20, Z
    2046:	9e 01       	movw	r18, r28
    2048:	2d 59       	subi	r18, 0x9D	; 157
    204a:	3f 4f       	sbci	r19, 0xFF	; 255
    204c:	8e 89       	ldd	r24, Y+22	; 0x16
    204e:	9f 89       	ldd	r25, Y+23	; 0x17
    2050:	82 0f       	add	r24, r18
    2052:	93 1f       	adc	r25, r19
    2054:	fc 01       	movw	r30, r24
    2056:	40 83       	st	Z, r20
    2058:	8e 89       	ldd	r24, Y+22	; 0x16
    205a:	9f 89       	ldd	r25, Y+23	; 0x17
    205c:	01 96       	adiw	r24, 0x01	; 1
    205e:	9f 8b       	std	Y+23, r25	; 0x17
    2060:	8e 8b       	std	Y+22, r24	; 0x16
    2062:	46 c0       	rjmp	.+140    	; 0x20f0 <_Z11ReceiveBonev+0x93e>
						//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
						} else if (hms<2 && recString[counter] == ':') {
    2064:	8c 89       	ldd	r24, Y+20	; 0x14
    2066:	9d 89       	ldd	r25, Y+21	; 0x15
    2068:	82 30       	cpi	r24, 0x02	; 2
    206a:	91 05       	cpc	r25, r1
    206c:	0c f0       	brlt	.+2      	; 0x2070 <_Z11ReceiveBonev+0x8be>
    206e:	40 c0       	rjmp	.+128    	; 0x20f0 <_Z11ReceiveBonev+0x93e>
    2070:	9e 01       	movw	r18, r28
    2072:	28 59       	subi	r18, 0x98	; 152
    2074:	3f 4f       	sbci	r19, 0xFF	; 255
    2076:	88 89       	ldd	r24, Y+16	; 0x10
    2078:	99 89       	ldd	r25, Y+17	; 0x11
    207a:	82 0f       	add	r24, r18
    207c:	93 1f       	adc	r25, r19
    207e:	fc 01       	movw	r30, r24
    2080:	80 81       	ld	r24, Z
    2082:	8a 33       	cpi	r24, 0x3A	; 58
    2084:	a9 f5       	brne	.+106    	; 0x20f0 <_Z11ReceiveBonev+0x93e>
							tempNum[hms++] = atoi(tempStringNum);
    2086:	ce 01       	movw	r24, r28
    2088:	8d 59       	subi	r24, 0x9D	; 157
    208a:	9f 4f       	sbci	r25, 0xFF	; 255
    208c:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
    2090:	9c 01       	movw	r18, r24
    2092:	ae 01       	movw	r20, r28
    2094:	49 5a       	subi	r20, 0xA9	; 169
    2096:	5f 4f       	sbci	r21, 0xFF	; 255
    2098:	8c 89       	ldd	r24, Y+20	; 0x14
    209a:	9d 89       	ldd	r25, Y+21	; 0x15
    209c:	88 0f       	add	r24, r24
    209e:	99 1f       	adc	r25, r25
    20a0:	84 0f       	add	r24, r20
    20a2:	95 1f       	adc	r25, r21
    20a4:	fc 01       	movw	r30, r24
    20a6:	31 83       	std	Z+1, r19	; 0x01
    20a8:	20 83       	st	Z, r18
    20aa:	8c 89       	ldd	r24, Y+20	; 0x14
    20ac:	9d 89       	ldd	r25, Y+21	; 0x15
    20ae:	01 96       	adiw	r24, 0x01	; 1
    20b0:	9d 8b       	std	Y+21, r25	; 0x15
    20b2:	8c 8b       	std	Y+20, r24	; 0x14
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    20b4:	19 8e       	std	Y+25, r1	; 0x19
    20b6:	18 8e       	std	Y+24, r1	; 0x18
    20b8:	0e c0       	rjmp	.+28     	; 0x20d6 <_Z11ReceiveBonev+0x924>
    20ba:	9e 01       	movw	r18, r28
    20bc:	2d 59       	subi	r18, 0x9D	; 157
    20be:	3f 4f       	sbci	r19, 0xFF	; 255
    20c0:	88 8d       	ldd	r24, Y+24	; 0x18
    20c2:	99 8d       	ldd	r25, Y+25	; 0x19
    20c4:	82 0f       	add	r24, r18
    20c6:	93 1f       	adc	r25, r19
    20c8:	fc 01       	movw	r30, r24
    20ca:	10 82       	st	Z, r1
    20cc:	88 8d       	ldd	r24, Y+24	; 0x18
    20ce:	99 8d       	ldd	r25, Y+25	; 0x19
    20d0:	01 96       	adiw	r24, 0x01	; 1
    20d2:	99 8f       	std	Y+25, r25	; 0x19
    20d4:	88 8f       	std	Y+24, r24	; 0x18
    20d6:	41 e0       	ldi	r20, 0x01	; 1
    20d8:	28 8d       	ldd	r18, Y+24	; 0x18
    20da:	39 8d       	ldd	r19, Y+25	; 0x19
    20dc:	8e 89       	ldd	r24, Y+22	; 0x16
    20de:	9f 89       	ldd	r25, Y+23	; 0x17
    20e0:	82 17       	cp	r24, r18
    20e2:	93 07       	cpc	r25, r19
    20e4:	0c f4       	brge	.+2      	; 0x20e8 <_Z11ReceiveBonev+0x936>
    20e6:	40 e0       	ldi	r20, 0x00	; 0
    20e8:	44 23       	and	r20, r20
    20ea:	39 f7       	brne	.-50     	; 0x20ba <_Z11ReceiveBonev+0x908>
							placement=0;												//reset placement
    20ec:	1f 8a       	std	Y+23, r1	; 0x17
    20ee:	1e 8a       	std	Y+22, r1	; 0x16
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
    20f0:	88 89       	ldd	r24, Y+16	; 0x10
    20f2:	99 89       	ldd	r25, Y+17	; 0x11
    20f4:	01 96       	adiw	r24, 0x01	; 1
    20f6:	99 8b       	std	Y+17, r25	; 0x11
    20f8:	88 8b       	std	Y+16, r24	; 0x10
					int counter=3;
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    20fa:	9e 01       	movw	r18, r28
    20fc:	28 59       	subi	r18, 0x98	; 152
    20fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2100:	88 89       	ldd	r24, Y+16	; 0x10
    2102:	99 89       	ldd	r25, Y+17	; 0x11
    2104:	82 0f       	add	r24, r18
    2106:	93 1f       	adc	r25, r19
    2108:	fc 01       	movw	r30, r24
    210a:	80 81       	ld	r24, Z
    210c:	8f 32       	cpi	r24, 0x2F	; 47
    210e:	69 f0       	breq	.+26     	; 0x212a <_Z11ReceiveBonev+0x978>
    2110:	9e 01       	movw	r18, r28
    2112:	28 59       	subi	r18, 0x98	; 152
    2114:	3f 4f       	sbci	r19, 0xFF	; 255
    2116:	88 89       	ldd	r24, Y+16	; 0x10
    2118:	99 89       	ldd	r25, Y+17	; 0x11
    211a:	82 0f       	add	r24, r18
    211c:	93 1f       	adc	r25, r19
    211e:	fc 01       	movw	r30, r24
    2120:	80 81       	ld	r24, Z
    2122:	88 23       	and	r24, r24
    2124:	11 f0       	breq	.+4      	; 0x212a <_Z11ReceiveBonev+0x978>
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	01 c0       	rjmp	.+2      	; 0x212c <_Z11ReceiveBonev+0x97a>
    212a:	80 e0       	ldi	r24, 0x00	; 0
    212c:	88 23       	and	r24, r24
    212e:	09 f0       	breq	.+2      	; 0x2132 <_Z11ReceiveBonev+0x980>
    2130:	71 cf       	rjmp	.-286    	; 0x2014 <_Z11ReceiveBonev+0x862>
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
					}//end while
					//Found a '/', assign tempNum otherwise exit with ACKBAD
					if (recString[counter] == '/'){
    2132:	9e 01       	movw	r18, r28
    2134:	28 59       	subi	r18, 0x98	; 152
    2136:	3f 4f       	sbci	r19, 0xFF	; 255
    2138:	88 89       	ldd	r24, Y+16	; 0x10
    213a:	99 89       	ldd	r25, Y+17	; 0x11
    213c:	82 0f       	add	r24, r18
    213e:	93 1f       	adc	r25, r19
    2140:	fc 01       	movw	r30, r24
    2142:	80 81       	ld	r24, Z
    2144:	8f 32       	cpi	r24, 0x2F	; 47
    2146:	a9 f4       	brne	.+42     	; 0x2172 <_Z11ReceiveBonev+0x9c0>
						tempNum[hms] = atoi(tempStringNum);
    2148:	ce 01       	movw	r24, r28
    214a:	8d 59       	subi	r24, 0x9D	; 157
    214c:	9f 4f       	sbci	r25, 0xFF	; 255
    214e:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
    2152:	9c 01       	movw	r18, r24
    2154:	ae 01       	movw	r20, r28
    2156:	49 5a       	subi	r20, 0xA9	; 169
    2158:	5f 4f       	sbci	r21, 0xFF	; 255
    215a:	8c 89       	ldd	r24, Y+20	; 0x14
    215c:	9d 89       	ldd	r25, Y+21	; 0x15
    215e:	88 0f       	add	r24, r24
    2160:	99 1f       	adc	r25, r25
    2162:	84 0f       	add	r24, r20
    2164:	95 1f       	adc	r25, r21
    2166:	fc 01       	movw	r30, r24
    2168:	31 83       	std	Z+1, r19	; 0x01
    216a:	20 83       	st	Z, r18
						successTime=fTrue;
    216c:	81 e0       	ldi	r24, 0x01	; 1
    216e:	8e 87       	std	Y+14, r24	; 0x0e
    2170:	04 c0       	rjmp	.+8      	; 0x217a <_Z11ReceiveBonev+0x9c8>
					} else {
						state=4;
    2172:	84 e0       	ldi	r24, 0x04	; 4
    2174:	90 e0       	ldi	r25, 0x00	; 0
    2176:	9a 83       	std	Y+2, r25	; 0x02
    2178:	89 83       	std	Y+1, r24	; 0x01
					}
					
					//If flag for Date is set, then parse the string and do something with it.
					//Now get the date. have to null the tempStringNum
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    217a:	1b 8e       	std	Y+27, r1	; 0x1b
    217c:	1a 8e       	std	Y+26, r1	; 0x1a
    217e:	0e c0       	rjmp	.+28     	; 0x219c <_Z11ReceiveBonev+0x9ea>
    2180:	9e 01       	movw	r18, r28
    2182:	2d 59       	subi	r18, 0x9D	; 157
    2184:	3f 4f       	sbci	r19, 0xFF	; 255
    2186:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2188:	9b 8d       	ldd	r25, Y+27	; 0x1b
    218a:	82 0f       	add	r24, r18
    218c:	93 1f       	adc	r25, r19
    218e:	fc 01       	movw	r30, r24
    2190:	10 82       	st	Z, r1
    2192:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2194:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2196:	01 96       	adiw	r24, 0x01	; 1
    2198:	9b 8f       	std	Y+27, r25	; 0x1b
    219a:	8a 8f       	std	Y+26, r24	; 0x1a
    219c:	41 e0       	ldi	r20, 0x01	; 1
    219e:	2a 8d       	ldd	r18, Y+26	; 0x1a
    21a0:	3b 8d       	ldd	r19, Y+27	; 0x1b
    21a2:	8e 89       	ldd	r24, Y+22	; 0x16
    21a4:	9f 89       	ldd	r25, Y+23	; 0x17
    21a6:	82 17       	cp	r24, r18
    21a8:	93 07       	cpc	r25, r19
    21aa:	0c f4       	brge	.+2      	; 0x21ae <_Z11ReceiveBonev+0x9fc>
    21ac:	40 e0       	ldi	r20, 0x00	; 0
    21ae:	44 23       	and	r20, r20
    21b0:	39 f7       	brne	.-50     	; 0x2180 <_Z11ReceiveBonev+0x9ce>
					placement=0;
    21b2:	1f 8a       	std	Y+23, r1	; 0x17
    21b4:	1e 8a       	std	Y+22, r1	; 0x16
					counter++;	//get past the '/'
    21b6:	88 89       	ldd	r24, Y+16	; 0x10
    21b8:	99 89       	ldd	r25, Y+17	; 0x11
    21ba:	01 96       	adiw	r24, 0x01	; 1
    21bc:	99 8b       	std	Y+17, r25	; 0x11
    21be:	88 8b       	std	Y+16, r24	; 0x10
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    21c0:	73 c0       	rjmp	.+230    	; 0x22a8 <_Z11ReceiveBonev+0xaf6>
						//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
						if  (recString[counter] != ',' && dmy < 3){
    21c2:	9e 01       	movw	r18, r28
    21c4:	28 59       	subi	r18, 0x98	; 152
    21c6:	3f 4f       	sbci	r19, 0xFF	; 255
    21c8:	88 89       	ldd	r24, Y+16	; 0x10
    21ca:	99 89       	ldd	r25, Y+17	; 0x11
    21cc:	82 0f       	add	r24, r18
    21ce:	93 1f       	adc	r25, r19
    21d0:	fc 01       	movw	r30, r24
    21d2:	80 81       	ld	r24, Z
    21d4:	8c 32       	cpi	r24, 0x2C	; 44
    21d6:	e9 f0       	breq	.+58     	; 0x2212 <_Z11ReceiveBonev+0xa60>
    21d8:	8a 89       	ldd	r24, Y+18	; 0x12
    21da:	9b 89       	ldd	r25, Y+19	; 0x13
    21dc:	83 30       	cpi	r24, 0x03	; 3
    21de:	91 05       	cpc	r25, r1
    21e0:	c4 f4       	brge	.+48     	; 0x2212 <_Z11ReceiveBonev+0xa60>
							tempStringNum[placement++]=recString[counter];
    21e2:	9e 01       	movw	r18, r28
    21e4:	28 59       	subi	r18, 0x98	; 152
    21e6:	3f 4f       	sbci	r19, 0xFF	; 255
    21e8:	88 89       	ldd	r24, Y+16	; 0x10
    21ea:	99 89       	ldd	r25, Y+17	; 0x11
    21ec:	82 0f       	add	r24, r18
    21ee:	93 1f       	adc	r25, r19
    21f0:	fc 01       	movw	r30, r24
    21f2:	40 81       	ld	r20, Z
    21f4:	9e 01       	movw	r18, r28
    21f6:	2d 59       	subi	r18, 0x9D	; 157
    21f8:	3f 4f       	sbci	r19, 0xFF	; 255
    21fa:	8e 89       	ldd	r24, Y+22	; 0x16
    21fc:	9f 89       	ldd	r25, Y+23	; 0x17
    21fe:	82 0f       	add	r24, r18
    2200:	93 1f       	adc	r25, r19
    2202:	fc 01       	movw	r30, r24
    2204:	40 83       	st	Z, r20
    2206:	8e 89       	ldd	r24, Y+22	; 0x16
    2208:	9f 89       	ldd	r25, Y+23	; 0x17
    220a:	01 96       	adiw	r24, 0x01	; 1
    220c:	9f 8b       	std	Y+23, r25	; 0x17
    220e:	8e 8b       	std	Y+22, r24	; 0x16
    2210:	46 c0       	rjmp	.+140    	; 0x229e <_Z11ReceiveBonev+0xaec>
						//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
						} else if (dmy<2 && recString[counter]==','){
    2212:	8a 89       	ldd	r24, Y+18	; 0x12
    2214:	9b 89       	ldd	r25, Y+19	; 0x13
    2216:	82 30       	cpi	r24, 0x02	; 2
    2218:	91 05       	cpc	r25, r1
    221a:	0c f0       	brlt	.+2      	; 0x221e <_Z11ReceiveBonev+0xa6c>
    221c:	40 c0       	rjmp	.+128    	; 0x229e <_Z11ReceiveBonev+0xaec>
    221e:	9e 01       	movw	r18, r28
    2220:	28 59       	subi	r18, 0x98	; 152
    2222:	3f 4f       	sbci	r19, 0xFF	; 255
    2224:	88 89       	ldd	r24, Y+16	; 0x10
    2226:	99 89       	ldd	r25, Y+17	; 0x11
    2228:	82 0f       	add	r24, r18
    222a:	93 1f       	adc	r25, r19
    222c:	fc 01       	movw	r30, r24
    222e:	80 81       	ld	r24, Z
    2230:	8c 32       	cpi	r24, 0x2C	; 44
    2232:	a9 f5       	brne	.+106    	; 0x229e <_Z11ReceiveBonev+0xaec>
							tempNum1[dmy++] = atoi(tempStringNum);
    2234:	ce 01       	movw	r24, r28
    2236:	8d 59       	subi	r24, 0x9D	; 157
    2238:	9f 4f       	sbci	r25, 0xFF	; 255
    223a:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
    223e:	9c 01       	movw	r18, r24
    2240:	ae 01       	movw	r20, r28
    2242:	43 5a       	subi	r20, 0xA3	; 163
    2244:	5f 4f       	sbci	r21, 0xFF	; 255
    2246:	8a 89       	ldd	r24, Y+18	; 0x12
    2248:	9b 89       	ldd	r25, Y+19	; 0x13
    224a:	88 0f       	add	r24, r24
    224c:	99 1f       	adc	r25, r25
    224e:	84 0f       	add	r24, r20
    2250:	95 1f       	adc	r25, r21
    2252:	fc 01       	movw	r30, r24
    2254:	31 83       	std	Z+1, r19	; 0x01
    2256:	20 83       	st	Z, r18
    2258:	8a 89       	ldd	r24, Y+18	; 0x12
    225a:	9b 89       	ldd	r25, Y+19	; 0x13
    225c:	01 96       	adiw	r24, 0x01	; 1
    225e:	9b 8b       	std	Y+19, r25	; 0x13
    2260:	8a 8b       	std	Y+18, r24	; 0x12
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    2262:	1d 8e       	std	Y+29, r1	; 0x1d
    2264:	1c 8e       	std	Y+28, r1	; 0x1c
    2266:	0e c0       	rjmp	.+28     	; 0x2284 <_Z11ReceiveBonev+0xad2>
    2268:	9e 01       	movw	r18, r28
    226a:	2d 59       	subi	r18, 0x9D	; 157
    226c:	3f 4f       	sbci	r19, 0xFF	; 255
    226e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    2270:	9d 8d       	ldd	r25, Y+29	; 0x1d
    2272:	82 0f       	add	r24, r18
    2274:	93 1f       	adc	r25, r19
    2276:	fc 01       	movw	r30, r24
    2278:	10 82       	st	Z, r1
    227a:	8c 8d       	ldd	r24, Y+28	; 0x1c
    227c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    227e:	01 96       	adiw	r24, 0x01	; 1
    2280:	9d 8f       	std	Y+29, r25	; 0x1d
    2282:	8c 8f       	std	Y+28, r24	; 0x1c
    2284:	41 e0       	ldi	r20, 0x01	; 1
    2286:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2288:	3d 8d       	ldd	r19, Y+29	; 0x1d
    228a:	8e 89       	ldd	r24, Y+22	; 0x16
    228c:	9f 89       	ldd	r25, Y+23	; 0x17
    228e:	82 17       	cp	r24, r18
    2290:	93 07       	cpc	r25, r19
    2292:	0c f4       	brge	.+2      	; 0x2296 <_Z11ReceiveBonev+0xae4>
    2294:	40 e0       	ldi	r20, 0x00	; 0
    2296:	44 23       	and	r20, r20
    2298:	39 f7       	brne	.-50     	; 0x2268 <_Z11ReceiveBonev+0xab6>
							placement=0;
    229a:	1f 8a       	std	Y+23, r1	; 0x17
    229c:	1e 8a       	std	Y+22, r1	; 0x16
						} else;
						counter++;							
    229e:	88 89       	ldd	r24, Y+16	; 0x10
    22a0:	99 89       	ldd	r25, Y+17	; 0x11
    22a2:	01 96       	adiw	r24, 0x01	; 1
    22a4:	99 8b       	std	Y+17, r25	; 0x11
    22a6:	88 8b       	std	Y+16, r24	; 0x10
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
					placement=0;
					counter++;	//get past the '/'
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    22a8:	9e 01       	movw	r18, r28
    22aa:	28 59       	subi	r18, 0x98	; 152
    22ac:	3f 4f       	sbci	r19, 0xFF	; 255
    22ae:	88 89       	ldd	r24, Y+16	; 0x10
    22b0:	99 89       	ldd	r25, Y+17	; 0x11
    22b2:	82 0f       	add	r24, r18
    22b4:	93 1f       	adc	r25, r19
    22b6:	fc 01       	movw	r30, r24
    22b8:	80 81       	ld	r24, Z
    22ba:	8e 32       	cpi	r24, 0x2E	; 46
    22bc:	a1 f0       	breq	.+40     	; 0x22e6 <_Z11ReceiveBonev+0xb34>
    22be:	9e 01       	movw	r18, r28
    22c0:	28 59       	subi	r18, 0x98	; 152
    22c2:	3f 4f       	sbci	r19, 0xFF	; 255
    22c4:	88 89       	ldd	r24, Y+16	; 0x10
    22c6:	99 89       	ldd	r25, Y+17	; 0x11
    22c8:	82 0f       	add	r24, r18
    22ca:	93 1f       	adc	r25, r19
    22cc:	fc 01       	movw	r30, r24
    22ce:	80 81       	ld	r24, Z
    22d0:	88 23       	and	r24, r24
    22d2:	49 f0       	breq	.+18     	; 0x22e6 <_Z11ReceiveBonev+0xb34>
    22d4:	28 89       	ldd	r18, Y+16	; 0x10
    22d6:	39 89       	ldd	r19, Y+17	; 0x11
    22d8:	8b 81       	ldd	r24, Y+3	; 0x03
    22da:	9c 81       	ldd	r25, Y+4	; 0x04
    22dc:	28 17       	cp	r18, r24
    22de:	39 07       	cpc	r19, r25
    22e0:	11 f0       	breq	.+4      	; 0x22e6 <_Z11ReceiveBonev+0xb34>
    22e2:	81 e0       	ldi	r24, 0x01	; 1
    22e4:	01 c0       	rjmp	.+2      	; 0x22e8 <_Z11ReceiveBonev+0xb36>
    22e6:	80 e0       	ldi	r24, 0x00	; 0
    22e8:	88 23       	and	r24, r24
    22ea:	09 f0       	breq	.+2      	; 0x22ee <_Z11ReceiveBonev+0xb3c>
    22ec:	6a cf       	rjmp	.-300    	; 0x21c2 <_Z11ReceiveBonev+0xa10>
						} else;
						counter++;							
					}//end while
					
					//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
					if (recString[counter] == '.'){
    22ee:	9e 01       	movw	r18, r28
    22f0:	28 59       	subi	r18, 0x98	; 152
    22f2:	3f 4f       	sbci	r19, 0xFF	; 255
    22f4:	88 89       	ldd	r24, Y+16	; 0x10
    22f6:	99 89       	ldd	r25, Y+17	; 0x11
    22f8:	82 0f       	add	r24, r18
    22fa:	93 1f       	adc	r25, r19
    22fc:	fc 01       	movw	r30, r24
    22fe:	80 81       	ld	r24, Z
    2300:	8e 32       	cpi	r24, 0x2E	; 46
    2302:	a9 f4       	brne	.+42     	; 0x232e <_Z11ReceiveBonev+0xb7c>
						tempNum1[dmy] = atoi(tempStringNum);
    2304:	ce 01       	movw	r24, r28
    2306:	8d 59       	subi	r24, 0x9D	; 157
    2308:	9f 4f       	sbci	r25, 0xFF	; 255
    230a:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
    230e:	9c 01       	movw	r18, r24
    2310:	ae 01       	movw	r20, r28
    2312:	43 5a       	subi	r20, 0xA3	; 163
    2314:	5f 4f       	sbci	r21, 0xFF	; 255
    2316:	8a 89       	ldd	r24, Y+18	; 0x12
    2318:	9b 89       	ldd	r25, Y+19	; 0x13
    231a:	88 0f       	add	r24, r24
    231c:	99 1f       	adc	r25, r25
    231e:	84 0f       	add	r24, r20
    2320:	95 1f       	adc	r25, r21
    2322:	fc 01       	movw	r30, r24
    2324:	31 83       	std	Z+1, r19	; 0x01
    2326:	20 83       	st	Z, r18
						successDate=fTrue;
    2328:	81 e0       	ldi	r24, 0x01	; 1
    232a:	8f 87       	std	Y+15, r24	; 0x0f
    232c:	04 c0       	rjmp	.+8      	; 0x2336 <_Z11ReceiveBonev+0xb84>
					} else {//something in the string was wrong, ACKBAD and then exit
						state=4;
    232e:	84 e0       	ldi	r24, 0x04	; 4
    2330:	90 e0       	ldi	r25, 0x00	; 0
    2332:	9a 83       	std	Y+2, r25	; 0x02
    2334:	89 83       	std	Y+1, r24	; 0x01
					}	
					
					//NOw set the time and date, then save it to EEPROM
					if (successDate && successTime){
    2336:	8f 85       	ldd	r24, Y+15	; 0x0f
    2338:	88 23       	and	r24, r24
    233a:	e9 f1       	breq	.+122    	; 0x23b6 <_Z11ReceiveBonev+0xc04>
    233c:	8e 85       	ldd	r24, Y+14	; 0x0e
    233e:	88 23       	and	r24, r24
    2340:	d1 f1       	breq	.+116    	; 0x23b6 <_Z11ReceiveBonev+0xc04>
						currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    2342:	ce 01       	movw	r24, r28
    2344:	83 5a       	subi	r24, 0xA3	; 163
    2346:	9f 4f       	sbci	r25, 0xFF	; 255
    2348:	fc 01       	movw	r30, r24
    234a:	60 81       	ld	r22, Z
    234c:	71 81       	ldd	r23, Z+1	; 0x01
    234e:	ce 01       	movw	r24, r28
    2350:	83 5a       	subi	r24, 0xA3	; 163
    2352:	9f 4f       	sbci	r25, 0xFF	; 255
    2354:	fc 01       	movw	r30, r24
    2356:	42 81       	ldd	r20, Z+2	; 0x02
    2358:	53 81       	ldd	r21, Z+3	; 0x03
    235a:	ce 01       	movw	r24, r28
    235c:	83 5a       	subi	r24, 0xA3	; 163
    235e:	9f 4f       	sbci	r25, 0xFF	; 255
    2360:	fc 01       	movw	r30, r24
    2362:	24 81       	ldd	r18, Z+4	; 0x04
    2364:	35 81       	ldd	r19, Z+5	; 0x05
    2366:	82 e9       	ldi	r24, 0x92	; 146
    2368:	91 e0       	ldi	r25, 0x01	; 1
    236a:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
						currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    236e:	ce 01       	movw	r24, r28
    2370:	89 5a       	subi	r24, 0xA9	; 169
    2372:	9f 4f       	sbci	r25, 0xFF	; 255
    2374:	fc 01       	movw	r30, r24
    2376:	60 81       	ld	r22, Z
    2378:	71 81       	ldd	r23, Z+1	; 0x01
    237a:	ce 01       	movw	r24, r28
    237c:	89 5a       	subi	r24, 0xA9	; 169
    237e:	9f 4f       	sbci	r25, 0xFF	; 255
    2380:	fc 01       	movw	r30, r24
    2382:	42 81       	ldd	r20, Z+2	; 0x02
    2384:	53 81       	ldd	r21, Z+3	; 0x03
    2386:	ce 01       	movw	r24, r28
    2388:	89 5a       	subi	r24, 0xA9	; 169
    238a:	9f 4f       	sbci	r25, 0xFF	; 255
    238c:	fc 01       	movw	r30, r24
    238e:	24 81       	ldd	r18, Z+4	; 0x04
    2390:	35 81       	ldd	r19, Z+5	; 0x05
    2392:	82 e9       	ldi	r24, 0x92	; 146
    2394:	91 e0       	ldi	r25, 0x01	; 1
    2396:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
						saveDateTime_eeprom(fTrue,fTrue);
    239a:	81 e0       	ldi	r24, 0x01	; 1
    239c:	61 e0       	ldi	r22, 0x01	; 1
    239e:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    23a2:	81 e0       	ldi	r24, 0x01	; 1
    23a4:	80 93 c0 01 	sts	0x01C0, r24
						//Make sure UserCLock flags are down
						flagUserClock=fFalse;
    23a8:	10 92 c2 01 	sts	0x01C2, r1
						state=3;	//Graceful exit
    23ac:	83 e0       	ldi	r24, 0x03	; 3
    23ae:	90 e0       	ldi	r25, 0x00	; 0
    23b0:	9a 83       	std	Y+2, r25	; 0x02
    23b2:	89 83       	std	Y+1, r24	; 0x01
    23b4:	2b c0       	rjmp	.+86     	; 0x240c <_Z11ReceiveBonev+0xc5a>
					} else if (!(successDate && successTime) && restart){
    23b6:	8f 85       	ldd	r24, Y+15	; 0x0f
    23b8:	88 23       	and	r24, r24
    23ba:	19 f0       	breq	.+6      	; 0x23c2 <_Z11ReceiveBonev+0xc10>
    23bc:	8e 85       	ldd	r24, Y+14	; 0x0e
    23be:	88 23       	and	r24, r24
    23c0:	71 f4       	brne	.+28     	; 0x23de <_Z11ReceiveBonev+0xc2c>
    23c2:	80 91 ca 01 	lds	r24, 0x01CA
    23c6:	88 23       	and	r24, r24
    23c8:	51 f0       	breq	.+20     	; 0x23de <_Z11ReceiveBonev+0xc2c>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    23ca:	81 e0       	ldi	r24, 0x01	; 1
    23cc:	80 93 c0 01 	sts	0x01C0, r24
						flagUserClock=fFalse;
    23d0:	10 92 c2 01 	sts	0x01C2, r1
						state=4;	//ACKBAD
    23d4:	84 e0       	ldi	r24, 0x04	; 4
    23d6:	90 e0       	ldi	r25, 0x00	; 0
    23d8:	9a 83       	std	Y+2, r25	; 0x02
    23da:	89 83       	std	Y+1, r24	; 0x01
    23dc:	17 c0       	rjmp	.+46     	; 0x240c <_Z11ReceiveBonev+0xc5a>
					} else if (!(successDate && successTime) && flagFreshStart && !restart){
    23de:	8f 85       	ldd	r24, Y+15	; 0x0f
    23e0:	88 23       	and	r24, r24
    23e2:	19 f0       	breq	.+6      	; 0x23ea <_Z11ReceiveBonev+0xc38>
    23e4:	8e 85       	ldd	r24, Y+14	; 0x0e
    23e6:	88 23       	and	r24, r24
    23e8:	89 f4       	brne	.+34     	; 0x240c <_Z11ReceiveBonev+0xc5a>
    23ea:	80 91 cb 01 	lds	r24, 0x01CB
    23ee:	88 23       	and	r24, r24
    23f0:	69 f0       	breq	.+26     	; 0x240c <_Z11ReceiveBonev+0xc5a>
    23f2:	80 91 ca 01 	lds	r24, 0x01CA
    23f6:	88 23       	and	r24, r24
    23f8:	49 f4       	brne	.+18     	; 0x240c <_Z11ReceiveBonev+0xc5a>
						flagUserClock=fTrue;
    23fa:	81 e0       	ldi	r24, 0x01	; 1
    23fc:	80 93 c2 01 	sts	0x01C2, r24
						flagUpdateGAVRClock=fFalse;
    2400:	10 92 c0 01 	sts	0x01C0, r1
						state=4;	//ACKBAD
    2404:	84 e0       	ldi	r24, 0x04	; 4
    2406:	90 e0       	ldi	r25, 0x00	; 0
    2408:	9a 83       	std	Y+2, r25	; 0x02
    240a:	89 83       	std	Y+1, r24	; 0x01
					} else;		
					
					//Lower restart flags. Should have parallel case in timer just in case this state doesn't happen.
					flagFreshStart=fFalse;
    240c:	10 92 cb 01 	sts	0x01CB, r1
					restart=fFalse;		
    2410:	10 92 ca 01 	sts	0x01CA, r1
					break;
    2414:	05 c0       	rjmp	.+10     	; 0x2420 <_Z11ReceiveBonev+0xc6e>
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
    2416:	10 92 ba 01 	sts	0x01BA, r1
    241a:	1a 82       	std	Y+2, r1	; 0x02
    241c:	19 82       	std	Y+1, r1	; 0x01
    241e:	00 00       	nop
	unsigned int state=0;
	char recChar, recString[40];
	unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	while (flagReceivingBone){
    2420:	90 91 ba 01 	lds	r25, 0x01BA
    2424:	81 e0       	ldi	r24, 0x01	; 1
    2426:	99 23       	and	r25, r25
    2428:	09 f4       	brne	.+2      	; 0x242c <_Z11ReceiveBonev+0xc7a>
    242a:	80 e0       	ldi	r24, 0x00	; 0
    242c:	88 23       	and	r24, r24
    242e:	09 f0       	breq	.+2      	; 0x2432 <_Z11ReceiveBonev+0xc80>
    2430:	d4 c9       	rjmp	.-3160   	; 0x17da <_Z11ReceiveBonev+0x28>
					break;
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
			}//end switch
	}//end while(flagUARTbone)	
}//end ReceiveBone()
    2432:	c1 57       	subi	r28, 0x71	; 113
    2434:	df 4f       	sbci	r29, 0xFF	; 255
    2436:	0f b6       	in	r0, 0x3f	; 63
    2438:	f8 94       	cli
    243a:	de bf       	out	0x3e, r29	; 62
    243c:	0f be       	out	0x3f, r0	; 63
    243e:	cd bf       	out	0x3d, r28	; 61
    2440:	df 91       	pop	r29
    2442:	cf 91       	pop	r28
    2444:	1f 91       	pop	r17
    2446:	0f 91       	pop	r16
    2448:	08 95       	ret

0000244a <_Z11ReceiveGAVRv>:

/*************************************************************************************************************/
void ReceiveGAVR(){
    244a:	0f 93       	push	r16
    244c:	1f 93       	push	r17
    244e:	cf 93       	push	r28
    2450:	df 93       	push	r29
    2452:	cd b7       	in	r28, 0x3d	; 61
    2454:	de b7       	in	r29, 0x3e	; 62
    2456:	c9 58       	subi	r28, 0x89	; 137
    2458:	d0 40       	sbci	r29, 0x00	; 0
    245a:	0f b6       	in	r0, 0x3f	; 63
    245c:	f8 94       	cli
    245e:	de bf       	out	0x3e, r29	; 62
    2460:	0f be       	out	0x3f, r0	; 63
    2462:	cd bf       	out	0x3d, r28	; 61
	unsigned int state=0;
    2464:	1a 82       	std	Y+2, r1	; 0x02
    2466:	19 82       	std	Y+1, r1	; 0x01
	char recChar, recString[40];
	unsigned int strLoc=0;
    2468:	1c 82       	std	Y+4, r1	; 0x04
    246a:	1b 82       	std	Y+3, r1	; 0x03
	BOOL noCarriage=fTrue;
    246c:	81 e0       	ldi	r24, 0x01	; 1
    246e:	8d 83       	std	Y+5, r24	; 0x05
	
	//While Loop
	while (flagReceivingGAVR){
    2470:	20 c6       	rjmp	.+3136   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
			/** State 5: Exit case. Lower "flagReceivingGAVR" which causes and exit.													   **/
			/** State 6: ACKERROR state. Send "ACKERROR", then exit through state 5.													   **/
			/** State 7: Successful acquire of time/date.																				   **/
			/** Default: Set state to 0, doesn't really matter though. Exit signalling timeout to sender.								   **/
			/********************************************************************************************************************************/			
			switch(state){
    2472:	89 81       	ldd	r24, Y+1	; 0x01
    2474:	9a 81       	ldd	r25, Y+2	; 0x02
    2476:	83 30       	cpi	r24, 0x03	; 3
    2478:	91 05       	cpc	r25, r1
    247a:	09 f4       	brne	.+2      	; 0x247e <_Z11ReceiveGAVRv+0x34>
    247c:	4a c1       	rjmp	.+660    	; 0x2712 <_Z11ReceiveGAVRv+0x2c8>
    247e:	84 30       	cpi	r24, 0x04	; 4
    2480:	91 05       	cpc	r25, r1
    2482:	48 f4       	brcc	.+18     	; 0x2496 <_Z11ReceiveGAVRv+0x4c>
    2484:	81 30       	cpi	r24, 0x01	; 1
    2486:	91 05       	cpc	r25, r1
    2488:	09 f4       	brne	.+2      	; 0x248c <_Z11ReceiveGAVRv+0x42>
    248a:	05 c1       	rjmp	.+522    	; 0x2696 <_Z11ReceiveGAVRv+0x24c>
    248c:	82 30       	cpi	r24, 0x02	; 2
    248e:	91 05       	cpc	r25, r1
    2490:	08 f0       	brcs	.+2      	; 0x2494 <_Z11ReceiveGAVRv+0x4a>
    2492:	0f c1       	rjmp	.+542    	; 0x26b2 <_Z11ReceiveGAVRv+0x268>
    2494:	11 c0       	rjmp	.+34     	; 0x24b8 <_Z11ReceiveGAVRv+0x6e>
    2496:	85 30       	cpi	r24, 0x05	; 5
    2498:	91 05       	cpc	r25, r1
    249a:	09 f4       	brne	.+2      	; 0x249e <_Z11ReceiveGAVRv+0x54>
    249c:	4e c4       	rjmp	.+2204   	; 0x2d3a <_Z11ReceiveGAVRv+0x8f0>
    249e:	85 30       	cpi	r24, 0x05	; 5
    24a0:	91 05       	cpc	r25, r1
    24a2:	08 f4       	brcc	.+2      	; 0x24a6 <_Z11ReceiveGAVRv+0x5c>
    24a4:	b1 c3       	rjmp	.+1890   	; 0x2c08 <_Z11ReceiveGAVRv+0x7be>
    24a6:	86 30       	cpi	r24, 0x06	; 6
    24a8:	91 05       	cpc	r25, r1
    24aa:	09 f4       	brne	.+2      	; 0x24ae <_Z11ReceiveGAVRv+0x64>
    24ac:	67 c4       	rjmp	.+2254   	; 0x2d7c <_Z11ReceiveGAVRv+0x932>
    24ae:	87 30       	cpi	r24, 0x07	; 7
    24b0:	91 05       	cpc	r25, r1
    24b2:	09 f4       	brne	.+2      	; 0x24b6 <_Z11ReceiveGAVRv+0x6c>
    24b4:	05 c5       	rjmp	.+2570   	; 0x2ec0 <_Z11ReceiveGAVRv+0xa76>
    24b6:	f6 c5       	rjmp	.+3052   	; 0x30a4 <_Z11ReceiveGAVRv+0xc5a>
    24b8:	80 e0       	ldi	r24, 0x00	; 0
    24ba:	90 e0       	ldi	r25, 0x00	; 0
    24bc:	aa e7       	ldi	r26, 0x7A	; 122
    24be:	b4 e4       	ldi	r27, 0x44	; 68
    24c0:	89 8f       	std	Y+25, r24	; 0x19
    24c2:	9a 8f       	std	Y+26, r25	; 0x1a
    24c4:	ab 8f       	std	Y+27, r26	; 0x1b
    24c6:	bc 8f       	std	Y+28, r27	; 0x1c
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    24c8:	69 8d       	ldd	r22, Y+25	; 0x19
    24ca:	7a 8d       	ldd	r23, Y+26	; 0x1a
    24cc:	8b 8d       	ldd	r24, Y+27	; 0x1b
    24ce:	9c 8d       	ldd	r25, Y+28	; 0x1c
    24d0:	20 e0       	ldi	r18, 0x00	; 0
    24d2:	30 e0       	ldi	r19, 0x00	; 0
    24d4:	4a e7       	ldi	r20, 0x7A	; 122
    24d6:	53 e4       	ldi	r21, 0x43	; 67
    24d8:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    24dc:	dc 01       	movw	r26, r24
    24de:	cb 01       	movw	r24, r22
    24e0:	8d 8f       	std	Y+29, r24	; 0x1d
    24e2:	9e 8f       	std	Y+30, r25	; 0x1e
    24e4:	af 8f       	std	Y+31, r26	; 0x1f
    24e6:	b8 a3       	lds	r27, 0x58
	if (__tmp < 1.0)
    24e8:	11 e0       	ldi	r17, 0x01	; 1
    24ea:	6d 8d       	ldd	r22, Y+29	; 0x1d
    24ec:	7e 8d       	ldd	r23, Y+30	; 0x1e
    24ee:	8f 8d       	ldd	r24, Y+31	; 0x1f
    24f0:	98 a1       	lds	r25, 0x48
    24f2:	20 e0       	ldi	r18, 0x00	; 0
    24f4:	30 e0       	ldi	r19, 0x00	; 0
    24f6:	40 e8       	ldi	r20, 0x80	; 128
    24f8:	5f e3       	ldi	r21, 0x3F	; 63
    24fa:	0e 94 96 21 	call	0x432c	; 0x432c <__cmpsf2>
    24fe:	88 23       	and	r24, r24
    2500:	0c f0       	brlt	.+2      	; 0x2504 <_Z11ReceiveGAVRv+0xba>
    2502:	10 e0       	ldi	r17, 0x00	; 0
    2504:	11 23       	and	r17, r17
    2506:	29 f0       	breq	.+10     	; 0x2512 <_Z11ReceiveGAVRv+0xc8>
		__ticks = 1;
    2508:	81 e0       	ldi	r24, 0x01	; 1
    250a:	90 e0       	ldi	r25, 0x00	; 0
    250c:	9a a3       	lds	r25, 0x5a
    250e:	89 a3       	lds	r24, 0x59
    2510:	4a c0       	rjmp	.+148    	; 0x25a6 <_Z11ReceiveGAVRv+0x15c>
	else if (__tmp > 65535)
    2512:	11 e0       	ldi	r17, 0x01	; 1
    2514:	6d 8d       	ldd	r22, Y+29	; 0x1d
    2516:	7e 8d       	ldd	r23, Y+30	; 0x1e
    2518:	8f 8d       	ldd	r24, Y+31	; 0x1f
    251a:	98 a1       	lds	r25, 0x48
    251c:	20 e0       	ldi	r18, 0x00	; 0
    251e:	3f ef       	ldi	r19, 0xFF	; 255
    2520:	4f e7       	ldi	r20, 0x7F	; 127
    2522:	57 e4       	ldi	r21, 0x47	; 71
    2524:	0e 94 13 22 	call	0x4426	; 0x4426 <__gesf2>
    2528:	18 16       	cp	r1, r24
    252a:	0c f0       	brlt	.+2      	; 0x252e <_Z11ReceiveGAVRv+0xe4>
    252c:	10 e0       	ldi	r17, 0x00	; 0
    252e:	11 23       	and	r17, r17
    2530:	81 f1       	breq	.+96     	; 0x2592 <_Z11ReceiveGAVRv+0x148>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2532:	69 8d       	ldd	r22, Y+25	; 0x19
    2534:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2536:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2538:	9c 8d       	ldd	r25, Y+28	; 0x1c
    253a:	20 e0       	ldi	r18, 0x00	; 0
    253c:	30 e0       	ldi	r19, 0x00	; 0
    253e:	40 e2       	ldi	r20, 0x20	; 32
    2540:	51 e4       	ldi	r21, 0x41	; 65
    2542:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    2546:	dc 01       	movw	r26, r24
    2548:	cb 01       	movw	r24, r22
    254a:	bc 01       	movw	r22, r24
    254c:	cd 01       	movw	r24, r26
    254e:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    2552:	dc 01       	movw	r26, r24
    2554:	cb 01       	movw	r24, r22
    2556:	9a a3       	lds	r25, 0x5a
    2558:	89 a3       	lds	r24, 0x59
    255a:	12 c0       	rjmp	.+36     	; 0x2580 <_Z11ReceiveGAVRv+0x136>
    255c:	89 e1       	ldi	r24, 0x19	; 25
    255e:	90 e0       	ldi	r25, 0x00	; 0
    2560:	9c a3       	lds	r25, 0x5c
    2562:	8b a3       	lds	r24, 0x5b
    2564:	8b a1       	lds	r24, 0x4b
    2566:	9c a1       	lds	r25, 0x4c
    2568:	8c 01       	movw	r16, r24
    256a:	c8 01       	movw	r24, r16
    256c:	01 97       	sbiw	r24, 0x01	; 1
    256e:	f1 f7       	brne	.-4      	; 0x256c <_Z11ReceiveGAVRv+0x122>
    2570:	8c 01       	movw	r16, r24
    2572:	1c a3       	lds	r17, 0x5c
    2574:	0b a3       	lds	r16, 0x5b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2576:	89 a1       	lds	r24, 0x49
    2578:	9a a1       	lds	r25, 0x4a
    257a:	01 97       	sbiw	r24, 0x01	; 1
    257c:	9a a3       	lds	r25, 0x5a
    257e:	89 a3       	lds	r24, 0x59
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2580:	21 e0       	ldi	r18, 0x01	; 1
    2582:	89 a1       	lds	r24, 0x49
    2584:	9a a1       	lds	r25, 0x4a
    2586:	00 97       	sbiw	r24, 0x00	; 0
    2588:	09 f4       	brne	.+2      	; 0x258c <_Z11ReceiveGAVRv+0x142>
    258a:	20 e0       	ldi	r18, 0x00	; 0
    258c:	22 23       	and	r18, r18
    258e:	31 f7       	brne	.-52     	; 0x255c <_Z11ReceiveGAVRv+0x112>
    2590:	17 c0       	rjmp	.+46     	; 0x25c0 <_Z11ReceiveGAVRv+0x176>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2592:	6d 8d       	ldd	r22, Y+29	; 0x1d
    2594:	7e 8d       	ldd	r23, Y+30	; 0x1e
    2596:	8f 8d       	ldd	r24, Y+31	; 0x1f
    2598:	98 a1       	lds	r25, 0x48
    259a:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    259e:	dc 01       	movw	r26, r24
    25a0:	cb 01       	movw	r24, r22
    25a2:	9a a3       	lds	r25, 0x5a
    25a4:	89 a3       	lds	r24, 0x59
    25a6:	89 a1       	lds	r24, 0x49
    25a8:	9a a1       	lds	r25, 0x4a
    25aa:	9e a3       	lds	r25, 0x5e
    25ac:	8d a3       	lds	r24, 0x5d
    25ae:	8d a1       	lds	r24, 0x4d
    25b0:	9e a1       	lds	r25, 0x4e
    25b2:	8c 01       	movw	r16, r24
    25b4:	f8 01       	movw	r30, r16
    25b6:	31 97       	sbiw	r30, 0x01	; 1
    25b8:	f1 f7       	brne	.-4      	; 0x25b6 <_Z11ReceiveGAVRv+0x16c>
    25ba:	8f 01       	movw	r16, r30
    25bc:	1e a3       	lds	r17, 0x5e
    25be:	0d a3       	lds	r16, 0x5d
				case 0:{
					//Beginning case
					_delay_ms(1000);	//wait for something to be loaded into the register.
					strLoc=0;
    25c0:	1c 82       	std	Y+4, r1	; 0x04
    25c2:	1b 82       	std	Y+3, r1	; 0x03
					recChar = UDR1;
    25c4:	8e ec       	ldi	r24, 0xCE	; 206
    25c6:	90 e0       	ldi	r25, 0x00	; 0
    25c8:	fc 01       	movw	r30, r24
    25ca:	80 81       	ld	r24, Z
    25cc:	88 8f       	std	Y+24, r24	; 0x18
					if (recChar=='.'){
    25ce:	88 8d       	ldd	r24, Y+24	; 0x18
    25d0:	8e 32       	cpi	r24, 0x2E	; 46
    25d2:	29 f4       	brne	.+10     	; 0x25de <_Z11ReceiveGAVRv+0x194>
						state=6;															//Go to error state.
    25d4:	86 e0       	ldi	r24, 0x06	; 6
    25d6:	90 e0       	ldi	r25, 0x00	; 0
    25d8:	9a 83       	std	Y+2, r25	; 0x02
    25da:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
    25dc:	6a c5       	rjmp	.+2772   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
					_delay_ms(1000);	//wait for something to be loaded into the register.
					strLoc=0;
					recChar = UDR1;
					if (recChar=='.'){
						state=6;															//Go to error state.
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
    25de:	9e 01       	movw	r18, r28
    25e0:	2e 59       	subi	r18, 0x9E	; 158
    25e2:	3f 4f       	sbci	r19, 0xFF	; 255
    25e4:	8b 81       	ldd	r24, Y+3	; 0x03
    25e6:	9c 81       	ldd	r25, Y+4	; 0x04
    25e8:	82 0f       	add	r24, r18
    25ea:	93 1f       	adc	r25, r19
    25ec:	28 8d       	ldd	r18, Y+24	; 0x18
    25ee:	fc 01       	movw	r30, r24
    25f0:	20 83       	st	Z, r18
    25f2:	8b 81       	ldd	r24, Y+3	; 0x03
    25f4:	9c 81       	ldd	r25, Y+4	; 0x04
    25f6:	01 96       	adiw	r24, 0x01	; 1
    25f8:	9c 83       	std	Y+4, r25	; 0x04
    25fa:	8b 83       	std	Y+3, r24	; 0x03
    25fc:	81 e0       	ldi	r24, 0x01	; 1
    25fe:	90 e0       	ldi	r25, 0x00	; 0
    2600:	9a 83       	std	Y+2, r25	; 0x02
    2602:	89 83       	std	Y+1, r24	; 0x01
					break;
    2604:	56 c5       	rjmp	.+2732   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
    2606:	00 00       	nop
    2608:	88 ec       	ldi	r24, 0xC8	; 200
    260a:	90 e0       	ldi	r25, 0x00	; 0
    260c:	fc 01       	movw	r30, r24
    260e:	80 81       	ld	r24, Z
    2610:	88 23       	and	r24, r24
    2612:	34 f0       	brlt	.+12     	; 0x2620 <_Z11ReceiveGAVRv+0x1d6>
    2614:	80 91 bc 01 	lds	r24, 0x01BC
    2618:	88 23       	and	r24, r24
    261a:	11 f0       	breq	.+4      	; 0x2620 <_Z11ReceiveGAVRv+0x1d6>
    261c:	81 e0       	ldi	r24, 0x01	; 1
    261e:	01 c0       	rjmp	.+2      	; 0x2622 <_Z11ReceiveGAVRv+0x1d8>
    2620:	80 e0       	ldi	r24, 0x00	; 0
    2622:	88 23       	and	r24, r24
    2624:	89 f7       	brne	.-30     	; 0x2608 <_Z11ReceiveGAVRv+0x1be>
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
    2626:	80 91 bc 01 	lds	r24, 0x01BC
    262a:	88 23       	and	r24, r24
    262c:	21 f4       	brne	.+8      	; 0x2636 <_Z11ReceiveGAVRv+0x1ec>
    262e:	1a 82       	std	Y+2, r1	; 0x02
    2630:	19 82       	std	Y+1, r1	; 0x01
    2632:	00 00       	nop
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    2634:	3e c5       	rjmp	.+2684   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
						recChar=UDR1;
    2636:	8e ec       	ldi	r24, 0xCE	; 206
    2638:	90 e0       	ldi	r25, 0x00	; 0
    263a:	fc 01       	movw	r30, r24
    263c:	80 81       	ld	r24, Z
    263e:	88 8f       	std	Y+24, r24	; 0x18
						recString[strLoc++]=recChar;										//'.' always included into recString
    2640:	9e 01       	movw	r18, r28
    2642:	2e 59       	subi	r18, 0x9E	; 158
    2644:	3f 4f       	sbci	r19, 0xFF	; 255
    2646:	8b 81       	ldd	r24, Y+3	; 0x03
    2648:	9c 81       	ldd	r25, Y+4	; 0x04
    264a:	82 0f       	add	r24, r18
    264c:	93 1f       	adc	r25, r19
    264e:	28 8d       	ldd	r18, Y+24	; 0x18
    2650:	fc 01       	movw	r30, r24
    2652:	20 83       	st	Z, r18
    2654:	8b 81       	ldd	r24, Y+3	; 0x03
    2656:	9c 81       	ldd	r25, Y+4	; 0x04
    2658:	01 96       	adiw	r24, 0x01	; 1
    265a:	9c 83       	std	Y+4, r25	; 0x04
    265c:	8b 83       	std	Y+3, r24	; 0x03
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    265e:	88 8d       	ldd	r24, Y+24	; 0x18
    2660:	8e 32       	cpi	r24, 0x2E	; 46
    2662:	79 f4       	brne	.+30     	; 0x2682 <_Z11ReceiveGAVRv+0x238>
    2664:	9e 01       	movw	r18, r28
    2666:	2e 59       	subi	r18, 0x9E	; 158
    2668:	3f 4f       	sbci	r19, 0xFF	; 255
    266a:	8b 81       	ldd	r24, Y+3	; 0x03
    266c:	9c 81       	ldd	r25, Y+4	; 0x04
    266e:	82 0f       	add	r24, r18
    2670:	93 1f       	adc	r25, r19
    2672:	fc 01       	movw	r30, r24
    2674:	10 82       	st	Z, r1
    2676:	1d 82       	std	Y+5, r1	; 0x05
    2678:	82 e0       	ldi	r24, 0x02	; 2
    267a:	90 e0       	ldi	r25, 0x00	; 0
    267c:	9a 83       	std	Y+2, r25	; 0x02
    267e:	89 83       	std	Y+1, r24	; 0x01
    2680:	0a c0       	rjmp	.+20     	; 0x2696 <_Z11ReceiveGAVRv+0x24c>
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
    2682:	8b 81       	ldd	r24, Y+3	; 0x03
    2684:	9c 81       	ldd	r25, Y+4	; 0x04
    2686:	87 32       	cpi	r24, 0x27	; 39
    2688:	91 05       	cpc	r25, r1
    268a:	28 f0       	brcs	.+10     	; 0x2696 <_Z11ReceiveGAVRv+0x24c>
    268c:	86 e0       	ldi	r24, 0x06	; 6
    268e:	90 e0       	ldi	r25, 0x00	; 0
    2690:	9a 83       	std	Y+2, r25	; 0x02
    2692:	89 83       	std	Y+1, r24	; 0x01
    2694:	1d 82       	std	Y+5, r1	; 0x05
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
    2696:	8d 81       	ldd	r24, Y+5	; 0x05
    2698:	88 23       	and	r24, r24
    269a:	31 f0       	breq	.+12     	; 0x26a8 <_Z11ReceiveGAVRv+0x25e>
    269c:	80 91 bc 01 	lds	r24, 0x01BC
    26a0:	88 23       	and	r24, r24
    26a2:	11 f0       	breq	.+4      	; 0x26a8 <_Z11ReceiveGAVRv+0x25e>
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	01 c0       	rjmp	.+2      	; 0x26aa <_Z11ReceiveGAVRv+0x260>
    26a8:	80 e0       	ldi	r24, 0x00	; 0
    26aa:	88 23       	and	r24, r24
    26ac:	09 f0       	breq	.+2      	; 0x26b0 <_Z11ReceiveGAVRv+0x266>
    26ae:	ab cf       	rjmp	.-170    	; 0x2606 <_Z11ReceiveGAVRv+0x1bc>
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    26b0:	00 c5       	rjmp	.+2560   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
    26b2:	ce 01       	movw	r24, r28
    26b4:	8e 59       	subi	r24, 0x9E	; 158
    26b6:	9f 4f       	sbci	r25, 0xFF	; 255
    26b8:	28 e6       	ldi	r18, 0x68	; 104
    26ba:	31 e0       	ldi	r19, 0x01	; 1
    26bc:	b9 01       	movw	r22, r18
    26be:	48 e0       	ldi	r20, 0x08	; 8
    26c0:	50 e0       	ldi	r21, 0x00	; 0
    26c2:	0e 94 14 23 	call	0x4628	; 0x4628 <strncmp>
    26c6:	00 97       	sbiw	r24, 0x00	; 0
    26c8:	29 f4       	brne	.+10     	; 0x26d4 <_Z11ReceiveGAVRv+0x28a>
    26ca:	84 e0       	ldi	r24, 0x04	; 4
    26cc:	90 e0       	ldi	r25, 0x00	; 0
    26ce:	9a 83       	std	Y+2, r25	; 0x02
    26d0:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
					break;
    26d2:	ef c4       	rjmp	.+2526   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
					break;
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
    26d4:	ce 01       	movw	r24, r28
    26d6:	8e 59       	subi	r24, 0x9E	; 158
    26d8:	9f 4f       	sbci	r25, 0xFF	; 255
    26da:	fc 01       	movw	r30, r24
    26dc:	84 81       	ldd	r24, Z+4	; 0x04
    26de:	21 e0       	ldi	r18, 0x01	; 1
    26e0:	8a 33       	cpi	r24, 0x3A	; 58
    26e2:	09 f0       	breq	.+2      	; 0x26e6 <_Z11ReceiveGAVRv+0x29c>
    26e4:	20 e0       	ldi	r18, 0x00	; 0
    26e6:	ce 01       	movw	r24, r28
    26e8:	8e 59       	subi	r24, 0x9E	; 158
    26ea:	9f 4f       	sbci	r25, 0xFF	; 255
    26ec:	fc 01       	movw	r30, r24
    26ee:	95 81       	ldd	r25, Z+5	; 0x05
    26f0:	81 e0       	ldi	r24, 0x01	; 1
    26f2:	9a 33       	cpi	r25, 0x3A	; 58
    26f4:	09 f0       	breq	.+2      	; 0x26f8 <_Z11ReceiveGAVRv+0x2ae>
    26f6:	80 e0       	ldi	r24, 0x00	; 0
    26f8:	82 27       	eor	r24, r18
    26fa:	88 23       	and	r24, r24
    26fc:	29 f0       	breq	.+10     	; 0x2708 <_Z11ReceiveGAVRv+0x2be>
    26fe:	83 e0       	ldi	r24, 0x03	; 3
    2700:	90 e0       	ldi	r25, 0x00	; 0
    2702:	9a 83       	std	Y+2, r25	; 0x02
    2704:	89 83       	std	Y+1, r24	; 0x01
					else {state=6;}
					break;
    2706:	d5 c4       	rjmp	.+2474   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
    2708:	86 e0       	ldi	r24, 0x06	; 6
    270a:	90 e0       	ldi	r25, 0x00	; 0
    270c:	9a 83       	std	Y+2, r25	; 0x02
    270e:	89 83       	std	Y+1, r24	; 0x01
					break;
    2710:	d0 c4       	rjmp	.+2464   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
				}//end case 2
				case 3:{
					//Parse for date/time case
					if (flagUserClock){
    2712:	80 91 c2 01 	lds	r24, 0x01C2
    2716:	88 23       	and	r24, r24
    2718:	09 f4       	brne	.+2      	; 0x271c <_Z11ReceiveGAVRv+0x2d2>
    271a:	6d c2       	rjmp	.+1242   	; 0x2bf6 <_Z11ReceiveGAVRv+0x7ac>
						//Go through the string and parse for the time. Must go through the time to get the date.
						BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    271c:	1e 82       	std	Y+6, r1	; 0x06
    271e:	1f 82       	std	Y+7, r1	; 0x07
						int counter=0;
    2720:	19 86       	std	Y+9, r1	; 0x09
    2722:	18 86       	std	Y+8, r1	; 0x08
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    2724:	ce 01       	movw	r24, r28
    2726:	8f 5a       	subi	r24, 0xAF	; 175
    2728:	9f 4f       	sbci	r25, 0xFF	; 255
    272a:	fc 01       	movw	r30, r24
    272c:	11 82       	std	Z+1, r1	; 0x01
    272e:	10 82       	st	Z, r1
    2730:	ce 01       	movw	r24, r28
    2732:	8f 5a       	subi	r24, 0xAF	; 175
    2734:	9f 4f       	sbci	r25, 0xFF	; 255
    2736:	fc 01       	movw	r30, r24
    2738:	13 82       	std	Z+3, r1	; 0x03
    273a:	12 82       	std	Z+2, r1	; 0x02
    273c:	ce 01       	movw	r24, r28
    273e:	8f 5a       	subi	r24, 0xAF	; 175
    2740:	9f 4f       	sbci	r25, 0xFF	; 255
    2742:	fc 01       	movw	r30, r24
    2744:	15 82       	std	Z+5, r1	; 0x05
    2746:	14 82       	std	Z+4, r1	; 0x04
    2748:	ce 01       	movw	r24, r28
    274a:	89 5a       	subi	r24, 0xA9	; 169
    274c:	9f 4f       	sbci	r25, 0xFF	; 255
    274e:	fc 01       	movw	r30, r24
    2750:	11 82       	std	Z+1, r1	; 0x01
    2752:	10 82       	st	Z, r1
    2754:	ce 01       	movw	r24, r28
    2756:	89 5a       	subi	r24, 0xA9	; 169
    2758:	9f 4f       	sbci	r25, 0xFF	; 255
    275a:	fc 01       	movw	r30, r24
    275c:	13 82       	std	Z+3, r1	; 0x03
    275e:	12 82       	std	Z+2, r1	; 0x02
    2760:	ce 01       	movw	r24, r28
    2762:	89 5a       	subi	r24, 0xA9	; 169
    2764:	9f 4f       	sbci	r25, 0xFF	; 255
    2766:	fc 01       	movw	r30, r24
    2768:	15 82       	std	Z+5, r1	; 0x05
    276a:	14 82       	std	Z+4, r1	; 0x04
    276c:	1b 86       	std	Y+11, r1	; 0x0b
    276e:	1a 86       	std	Y+10, r1	; 0x0a
    2770:	1d 86       	std	Y+13, r1	; 0x0d
    2772:	1c 86       	std	Y+12, r1	; 0x0c
    2774:	1f 86       	std	Y+15, r1	; 0x0f
    2776:	1e 86       	std	Y+14, r1	; 0x0e
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    2778:	73 c0       	rjmp	.+230    	; 0x2860 <_Z11ReceiveGAVRv+0x416>
							//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
							if (recString[counter]!=':' && hms<3){
    277a:	9e 01       	movw	r18, r28
    277c:	2e 59       	subi	r18, 0x9E	; 158
    277e:	3f 4f       	sbci	r19, 0xFF	; 255
    2780:	88 85       	ldd	r24, Y+8	; 0x08
    2782:	99 85       	ldd	r25, Y+9	; 0x09
    2784:	82 0f       	add	r24, r18
    2786:	93 1f       	adc	r25, r19
    2788:	fc 01       	movw	r30, r24
    278a:	80 81       	ld	r24, Z
    278c:	8a 33       	cpi	r24, 0x3A	; 58
    278e:	e9 f0       	breq	.+58     	; 0x27ca <_Z11ReceiveGAVRv+0x380>
    2790:	8c 85       	ldd	r24, Y+12	; 0x0c
    2792:	9d 85       	ldd	r25, Y+13	; 0x0d
    2794:	83 30       	cpi	r24, 0x03	; 3
    2796:	91 05       	cpc	r25, r1
    2798:	c4 f4       	brge	.+48     	; 0x27ca <_Z11ReceiveGAVRv+0x380>
								tempStringNum[placement++]=recString[counter];
    279a:	9e 01       	movw	r18, r28
    279c:	2e 59       	subi	r18, 0x9E	; 158
    279e:	3f 4f       	sbci	r19, 0xFF	; 255
    27a0:	88 85       	ldd	r24, Y+8	; 0x08
    27a2:	99 85       	ldd	r25, Y+9	; 0x09
    27a4:	82 0f       	add	r24, r18
    27a6:	93 1f       	adc	r25, r19
    27a8:	fc 01       	movw	r30, r24
    27aa:	40 81       	ld	r20, Z
    27ac:	9e 01       	movw	r18, r28
    27ae:	23 5a       	subi	r18, 0xA3	; 163
    27b0:	3f 4f       	sbci	r19, 0xFF	; 255
    27b2:	8e 85       	ldd	r24, Y+14	; 0x0e
    27b4:	9f 85       	ldd	r25, Y+15	; 0x0f
    27b6:	82 0f       	add	r24, r18
    27b8:	93 1f       	adc	r25, r19
    27ba:	fc 01       	movw	r30, r24
    27bc:	40 83       	st	Z, r20
    27be:	8e 85       	ldd	r24, Y+14	; 0x0e
    27c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    27c2:	01 96       	adiw	r24, 0x01	; 1
    27c4:	9f 87       	std	Y+15, r25	; 0x0f
    27c6:	8e 87       	std	Y+14, r24	; 0x0e
    27c8:	46 c0       	rjmp	.+140    	; 0x2856 <_Z11ReceiveGAVRv+0x40c>
							//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
							} else if (hms<2 && recString[counter] == ':') {
    27ca:	8c 85       	ldd	r24, Y+12	; 0x0c
    27cc:	9d 85       	ldd	r25, Y+13	; 0x0d
    27ce:	82 30       	cpi	r24, 0x02	; 2
    27d0:	91 05       	cpc	r25, r1
    27d2:	0c f0       	brlt	.+2      	; 0x27d6 <_Z11ReceiveGAVRv+0x38c>
    27d4:	40 c0       	rjmp	.+128    	; 0x2856 <_Z11ReceiveGAVRv+0x40c>
    27d6:	9e 01       	movw	r18, r28
    27d8:	2e 59       	subi	r18, 0x9E	; 158
    27da:	3f 4f       	sbci	r19, 0xFF	; 255
    27dc:	88 85       	ldd	r24, Y+8	; 0x08
    27de:	99 85       	ldd	r25, Y+9	; 0x09
    27e0:	82 0f       	add	r24, r18
    27e2:	93 1f       	adc	r25, r19
    27e4:	fc 01       	movw	r30, r24
    27e6:	80 81       	ld	r24, Z
    27e8:	8a 33       	cpi	r24, 0x3A	; 58
    27ea:	a9 f5       	brne	.+106    	; 0x2856 <_Z11ReceiveGAVRv+0x40c>
								tempNum[hms++] = atoi(tempStringNum);
    27ec:	ce 01       	movw	r24, r28
    27ee:	83 5a       	subi	r24, 0xA3	; 163
    27f0:	9f 4f       	sbci	r25, 0xFF	; 255
    27f2:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
    27f6:	9c 01       	movw	r18, r24
    27f8:	ae 01       	movw	r20, r28
    27fa:	4f 5a       	subi	r20, 0xAF	; 175
    27fc:	5f 4f       	sbci	r21, 0xFF	; 255
    27fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    2800:	9d 85       	ldd	r25, Y+13	; 0x0d
    2802:	88 0f       	add	r24, r24
    2804:	99 1f       	adc	r25, r25
    2806:	84 0f       	add	r24, r20
    2808:	95 1f       	adc	r25, r21
    280a:	fc 01       	movw	r30, r24
    280c:	31 83       	std	Z+1, r19	; 0x01
    280e:	20 83       	st	Z, r18
    2810:	8c 85       	ldd	r24, Y+12	; 0x0c
    2812:	9d 85       	ldd	r25, Y+13	; 0x0d
    2814:	01 96       	adiw	r24, 0x01	; 1
    2816:	9d 87       	std	Y+13, r25	; 0x0d
    2818:	8c 87       	std	Y+12, r24	; 0x0c
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    281a:	19 8a       	std	Y+17, r1	; 0x11
    281c:	18 8a       	std	Y+16, r1	; 0x10
    281e:	0e c0       	rjmp	.+28     	; 0x283c <_Z11ReceiveGAVRv+0x3f2>
    2820:	9e 01       	movw	r18, r28
    2822:	23 5a       	subi	r18, 0xA3	; 163
    2824:	3f 4f       	sbci	r19, 0xFF	; 255
    2826:	88 89       	ldd	r24, Y+16	; 0x10
    2828:	99 89       	ldd	r25, Y+17	; 0x11
    282a:	82 0f       	add	r24, r18
    282c:	93 1f       	adc	r25, r19
    282e:	fc 01       	movw	r30, r24
    2830:	10 82       	st	Z, r1
    2832:	88 89       	ldd	r24, Y+16	; 0x10
    2834:	99 89       	ldd	r25, Y+17	; 0x11
    2836:	01 96       	adiw	r24, 0x01	; 1
    2838:	99 8b       	std	Y+17, r25	; 0x11
    283a:	88 8b       	std	Y+16, r24	; 0x10
    283c:	41 e0       	ldi	r20, 0x01	; 1
    283e:	28 89       	ldd	r18, Y+16	; 0x10
    2840:	39 89       	ldd	r19, Y+17	; 0x11
    2842:	8e 85       	ldd	r24, Y+14	; 0x0e
    2844:	9f 85       	ldd	r25, Y+15	; 0x0f
    2846:	82 17       	cp	r24, r18
    2848:	93 07       	cpc	r25, r19
    284a:	0c f4       	brge	.+2      	; 0x284e <_Z11ReceiveGAVRv+0x404>
    284c:	40 e0       	ldi	r20, 0x00	; 0
    284e:	44 23       	and	r20, r20
    2850:	39 f7       	brne	.-50     	; 0x2820 <_Z11ReceiveGAVRv+0x3d6>
								placement=0;												//reset placement
    2852:	1f 86       	std	Y+15, r1	; 0x0f
    2854:	1e 86       	std	Y+14, r1	; 0x0e
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
    2856:	88 85       	ldd	r24, Y+8	; 0x08
    2858:	99 85       	ldd	r25, Y+9	; 0x09
    285a:	01 96       	adiw	r24, 0x01	; 1
    285c:	99 87       	std	Y+9, r25	; 0x09
    285e:	88 87       	std	Y+8, r24	; 0x08
						int counter=0;
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    2860:	9e 01       	movw	r18, r28
    2862:	2e 59       	subi	r18, 0x9E	; 158
    2864:	3f 4f       	sbci	r19, 0xFF	; 255
    2866:	88 85       	ldd	r24, Y+8	; 0x08
    2868:	99 85       	ldd	r25, Y+9	; 0x09
    286a:	82 0f       	add	r24, r18
    286c:	93 1f       	adc	r25, r19
    286e:	fc 01       	movw	r30, r24
    2870:	80 81       	ld	r24, Z
    2872:	8f 32       	cpi	r24, 0x2F	; 47
    2874:	69 f0       	breq	.+26     	; 0x2890 <_Z11ReceiveGAVRv+0x446>
    2876:	9e 01       	movw	r18, r28
    2878:	2e 59       	subi	r18, 0x9E	; 158
    287a:	3f 4f       	sbci	r19, 0xFF	; 255
    287c:	88 85       	ldd	r24, Y+8	; 0x08
    287e:	99 85       	ldd	r25, Y+9	; 0x09
    2880:	82 0f       	add	r24, r18
    2882:	93 1f       	adc	r25, r19
    2884:	fc 01       	movw	r30, r24
    2886:	80 81       	ld	r24, Z
    2888:	88 23       	and	r24, r24
    288a:	11 f0       	breq	.+4      	; 0x2890 <_Z11ReceiveGAVRv+0x446>
    288c:	81 e0       	ldi	r24, 0x01	; 1
    288e:	01 c0       	rjmp	.+2      	; 0x2892 <_Z11ReceiveGAVRv+0x448>
    2890:	80 e0       	ldi	r24, 0x00	; 0
    2892:	88 23       	and	r24, r24
    2894:	09 f0       	breq	.+2      	; 0x2898 <_Z11ReceiveGAVRv+0x44e>
    2896:	71 cf       	rjmp	.-286    	; 0x277a <_Z11ReceiveGAVRv+0x330>
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
						}//end while
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
    2898:	9e 01       	movw	r18, r28
    289a:	2e 59       	subi	r18, 0x9E	; 158
    289c:	3f 4f       	sbci	r19, 0xFF	; 255
    289e:	88 85       	ldd	r24, Y+8	; 0x08
    28a0:	99 85       	ldd	r25, Y+9	; 0x09
    28a2:	82 0f       	add	r24, r18
    28a4:	93 1f       	adc	r25, r19
    28a6:	fc 01       	movw	r30, r24
    28a8:	80 81       	ld	r24, Z
    28aa:	8f 32       	cpi	r24, 0x2F	; 47
    28ac:	a9 f4       	brne	.+42     	; 0x28d8 <_Z11ReceiveGAVRv+0x48e>
							tempNum[hms] = atoi(tempStringNum);
    28ae:	ce 01       	movw	r24, r28
    28b0:	83 5a       	subi	r24, 0xA3	; 163
    28b2:	9f 4f       	sbci	r25, 0xFF	; 255
    28b4:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
    28b8:	9c 01       	movw	r18, r24
    28ba:	ae 01       	movw	r20, r28
    28bc:	4f 5a       	subi	r20, 0xAF	; 175
    28be:	5f 4f       	sbci	r21, 0xFF	; 255
    28c0:	8c 85       	ldd	r24, Y+12	; 0x0c
    28c2:	9d 85       	ldd	r25, Y+13	; 0x0d
    28c4:	88 0f       	add	r24, r24
    28c6:	99 1f       	adc	r25, r25
    28c8:	84 0f       	add	r24, r20
    28ca:	95 1f       	adc	r25, r21
    28cc:	fc 01       	movw	r30, r24
    28ce:	31 83       	std	Z+1, r19	; 0x01
    28d0:	20 83       	st	Z, r18
							successTime=fTrue;
    28d2:	81 e0       	ldi	r24, 0x01	; 1
    28d4:	8e 83       	std	Y+6, r24	; 0x06
    28d6:	08 c0       	rjmp	.+16     	; 0x28e8 <_Z11ReceiveGAVRv+0x49e>
						} else {
							state=5;
    28d8:	85 e0       	ldi	r24, 0x05	; 5
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	9a 83       	std	Y+2, r25	; 0x02
    28de:	89 83       	std	Y+1, r24	; 0x01
							PrintGAVR("ACKBAD.");
    28e0:	8d e0       	ldi	r24, 0x0D	; 13
    28e2:	91 e0       	ldi	r25, 0x01	; 1
    28e4:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    28e8:	1b 8a       	std	Y+19, r1	; 0x13
    28ea:	1a 8a       	std	Y+18, r1	; 0x12
    28ec:	0e c0       	rjmp	.+28     	; 0x290a <_Z11ReceiveGAVRv+0x4c0>
    28ee:	9e 01       	movw	r18, r28
    28f0:	23 5a       	subi	r18, 0xA3	; 163
    28f2:	3f 4f       	sbci	r19, 0xFF	; 255
    28f4:	8a 89       	ldd	r24, Y+18	; 0x12
    28f6:	9b 89       	ldd	r25, Y+19	; 0x13
    28f8:	82 0f       	add	r24, r18
    28fa:	93 1f       	adc	r25, r19
    28fc:	fc 01       	movw	r30, r24
    28fe:	10 82       	st	Z, r1
    2900:	8a 89       	ldd	r24, Y+18	; 0x12
    2902:	9b 89       	ldd	r25, Y+19	; 0x13
    2904:	01 96       	adiw	r24, 0x01	; 1
    2906:	9b 8b       	std	Y+19, r25	; 0x13
    2908:	8a 8b       	std	Y+18, r24	; 0x12
    290a:	41 e0       	ldi	r20, 0x01	; 1
    290c:	2a 89       	ldd	r18, Y+18	; 0x12
    290e:	3b 89       	ldd	r19, Y+19	; 0x13
    2910:	8e 85       	ldd	r24, Y+14	; 0x0e
    2912:	9f 85       	ldd	r25, Y+15	; 0x0f
    2914:	82 17       	cp	r24, r18
    2916:	93 07       	cpc	r25, r19
    2918:	0c f4       	brge	.+2      	; 0x291c <_Z11ReceiveGAVRv+0x4d2>
    291a:	40 e0       	ldi	r20, 0x00	; 0
    291c:	44 23       	and	r20, r20
    291e:	39 f7       	brne	.-50     	; 0x28ee <_Z11ReceiveGAVRv+0x4a4>
						placement=0;
    2920:	1f 86       	std	Y+15, r1	; 0x0f
    2922:	1e 86       	std	Y+14, r1	; 0x0e
						counter++;	//get past the '/'
    2924:	88 85       	ldd	r24, Y+8	; 0x08
    2926:	99 85       	ldd	r25, Y+9	; 0x09
    2928:	01 96       	adiw	r24, 0x01	; 1
    292a:	99 87       	std	Y+9, r25	; 0x09
    292c:	88 87       	std	Y+8, r24	; 0x08
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    292e:	73 c0       	rjmp	.+230    	; 0x2a16 <_Z11ReceiveGAVRv+0x5cc>
							//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
							if  (recString[counter] != ',' && dmy < 3){
    2930:	9e 01       	movw	r18, r28
    2932:	2e 59       	subi	r18, 0x9E	; 158
    2934:	3f 4f       	sbci	r19, 0xFF	; 255
    2936:	88 85       	ldd	r24, Y+8	; 0x08
    2938:	99 85       	ldd	r25, Y+9	; 0x09
    293a:	82 0f       	add	r24, r18
    293c:	93 1f       	adc	r25, r19
    293e:	fc 01       	movw	r30, r24
    2940:	80 81       	ld	r24, Z
    2942:	8c 32       	cpi	r24, 0x2C	; 44
    2944:	e9 f0       	breq	.+58     	; 0x2980 <_Z11ReceiveGAVRv+0x536>
    2946:	8a 85       	ldd	r24, Y+10	; 0x0a
    2948:	9b 85       	ldd	r25, Y+11	; 0x0b
    294a:	83 30       	cpi	r24, 0x03	; 3
    294c:	91 05       	cpc	r25, r1
    294e:	c4 f4       	brge	.+48     	; 0x2980 <_Z11ReceiveGAVRv+0x536>
								tempStringNum[placement++]=recString[counter];
    2950:	9e 01       	movw	r18, r28
    2952:	2e 59       	subi	r18, 0x9E	; 158
    2954:	3f 4f       	sbci	r19, 0xFF	; 255
    2956:	88 85       	ldd	r24, Y+8	; 0x08
    2958:	99 85       	ldd	r25, Y+9	; 0x09
    295a:	82 0f       	add	r24, r18
    295c:	93 1f       	adc	r25, r19
    295e:	fc 01       	movw	r30, r24
    2960:	40 81       	ld	r20, Z
    2962:	9e 01       	movw	r18, r28
    2964:	23 5a       	subi	r18, 0xA3	; 163
    2966:	3f 4f       	sbci	r19, 0xFF	; 255
    2968:	8e 85       	ldd	r24, Y+14	; 0x0e
    296a:	9f 85       	ldd	r25, Y+15	; 0x0f
    296c:	82 0f       	add	r24, r18
    296e:	93 1f       	adc	r25, r19
    2970:	fc 01       	movw	r30, r24
    2972:	40 83       	st	Z, r20
    2974:	8e 85       	ldd	r24, Y+14	; 0x0e
    2976:	9f 85       	ldd	r25, Y+15	; 0x0f
    2978:	01 96       	adiw	r24, 0x01	; 1
    297a:	9f 87       	std	Y+15, r25	; 0x0f
    297c:	8e 87       	std	Y+14, r24	; 0x0e
    297e:	46 c0       	rjmp	.+140    	; 0x2a0c <_Z11ReceiveGAVRv+0x5c2>
							//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
							} else if (dmy<2 && recString[counter]==','){
    2980:	8a 85       	ldd	r24, Y+10	; 0x0a
    2982:	9b 85       	ldd	r25, Y+11	; 0x0b
    2984:	82 30       	cpi	r24, 0x02	; 2
    2986:	91 05       	cpc	r25, r1
    2988:	0c f0       	brlt	.+2      	; 0x298c <_Z11ReceiveGAVRv+0x542>
    298a:	40 c0       	rjmp	.+128    	; 0x2a0c <_Z11ReceiveGAVRv+0x5c2>
    298c:	9e 01       	movw	r18, r28
    298e:	2e 59       	subi	r18, 0x9E	; 158
    2990:	3f 4f       	sbci	r19, 0xFF	; 255
    2992:	88 85       	ldd	r24, Y+8	; 0x08
    2994:	99 85       	ldd	r25, Y+9	; 0x09
    2996:	82 0f       	add	r24, r18
    2998:	93 1f       	adc	r25, r19
    299a:	fc 01       	movw	r30, r24
    299c:	80 81       	ld	r24, Z
    299e:	8c 32       	cpi	r24, 0x2C	; 44
    29a0:	a9 f5       	brne	.+106    	; 0x2a0c <_Z11ReceiveGAVRv+0x5c2>
								tempNum1[dmy++] = atoi(tempStringNum);
    29a2:	ce 01       	movw	r24, r28
    29a4:	83 5a       	subi	r24, 0xA3	; 163
    29a6:	9f 4f       	sbci	r25, 0xFF	; 255
    29a8:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
    29ac:	9c 01       	movw	r18, r24
    29ae:	ae 01       	movw	r20, r28
    29b0:	49 5a       	subi	r20, 0xA9	; 169
    29b2:	5f 4f       	sbci	r21, 0xFF	; 255
    29b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    29b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    29b8:	88 0f       	add	r24, r24
    29ba:	99 1f       	adc	r25, r25
    29bc:	84 0f       	add	r24, r20
    29be:	95 1f       	adc	r25, r21
    29c0:	fc 01       	movw	r30, r24
    29c2:	31 83       	std	Z+1, r19	; 0x01
    29c4:	20 83       	st	Z, r18
    29c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    29c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    29ca:	01 96       	adiw	r24, 0x01	; 1
    29cc:	9b 87       	std	Y+11, r25	; 0x0b
    29ce:	8a 87       	std	Y+10, r24	; 0x0a
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    29d0:	1d 8a       	std	Y+21, r1	; 0x15
    29d2:	1c 8a       	std	Y+20, r1	; 0x14
    29d4:	0e c0       	rjmp	.+28     	; 0x29f2 <_Z11ReceiveGAVRv+0x5a8>
    29d6:	9e 01       	movw	r18, r28
    29d8:	23 5a       	subi	r18, 0xA3	; 163
    29da:	3f 4f       	sbci	r19, 0xFF	; 255
    29dc:	8c 89       	ldd	r24, Y+20	; 0x14
    29de:	9d 89       	ldd	r25, Y+21	; 0x15
    29e0:	82 0f       	add	r24, r18
    29e2:	93 1f       	adc	r25, r19
    29e4:	fc 01       	movw	r30, r24
    29e6:	10 82       	st	Z, r1
    29e8:	8c 89       	ldd	r24, Y+20	; 0x14
    29ea:	9d 89       	ldd	r25, Y+21	; 0x15
    29ec:	01 96       	adiw	r24, 0x01	; 1
    29ee:	9d 8b       	std	Y+21, r25	; 0x15
    29f0:	8c 8b       	std	Y+20, r24	; 0x14
    29f2:	41 e0       	ldi	r20, 0x01	; 1
    29f4:	2c 89       	ldd	r18, Y+20	; 0x14
    29f6:	3d 89       	ldd	r19, Y+21	; 0x15
    29f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    29fa:	9f 85       	ldd	r25, Y+15	; 0x0f
    29fc:	82 17       	cp	r24, r18
    29fe:	93 07       	cpc	r25, r19
    2a00:	0c f4       	brge	.+2      	; 0x2a04 <_Z11ReceiveGAVRv+0x5ba>
    2a02:	40 e0       	ldi	r20, 0x00	; 0
    2a04:	44 23       	and	r20, r20
    2a06:	39 f7       	brne	.-50     	; 0x29d6 <_Z11ReceiveGAVRv+0x58c>
								placement=0;
    2a08:	1f 86       	std	Y+15, r1	; 0x0f
    2a0a:	1e 86       	std	Y+14, r1	; 0x0e
							} else;
							counter++;							
    2a0c:	88 85       	ldd	r24, Y+8	; 0x08
    2a0e:	99 85       	ldd	r25, Y+9	; 0x09
    2a10:	01 96       	adiw	r24, 0x01	; 1
    2a12:	99 87       	std	Y+9, r25	; 0x09
    2a14:	88 87       	std	Y+8, r24	; 0x08
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
						placement=0;
						counter++;	//get past the '/'
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    2a16:	9e 01       	movw	r18, r28
    2a18:	2e 59       	subi	r18, 0x9E	; 158
    2a1a:	3f 4f       	sbci	r19, 0xFF	; 255
    2a1c:	88 85       	ldd	r24, Y+8	; 0x08
    2a1e:	99 85       	ldd	r25, Y+9	; 0x09
    2a20:	82 0f       	add	r24, r18
    2a22:	93 1f       	adc	r25, r19
    2a24:	fc 01       	movw	r30, r24
    2a26:	80 81       	ld	r24, Z
    2a28:	8e 32       	cpi	r24, 0x2E	; 46
    2a2a:	a1 f0       	breq	.+40     	; 0x2a54 <_Z11ReceiveGAVRv+0x60a>
    2a2c:	9e 01       	movw	r18, r28
    2a2e:	2e 59       	subi	r18, 0x9E	; 158
    2a30:	3f 4f       	sbci	r19, 0xFF	; 255
    2a32:	88 85       	ldd	r24, Y+8	; 0x08
    2a34:	99 85       	ldd	r25, Y+9	; 0x09
    2a36:	82 0f       	add	r24, r18
    2a38:	93 1f       	adc	r25, r19
    2a3a:	fc 01       	movw	r30, r24
    2a3c:	80 81       	ld	r24, Z
    2a3e:	88 23       	and	r24, r24
    2a40:	49 f0       	breq	.+18     	; 0x2a54 <_Z11ReceiveGAVRv+0x60a>
    2a42:	28 85       	ldd	r18, Y+8	; 0x08
    2a44:	39 85       	ldd	r19, Y+9	; 0x09
    2a46:	8b 81       	ldd	r24, Y+3	; 0x03
    2a48:	9c 81       	ldd	r25, Y+4	; 0x04
    2a4a:	28 17       	cp	r18, r24
    2a4c:	39 07       	cpc	r19, r25
    2a4e:	11 f0       	breq	.+4      	; 0x2a54 <_Z11ReceiveGAVRv+0x60a>
    2a50:	81 e0       	ldi	r24, 0x01	; 1
    2a52:	01 c0       	rjmp	.+2      	; 0x2a56 <_Z11ReceiveGAVRv+0x60c>
    2a54:	80 e0       	ldi	r24, 0x00	; 0
    2a56:	88 23       	and	r24, r24
    2a58:	09 f0       	breq	.+2      	; 0x2a5c <_Z11ReceiveGAVRv+0x612>
    2a5a:	6a cf       	rjmp	.-300    	; 0x2930 <_Z11ReceiveGAVRv+0x4e6>
								placement=0;
							} else;
							counter++;							
						}//end while
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
    2a5c:	9e 01       	movw	r18, r28
    2a5e:	2e 59       	subi	r18, 0x9E	; 158
    2a60:	3f 4f       	sbci	r19, 0xFF	; 255
    2a62:	88 85       	ldd	r24, Y+8	; 0x08
    2a64:	99 85       	ldd	r25, Y+9	; 0x09
    2a66:	82 0f       	add	r24, r18
    2a68:	93 1f       	adc	r25, r19
    2a6a:	fc 01       	movw	r30, r24
    2a6c:	80 81       	ld	r24, Z
    2a6e:	8e 32       	cpi	r24, 0x2E	; 46
    2a70:	a9 f4       	brne	.+42     	; 0x2a9c <_Z11ReceiveGAVRv+0x652>
							tempNum1[dmy] = atoi(tempStringNum);
    2a72:	ce 01       	movw	r24, r28
    2a74:	83 5a       	subi	r24, 0xA3	; 163
    2a76:	9f 4f       	sbci	r25, 0xFF	; 255
    2a78:	0e 94 db 22 	call	0x45b6	; 0x45b6 <atoi>
    2a7c:	9c 01       	movw	r18, r24
    2a7e:	ae 01       	movw	r20, r28
    2a80:	49 5a       	subi	r20, 0xA9	; 169
    2a82:	5f 4f       	sbci	r21, 0xFF	; 255
    2a84:	8a 85       	ldd	r24, Y+10	; 0x0a
    2a86:	9b 85       	ldd	r25, Y+11	; 0x0b
    2a88:	88 0f       	add	r24, r24
    2a8a:	99 1f       	adc	r25, r25
    2a8c:	84 0f       	add	r24, r20
    2a8e:	95 1f       	adc	r25, r21
    2a90:	fc 01       	movw	r30, r24
    2a92:	31 83       	std	Z+1, r19	; 0x01
    2a94:	20 83       	st	Z, r18
							successDate=fTrue;
    2a96:	81 e0       	ldi	r24, 0x01	; 1
    2a98:	8f 83       	std	Y+7, r24	; 0x07
    2a9a:	08 c0       	rjmp	.+16     	; 0x2aac <_Z11ReceiveGAVRv+0x662>
						} else {//something in the string was wrong, ACKBAD and then exit
							PrintGAVR("ACKBAD.");
    2a9c:	8d e0       	ldi	r24, 0x0D	; 13
    2a9e:	91 e0       	ldi	r25, 0x01	; 1
    2aa0:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
							state=5;
    2aa4:	85 e0       	ldi	r24, 0x05	; 5
    2aa6:	90 e0       	ldi	r25, 0x00	; 0
    2aa8:	9a 83       	std	Y+2, r25	; 0x02
    2aaa:	89 83       	std	Y+1, r24	; 0x01
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0 && successTime){
    2aac:	ce 01       	movw	r24, r28
    2aae:	8f 5a       	subi	r24, 0xAF	; 175
    2ab0:	9f 4f       	sbci	r25, 0xFF	; 255
    2ab2:	fc 01       	movw	r30, r24
    2ab4:	80 81       	ld	r24, Z
    2ab6:	91 81       	ldd	r25, Z+1	; 0x01
    2ab8:	47 96       	adiw	r24, 0x17	; 23
    2aba:	8f 32       	cpi	r24, 0x2F	; 47
    2abc:	91 05       	cpc	r25, r1
    2abe:	90 f5       	brcc	.+100    	; 0x2b24 <_Z11ReceiveGAVRv+0x6da>
    2ac0:	ce 01       	movw	r24, r28
    2ac2:	8f 5a       	subi	r24, 0xAF	; 175
    2ac4:	9f 4f       	sbci	r25, 0xFF	; 255
    2ac6:	fc 01       	movw	r30, r24
    2ac8:	82 81       	ldd	r24, Z+2	; 0x02
    2aca:	93 81       	ldd	r25, Z+3	; 0x03
    2acc:	cb 96       	adiw	r24, 0x3b	; 59
    2ace:	87 37       	cpi	r24, 0x77	; 119
    2ad0:	91 05       	cpc	r25, r1
    2ad2:	40 f5       	brcc	.+80     	; 0x2b24 <_Z11ReceiveGAVRv+0x6da>
    2ad4:	ce 01       	movw	r24, r28
    2ad6:	8f 5a       	subi	r24, 0xAF	; 175
    2ad8:	9f 4f       	sbci	r25, 0xFF	; 255
    2ada:	fc 01       	movw	r30, r24
    2adc:	84 81       	ldd	r24, Z+4	; 0x04
    2ade:	95 81       	ldd	r25, Z+5	; 0x05
    2ae0:	cb 96       	adiw	r24, 0x3b	; 59
    2ae2:	87 37       	cpi	r24, 0x77	; 119
    2ae4:	91 05       	cpc	r25, r1
    2ae6:	f0 f4       	brcc	.+60     	; 0x2b24 <_Z11ReceiveGAVRv+0x6da>
    2ae8:	8e 81       	ldd	r24, Y+6	; 0x06
    2aea:	88 23       	and	r24, r24
    2aec:	d9 f0       	breq	.+54     	; 0x2b24 <_Z11ReceiveGAVRv+0x6da>
							currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    2aee:	ce 01       	movw	r24, r28
    2af0:	8f 5a       	subi	r24, 0xAF	; 175
    2af2:	9f 4f       	sbci	r25, 0xFF	; 255
    2af4:	fc 01       	movw	r30, r24
    2af6:	60 81       	ld	r22, Z
    2af8:	71 81       	ldd	r23, Z+1	; 0x01
    2afa:	ce 01       	movw	r24, r28
    2afc:	8f 5a       	subi	r24, 0xAF	; 175
    2afe:	9f 4f       	sbci	r25, 0xFF	; 255
    2b00:	fc 01       	movw	r30, r24
    2b02:	42 81       	ldd	r20, Z+2	; 0x02
    2b04:	53 81       	ldd	r21, Z+3	; 0x03
    2b06:	ce 01       	movw	r24, r28
    2b08:	8f 5a       	subi	r24, 0xAF	; 175
    2b0a:	9f 4f       	sbci	r25, 0xFF	; 255
    2b0c:	fc 01       	movw	r30, r24
    2b0e:	24 81       	ldd	r18, Z+4	; 0x04
    2b10:	35 81       	ldd	r19, Z+5	; 0x05
    2b12:	82 e9       	ldi	r24, 0x92	; 146
    2b14:	91 e0       	ldi	r25, 0x01	; 1
    2b16:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
							saveDateTime_eeprom(fTrue,fFalse);
    2b1a:	81 e0       	ldi	r24, 0x01	; 1
    2b1c:	60 e0       	ldi	r22, 0x00	; 0
    2b1e:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    2b22:	08 c0       	rjmp	.+16     	; 0x2b34 <_Z11ReceiveGAVRv+0x6ea>
						} else {
							PrintGAVR("ACKBAD.");
    2b24:	8d e0       	ldi	r24, 0x0D	; 13
    2b26:	91 e0       	ldi	r25, 0x01	; 1
    2b28:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
							state=5;
    2b2c:	85 e0       	ldi	r24, 0x05	; 5
    2b2e:	90 e0       	ldi	r25, 0x00	; 0
    2b30:	9a 83       	std	Y+2, r25	; 0x02
    2b32:	89 83       	std	Y+1, r24	; 0x01
						}//end if-else time
						
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && successDate){
    2b34:	ce 01       	movw	r24, r28
    2b36:	89 5a       	subi	r24, 0xA9	; 169
    2b38:	9f 4f       	sbci	r25, 0xFF	; 255
    2b3a:	fc 01       	movw	r30, r24
    2b3c:	80 81       	ld	r24, Z
    2b3e:	91 81       	ldd	r25, Z+1	; 0x01
    2b40:	0c 96       	adiw	r24, 0x0c	; 12
    2b42:	89 31       	cpi	r24, 0x19	; 25
    2b44:	91 05       	cpc	r25, r1
    2b46:	b0 f5       	brcc	.+108    	; 0x2bb4 <_Z11ReceiveGAVRv+0x76a>
    2b48:	ce 01       	movw	r24, r28
    2b4a:	89 5a       	subi	r24, 0xA9	; 169
    2b4c:	9f 4f       	sbci	r25, 0xFF	; 255
    2b4e:	fc 01       	movw	r30, r24
    2b50:	82 81       	ldd	r24, Z+2	; 0x02
    2b52:	93 81       	ldd	r25, Z+3	; 0x03
    2b54:	4f 96       	adiw	r24, 0x1f	; 31
    2b56:	8f 33       	cpi	r24, 0x3F	; 63
    2b58:	91 05       	cpc	r25, r1
    2b5a:	60 f5       	brcc	.+88     	; 0x2bb4 <_Z11ReceiveGAVRv+0x76a>
    2b5c:	ce 01       	movw	r24, r28
    2b5e:	89 5a       	subi	r24, 0xA9	; 169
    2b60:	9f 4f       	sbci	r25, 0xFF	; 255
    2b62:	fc 01       	movw	r30, r24
    2b64:	84 81       	ldd	r24, Z+4	; 0x04
    2b66:	95 81       	ldd	r25, Z+5	; 0x05
    2b68:	f7 e0       	ldi	r31, 0x07	; 7
    2b6a:	80 3d       	cpi	r24, 0xD0	; 208
    2b6c:	9f 07       	cpc	r25, r31
    2b6e:	14 f1       	brlt	.+68     	; 0x2bb4 <_Z11ReceiveGAVRv+0x76a>
    2b70:	8f 81       	ldd	r24, Y+7	; 0x07
    2b72:	88 23       	and	r24, r24
    2b74:	f9 f0       	breq	.+62     	; 0x2bb4 <_Z11ReceiveGAVRv+0x76a>
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
    2b76:	ce 01       	movw	r24, r28
    2b78:	89 5a       	subi	r24, 0xA9	; 169
    2b7a:	9f 4f       	sbci	r25, 0xFF	; 255
    2b7c:	fc 01       	movw	r30, r24
    2b7e:	60 81       	ld	r22, Z
    2b80:	71 81       	ldd	r23, Z+1	; 0x01
    2b82:	ce 01       	movw	r24, r28
    2b84:	89 5a       	subi	r24, 0xA9	; 169
    2b86:	9f 4f       	sbci	r25, 0xFF	; 255
    2b88:	fc 01       	movw	r30, r24
    2b8a:	42 81       	ldd	r20, Z+2	; 0x02
    2b8c:	53 81       	ldd	r21, Z+3	; 0x03
    2b8e:	ce 01       	movw	r24, r28
    2b90:	89 5a       	subi	r24, 0xA9	; 169
    2b92:	9f 4f       	sbci	r25, 0xFF	; 255
    2b94:	fc 01       	movw	r30, r24
    2b96:	24 81       	ldd	r18, Z+4	; 0x04
    2b98:	35 81       	ldd	r19, Z+5	; 0x05
    2b9a:	82 e9       	ldi	r24, 0x92	; 146
    2b9c:	91 e0       	ldi	r25, 0x01	; 1
    2b9e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
							saveDateTime_eeprom(fFalse,fTrue);
    2ba2:	80 e0       	ldi	r24, 0x00	; 0
    2ba4:	61 e0       	ldi	r22, 0x01	; 1
    2ba6:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
							state=5;
							break;
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    2baa:	80 91 c2 01 	lds	r24, 0x01C2
    2bae:	88 23       	and	r24, r24
    2bb0:	51 f4       	brne	.+20     	; 0x2bc6 <_Z11ReceiveGAVRv+0x77c>
    2bb2:	18 c0       	rjmp	.+48     	; 0x2be4 <_Z11ReceiveGAVRv+0x79a>
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && successDate){
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
							saveDateTime_eeprom(fFalse,fTrue);
						} else {
							PrintGAVR("ACKBAD.");
    2bb4:	8d e0       	ldi	r24, 0x0D	; 13
    2bb6:	91 e0       	ldi	r25, 0x01	; 1
    2bb8:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
							state=5;
    2bbc:	85 e0       	ldi	r24, 0x05	; 5
    2bbe:	90 e0       	ldi	r25, 0x00	; 0
    2bc0:	9a 83       	std	Y+2, r25	; 0x02
    2bc2:	89 83       	std	Y+1, r24	; 0x01
							break;
    2bc4:	76 c2       	rjmp	.+1260   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    2bc6:	8f 81       	ldd	r24, Y+7	; 0x07
    2bc8:	88 23       	and	r24, r24
    2bca:	61 f0       	breq	.+24     	; 0x2be4 <_Z11ReceiveGAVRv+0x79a>
    2bcc:	8e 81       	ldd	r24, Y+6	; 0x06
    2bce:	88 23       	and	r24, r24
    2bd0:	49 f0       	breq	.+18     	; 0x2be4 <_Z11ReceiveGAVRv+0x79a>
							flagUserClock=fFalse;
    2bd2:	10 92 c2 01 	sts	0x01C2, r1
							flagWaitingForReceiveGAVR=fFalse;
    2bd6:	10 92 bd 01 	sts	0x01BD, r1
							state=7;					//Respond with correct string ACK
    2bda:	87 e0       	ldi	r24, 0x07	; 7
    2bdc:	90 e0       	ldi	r25, 0x00	; 0
    2bde:	9a 83       	std	Y+2, r25	; 0x02
    2be0:	89 83       	std	Y+1, r24	; 0x01
						PrintGAVR("ACKNO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    2be2:	67 c2       	rjmp	.+1230   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
						if (flagUserClock && successDate && successTime){
							flagUserClock=fFalse;
							flagWaitingForReceiveGAVR=fFalse;
							state=7;					//Respond with correct string ACK
						} else {
							PrintGAVR("ACKBAD.");
    2be4:	8d e0       	ldi	r24, 0x0D	; 13
    2be6:	91 e0       	ldi	r25, 0x01	; 1
    2be8:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
							state=5;
    2bec:	85 e0       	ldi	r24, 0x05	; 5
    2bee:	90 e0       	ldi	r25, 0x00	; 0
    2bf0:	9a 83       	std	Y+2, r25	; 0x02
    2bf2:	89 83       	std	Y+1, r24	; 0x01
						PrintGAVR("ACKNO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    2bf4:	5e c2       	rjmp	.+1212   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
						} else {
							PrintGAVR("ACKBAD.");
							state=5;
						}																										
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("ACKNO.");
    2bf6:	81 e7       	ldi	r24, 0x71	; 113
    2bf8:	91 e0       	ldi	r25, 0x01	; 1
    2bfa:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
						state=5;
    2bfe:	85 e0       	ldi	r24, 0x05	; 5
    2c00:	90 e0       	ldi	r25, 0x00	; 0
    2c02:	9a 83       	std	Y+2, r25	; 0x02
    2c04:	89 83       	std	Y+1, r24	; 0x01
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    2c06:	55 c2       	rjmp	.+1194   	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
    2c08:	80 e0       	ldi	r24, 0x00	; 0
    2c0a:	90 e0       	ldi	r25, 0x00	; 0
    2c0c:	a8 ec       	ldi	r26, 0xC8	; 200
    2c0e:	b2 e4       	ldi	r27, 0x42	; 66
    2c10:	8f a3       	lds	r24, 0x5f
    2c12:	98 a7       	lds	r25, 0x78
    2c14:	a9 a7       	lds	r26, 0x79
    2c16:	ba a7       	lds	r27, 0x7a
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    2c18:	6f a1       	lds	r22, 0x4f
    2c1a:	78 a5       	lds	r23, 0x68
    2c1c:	89 a5       	lds	r24, 0x69
    2c1e:	9a a5       	lds	r25, 0x6a
    2c20:	20 e0       	ldi	r18, 0x00	; 0
    2c22:	30 e0       	ldi	r19, 0x00	; 0
    2c24:	4a e7       	ldi	r20, 0x7A	; 122
    2c26:	53 e4       	ldi	r21, 0x43	; 67
    2c28:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    2c2c:	dc 01       	movw	r26, r24
    2c2e:	cb 01       	movw	r24, r22
    2c30:	8b a7       	lds	r24, 0x7b
    2c32:	9c a7       	lds	r25, 0x7c
    2c34:	ad a7       	lds	r26, 0x7d
    2c36:	be a7       	lds	r27, 0x7e
	if (__tmp < 1.0)
    2c38:	11 e0       	ldi	r17, 0x01	; 1
    2c3a:	6b a5       	lds	r22, 0x6b
    2c3c:	7c a5       	lds	r23, 0x6c
    2c3e:	8d a5       	lds	r24, 0x6d
    2c40:	9e a5       	lds	r25, 0x6e
    2c42:	20 e0       	ldi	r18, 0x00	; 0
    2c44:	30 e0       	ldi	r19, 0x00	; 0
    2c46:	40 e8       	ldi	r20, 0x80	; 128
    2c48:	5f e3       	ldi	r21, 0x3F	; 63
    2c4a:	0e 94 96 21 	call	0x432c	; 0x432c <__cmpsf2>
    2c4e:	88 23       	and	r24, r24
    2c50:	0c f0       	brlt	.+2      	; 0x2c54 <_Z11ReceiveGAVRv+0x80a>
    2c52:	10 e0       	ldi	r17, 0x00	; 0
    2c54:	11 23       	and	r17, r17
    2c56:	29 f0       	breq	.+10     	; 0x2c62 <_Z11ReceiveGAVRv+0x818>
		__ticks = 1;
    2c58:	81 e0       	ldi	r24, 0x01	; 1
    2c5a:	90 e0       	ldi	r25, 0x00	; 0
    2c5c:	98 ab       	sts	0x58, r25
    2c5e:	8f a7       	lds	r24, 0x7f
    2c60:	4a c0       	rjmp	.+148    	; 0x2cf6 <_Z11ReceiveGAVRv+0x8ac>
	else if (__tmp > 65535)
    2c62:	11 e0       	ldi	r17, 0x01	; 1
    2c64:	6b a5       	lds	r22, 0x6b
    2c66:	7c a5       	lds	r23, 0x6c
    2c68:	8d a5       	lds	r24, 0x6d
    2c6a:	9e a5       	lds	r25, 0x6e
    2c6c:	20 e0       	ldi	r18, 0x00	; 0
    2c6e:	3f ef       	ldi	r19, 0xFF	; 255
    2c70:	4f e7       	ldi	r20, 0x7F	; 127
    2c72:	57 e4       	ldi	r21, 0x47	; 71
    2c74:	0e 94 13 22 	call	0x4426	; 0x4426 <__gesf2>
    2c78:	18 16       	cp	r1, r24
    2c7a:	0c f0       	brlt	.+2      	; 0x2c7e <_Z11ReceiveGAVRv+0x834>
    2c7c:	10 e0       	ldi	r17, 0x00	; 0
    2c7e:	11 23       	and	r17, r17
    2c80:	81 f1       	breq	.+96     	; 0x2ce2 <_Z11ReceiveGAVRv+0x898>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2c82:	6f a1       	lds	r22, 0x4f
    2c84:	78 a5       	lds	r23, 0x68
    2c86:	89 a5       	lds	r24, 0x69
    2c88:	9a a5       	lds	r25, 0x6a
    2c8a:	20 e0       	ldi	r18, 0x00	; 0
    2c8c:	30 e0       	ldi	r19, 0x00	; 0
    2c8e:	40 e2       	ldi	r20, 0x20	; 32
    2c90:	51 e4       	ldi	r21, 0x41	; 65
    2c92:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    2c96:	dc 01       	movw	r26, r24
    2c98:	cb 01       	movw	r24, r22
    2c9a:	bc 01       	movw	r22, r24
    2c9c:	cd 01       	movw	r24, r26
    2c9e:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    2ca2:	dc 01       	movw	r26, r24
    2ca4:	cb 01       	movw	r24, r22
    2ca6:	98 ab       	sts	0x58, r25
    2ca8:	8f a7       	lds	r24, 0x7f
    2caa:	12 c0       	rjmp	.+36     	; 0x2cd0 <_Z11ReceiveGAVRv+0x886>
    2cac:	89 e1       	ldi	r24, 0x19	; 25
    2cae:	90 e0       	ldi	r25, 0x00	; 0
    2cb0:	9a ab       	sts	0x5a, r25
    2cb2:	89 ab       	sts	0x59, r24
    2cb4:	89 a9       	sts	0x49, r24
    2cb6:	9a a9       	sts	0x4a, r25
    2cb8:	8c 01       	movw	r16, r24
    2cba:	c8 01       	movw	r24, r16
    2cbc:	01 97       	sbiw	r24, 0x01	; 1
    2cbe:	f1 f7       	brne	.-4      	; 0x2cbc <_Z11ReceiveGAVRv+0x872>
    2cc0:	8c 01       	movw	r16, r24
    2cc2:	1a ab       	sts	0x5a, r17
    2cc4:	09 ab       	sts	0x59, r16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2cc6:	8f a5       	lds	r24, 0x6f
    2cc8:	98 a9       	sts	0x48, r25
    2cca:	01 97       	sbiw	r24, 0x01	; 1
    2ccc:	98 ab       	sts	0x58, r25
    2cce:	8f a7       	lds	r24, 0x7f
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2cd0:	21 e0       	ldi	r18, 0x01	; 1
    2cd2:	8f a5       	lds	r24, 0x6f
    2cd4:	98 a9       	sts	0x48, r25
    2cd6:	00 97       	sbiw	r24, 0x00	; 0
    2cd8:	09 f4       	brne	.+2      	; 0x2cdc <_Z11ReceiveGAVRv+0x892>
    2cda:	20 e0       	ldi	r18, 0x00	; 0
    2cdc:	22 23       	and	r18, r18
    2cde:	31 f7       	brne	.-52     	; 0x2cac <_Z11ReceiveGAVRv+0x862>
    2ce0:	17 c0       	rjmp	.+46     	; 0x2d10 <_Z11ReceiveGAVRv+0x8c6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2ce2:	6b a5       	lds	r22, 0x6b
    2ce4:	7c a5       	lds	r23, 0x6c
    2ce6:	8d a5       	lds	r24, 0x6d
    2ce8:	9e a5       	lds	r25, 0x6e
    2cea:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    2cee:	dc 01       	movw	r26, r24
    2cf0:	cb 01       	movw	r24, r22
    2cf2:	98 ab       	sts	0x58, r25
    2cf4:	8f a7       	lds	r24, 0x7f
    2cf6:	8f a5       	lds	r24, 0x6f
    2cf8:	98 a9       	sts	0x48, r25
    2cfa:	9c ab       	sts	0x5c, r25
    2cfc:	8b ab       	sts	0x5b, r24
    2cfe:	8b a9       	sts	0x4b, r24
    2d00:	9c a9       	sts	0x4c, r25
    2d02:	8c 01       	movw	r16, r24
    2d04:	f8 01       	movw	r30, r16
    2d06:	31 97       	sbiw	r30, 0x01	; 1
    2d08:	f1 f7       	brne	.-4      	; 0x2d06 <_Z11ReceiveGAVRv+0x8bc>
    2d0a:	8f 01       	movw	r16, r30
    2d0c:	1c ab       	sts	0x5c, r17
    2d0e:	0b ab       	sts	0x5b, r16
					}//end case 3				
				case 4:{
					_delay_ms(100);
					//Successful SYNNEED case.
					if (!flagUserClock){	//If we don't need the date or time, update with what we have.
    2d10:	80 91 c2 01 	lds	r24, 0x01C2
    2d14:	88 23       	and	r24, r24
    2d16:	41 f4       	brne	.+16     	; 0x2d28 <_Z11ReceiveGAVRv+0x8de>
						flagUpdateGAVRClock=fTrue;
    2d18:	81 e0       	ldi	r24, 0x01	; 1
    2d1a:	80 93 c0 01 	sts	0x01C0, r24
						PrintGAVR("ACKNEED.");				//respond with correct ack
    2d1e:	88 e7       	ldi	r24, 0x78	; 120
    2d20:	91 e0       	ldi	r25, 0x01	; 1
    2d22:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
    2d26:	04 c0       	rjmp	.+8      	; 0x2d30 <_Z11ReceiveGAVRv+0x8e6>
					} else {
						PrintGAVR("ACKNO.");	//say we can't give you anything, ask the user.
    2d28:	81 e7       	ldi	r24, 0x71	; 113
    2d2a:	91 e0       	ldi	r25, 0x01	; 1
    2d2c:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
						//Should be expecting something from the GAVR with user date and time, this reminds the GAVR.
					} //end if-else
					state=5;
    2d30:	85 e0       	ldi	r24, 0x05	; 5
    2d32:	90 e0       	ldi	r25, 0x00	; 0
    2d34:	9a 83       	std	Y+2, r25	; 0x02
    2d36:	89 83       	std	Y+1, r24	; 0x01
					break;					
    2d38:	bc c1       	rjmp	.+888    	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
				}//end case 4
				case 5:{
					//Exit case
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    2d3a:	1f 8a       	std	Y+23, r1	; 0x17
    2d3c:	1e 8a       	std	Y+22, r1	; 0x16
    2d3e:	0e c0       	rjmp	.+28     	; 0x2d5c <_Z11ReceiveGAVRv+0x912>
    2d40:	9e 01       	movw	r18, r28
    2d42:	2e 59       	subi	r18, 0x9E	; 158
    2d44:	3f 4f       	sbci	r19, 0xFF	; 255
    2d46:	8e 89       	ldd	r24, Y+22	; 0x16
    2d48:	9f 89       	ldd	r25, Y+23	; 0x17
    2d4a:	82 0f       	add	r24, r18
    2d4c:	93 1f       	adc	r25, r19
    2d4e:	fc 01       	movw	r30, r24
    2d50:	10 82       	st	Z, r1
    2d52:	8e 89       	ldd	r24, Y+22	; 0x16
    2d54:	9f 89       	ldd	r25, Y+23	; 0x17
    2d56:	01 96       	adiw	r24, 0x01	; 1
    2d58:	9f 8b       	std	Y+23, r25	; 0x17
    2d5a:	8e 8b       	std	Y+22, r24	; 0x16
    2d5c:	2e 89       	ldd	r18, Y+22	; 0x16
    2d5e:	3f 89       	ldd	r19, Y+23	; 0x17
    2d60:	41 e0       	ldi	r20, 0x01	; 1
    2d62:	8b 81       	ldd	r24, Y+3	; 0x03
    2d64:	9c 81       	ldd	r25, Y+4	; 0x04
    2d66:	28 17       	cp	r18, r24
    2d68:	39 07       	cpc	r19, r25
    2d6a:	08 f0       	brcs	.+2      	; 0x2d6e <_Z11ReceiveGAVRv+0x924>
    2d6c:	40 e0       	ldi	r20, 0x00	; 0
    2d6e:	44 23       	and	r20, r20
    2d70:	39 f7       	brne	.-50     	; 0x2d40 <_Z11ReceiveGAVRv+0x8f6>
					flagReceivingGAVR=fFalse;
    2d72:	10 92 bc 01 	sts	0x01BC, r1
					state=0;		//just in case
    2d76:	1a 82       	std	Y+2, r1	; 0x02
    2d78:	19 82       	std	Y+1, r1	; 0x01
					break;
    2d7a:	9b c1       	rjmp	.+822    	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
    2d7c:	80 e0       	ldi	r24, 0x00	; 0
    2d7e:	90 e0       	ldi	r25, 0x00	; 0
    2d80:	a8 ec       	ldi	r26, 0xC8	; 200
    2d82:	b2 e4       	ldi	r27, 0x42	; 66
    2d84:	8d ab       	sts	0x5d, r24
    2d86:	9e ab       	sts	0x5e, r25
    2d88:	af ab       	sts	0x5f, r26
    2d8a:	b8 af       	sts	0x78, r27
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    2d8c:	6d a9       	sts	0x4d, r22
    2d8e:	7e a9       	sts	0x4e, r23
    2d90:	8f a9       	sts	0x4f, r24
    2d92:	98 ad       	sts	0x68, r25
    2d94:	20 e0       	ldi	r18, 0x00	; 0
    2d96:	30 e0       	ldi	r19, 0x00	; 0
    2d98:	4a e7       	ldi	r20, 0x7A	; 122
    2d9a:	53 e4       	ldi	r21, 0x43	; 67
    2d9c:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    2da0:	dc 01       	movw	r26, r24
    2da2:	cb 01       	movw	r24, r22
    2da4:	89 af       	sts	0x79, r24
    2da6:	9a af       	sts	0x7a, r25
    2da8:	ab af       	sts	0x7b, r26
    2daa:	bc af       	sts	0x7c, r27
	if (__tmp < 1.0)
    2dac:	11 e0       	ldi	r17, 0x01	; 1
    2dae:	69 ad       	sts	0x69, r22
    2db0:	7a ad       	sts	0x6a, r23
    2db2:	8b ad       	sts	0x6b, r24
    2db4:	9c ad       	sts	0x6c, r25
    2db6:	20 e0       	ldi	r18, 0x00	; 0
    2db8:	30 e0       	ldi	r19, 0x00	; 0
    2dba:	40 e8       	ldi	r20, 0x80	; 128
    2dbc:	5f e3       	ldi	r21, 0x3F	; 63
    2dbe:	0e 94 96 21 	call	0x432c	; 0x432c <__cmpsf2>
    2dc2:	88 23       	and	r24, r24
    2dc4:	0c f0       	brlt	.+2      	; 0x2dc8 <_Z11ReceiveGAVRv+0x97e>
    2dc6:	10 e0       	ldi	r17, 0x00	; 0
    2dc8:	11 23       	and	r17, r17
    2dca:	29 f0       	breq	.+10     	; 0x2dd6 <_Z11ReceiveGAVRv+0x98c>
		__ticks = 1;
    2dcc:	81 e0       	ldi	r24, 0x01	; 1
    2dce:	90 e0       	ldi	r25, 0x00	; 0
    2dd0:	9e af       	sts	0x7e, r25
    2dd2:	8d af       	sts	0x7d, r24
    2dd4:	53 c0       	rjmp	.+166    	; 0x2e7c <_Z11ReceiveGAVRv+0xa32>
	else if (__tmp > 65535)
    2dd6:	11 e0       	ldi	r17, 0x01	; 1
    2dd8:	69 ad       	sts	0x69, r22
    2dda:	7a ad       	sts	0x6a, r23
    2ddc:	8b ad       	sts	0x6b, r24
    2dde:	9c ad       	sts	0x6c, r25
    2de0:	20 e0       	ldi	r18, 0x00	; 0
    2de2:	3f ef       	ldi	r19, 0xFF	; 255
    2de4:	4f e7       	ldi	r20, 0x7F	; 127
    2de6:	57 e4       	ldi	r21, 0x47	; 71
    2de8:	0e 94 13 22 	call	0x4426	; 0x4426 <__gesf2>
    2dec:	18 16       	cp	r1, r24
    2dee:	0c f0       	brlt	.+2      	; 0x2df2 <_Z11ReceiveGAVRv+0x9a8>
    2df0:	10 e0       	ldi	r17, 0x00	; 0
    2df2:	11 23       	and	r17, r17
    2df4:	c9 f1       	breq	.+114    	; 0x2e68 <_Z11ReceiveGAVRv+0xa1e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2df6:	6d a9       	sts	0x4d, r22
    2df8:	7e a9       	sts	0x4e, r23
    2dfa:	8f a9       	sts	0x4f, r24
    2dfc:	98 ad       	sts	0x68, r25
    2dfe:	20 e0       	ldi	r18, 0x00	; 0
    2e00:	30 e0       	ldi	r19, 0x00	; 0
    2e02:	40 e2       	ldi	r20, 0x20	; 32
    2e04:	51 e4       	ldi	r21, 0x41	; 65
    2e06:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    2e0a:	dc 01       	movw	r26, r24
    2e0c:	cb 01       	movw	r24, r22
    2e0e:	bc 01       	movw	r22, r24
    2e10:	cd 01       	movw	r24, r26
    2e12:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    2e16:	dc 01       	movw	r26, r24
    2e18:	cb 01       	movw	r24, r22
    2e1a:	9e af       	sts	0x7e, r25
    2e1c:	8d af       	sts	0x7d, r24
    2e1e:	1b c0       	rjmp	.+54     	; 0x2e56 <_Z11ReceiveGAVRv+0xa0c>
    2e20:	29 e1       	ldi	r18, 0x19	; 25
    2e22:	30 e0       	ldi	r19, 0x00	; 0
    2e24:	ce 01       	movw	r24, r28
    2e26:	cf 96       	adiw	r24, 0x3f	; 63
    2e28:	fc 01       	movw	r30, r24
    2e2a:	31 83       	std	Z+1, r19	; 0x01
    2e2c:	20 83       	st	Z, r18
    2e2e:	ce 01       	movw	r24, r28
    2e30:	cf 96       	adiw	r24, 0x3f	; 63
    2e32:	fc 01       	movw	r30, r24
    2e34:	80 81       	ld	r24, Z
    2e36:	91 81       	ldd	r25, Z+1	; 0x01
    2e38:	8c 01       	movw	r16, r24
    2e3a:	c8 01       	movw	r24, r16
    2e3c:	01 97       	sbiw	r24, 0x01	; 1
    2e3e:	f1 f7       	brne	.-4      	; 0x2e3c <_Z11ReceiveGAVRv+0x9f2>
    2e40:	8c 01       	movw	r16, r24
    2e42:	ce 01       	movw	r24, r28
    2e44:	cf 96       	adiw	r24, 0x3f	; 63
    2e46:	fc 01       	movw	r30, r24
    2e48:	11 83       	std	Z+1, r17	; 0x01
    2e4a:	00 83       	st	Z, r16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2e4c:	8d ad       	sts	0x6d, r24
    2e4e:	9e ad       	sts	0x6e, r25
    2e50:	01 97       	sbiw	r24, 0x01	; 1
    2e52:	9e af       	sts	0x7e, r25
    2e54:	8d af       	sts	0x7d, r24
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2e56:	21 e0       	ldi	r18, 0x01	; 1
    2e58:	8d ad       	sts	0x6d, r24
    2e5a:	9e ad       	sts	0x6e, r25
    2e5c:	00 97       	sbiw	r24, 0x00	; 0
    2e5e:	09 f4       	brne	.+2      	; 0x2e62 <_Z11ReceiveGAVRv+0xa18>
    2e60:	20 e0       	ldi	r18, 0x00	; 0
    2e62:	22 23       	and	r18, r18
    2e64:	e9 f6       	brne	.-70     	; 0x2e20 <_Z11ReceiveGAVRv+0x9d6>
    2e66:	23 c0       	rjmp	.+70     	; 0x2eae <_Z11ReceiveGAVRv+0xa64>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2e68:	69 ad       	sts	0x69, r22
    2e6a:	7a ad       	sts	0x6a, r23
    2e6c:	8b ad       	sts	0x6b, r24
    2e6e:	9c ad       	sts	0x6c, r25
    2e70:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    2e74:	dc 01       	movw	r26, r24
    2e76:	cb 01       	movw	r24, r22
    2e78:	9e af       	sts	0x7e, r25
    2e7a:	8d af       	sts	0x7d, r24
    2e7c:	ce 01       	movw	r24, r28
    2e7e:	8f 5b       	subi	r24, 0xBF	; 191
    2e80:	9f 4f       	sbci	r25, 0xFF	; 255
    2e82:	2d ad       	sts	0x6d, r18
    2e84:	3e ad       	sts	0x6e, r19
    2e86:	fc 01       	movw	r30, r24
    2e88:	31 83       	std	Z+1, r19	; 0x01
    2e8a:	20 83       	st	Z, r18
    2e8c:	ce 01       	movw	r24, r28
    2e8e:	8f 5b       	subi	r24, 0xBF	; 191
    2e90:	9f 4f       	sbci	r25, 0xFF	; 255
    2e92:	fc 01       	movw	r30, r24
    2e94:	80 81       	ld	r24, Z
    2e96:	91 81       	ldd	r25, Z+1	; 0x01
    2e98:	8c 01       	movw	r16, r24
    2e9a:	c8 01       	movw	r24, r16
    2e9c:	01 97       	sbiw	r24, 0x01	; 1
    2e9e:	f1 f7       	brne	.-4      	; 0x2e9c <_Z11ReceiveGAVRv+0xa52>
    2ea0:	8c 01       	movw	r16, r24
    2ea2:	ce 01       	movw	r24, r28
    2ea4:	8f 5b       	subi	r24, 0xBF	; 191
    2ea6:	9f 4f       	sbci	r25, 0xFF	; 255
    2ea8:	fc 01       	movw	r30, r24
    2eaa:	11 83       	std	Z+1, r17	; 0x01
    2eac:	00 83       	st	Z, r16
				}//end case 5
				case 6:{
					//Error in ACK case
					_delay_ms(100);
					PrintGAVR("ACKERROR.");
    2eae:	8e e5       	ldi	r24, 0x5E	; 94
    2eb0:	91 e0       	ldi	r25, 0x01	; 1
    2eb2:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
					state=5;
    2eb6:	85 e0       	ldi	r24, 0x05	; 5
    2eb8:	90 e0       	ldi	r25, 0x00	; 0
    2eba:	9a 83       	std	Y+2, r25	; 0x02
    2ebc:	89 83       	std	Y+1, r24	; 0x01
					break;
    2ebe:	f9 c0       	rjmp	.+498    	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
    2ec0:	9e 01       	movw	r18, r28
    2ec2:	2d 5b       	subi	r18, 0xBD	; 189
    2ec4:	3f 4f       	sbci	r19, 0xFF	; 255
    2ec6:	80 e0       	ldi	r24, 0x00	; 0
    2ec8:	90 e0       	ldi	r25, 0x00	; 0
    2eca:	a8 ec       	ldi	r26, 0xC8	; 200
    2ecc:	b2 e4       	ldi	r27, 0x42	; 66
    2ece:	f9 01       	movw	r30, r18
    2ed0:	80 83       	st	Z, r24
    2ed2:	91 83       	std	Z+1, r25	; 0x01
    2ed4:	a2 83       	std	Z+2, r26	; 0x02
    2ed6:	b3 83       	std	Z+3, r27	; 0x03
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	__tmp = ((F_CPU) / 4e3) * __ms;
    2ed8:	8e 01       	movw	r16, r28
    2eda:	09 5b       	subi	r16, 0xB9	; 185
    2edc:	1f 4f       	sbci	r17, 0xFF	; 255
    2ede:	ce 01       	movw	r24, r28
    2ee0:	8d 5b       	subi	r24, 0xBD	; 189
    2ee2:	9f 4f       	sbci	r25, 0xFF	; 255
    2ee4:	fc 01       	movw	r30, r24
    2ee6:	60 81       	ld	r22, Z
    2ee8:	71 81       	ldd	r23, Z+1	; 0x01
    2eea:	82 81       	ldd	r24, Z+2	; 0x02
    2eec:	93 81       	ldd	r25, Z+3	; 0x03
    2eee:	20 e0       	ldi	r18, 0x00	; 0
    2ef0:	30 e0       	ldi	r19, 0x00	; 0
    2ef2:	4a e7       	ldi	r20, 0x7A	; 122
    2ef4:	53 e4       	ldi	r21, 0x43	; 67
    2ef6:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    2efa:	dc 01       	movw	r26, r24
    2efc:	cb 01       	movw	r24, r22
    2efe:	f8 01       	movw	r30, r16
    2f00:	80 83       	st	Z, r24
    2f02:	91 83       	std	Z+1, r25	; 0x01
    2f04:	a2 83       	std	Z+2, r26	; 0x02
    2f06:	b3 83       	std	Z+3, r27	; 0x03
	if (__tmp < 1.0)
    2f08:	ce 01       	movw	r24, r28
    2f0a:	89 5b       	subi	r24, 0xB9	; 185
    2f0c:	9f 4f       	sbci	r25, 0xFF	; 255
    2f0e:	11 e0       	ldi	r17, 0x01	; 1
    2f10:	fc 01       	movw	r30, r24
    2f12:	60 81       	ld	r22, Z
    2f14:	71 81       	ldd	r23, Z+1	; 0x01
    2f16:	82 81       	ldd	r24, Z+2	; 0x02
    2f18:	93 81       	ldd	r25, Z+3	; 0x03
    2f1a:	20 e0       	ldi	r18, 0x00	; 0
    2f1c:	30 e0       	ldi	r19, 0x00	; 0
    2f1e:	40 e8       	ldi	r20, 0x80	; 128
    2f20:	5f e3       	ldi	r21, 0x3F	; 63
    2f22:	0e 94 96 21 	call	0x432c	; 0x432c <__cmpsf2>
    2f26:	88 23       	and	r24, r24
    2f28:	0c f0       	brlt	.+2      	; 0x2f2c <_Z11ReceiveGAVRv+0xae2>
    2f2a:	10 e0       	ldi	r17, 0x00	; 0
    2f2c:	11 23       	and	r17, r17
    2f2e:	49 f0       	breq	.+18     	; 0x2f42 <_Z11ReceiveGAVRv+0xaf8>
		__ticks = 1;
    2f30:	ce 01       	movw	r24, r28
    2f32:	85 5b       	subi	r24, 0xB5	; 181
    2f34:	9f 4f       	sbci	r25, 0xFF	; 255
    2f36:	21 e0       	ldi	r18, 0x01	; 1
    2f38:	30 e0       	ldi	r19, 0x00	; 0
    2f3a:	fc 01       	movw	r30, r24
    2f3c:	31 83       	std	Z+1, r19	; 0x01
    2f3e:	20 83       	st	Z, r18
    2f40:	78 c0       	rjmp	.+240    	; 0x3032 <_Z11ReceiveGAVRv+0xbe8>
	else if (__tmp > 65535)
    2f42:	ce 01       	movw	r24, r28
    2f44:	89 5b       	subi	r24, 0xB9	; 185
    2f46:	9f 4f       	sbci	r25, 0xFF	; 255
    2f48:	11 e0       	ldi	r17, 0x01	; 1
    2f4a:	fc 01       	movw	r30, r24
    2f4c:	60 81       	ld	r22, Z
    2f4e:	71 81       	ldd	r23, Z+1	; 0x01
    2f50:	82 81       	ldd	r24, Z+2	; 0x02
    2f52:	93 81       	ldd	r25, Z+3	; 0x03
    2f54:	20 e0       	ldi	r18, 0x00	; 0
    2f56:	3f ef       	ldi	r19, 0xFF	; 255
    2f58:	4f e7       	ldi	r20, 0x7F	; 127
    2f5a:	57 e4       	ldi	r21, 0x47	; 71
    2f5c:	0e 94 13 22 	call	0x4426	; 0x4426 <__gesf2>
    2f60:	18 16       	cp	r1, r24
    2f62:	0c f0       	brlt	.+2      	; 0x2f66 <_Z11ReceiveGAVRv+0xb1c>
    2f64:	10 e0       	ldi	r17, 0x00	; 0
    2f66:	11 23       	and	r17, r17
    2f68:	09 f4       	brne	.+2      	; 0x2f6c <_Z11ReceiveGAVRv+0xb22>
    2f6a:	51 c0       	rjmp	.+162    	; 0x300e <_Z11ReceiveGAVRv+0xbc4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    2f6c:	ce 01       	movw	r24, r28
    2f6e:	8d 5b       	subi	r24, 0xBD	; 189
    2f70:	9f 4f       	sbci	r25, 0xFF	; 255
    2f72:	fc 01       	movw	r30, r24
    2f74:	60 81       	ld	r22, Z
    2f76:	71 81       	ldd	r23, Z+1	; 0x01
    2f78:	82 81       	ldd	r24, Z+2	; 0x02
    2f7a:	93 81       	ldd	r25, Z+3	; 0x03
    2f7c:	20 e0       	ldi	r18, 0x00	; 0
    2f7e:	30 e0       	ldi	r19, 0x00	; 0
    2f80:	40 e2       	ldi	r20, 0x20	; 32
    2f82:	51 e4       	ldi	r21, 0x41	; 65
    2f84:	0e 94 17 22 	call	0x442e	; 0x442e <__mulsf3>
    2f88:	dc 01       	movw	r26, r24
    2f8a:	cb 01       	movw	r24, r22
    2f8c:	8e 01       	movw	r16, r28
    2f8e:	05 5b       	subi	r16, 0xB5	; 181
    2f90:	1f 4f       	sbci	r17, 0xFF	; 255
    2f92:	bc 01       	movw	r22, r24
    2f94:	cd 01       	movw	r24, r26
    2f96:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    2f9a:	dc 01       	movw	r26, r24
    2f9c:	cb 01       	movw	r24, r22
    2f9e:	f8 01       	movw	r30, r16
    2fa0:	91 83       	std	Z+1, r25	; 0x01
    2fa2:	80 83       	st	Z, r24
    2fa4:	27 c0       	rjmp	.+78     	; 0x2ff4 <_Z11ReceiveGAVRv+0xbaa>
    2fa6:	ce 01       	movw	r24, r28
    2fa8:	83 5b       	subi	r24, 0xB3	; 179
    2faa:	9f 4f       	sbci	r25, 0xFF	; 255
    2fac:	29 e1       	ldi	r18, 0x19	; 25
    2fae:	30 e0       	ldi	r19, 0x00	; 0
    2fb0:	fc 01       	movw	r30, r24
    2fb2:	31 83       	std	Z+1, r19	; 0x01
    2fb4:	20 83       	st	Z, r18
    2fb6:	ce 01       	movw	r24, r28
    2fb8:	83 5b       	subi	r24, 0xB3	; 179
    2fba:	9f 4f       	sbci	r25, 0xFF	; 255
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	80 81       	ld	r24, Z
    2fc0:	91 81       	ldd	r25, Z+1	; 0x01
    2fc2:	8c 01       	movw	r16, r24
    2fc4:	c8 01       	movw	r24, r16
    2fc6:	01 97       	sbiw	r24, 0x01	; 1
    2fc8:	f1 f7       	brne	.-4      	; 0x2fc6 <_Z11ReceiveGAVRv+0xb7c>
    2fca:	8c 01       	movw	r16, r24
    2fcc:	ce 01       	movw	r24, r28
    2fce:	83 5b       	subi	r24, 0xB3	; 179
    2fd0:	9f 4f       	sbci	r25, 0xFF	; 255
    2fd2:	fc 01       	movw	r30, r24
    2fd4:	11 83       	std	Z+1, r17	; 0x01
    2fd6:	00 83       	st	Z, r16
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2fd8:	ce 01       	movw	r24, r28
    2fda:	85 5b       	subi	r24, 0xB5	; 181
    2fdc:	9f 4f       	sbci	r25, 0xFF	; 255
    2fde:	9e 01       	movw	r18, r28
    2fe0:	25 5b       	subi	r18, 0xB5	; 181
    2fe2:	3f 4f       	sbci	r19, 0xFF	; 255
    2fe4:	f9 01       	movw	r30, r18
    2fe6:	20 81       	ld	r18, Z
    2fe8:	31 81       	ldd	r19, Z+1	; 0x01
    2fea:	21 50       	subi	r18, 0x01	; 1
    2fec:	30 40       	sbci	r19, 0x00	; 0
    2fee:	fc 01       	movw	r30, r24
    2ff0:	31 83       	std	Z+1, r19	; 0x01
    2ff2:	20 83       	st	Z, r18
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2ff4:	ce 01       	movw	r24, r28
    2ff6:	85 5b       	subi	r24, 0xB5	; 181
    2ff8:	9f 4f       	sbci	r25, 0xFF	; 255
    2ffa:	21 e0       	ldi	r18, 0x01	; 1
    2ffc:	fc 01       	movw	r30, r24
    2ffe:	80 81       	ld	r24, Z
    3000:	91 81       	ldd	r25, Z+1	; 0x01
    3002:	00 97       	sbiw	r24, 0x00	; 0
    3004:	09 f4       	brne	.+2      	; 0x3008 <_Z11ReceiveGAVRv+0xbbe>
    3006:	20 e0       	ldi	r18, 0x00	; 0
    3008:	22 23       	and	r18, r18
    300a:	69 f6       	brne	.-102    	; 0x2fa6 <_Z11ReceiveGAVRv+0xb5c>
    300c:	2f c0       	rjmp	.+94     	; 0x306c <_Z11ReceiveGAVRv+0xc22>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    300e:	8e 01       	movw	r16, r28
    3010:	05 5b       	subi	r16, 0xB5	; 181
    3012:	1f 4f       	sbci	r17, 0xFF	; 255
    3014:	ce 01       	movw	r24, r28
    3016:	89 5b       	subi	r24, 0xB9	; 185
    3018:	9f 4f       	sbci	r25, 0xFF	; 255
    301a:	fc 01       	movw	r30, r24
    301c:	60 81       	ld	r22, Z
    301e:	71 81       	ldd	r23, Z+1	; 0x01
    3020:	82 81       	ldd	r24, Z+2	; 0x02
    3022:	93 81       	ldd	r25, Z+3	; 0x03
    3024:	0e 94 9a 21 	call	0x4334	; 0x4334 <__fixunssfsi>
    3028:	dc 01       	movw	r26, r24
    302a:	cb 01       	movw	r24, r22
    302c:	f8 01       	movw	r30, r16
    302e:	91 83       	std	Z+1, r25	; 0x01
    3030:	80 83       	st	Z, r24
    3032:	ce 01       	movw	r24, r28
    3034:	81 5b       	subi	r24, 0xB1	; 177
    3036:	9f 4f       	sbci	r25, 0xFF	; 255
    3038:	9e 01       	movw	r18, r28
    303a:	25 5b       	subi	r18, 0xB5	; 181
    303c:	3f 4f       	sbci	r19, 0xFF	; 255
    303e:	f9 01       	movw	r30, r18
    3040:	20 81       	ld	r18, Z
    3042:	31 81       	ldd	r19, Z+1	; 0x01
    3044:	fc 01       	movw	r30, r24
    3046:	31 83       	std	Z+1, r19	; 0x01
    3048:	20 83       	st	Z, r18
    304a:	ce 01       	movw	r24, r28
    304c:	81 5b       	subi	r24, 0xB1	; 177
    304e:	9f 4f       	sbci	r25, 0xFF	; 255
    3050:	fc 01       	movw	r30, r24
    3052:	80 81       	ld	r24, Z
    3054:	91 81       	ldd	r25, Z+1	; 0x01
    3056:	8c 01       	movw	r16, r24
    3058:	c8 01       	movw	r24, r16
    305a:	01 97       	sbiw	r24, 0x01	; 1
    305c:	f1 f7       	brne	.-4      	; 0x305a <_Z11ReceiveGAVRv+0xc10>
    305e:	8c 01       	movw	r16, r24
    3060:	ce 01       	movw	r24, r28
    3062:	81 5b       	subi	r24, 0xB1	; 177
    3064:	9f 4f       	sbci	r25, 0xFF	; 255
    3066:	fc 01       	movw	r30, r24
    3068:	11 83       	std	Z+1, r17	; 0x01
    306a:	00 83       	st	Z, r16
				}//end case 6
				case 7:{
					_delay_ms(100);
					//Successful grab of date/time case
					recString[0]='A';
    306c:	ce 01       	movw	r24, r28
    306e:	8e 59       	subi	r24, 0x9E	; 158
    3070:	9f 4f       	sbci	r25, 0xFF	; 255
    3072:	21 e4       	ldi	r18, 0x41	; 65
    3074:	fc 01       	movw	r30, r24
    3076:	20 83       	st	Z, r18
					recString[1]='C';
    3078:	ce 01       	movw	r24, r28
    307a:	8e 59       	subi	r24, 0x9E	; 158
    307c:	9f 4f       	sbci	r25, 0xFF	; 255
    307e:	23 e4       	ldi	r18, 0x43	; 67
    3080:	fc 01       	movw	r30, r24
    3082:	21 83       	std	Z+1, r18	; 0x01
					recString[2]='K';
    3084:	ce 01       	movw	r24, r28
    3086:	8e 59       	subi	r24, 0x9E	; 158
    3088:	9f 4f       	sbci	r25, 0xFF	; 255
    308a:	2b e4       	ldi	r18, 0x4B	; 75
    308c:	fc 01       	movw	r30, r24
    308e:	22 83       	std	Z+2, r18	; 0x02
					PrintGAVR(recString);
    3090:	ce 01       	movw	r24, r28
    3092:	8e 59       	subi	r24, 0x9E	; 158
    3094:	9f 4f       	sbci	r25, 0xFF	; 255
    3096:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
					state=5;
    309a:	85 e0       	ldi	r24, 0x05	; 5
    309c:	90 e0       	ldi	r25, 0x00	; 0
    309e:	9a 83       	std	Y+2, r25	; 0x02
    30a0:	89 83       	std	Y+1, r24	; 0x01
					break;		
    30a2:	07 c0       	rjmp	.+14     	; 0x30b2 <_Z11ReceiveGAVRv+0xc68>
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
    30a4:	1a 82       	std	Y+2, r1	; 0x02
    30a6:	19 82       	std	Y+1, r1	; 0x01
    30a8:	1c 82       	std	Y+4, r1	; 0x04
    30aa:	1b 82       	std	Y+3, r1	; 0x03
    30ac:	10 92 bc 01 	sts	0x01BC, r1
    30b0:	00 00       	nop
	char recChar, recString[40];
	unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	//While Loop
	while (flagReceivingGAVR){
    30b2:	90 91 bc 01 	lds	r25, 0x01BC
    30b6:	81 e0       	ldi	r24, 0x01	; 1
    30b8:	99 23       	and	r25, r25
    30ba:	09 f4       	brne	.+2      	; 0x30be <_Z11ReceiveGAVRv+0xc74>
    30bc:	80 e0       	ldi	r24, 0x00	; 0
    30be:	88 23       	and	r24, r24
    30c0:	09 f0       	breq	.+2      	; 0x30c4 <_Z11ReceiveGAVRv+0xc7a>
    30c2:	d7 c9       	rjmp	.-3154   	; 0x2472 <_Z11ReceiveGAVRv+0x28>
					break;		
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
			}//end switch	
		}//end while flagReceivingGAVR	
}
    30c4:	c7 57       	subi	r28, 0x77	; 119
    30c6:	df 4f       	sbci	r29, 0xFF	; 255
    30c8:	0f b6       	in	r0, 0x3f	; 63
    30ca:	f8 94       	cli
    30cc:	de bf       	out	0x3e, r29	; 62
    30ce:	0f be       	out	0x3f, r0	; 63
    30d0:	cd bf       	out	0x3d, r28	; 61
    30d2:	df 91       	pop	r29
    30d4:	cf 91       	pop	r28
    30d6:	1f 91       	pop	r17
    30d8:	0f 91       	pop	r16
    30da:	08 95       	ret

000030dc <_Z13printTimeDatehhh>:
/*************************************************************************************************************/
//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    30dc:	cf 93       	push	r28
    30de:	df 93       	push	r29
    30e0:	cd b7       	in	r28, 0x3d	; 61
    30e2:	de b7       	in	r29, 0x3e	; 62
    30e4:	eb 97       	sbiw	r28, 0x3b	; 59
    30e6:	0f b6       	in	r0, 0x3f	; 63
    30e8:	f8 94       	cli
    30ea:	de bf       	out	0x3e, r29	; 62
    30ec:	0f be       	out	0x3f, r0	; 63
    30ee:	cd bf       	out	0x3d, r28	; 61
    30f0:	89 af       	sts	0x79, r24
    30f2:	6a af       	sts	0x7a, r22
    30f4:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    30f6:	89 ad       	sts	0x69, r24
    30f8:	88 23       	and	r24, r24
    30fa:	49 f1       	breq	.+82     	; 0x314e <_Z13printTimeDatehhh+0x72>
		if (pTime){
    30fc:	8a ad       	sts	0x6a, r24
    30fe:	88 23       	and	r24, r24
    3100:	89 f0       	breq	.+34     	; 0x3124 <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    3102:	82 e9       	ldi	r24, 0x92	; 146
    3104:	91 e0       	ldi	r25, 0x01	; 1
    3106:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    310a:	9c 01       	movw	r18, r24
    310c:	ce 01       	movw	r24, r28
    310e:	01 96       	adiw	r24, 0x01	; 1
    3110:	b9 01       	movw	r22, r18
    3112:	0e 94 0d 23 	call	0x461a	; 0x461a <strcpy>
			PrintBone(tempTime);
    3116:	ce 01       	movw	r24, r28
    3118:	01 96       	adiw	r24, 0x01	; 1
    311a:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
			PutUartChBone('/');
    311e:	8f e2       	ldi	r24, 0x2F	; 47
    3120:	0e 94 c8 08 	call	0x1190	; 0x1190 <_Z13PutUartChBonec>
		}
		if (pDate){
    3124:	8b ad       	sts	0x6b, r24
    3126:	88 23       	and	r24, r24
    3128:	d1 f1       	breq	.+116    	; 0x319e <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    312a:	82 e9       	ldi	r24, 0x92	; 146
    312c:	91 e0       	ldi	r25, 0x01	; 1
    312e:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    3132:	9c 01       	movw	r18, r24
    3134:	ce 01       	movw	r24, r28
    3136:	0c 96       	adiw	r24, 0x0c	; 12
    3138:	b9 01       	movw	r22, r18
    313a:	0e 94 0d 23 	call	0x461a	; 0x461a <strcpy>
			PrintBone(tempDate);
    313e:	ce 01       	movw	r24, r28
    3140:	0c 96       	adiw	r24, 0x0c	; 12
    3142:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
			PutUartChGAVR('.');
    3146:	8e e2       	ldi	r24, 0x2E	; 46
    3148:	0e 94 17 09 	call	0x122e	; 0x122e <_Z13PutUartChGAVRc>
    314c:	28 c0       	rjmp	.+80     	; 0x319e <_Z13printTimeDatehhh+0xc2>
		}
	} else { //Printing to GAVR
		if (pTime){
    314e:	8a ad       	sts	0x6a, r24
    3150:	88 23       	and	r24, r24
    3152:	89 f0       	breq	.+34     	; 0x3176 <_Z13printTimeDatehhh+0x9a>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    3154:	82 e9       	ldi	r24, 0x92	; 146
    3156:	91 e0       	ldi	r25, 0x01	; 1
    3158:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    315c:	9c 01       	movw	r18, r24
    315e:	ce 01       	movw	r24, r28
    3160:	4d 96       	adiw	r24, 0x1d	; 29
    3162:	b9 01       	movw	r22, r18
    3164:	0e 94 0d 23 	call	0x461a	; 0x461a <strcpy>
			PrintGAVR(tempTime);
    3168:	ce 01       	movw	r24, r28
    316a:	4d 96       	adiw	r24, 0x1d	; 29
    316c:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    3170:	8f e2       	ldi	r24, 0x2F	; 47
    3172:	0e 94 17 09 	call	0x122e	; 0x122e <_Z13PutUartChGAVRc>
		}
		if (pDate){
    3176:	8b ad       	sts	0x6b, r24
    3178:	88 23       	and	r24, r24
    317a:	89 f0       	breq	.+34     	; 0x319e <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    317c:	82 e9       	ldi	r24, 0x92	; 146
    317e:	91 e0       	ldi	r25, 0x01	; 1
    3180:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    3184:	9c 01       	movw	r18, r24
    3186:	ce 01       	movw	r24, r28
    3188:	88 96       	adiw	r24, 0x28	; 40
    318a:	b9 01       	movw	r22, r18
    318c:	0e 94 0d 23 	call	0x461a	; 0x461a <strcpy>
			PrintGAVR(tempDate);
    3190:	ce 01       	movw	r24, r28
    3192:	88 96       	adiw	r24, 0x28	; 40
    3194:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
			PutUartChGAVR('.');
    3198:	8e e2       	ldi	r24, 0x2E	; 46
    319a:	0e 94 17 09 	call	0x122e	; 0x122e <_Z13PutUartChGAVRc>
		}
	}
}
    319e:	eb 96       	adiw	r28, 0x3b	; 59
    31a0:	0f b6       	in	r0, 0x3f	; 63
    31a2:	f8 94       	cli
    31a4:	de bf       	out	0x3e, r29	; 62
    31a6:	0f be       	out	0x3f, r0	; 63
    31a8:	cd bf       	out	0x3d, r28	; 61
    31aa:	df 91       	pop	r29
    31ac:	cf 91       	pop	r28
    31ae:	08 95       	ret

000031b0 <__vector_6>:
/****************************************************************************************************************/


/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
//PCINT_17: Getting information from the GAVR
ISR(PCINT2_vect){
    31b0:	1f 92       	push	r1
    31b2:	0f 92       	push	r0
    31b4:	0f b6       	in	r0, 0x3f	; 63
    31b6:	0f 92       	push	r0
    31b8:	11 24       	eor	r1, r1
    31ba:	2f 93       	push	r18
    31bc:	3f 93       	push	r19
    31be:	4f 93       	push	r20
    31c0:	5f 93       	push	r21
    31c2:	6f 93       	push	r22
    31c4:	7f 93       	push	r23
    31c6:	8f 93       	push	r24
    31c8:	9f 93       	push	r25
    31ca:	af 93       	push	r26
    31cc:	bf 93       	push	r27
    31ce:	ef 93       	push	r30
    31d0:	ff 93       	push	r31
    31d2:	cf 93       	push	r28
    31d4:	df 93       	push	r29
    31d6:	cd b7       	in	r28, 0x3d	; 61
    31d8:	de b7       	in	r29, 0x3e	; 62
	cli();
    31da:	f8 94       	cli
	if ((PINC & (1 << PCINT17)) && !flagShutdown){
    31dc:	86 e2       	ldi	r24, 0x26	; 38
    31de:	90 e0       	ldi	r25, 0x00	; 0
    31e0:	fc 01       	movw	r30, r24
    31e2:	80 81       	ld	r24, Z
    31e4:	88 2f       	mov	r24, r24
    31e6:	90 e0       	ldi	r25, 0x00	; 0
    31e8:	82 70       	andi	r24, 0x02	; 2
    31ea:	90 70       	andi	r25, 0x00	; 0
    31ec:	00 97       	sbiw	r24, 0x00	; 0
    31ee:	31 f0       	breq	.+12     	; 0x31fc <__vector_6+0x4c>
    31f0:	80 91 c7 01 	lds	r24, 0x01C7
    31f4:	88 23       	and	r24, r24
    31f6:	11 f4       	brne	.+4      	; 0x31fc <__vector_6+0x4c>
    31f8:	81 e0       	ldi	r24, 0x01	; 1
    31fa:	01 c0       	rjmp	.+2      	; 0x31fe <__vector_6+0x4e>
    31fc:	80 e0       	ldi	r24, 0x00	; 0
    31fe:	88 23       	and	r24, r24
    3200:	e1 f0       	breq	.+56     	; 0x323a <__vector_6+0x8a>
		//Do work, correct interrupt
		UCSR1B |= (1 << RXCIE1);
    3202:	89 ec       	ldi	r24, 0xC9	; 201
    3204:	90 e0       	ldi	r25, 0x00	; 0
    3206:	29 ec       	ldi	r18, 0xC9	; 201
    3208:	30 e0       	ldi	r19, 0x00	; 0
    320a:	f9 01       	movw	r30, r18
    320c:	20 81       	ld	r18, Z
    320e:	20 68       	ori	r18, 0x80	; 128
    3210:	fc 01       	movw	r30, r24
    3212:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;
    3214:	10 92 81 01 	sts	0x0181, r1
		flagNormalMode=fFalse;
    3218:	10 92 bb 01 	sts	0x01BB, r1
		flagWaitingForSYNGAVR=fTrue;
    321c:	81 e0       	ldi	r24, 0x01	; 1
    321e:	80 93 be 01 	sts	0x01BE, r24
		__killCommINT();
    3222:	8d e3       	ldi	r24, 0x3D	; 61
    3224:	90 e0       	ldi	r25, 0x00	; 0
    3226:	fc 01       	movw	r30, r24
    3228:	10 82       	st	Z, r1
    322a:	8d e6       	ldi	r24, 0x6D	; 109
    322c:	90 e0       	ldi	r25, 0x00	; 0
    322e:	fc 01       	movw	r30, r24
    3230:	10 82       	st	Z, r1
		//Acknowledge
		PrintGAVR("ACKG.");
    3232:	82 e8       	ldi	r24, 0x82	; 130
    3234:	91 e0       	ldi	r25, 0x01	; 1
    3236:	0e 94 35 09 	call	0x126a	; 0x126a <_Z9PrintGAVRPc>
	}
	sei();
    323a:	78 94       	sei
}	
    323c:	df 91       	pop	r29
    323e:	cf 91       	pop	r28
    3240:	ff 91       	pop	r31
    3242:	ef 91       	pop	r30
    3244:	bf 91       	pop	r27
    3246:	af 91       	pop	r26
    3248:	9f 91       	pop	r25
    324a:	8f 91       	pop	r24
    324c:	7f 91       	pop	r23
    324e:	6f 91       	pop	r22
    3250:	5f 91       	pop	r21
    3252:	4f 91       	pop	r20
    3254:	3f 91       	pop	r19
    3256:	2f 91       	pop	r18
    3258:	0f 90       	pop	r0
    325a:	0f be       	out	0x3f, r0	; 63
    325c:	0f 90       	pop	r0
    325e:	1f 90       	pop	r1
    3260:	18 95       	reti

00003262 <__vector_3>:
/********************************************************/
//INT2: Getting information from BeagleBone
ISR(INT2_vect){	//about to get time, get things ready
    3262:	1f 92       	push	r1
    3264:	0f 92       	push	r0
    3266:	0f b6       	in	r0, 0x3f	; 63
    3268:	0f 92       	push	r0
    326a:	11 24       	eor	r1, r1
    326c:	2f 93       	push	r18
    326e:	3f 93       	push	r19
    3270:	4f 93       	push	r20
    3272:	5f 93       	push	r21
    3274:	6f 93       	push	r22
    3276:	7f 93       	push	r23
    3278:	8f 93       	push	r24
    327a:	9f 93       	push	r25
    327c:	af 93       	push	r26
    327e:	bf 93       	push	r27
    3280:	ef 93       	push	r30
    3282:	ff 93       	push	r31
    3284:	cf 93       	push	r28
    3286:	df 93       	push	r29
    3288:	cd b7       	in	r28, 0x3d	; 61
    328a:	de b7       	in	r29, 0x3e	; 62
	cli();
    328c:	f8 94       	cli
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    328e:	80 91 c7 01 	lds	r24, 0x01C7
    3292:	88 23       	and	r24, r24
    3294:	e1 f4       	brne	.+56     	; 0x32ce <__vector_3+0x6c>
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    3296:	10 92 81 01 	sts	0x0181, r1
		flagNormalMode=fFalse;
    329a:	10 92 bb 01 	sts	0x01BB, r1
		flagWaitingForSYNBone=fTrue;
    329e:	81 e0       	ldi	r24, 0x01	; 1
    32a0:	80 93 bf 01 	sts	0x01BF, r24
		__killCommINT();
    32a4:	8d e3       	ldi	r24, 0x3D	; 61
    32a6:	90 e0       	ldi	r25, 0x00	; 0
    32a8:	fc 01       	movw	r30, r24
    32aa:	10 82       	st	Z, r1
    32ac:	8d e6       	ldi	r24, 0x6D	; 109
    32ae:	90 e0       	ldi	r25, 0x00	; 0
    32b0:	fc 01       	movw	r30, r24
    32b2:	10 82       	st	Z, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("ACKB.");
    32b4:	88 e8       	ldi	r24, 0x88	; 136
    32b6:	91 e0       	ldi	r25, 0x01	; 1
    32b8:	0e 94 e6 08 	call	0x11cc	; 0x11cc <_Z9PrintBonePc>
		UCSR0B |= (1 << RXCIE0);
    32bc:	81 ec       	ldi	r24, 0xC1	; 193
    32be:	90 e0       	ldi	r25, 0x00	; 0
    32c0:	21 ec       	ldi	r18, 0xC1	; 193
    32c2:	30 e0       	ldi	r19, 0x00	; 0
    32c4:	f9 01       	movw	r30, r18
    32c6:	20 81       	ld	r18, Z
    32c8:	20 68       	ori	r18, 0x80	; 128
    32ca:	fc 01       	movw	r30, r24
    32cc:	20 83       	st	Z, r18
	}
	sei();
    32ce:	78 94       	sei
}
    32d0:	df 91       	pop	r29
    32d2:	cf 91       	pop	r28
    32d4:	ff 91       	pop	r31
    32d6:	ef 91       	pop	r30
    32d8:	bf 91       	pop	r27
    32da:	af 91       	pop	r26
    32dc:	9f 91       	pop	r25
    32de:	8f 91       	pop	r24
    32e0:	7f 91       	pop	r23
    32e2:	6f 91       	pop	r22
    32e4:	5f 91       	pop	r21
    32e6:	4f 91       	pop	r20
    32e8:	3f 91       	pop	r19
    32ea:	2f 91       	pop	r18
    32ec:	0f 90       	pop	r0
    32ee:	0f be       	out	0x3f, r0	; 63
    32f0:	0f 90       	pop	r0
    32f2:	1f 90       	pop	r1
    32f4:	18 95       	reti

000032f6 <__vector_20>:
/********************************************************/
//UART Receive from BeagleBone
ISR(USART0_RX_vect){
    32f6:	1f 92       	push	r1
    32f8:	0f 92       	push	r0
    32fa:	0f b6       	in	r0, 0x3f	; 63
    32fc:	0f 92       	push	r0
    32fe:	11 24       	eor	r1, r1
    3300:	2f 93       	push	r18
    3302:	3f 93       	push	r19
    3304:	8f 93       	push	r24
    3306:	9f 93       	push	r25
    3308:	ef 93       	push	r30
    330a:	ff 93       	push	r31
    330c:	cf 93       	push	r28
    330e:	df 93       	push	r29
    3310:	cd b7       	in	r28, 0x3d	; 61
    3312:	de b7       	in	r29, 0x3e	; 62
	cli();
    3314:	f8 94       	cli
	if (flagWaitingForSYNBone){
    3316:	80 91 bf 01 	lds	r24, 0x01BF
    331a:	88 23       	and	r24, r24
    331c:	31 f0       	breq	.+12     	; 0x332a <__vector_20+0x34>
		flagReceivingBone=fTrue;
    331e:	81 e0       	ldi	r24, 0x01	; 1
    3320:	80 93 ba 01 	sts	0x01BA, r24
		flagWaitingForSYNBone=fFalse;
    3324:	10 92 bf 01 	sts	0x01BF, r1
    3328:	02 c0       	rjmp	.+4      	; 0x332e <__vector_20+0x38>
	} else {
		flagReceivingBone=fFalse;		//there was a timeout between the initial interrupt and when we are getting this.
    332a:	10 92 ba 01 	sts	0x01BA, r1
	}	
	UCSR0B &= ~(1 << RXCIE0);
    332e:	81 ec       	ldi	r24, 0xC1	; 193
    3330:	90 e0       	ldi	r25, 0x00	; 0
    3332:	21 ec       	ldi	r18, 0xC1	; 193
    3334:	30 e0       	ldi	r19, 0x00	; 0
    3336:	f9 01       	movw	r30, r18
    3338:	20 81       	ld	r18, Z
    333a:	2f 77       	andi	r18, 0x7F	; 127
    333c:	fc 01       	movw	r30, r24
    333e:	20 83       	st	Z, r18
	sei();
    3340:	78 94       	sei
}
    3342:	df 91       	pop	r29
    3344:	cf 91       	pop	r28
    3346:	ff 91       	pop	r31
    3348:	ef 91       	pop	r30
    334a:	9f 91       	pop	r25
    334c:	8f 91       	pop	r24
    334e:	3f 91       	pop	r19
    3350:	2f 91       	pop	r18
    3352:	0f 90       	pop	r0
    3354:	0f be       	out	0x3f, r0	; 63
    3356:	0f 90       	pop	r0
    3358:	1f 90       	pop	r1
    335a:	18 95       	reti

0000335c <__vector_28>:
/********************************************************/
ISR(USART1_RX_vect){
    335c:	1f 92       	push	r1
    335e:	0f 92       	push	r0
    3360:	0f b6       	in	r0, 0x3f	; 63
    3362:	0f 92       	push	r0
    3364:	11 24       	eor	r1, r1
    3366:	2f 93       	push	r18
    3368:	3f 93       	push	r19
    336a:	8f 93       	push	r24
    336c:	9f 93       	push	r25
    336e:	ef 93       	push	r30
    3370:	ff 93       	push	r31
    3372:	cf 93       	push	r28
    3374:	df 93       	push	r29
    3376:	cd b7       	in	r28, 0x3d	; 61
    3378:	de b7       	in	r29, 0x3e	; 62
	cli();
    337a:	f8 94       	cli
	if (flagWaitingForSYNGAVR){
    337c:	80 91 be 01 	lds	r24, 0x01BE
    3380:	88 23       	and	r24, r24
    3382:	31 f0       	breq	.+12     	; 0x3390 <__vector_28+0x34>
		flagReceivingGAVR=fTrue;
    3384:	81 e0       	ldi	r24, 0x01	; 1
    3386:	80 93 bc 01 	sts	0x01BC, r24
		flagWaitingForSYNGAVR=fFalse;
    338a:	10 92 be 01 	sts	0x01BE, r1
    338e:	02 c0       	rjmp	.+4      	; 0x3394 <__vector_28+0x38>
	}else {
		flagReceivingGAVR=fFalse;
    3390:	10 92 bc 01 	sts	0x01BC, r1
	}
	
	UCSR1B &= ~(1 <<RXCIE1);	//disable interrupt
    3394:	89 ec       	ldi	r24, 0xC9	; 201
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	29 ec       	ldi	r18, 0xC9	; 201
    339a:	30 e0       	ldi	r19, 0x00	; 0
    339c:	f9 01       	movw	r30, r18
    339e:	20 81       	ld	r18, Z
    33a0:	2f 77       	andi	r18, 0x7F	; 127
    33a2:	fc 01       	movw	r30, r24
    33a4:	20 83       	st	Z, r18
	sei();
    33a6:	78 94       	sei
}
    33a8:	df 91       	pop	r29
    33aa:	cf 91       	pop	r28
    33ac:	ff 91       	pop	r31
    33ae:	ef 91       	pop	r30
    33b0:	9f 91       	pop	r25
    33b2:	8f 91       	pop	r24
    33b4:	3f 91       	pop	r19
    33b6:	2f 91       	pop	r18
    33b8:	0f 90       	pop	r0
    33ba:	0f be       	out	0x3f, r0	; 63
    33bc:	0f 90       	pop	r0
    33be:	1f 90       	pop	r1
    33c0:	18 95       	reti

000033c2 <__vector_11>:

/********************************************************/
//RTC Timer.
ISR(TIMER2_OVF_vect){
    33c2:	1f 92       	push	r1
    33c4:	0f 92       	push	r0
    33c6:	0f b6       	in	r0, 0x3f	; 63
    33c8:	0f 92       	push	r0
    33ca:	11 24       	eor	r1, r1
    33cc:	2f 93       	push	r18
    33ce:	3f 93       	push	r19
    33d0:	4f 93       	push	r20
    33d2:	5f 93       	push	r21
    33d4:	6f 93       	push	r22
    33d6:	7f 93       	push	r23
    33d8:	8f 93       	push	r24
    33da:	9f 93       	push	r25
    33dc:	af 93       	push	r26
    33de:	bf 93       	push	r27
    33e0:	ef 93       	push	r30
    33e2:	ff 93       	push	r31
    33e4:	cf 93       	push	r28
    33e6:	df 93       	push	r29
    33e8:	cd b7       	in	r28, 0x3d	; 61
    33ea:	de b7       	in	r29, 0x3e	; 62
	cli();
    33ec:	f8 94       	cli
	prtSLEEPled ^= (1 << bnSLEEPled);
    33ee:	8b e2       	ldi	r24, 0x2B	; 43
    33f0:	90 e0       	ldi	r25, 0x00	; 0
    33f2:	2b e2       	ldi	r18, 0x2B	; 43
    33f4:	30 e0       	ldi	r19, 0x00	; 0
    33f6:	f9 01       	movw	r30, r18
    33f8:	30 81       	ld	r19, Z
    33fa:	20 e8       	ldi	r18, 0x80	; 128
    33fc:	23 27       	eor	r18, r19
    33fe:	fc 01       	movw	r30, r24
    3400:	20 83       	st	Z, r18
	static int gavrSendTimeout=0, boneReceiveTimeout=0, gavrReceiveTimeout=0, startupTimeout=0;
	
	currentTime.addSeconds(1);
    3402:	82 e9       	ldi	r24, 0x92	; 146
    3404:	91 e0       	ldi	r25, 0x01	; 1
    3406:	61 e0       	ldi	r22, 0x01	; 1
    3408:	70 e0       	ldi	r23, 0x00	; 0
    340a:	0e 94 72 06 	call	0xce4	; 0xce4 <_ZN6myTime10addSecondsEi>
	
	//GAVR Transmission Timeout
	if (flagSendingGAVR && gavrSendTimeout <=COMM_TIMEOUT_SEC){gavrSendTimeout++;}
    340e:	80 91 c1 01 	lds	r24, 0x01C1
    3412:	88 23       	and	r24, r24
    3414:	89 f0       	breq	.+34     	; 0x3438 <__vector_11+0x76>
    3416:	80 91 cc 01 	lds	r24, 0x01CC
    341a:	90 91 cd 01 	lds	r25, 0x01CD
    341e:	89 30       	cpi	r24, 0x09	; 9
    3420:	91 05       	cpc	r25, r1
    3422:	54 f4       	brge	.+20     	; 0x3438 <__vector_11+0x76>
    3424:	80 91 cc 01 	lds	r24, 0x01CC
    3428:	90 91 cd 01 	lds	r25, 0x01CD
    342c:	01 96       	adiw	r24, 0x01	; 1
    342e:	90 93 cd 01 	sts	0x01CD, r25
    3432:	80 93 cc 01 	sts	0x01CC, r24
    3436:	32 c0       	rjmp	.+100    	; 0x349c <__vector_11+0xda>
	else if (flagSendingGAVR && gavrSendTimeout > COMM_TIMEOUT_SEC){flagSendingGAVR=fFalse;flagGoToSleep=fTrue; gavrSendTimeout=0; __enableCommINT();}
    3438:	80 91 c1 01 	lds	r24, 0x01C1
    343c:	88 23       	and	r24, r24
    343e:	f9 f0       	breq	.+62     	; 0x347e <__vector_11+0xbc>
    3440:	80 91 cc 01 	lds	r24, 0x01CC
    3444:	90 91 cd 01 	lds	r25, 0x01CD
    3448:	89 30       	cpi	r24, 0x09	; 9
    344a:	91 05       	cpc	r25, r1
    344c:	c4 f0       	brlt	.+48     	; 0x347e <__vector_11+0xbc>
    344e:	10 92 c1 01 	sts	0x01C1, r1
    3452:	81 e0       	ldi	r24, 0x01	; 1
    3454:	80 93 81 01 	sts	0x0181, r24
    3458:	10 92 cd 01 	sts	0x01CD, r1
    345c:	10 92 cc 01 	sts	0x01CC, r1
    3460:	8d e3       	ldi	r24, 0x3D	; 61
    3462:	90 e0       	ldi	r25, 0x00	; 0
    3464:	2d e3       	ldi	r18, 0x3D	; 61
    3466:	30 e0       	ldi	r19, 0x00	; 0
    3468:	f9 01       	movw	r30, r18
    346a:	20 81       	ld	r18, Z
    346c:	24 60       	ori	r18, 0x04	; 4
    346e:	fc 01       	movw	r30, r24
    3470:	20 83       	st	Z, r18
    3472:	8d e6       	ldi	r24, 0x6D	; 109
    3474:	90 e0       	ldi	r25, 0x00	; 0
    3476:	22 e0       	ldi	r18, 0x02	; 2
    3478:	fc 01       	movw	r30, r24
    347a:	20 83       	st	Z, r18
    347c:	0f c0       	rjmp	.+30     	; 0x349c <__vector_11+0xda>
	else if (!flagSendingGAVR && gavrSendTimeout > 0){gavrSendTimeout=0;}
    347e:	80 91 c1 01 	lds	r24, 0x01C1
    3482:	88 23       	and	r24, r24
    3484:	59 f4       	brne	.+22     	; 0x349c <__vector_11+0xda>
    3486:	80 91 cc 01 	lds	r24, 0x01CC
    348a:	90 91 cd 01 	lds	r25, 0x01CD
    348e:	18 16       	cp	r1, r24
    3490:	19 06       	cpc	r1, r25
    3492:	24 f4       	brge	.+8      	; 0x349c <__vector_11+0xda>
    3494:	10 92 cd 01 	sts	0x01CD, r1
    3498:	10 92 cc 01 	sts	0x01CC, r1
	else;
	
	//BeagleBone Reception Timeout
	if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout <=COMM_TIMEOUT_SEC)){boneReceiveTimeout++;}
    349c:	80 91 ba 01 	lds	r24, 0x01BA
    34a0:	88 23       	and	r24, r24
    34a2:	21 f4       	brne	.+8      	; 0x34ac <__vector_11+0xea>
    34a4:	80 91 bf 01 	lds	r24, 0x01BF
    34a8:	88 23       	and	r24, r24
    34aa:	89 f0       	breq	.+34     	; 0x34ce <__vector_11+0x10c>
    34ac:	80 91 ce 01 	lds	r24, 0x01CE
    34b0:	90 91 cf 01 	lds	r25, 0x01CF
    34b4:	89 30       	cpi	r24, 0x09	; 9
    34b6:	91 05       	cpc	r25, r1
    34b8:	54 f4       	brge	.+20     	; 0x34ce <__vector_11+0x10c>
    34ba:	80 91 ce 01 	lds	r24, 0x01CE
    34be:	90 91 cf 01 	lds	r25, 0x01CF
    34c2:	01 96       	adiw	r24, 0x01	; 1
    34c4:	90 93 cf 01 	sts	0x01CF, r25
    34c8:	80 93 ce 01 	sts	0x01CE, r24
    34cc:	3f c0       	rjmp	.+126    	; 0x354c <__vector_11+0x18a>
	else if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout > COMM_TIMEOUT_SEC)){flagReceivingBone=fFalse; flagWaitingForSYNBone=fFalse;flagGoToSleep=fTrue; flagNormalMode=fTrue; boneReceiveTimeout=0; __enableCommINT();}
    34ce:	80 91 ba 01 	lds	r24, 0x01BA
    34d2:	88 23       	and	r24, r24
    34d4:	21 f4       	brne	.+8      	; 0x34de <__vector_11+0x11c>
    34d6:	80 91 bf 01 	lds	r24, 0x01BF
    34da:	88 23       	and	r24, r24
    34dc:	21 f1       	breq	.+72     	; 0x3526 <__vector_11+0x164>
    34de:	80 91 ce 01 	lds	r24, 0x01CE
    34e2:	90 91 cf 01 	lds	r25, 0x01CF
    34e6:	89 30       	cpi	r24, 0x09	; 9
    34e8:	91 05       	cpc	r25, r1
    34ea:	ec f0       	brlt	.+58     	; 0x3526 <__vector_11+0x164>
    34ec:	10 92 ba 01 	sts	0x01BA, r1
    34f0:	10 92 bf 01 	sts	0x01BF, r1
    34f4:	81 e0       	ldi	r24, 0x01	; 1
    34f6:	80 93 81 01 	sts	0x0181, r24
    34fa:	81 e0       	ldi	r24, 0x01	; 1
    34fc:	80 93 bb 01 	sts	0x01BB, r24
    3500:	10 92 cf 01 	sts	0x01CF, r1
    3504:	10 92 ce 01 	sts	0x01CE, r1
    3508:	8d e3       	ldi	r24, 0x3D	; 61
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	2d e3       	ldi	r18, 0x3D	; 61
    350e:	30 e0       	ldi	r19, 0x00	; 0
    3510:	f9 01       	movw	r30, r18
    3512:	20 81       	ld	r18, Z
    3514:	24 60       	ori	r18, 0x04	; 4
    3516:	fc 01       	movw	r30, r24
    3518:	20 83       	st	Z, r18
    351a:	8d e6       	ldi	r24, 0x6D	; 109
    351c:	90 e0       	ldi	r25, 0x00	; 0
    351e:	22 e0       	ldi	r18, 0x02	; 2
    3520:	fc 01       	movw	r30, r24
    3522:	20 83       	st	Z, r18
    3524:	13 c0       	rjmp	.+38     	; 0x354c <__vector_11+0x18a>
	else if ((!flagReceivingBone && !flagWaitingForSYNBone) && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    3526:	80 91 ba 01 	lds	r24, 0x01BA
    352a:	88 23       	and	r24, r24
    352c:	79 f4       	brne	.+30     	; 0x354c <__vector_11+0x18a>
    352e:	80 91 bf 01 	lds	r24, 0x01BF
    3532:	88 23       	and	r24, r24
    3534:	59 f4       	brne	.+22     	; 0x354c <__vector_11+0x18a>
    3536:	80 91 ce 01 	lds	r24, 0x01CE
    353a:	90 91 cf 01 	lds	r25, 0x01CF
    353e:	18 16       	cp	r1, r24
    3540:	19 06       	cpc	r1, r25
    3542:	24 f4       	brge	.+8      	; 0x354c <__vector_11+0x18a>
    3544:	10 92 cf 01 	sts	0x01CF, r1
    3548:	10 92 ce 01 	sts	0x01CE, r1
	else;

	//GAVR Reception Timeout
	if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout <= COMM_TIMEOUT_SEC){gavrReceiveTimeout++;}
    354c:	80 91 bc 01 	lds	r24, 0x01BC
    3550:	88 23       	and	r24, r24
    3552:	21 f4       	brne	.+8      	; 0x355c <__vector_11+0x19a>
    3554:	80 91 be 01 	lds	r24, 0x01BE
    3558:	88 23       	and	r24, r24
    355a:	89 f0       	breq	.+34     	; 0x357e <__vector_11+0x1bc>
    355c:	80 91 d0 01 	lds	r24, 0x01D0
    3560:	90 91 d1 01 	lds	r25, 0x01D1
    3564:	89 30       	cpi	r24, 0x09	; 9
    3566:	91 05       	cpc	r25, r1
    3568:	54 f4       	brge	.+20     	; 0x357e <__vector_11+0x1bc>
    356a:	80 91 d0 01 	lds	r24, 0x01D0
    356e:	90 91 d1 01 	lds	r25, 0x01D1
    3572:	01 96       	adiw	r24, 0x01	; 1
    3574:	90 93 d1 01 	sts	0x01D1, r25
    3578:	80 93 d0 01 	sts	0x01D0, r24
    357c:	3f c0       	rjmp	.+126    	; 0x35fc <__vector_11+0x23a>
	else if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout > COMM_TIMEOUT_SEC){flagReceivingGAVR=fFalse;flagGoToSleep=fTrue; flagWaitingForSYNGAVR=fFalse;flagNormalMode=fTrue;boneReceiveTimeout=0; __enableCommINT();}
    357e:	80 91 bc 01 	lds	r24, 0x01BC
    3582:	88 23       	and	r24, r24
    3584:	21 f4       	brne	.+8      	; 0x358e <__vector_11+0x1cc>
    3586:	80 91 be 01 	lds	r24, 0x01BE
    358a:	88 23       	and	r24, r24
    358c:	21 f1       	breq	.+72     	; 0x35d6 <__vector_11+0x214>
    358e:	80 91 d0 01 	lds	r24, 0x01D0
    3592:	90 91 d1 01 	lds	r25, 0x01D1
    3596:	89 30       	cpi	r24, 0x09	; 9
    3598:	91 05       	cpc	r25, r1
    359a:	ec f0       	brlt	.+58     	; 0x35d6 <__vector_11+0x214>
    359c:	10 92 bc 01 	sts	0x01BC, r1
    35a0:	81 e0       	ldi	r24, 0x01	; 1
    35a2:	80 93 81 01 	sts	0x0181, r24
    35a6:	10 92 be 01 	sts	0x01BE, r1
    35aa:	81 e0       	ldi	r24, 0x01	; 1
    35ac:	80 93 bb 01 	sts	0x01BB, r24
    35b0:	10 92 cf 01 	sts	0x01CF, r1
    35b4:	10 92 ce 01 	sts	0x01CE, r1
    35b8:	8d e3       	ldi	r24, 0x3D	; 61
    35ba:	90 e0       	ldi	r25, 0x00	; 0
    35bc:	2d e3       	ldi	r18, 0x3D	; 61
    35be:	30 e0       	ldi	r19, 0x00	; 0
    35c0:	f9 01       	movw	r30, r18
    35c2:	20 81       	ld	r18, Z
    35c4:	24 60       	ori	r18, 0x04	; 4
    35c6:	fc 01       	movw	r30, r24
    35c8:	20 83       	st	Z, r18
    35ca:	8d e6       	ldi	r24, 0x6D	; 109
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	22 e0       	ldi	r18, 0x02	; 2
    35d0:	fc 01       	movw	r30, r24
    35d2:	20 83       	st	Z, r18
    35d4:	13 c0       	rjmp	.+38     	; 0x35fc <__vector_11+0x23a>
	else if ((!flagReceivingGAVR && !flagWaitingForSYNGAVR) && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    35d6:	80 91 bc 01 	lds	r24, 0x01BC
    35da:	88 23       	and	r24, r24
    35dc:	79 f4       	brne	.+30     	; 0x35fc <__vector_11+0x23a>
    35de:	80 91 be 01 	lds	r24, 0x01BE
    35e2:	88 23       	and	r24, r24
    35e4:	59 f4       	brne	.+22     	; 0x35fc <__vector_11+0x23a>
    35e6:	80 91 ce 01 	lds	r24, 0x01CE
    35ea:	90 91 cf 01 	lds	r25, 0x01CF
    35ee:	18 16       	cp	r1, r24
    35f0:	19 06       	cpc	r1, r25
    35f2:	24 f4       	brge	.+8      	; 0x35fc <__vector_11+0x23a>
    35f4:	10 92 cf 01 	sts	0x01CF, r1
    35f8:	10 92 ce 01 	sts	0x01CE, r1
	else;

	//Startup Tiemout for sending clock to GAVR
	if ((flagFreshStart || restart) && startupTimeout <= STARTUP_TIMEOUT_SEC){startupTimeout++;}
    35fc:	80 91 cb 01 	lds	r24, 0x01CB
    3600:	88 23       	and	r24, r24
    3602:	21 f4       	brne	.+8      	; 0x360c <__vector_11+0x24a>
    3604:	80 91 ca 01 	lds	r24, 0x01CA
    3608:	88 23       	and	r24, r24
    360a:	89 f0       	breq	.+34     	; 0x362e <__vector_11+0x26c>
    360c:	80 91 d2 01 	lds	r24, 0x01D2
    3610:	90 91 d3 01 	lds	r25, 0x01D3
    3614:	8d 30       	cpi	r24, 0x0D	; 13
    3616:	91 05       	cpc	r25, r1
    3618:	54 f4       	brge	.+20     	; 0x362e <__vector_11+0x26c>
    361a:	80 91 d2 01 	lds	r24, 0x01D2
    361e:	90 91 d3 01 	lds	r25, 0x01D3
    3622:	01 96       	adiw	r24, 0x01	; 1
    3624:	90 93 d3 01 	sts	0x01D3, r25
    3628:	80 93 d2 01 	sts	0x01D2, r24
    362c:	52 c0       	rjmp	.+164    	; 0x36d2 <__vector_11+0x310>
	else if ((flagFreshStart || restart) && startupTimeout > STARTUP_TIMEOUT_SEC){
    362e:	80 91 cb 01 	lds	r24, 0x01CB
    3632:	88 23       	and	r24, r24
    3634:	21 f4       	brne	.+8      	; 0x363e <__vector_11+0x27c>
    3636:	80 91 ca 01 	lds	r24, 0x01CA
    363a:	88 23       	and	r24, r24
    363c:	b9 f1       	breq	.+110    	; 0x36ac <__vector_11+0x2ea>
    363e:	80 91 d2 01 	lds	r24, 0x01D2
    3642:	90 91 d3 01 	lds	r25, 0x01D3
    3646:	8d 30       	cpi	r24, 0x0D	; 13
    3648:	91 05       	cpc	r25, r1
    364a:	84 f1       	brlt	.+96     	; 0x36ac <__vector_11+0x2ea>
		if (flagFreshStart){flagFreshStart=fFalse; flagUserClock=fTrue; flagUpdateGAVRClock=fFalse;}	//The GPS didn't send valid data, get user clock.
    364c:	80 91 cb 01 	lds	r24, 0x01CB
    3650:	88 23       	and	r24, r24
    3652:	41 f0       	breq	.+16     	; 0x3664 <__vector_11+0x2a2>
    3654:	10 92 cb 01 	sts	0x01CB, r1
    3658:	81 e0       	ldi	r24, 0x01	; 1
    365a:	80 93 c2 01 	sts	0x01C2, r24
    365e:	10 92 c0 01 	sts	0x01C0, r1
    3662:	0b c0       	rjmp	.+22     	; 0x367a <__vector_11+0x2b8>
		else if (restart){restart=fFalse; flagUserClock=fFalse; flagUpdateGAVRClock=fTrue;}				//Gps didn't send valid data, we have valid data. This is redundant to the main
    3664:	80 91 ca 01 	lds	r24, 0x01CA
    3668:	88 23       	and	r24, r24
    366a:	39 f0       	breq	.+14     	; 0x367a <__vector_11+0x2b8>
    366c:	10 92 ca 01 	sts	0x01CA, r1
    3670:	10 92 c2 01 	sts	0x01C2, r1
    3674:	81 e0       	ldi	r24, 0x01	; 1
    3676:	80 93 c0 01 	sts	0x01C0, r24
		__enableCommINT();																				//--procedure that depends on "if (restart)"
    367a:	8d e3       	ldi	r24, 0x3D	; 61
    367c:	90 e0       	ldi	r25, 0x00	; 0
    367e:	2d e3       	ldi	r18, 0x3D	; 61
    3680:	30 e0       	ldi	r19, 0x00	; 0
    3682:	f9 01       	movw	r30, r18
    3684:	20 81       	ld	r18, Z
    3686:	24 60       	ori	r18, 0x04	; 4
    3688:	fc 01       	movw	r30, r24
    368a:	20 83       	st	Z, r18
    368c:	8d e6       	ldi	r24, 0x6D	; 109
    368e:	90 e0       	ldi	r25, 0x00	; 0
    3690:	22 e0       	ldi	r18, 0x02	; 2
    3692:	fc 01       	movw	r30, r24
    3694:	20 83       	st	Z, r18
		startupTimeout=0;
    3696:	10 92 d3 01 	sts	0x01D3, r1
    369a:	10 92 d2 01 	sts	0x01D2, r1
		flagGoToSleep=fTrue;
    369e:	81 e0       	ldi	r24, 0x01	; 1
    36a0:	80 93 81 01 	sts	0x0181, r24
		flagNormalMode=fTrue;
    36a4:	81 e0       	ldi	r24, 0x01	; 1
    36a6:	80 93 bb 01 	sts	0x01BB, r24
    36aa:	13 c0       	rjmp	.+38     	; 0x36d2 <__vector_11+0x310>
	} else if (!(flagFreshStart || restart) && startupTimeout > 0){startupTimeout=0;}
    36ac:	80 91 cb 01 	lds	r24, 0x01CB
    36b0:	88 23       	and	r24, r24
    36b2:	79 f4       	brne	.+30     	; 0x36d2 <__vector_11+0x310>
    36b4:	80 91 ca 01 	lds	r24, 0x01CA
    36b8:	88 23       	and	r24, r24
    36ba:	59 f4       	brne	.+22     	; 0x36d2 <__vector_11+0x310>
    36bc:	80 91 d2 01 	lds	r24, 0x01D2
    36c0:	90 91 d3 01 	lds	r25, 0x01D3
    36c4:	18 16       	cp	r1, r24
    36c6:	19 06       	cpc	r1, r25
    36c8:	24 f4       	brge	.+8      	; 0x36d2 <__vector_11+0x310>
    36ca:	10 92 d3 01 	sts	0x01D3, r1
    36ce:	10 92 d2 01 	sts	0x01D2, r1
	else;
	sei();
    36d2:	78 94       	sei
}//End timer 2 overflow.
    36d4:	df 91       	pop	r29
    36d6:	cf 91       	pop	r28
    36d8:	ff 91       	pop	r31
    36da:	ef 91       	pop	r30
    36dc:	bf 91       	pop	r27
    36de:	af 91       	pop	r26
    36e0:	9f 91       	pop	r25
    36e2:	8f 91       	pop	r24
    36e4:	7f 91       	pop	r23
    36e6:	6f 91       	pop	r22
    36e8:	5f 91       	pop	r21
    36ea:	4f 91       	pop	r20
    36ec:	3f 91       	pop	r19
    36ee:	2f 91       	pop	r18
    36f0:	0f 90       	pop	r0
    36f2:	0f be       	out	0x3f, r0	; 63
    36f4:	0f 90       	pop	r0
    36f6:	1f 90       	pop	r1
    36f8:	18 95       	reti

000036fa <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    36fa:	cf 93       	push	r28
    36fc:	df 93       	push	r29
    36fe:	cd b7       	in	r28, 0x3d	; 61
    3700:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    3702:	0e 94 d4 1c 	call	0x39a8	; 0x39a8 <_Z10DeviceInitv>
	AppInit(MYUBRR);
    3706:	83 e3       	ldi	r24, 0x33	; 51
    3708:	90 e0       	ldi	r25, 0x00	; 0
    370a:	0e 94 fb 1c 	call	0x39f6	; 0x39f6 <_Z7AppInitj>
	EnableRTCTimer();
    370e:	0e 94 57 1e 	call	0x3cae	; 0x3cae <_Z14EnableRTCTimerv>
	InitBools();
    3712:	0e 94 2c 1e 	call	0x3c58	; 0x3c58 <_Z9InitBoolsv>
	getDateTime_eeprom(fTrue,fTrue);
    3716:	81 e0       	ldi	r24, 0x01	; 1
    3718:	61 e0       	ldi	r22, 0x01	; 1
    371a:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z18getDateTime_eepromhh>
	//Prep/make sure power/temp is good
	Wait_ms(2000);
    371e:	80 ed       	ldi	r24, 0xD0	; 208
    3720:	97 e0       	ldi	r25, 0x07	; 7
    3722:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <_Z7Wait_msi>
	//GetTemp();
	TakeADC();
    3726:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <_Z7TakeADCv>
	flagGoodTemp=fTrue;
    372a:	81 e0       	ldi	r24, 0x01	; 1
    372c:	80 93 c8 01 	sts	0x01C8, r24
	if (flagGoodVolts && flagGoodTemp){				//Good to power on system
    3730:	80 91 c9 01 	lds	r24, 0x01C9
    3734:	88 23       	and	r24, r24
    3736:	e1 f0       	breq	.+56     	; 0x3770 <main+0x76>
    3738:	80 91 c8 01 	lds	r24, 0x01C8
    373c:	88 23       	and	r24, r24
    373e:	c1 f0       	breq	.+48     	; 0x3770 <main+0x76>
		__enableCommINT();
    3740:	8d e3       	ldi	r24, 0x3D	; 61
    3742:	90 e0       	ldi	r25, 0x00	; 0
    3744:	2d e3       	ldi	r18, 0x3D	; 61
    3746:	30 e0       	ldi	r19, 0x00	; 0
    3748:	f9 01       	movw	r30, r18
    374a:	20 81       	ld	r18, Z
    374c:	24 60       	ori	r18, 0x04	; 4
    374e:	fc 01       	movw	r30, r24
    3750:	20 83       	st	Z, r18
    3752:	8d e6       	ldi	r24, 0x6D	; 109
    3754:	90 e0       	ldi	r25, 0x00	; 0
    3756:	22 e0       	ldi	r18, 0x02	; 2
    3758:	fc 01       	movw	r30, r24
    375a:	20 83       	st	Z, r18
		PowerUp(POWER_UP_INTERVAL);
    375c:	83 e0       	ldi	r24, 0x03	; 3
    375e:	90 e0       	ldi	r25, 0x00	; 0
    3760:	0e 94 c6 20 	call	0x418c	; 0x418c <_Z7PowerUpj>
		flagFreshStart=fTrue;
    3764:	81 e0       	ldi	r24, 0x01	; 1
    3766:	80 93 cb 01 	sts	0x01CB, r24
		flagShutdown=fFalse;
    376a:	10 92 c7 01 	sts	0x01C7, r1
    376e:	0d c0       	rjmp	.+26     	; 0x378a <main+0x90>
	} else {										//Something isn't right, don't power on the system.
		__killCommINT();
    3770:	8d e3       	ldi	r24, 0x3D	; 61
    3772:	90 e0       	ldi	r25, 0x00	; 0
    3774:	fc 01       	movw	r30, r24
    3776:	10 82       	st	Z, r1
    3778:	8d e6       	ldi	r24, 0x6D	; 109
    377a:	90 e0       	ldi	r25, 0x00	; 0
    377c:	fc 01       	movw	r30, r24
    377e:	10 82       	st	Z, r1
		flagShutdown=fTrue;
    3780:	81 e0       	ldi	r24, 0x01	; 1
    3782:	80 93 c7 01 	sts	0x01C7, r24
		flagFreshStart=fFalse;
    3786:	10 92 cb 01 	sts	0x01CB, r1
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
    378a:	88 e2       	ldi	r24, 0x28	; 40
    378c:	90 e0       	ldi	r25, 0x00	; 0
    378e:	28 e2       	ldi	r18, 0x28	; 40
    3790:	30 e0       	ldi	r19, 0x00	; 0
    3792:	f9 01       	movw	r30, r18
    3794:	20 81       	ld	r18, Z
    3796:	24 60       	ori	r18, 0x04	; 4
    3798:	fc 01       	movw	r30, r24
    379a:	20 83       	st	Z, r18
    379c:	01 c0       	rjmp	.+2      	; 0x37a0 <main+0xa6>
	//main programming loop
	while(fTrue)
    379e:	00 00       	nop
	{		
		Wait_ms(2000);
    37a0:	80 ed       	ldi	r24, 0xD0	; 208
    37a2:	97 e0       	ldi	r25, 0x07	; 7
    37a4:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <_Z7Wait_msi>
		//If receiving UART string, go get rest of it.
		if (flagReceivingBone){
    37a8:	80 91 ba 01 	lds	r24, 0x01BA
    37ac:	88 23       	and	r24, r24
    37ae:	b1 f0       	breq	.+44     	; 0x37dc <main+0xe2>
			ReceiveBone();
    37b0:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <_Z11ReceiveBonev>
			__enableCommINT();
    37b4:	8d e3       	ldi	r24, 0x3D	; 61
    37b6:	90 e0       	ldi	r25, 0x00	; 0
    37b8:	2d e3       	ldi	r18, 0x3D	; 61
    37ba:	30 e0       	ldi	r19, 0x00	; 0
    37bc:	f9 01       	movw	r30, r18
    37be:	20 81       	ld	r18, Z
    37c0:	24 60       	ori	r18, 0x04	; 4
    37c2:	fc 01       	movw	r30, r24
    37c4:	20 83       	st	Z, r18
    37c6:	8d e6       	ldi	r24, 0x6D	; 109
    37c8:	90 e0       	ldi	r25, 0x00	; 0
    37ca:	22 e0       	ldi	r18, 0x02	; 2
    37cc:	fc 01       	movw	r30, r24
    37ce:	20 83       	st	Z, r18
			flagGoToSleep=fTrue;
    37d0:	81 e0       	ldi	r24, 0x01	; 1
    37d2:	80 93 81 01 	sts	0x0181, r24
			flagNormalMode=fTrue;
    37d6:	81 e0       	ldi	r24, 0x01	; 1
    37d8:	80 93 bb 01 	sts	0x01BB, r24
		}//end flag Receiving from Bone 
		
		//Receiving Data/Signals from GAVR
		if (flagReceivingGAVR){
    37dc:	80 91 bc 01 	lds	r24, 0x01BC
    37e0:	88 23       	and	r24, r24
    37e2:	d1 f0       	breq	.+52     	; 0x3818 <main+0x11e>
			ReceiveGAVR();
    37e4:	0e 94 25 12 	call	0x244a	; 0x244a <_Z11ReceiveGAVRv>
			__enableCommINT();
    37e8:	8d e3       	ldi	r24, 0x3D	; 61
    37ea:	90 e0       	ldi	r25, 0x00	; 0
    37ec:	2d e3       	ldi	r18, 0x3D	; 61
    37ee:	30 e0       	ldi	r19, 0x00	; 0
    37f0:	f9 01       	movw	r30, r18
    37f2:	20 81       	ld	r18, Z
    37f4:	24 60       	ori	r18, 0x04	; 4
    37f6:	fc 01       	movw	r30, r24
    37f8:	20 83       	st	Z, r18
    37fa:	8d e6       	ldi	r24, 0x6D	; 109
    37fc:	90 e0       	ldi	r25, 0x00	; 0
    37fe:	22 e0       	ldi	r18, 0x02	; 2
    3800:	fc 01       	movw	r30, r24
    3802:	20 83       	st	Z, r18
			if (!flagReceivingBone){		//Just in case there was an interrupt IMMEDIATELY after the enabling of Communication interrupts
    3804:	80 91 ba 01 	lds	r24, 0x01BA
    3808:	88 23       	and	r24, r24
    380a:	31 f4       	brne	.+12     	; 0x3818 <main+0x11e>
				flagGoToSleep=fTrue;
    380c:	81 e0       	ldi	r24, 0x01	; 1
    380e:	80 93 81 01 	sts	0x0181, r24
				flagNormalMode=fTrue;
    3812:	81 e0       	ldi	r24, 0x01	; 1
    3814:	80 93 bb 01 	sts	0x01BB, r24
			}			
		}//end flag Receiving from GAVR case
		
	
		//Communication with GAVR. Either updating the date/time on it or asking for date and time. The internal send machine deals with the flags.
		if ((flagUpdateGAVRClock  || flagUserClock) && !flagWaitingForReceiveGAVR){
    3818:	80 91 c0 01 	lds	r24, 0x01C0
    381c:	88 23       	and	r24, r24
    381e:	21 f4       	brne	.+8      	; 0x3828 <main+0x12e>
    3820:	80 91 c2 01 	lds	r24, 0x01C2
    3824:	88 23       	and	r24, r24
    3826:	e1 f0       	breq	.+56     	; 0x3860 <main+0x166>
    3828:	80 91 bd 01 	lds	r24, 0x01BD
    382c:	88 23       	and	r24, r24
    382e:	c1 f4       	brne	.+48     	; 0x3860 <main+0x166>
			__killCommINT();
    3830:	8d e3       	ldi	r24, 0x3D	; 61
    3832:	90 e0       	ldi	r25, 0x00	; 0
    3834:	fc 01       	movw	r30, r24
    3836:	10 82       	st	Z, r1
    3838:	8d e6       	ldi	r24, 0x6D	; 109
    383a:	90 e0       	ldi	r25, 0x00	; 0
    383c:	fc 01       	movw	r30, r24
    383e:	10 82       	st	Z, r1
			sendGAVR();
    3840:	0e 94 66 09 	call	0x12cc	; 0x12cc <_Z8sendGAVRv>
			__enableCommINT();
    3844:	8d e3       	ldi	r24, 0x3D	; 61
    3846:	90 e0       	ldi	r25, 0x00	; 0
    3848:	2d e3       	ldi	r18, 0x3D	; 61
    384a:	30 e0       	ldi	r19, 0x00	; 0
    384c:	f9 01       	movw	r30, r18
    384e:	20 81       	ld	r18, Z
    3850:	24 60       	ori	r18, 0x04	; 4
    3852:	fc 01       	movw	r30, r24
    3854:	20 83       	st	Z, r18
    3856:	8d e6       	ldi	r24, 0x6D	; 109
    3858:	90 e0       	ldi	r25, 0x00	; 0
    385a:	22 e0       	ldi	r18, 0x02	; 2
    385c:	fc 01       	movw	r30, r24
    385e:	20 83       	st	Z, r18
		}//end send to GAVR case

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    3860:	80 91 bb 01 	lds	r24, 0x01BB
    3864:	88 23       	and	r24, r24
    3866:	49 f1       	breq	.+82     	; 0x38ba <main+0x1c0>
			if (currentTime.getMinutes()%30 == 0){
    3868:	82 e9       	ldi	r24, 0x92	; 146
    386a:	91 e0       	ldi	r25, 0x01	; 1
    386c:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    3870:	9e e1       	ldi	r25, 0x1E	; 30
    3872:	69 2f       	mov	r22, r25
    3874:	0e 94 a2 22 	call	0x4544	; 0x4544 <__udivmodqi4>
    3878:	89 2f       	mov	r24, r25
    387a:	98 2f       	mov	r25, r24
    387c:	81 e0       	ldi	r24, 0x01	; 1
    387e:	99 23       	and	r25, r25
    3880:	09 f0       	breq	.+2      	; 0x3884 <main+0x18a>
    3882:	80 e0       	ldi	r24, 0x00	; 0
    3884:	88 23       	and	r24, r24
    3886:	c9 f0       	breq	.+50     	; 0x38ba <main+0x1c0>
				if (currentTime.getHours()%12 == 0){
    3888:	82 e9       	ldi	r24, 0x92	; 146
    388a:	91 e0       	ldi	r25, 0x01	; 1
    388c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    3890:	9c e0       	ldi	r25, 0x0C	; 12
    3892:	69 2f       	mov	r22, r25
    3894:	0e 94 a2 22 	call	0x4544	; 0x4544 <__udivmodqi4>
    3898:	89 2f       	mov	r24, r25
    389a:	98 2f       	mov	r25, r24
    389c:	81 e0       	ldi	r24, 0x01	; 1
    389e:	99 23       	and	r25, r25
    38a0:	09 f0       	breq	.+2      	; 0x38a4 <main+0x1aa>
    38a2:	80 e0       	ldi	r24, 0x00	; 0
    38a4:	88 23       	and	r24, r24
    38a6:	29 f0       	breq	.+10     	; 0x38b2 <main+0x1b8>
					saveDateTime_eeprom(fTrue,fTrue);
    38a8:	81 e0       	ldi	r24, 0x01	; 1
    38aa:	61 e0       	ldi	r22, 0x01	; 1
    38ac:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    38b0:	04 c0       	rjmp	.+8      	; 0x38ba <main+0x1c0>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    38b2:	81 e0       	ldi	r24, 0x01	; 1
    38b4:	60 e0       	ldi	r22, 0x00	; 0
    38b6:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}//end time capture/save

		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    38ba:	80 91 bb 01 	lds	r24, 0x01BB
    38be:	88 23       	and	r24, r24
    38c0:	09 f1       	breq	.+66     	; 0x3904 <main+0x20a>
			TakeADC();
    38c2:	0e 94 5b 1f 	call	0x3eb6	; 0x3eb6 <_Z7TakeADCv>
			//GetTemp();
			flagGoodTemp=fTrue;
    38c6:	81 e0       	ldi	r24, 0x01	; 1
    38c8:	80 93 c8 01 	sts	0x01C8, r24
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    38cc:	80 91 c9 01 	lds	r24, 0x01C9
    38d0:	88 23       	and	r24, r24
    38d2:	71 f0       	breq	.+28     	; 0x38f0 <main+0x1f6>
    38d4:	80 91 c8 01 	lds	r24, 0x01C8
    38d8:	88 23       	and	r24, r24
    38da:	51 f0       	breq	.+20     	; 0x38f0 <main+0x1f6>
				if(flagShutdown){restart = fTrue; flagShutdown=fFalse;}
    38dc:	80 91 c7 01 	lds	r24, 0x01C7
    38e0:	88 23       	and	r24, r24
    38e2:	81 f0       	breq	.+32     	; 0x3904 <main+0x20a>
    38e4:	81 e0       	ldi	r24, 0x01	; 1
    38e6:	80 93 ca 01 	sts	0x01CA, r24
    38ea:	10 92 c7 01 	sts	0x01C7, r1
    38ee:	0a c0       	rjmp	.+20     	; 0x3904 <main+0x20a>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (!flagShutdown){
    38f0:	80 91 c7 01 	lds	r24, 0x01C7
    38f4:	88 23       	and	r24, r24
    38f6:	31 f4       	brne	.+12     	; 0x3904 <main+0x20a>
					flagNewShutdown = fTrue;
    38f8:	81 e0       	ldi	r24, 0x01	; 1
    38fa:	80 93 c6 01 	sts	0x01C6, r24
					flagShutdown=fTrue;
    38fe:	81 e0       	ldi	r24, 0x01	; 1
    3900:	80 93 c7 01 	sts	0x01C7, r24
		
		//Waiting...
		//Wait_sec(1);
				
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    3904:	80 91 c6 01 	lds	r24, 0x01C6
    3908:	88 23       	and	r24, r24
    390a:	b9 f0       	breq	.+46     	; 0x393a <main+0x240>
			//Make sure nothing messes with the routine that we care about
			__killCommINT();
    390c:	8d e3       	ldi	r24, 0x3D	; 61
    390e:	90 e0       	ldi	r25, 0x00	; 0
    3910:	fc 01       	movw	r30, r24
    3912:	10 82       	st	Z, r1
    3914:	8d e6       	ldi	r24, 0x6D	; 109
    3916:	90 e0       	ldi	r25, 0x00	; 0
    3918:	fc 01       	movw	r30, r24
    391a:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    391c:	81 e0       	ldi	r24, 0x01	; 1
    391e:	80 93 81 01 	sts	0x0181, r24
			flagReceivingBone = fFalse;
    3922:	10 92 ba 01 	sts	0x01BA, r1
			flagUserClock=fFalse;						//reset this so next boot is correct. Done in restart case as well for redundancy
    3926:	10 92 c2 01 	sts	0x01C2, r1
			saveDateTime_eeprom(fTrue,fTrue);
    392a:	81 e0       	ldi	r24, 0x01	; 1
    392c:	61 e0       	ldi	r22, 0x01	; 1
    392e:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
			
			//Kill power--Alert comes in that function
			PowerDown();
    3932:	0e 94 1c 21 	call	0x4238	; 0x4238 <_Z9PowerDownv>
			flagNewShutdown = fFalse;
    3936:	10 92 c6 01 	sts	0x01C6, r1
		}//end new shutdown
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    393a:	80 91 ca 01 	lds	r24, 0x01CA
    393e:	88 23       	and	r24, r24
    3940:	c9 f0       	breq	.+50     	; 0x3974 <main+0x27a>
			//Enable COmmunication protocols and then power up. Power up specifies the timing for it to happen	
			PowerUp(POWER_UP_INTERVAL);
    3942:	83 e0       	ldi	r24, 0x03	; 3
    3944:	90 e0       	ldi	r25, 0x00	; 0
    3946:	0e 94 c6 20 	call	0x418c	; 0x418c <_Z7PowerUpj>
			__enableCommINT();
    394a:	8d e3       	ldi	r24, 0x3D	; 61
    394c:	90 e0       	ldi	r25, 0x00	; 0
    394e:	2d e3       	ldi	r18, 0x3D	; 61
    3950:	30 e0       	ldi	r19, 0x00	; 0
    3952:	f9 01       	movw	r30, r18
    3954:	20 81       	ld	r18, Z
    3956:	24 60       	ori	r18, 0x04	; 4
    3958:	fc 01       	movw	r30, r24
    395a:	20 83       	st	Z, r18
    395c:	8d e6       	ldi	r24, 0x6D	; 109
    395e:	90 e0       	ldi	r25, 0x00	; 0
    3960:	22 e0       	ldi	r18, 0x02	; 2
    3962:	fc 01       	movw	r30, r24
    3964:	20 83       	st	Z, r18
			//Update the GAVRClock since it's a restart, we have the correct date and time. If BeagleBone sends GPS data, use that to back it up.
			flagUpdateGAVRClock=fTrue;
    3966:	81 e0       	ldi	r24, 0x01	; 1
    3968:	80 93 c0 01 	sts	0x01C0, r24
			flagUserClock=fFalse;	
    396c:	10 92 c2 01 	sts	0x01C2, r1
			restart=fFalse;	
    3970:	10 92 ca 01 	sts	0x01CA, r1
		}//end restart		
		
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep){GoToSleep(flagShutdown);}
    3974:	80 91 81 01 	lds	r24, 0x0181
    3978:	88 23       	and	r24, r24
    397a:	21 f0       	breq	.+8      	; 0x3984 <main+0x28a>
    397c:	80 91 c7 01 	lds	r24, 0x01C7
    3980:	0e 94 fd 1e 	call	0x3dfa	; 0x3dfa <_Z9GoToSleeph>
		
		//Add logic for an invalid date and time somehow getting in here
		if (flagInvalidDateTime && !flagShutdown){
    3984:	80 91 c3 01 	lds	r24, 0x01C3
    3988:	88 23       	and	r24, r24
    398a:	09 f4       	brne	.+2      	; 0x398e <main+0x294>
    398c:	08 cf       	rjmp	.-496    	; 0x379e <main+0xa4>
    398e:	80 91 c7 01 	lds	r24, 0x01C7
    3992:	88 23       	and	r24, r24
    3994:	09 f0       	breq	.+2      	; 0x3998 <main+0x29e>
    3996:	03 cf       	rjmp	.-506    	; 0x379e <main+0xa4>
			flagInvalidDateTime=fFalse;
    3998:	10 92 c3 01 	sts	0x01C3, r1
			flagUserClock=fTrue;
    399c:	81 e0       	ldi	r24, 0x01	; 1
    399e:	80 93 c2 01 	sts	0x01C2, r24
			flagUpdateGAVRClock=fFalse;
    39a2:	10 92 c0 01 	sts	0x01C0, r1
		flagFreshStart=fFalse;
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
	//main programming loop
	while(fTrue)
    39a6:	fb ce       	rjmp	.-522    	; 0x379e <main+0xa4>

000039a8 <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    39a8:	cf 93       	push	r28
    39aa:	df 93       	push	r29
    39ac:	cd b7       	in	r28, 0x3d	; 61
    39ae:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    39b0:	81 e2       	ldi	r24, 0x21	; 33
    39b2:	90 e0       	ldi	r25, 0x00	; 0
    39b4:	fc 01       	movw	r30, r24
    39b6:	10 82       	st	Z, r1
	DDRB = 0;
    39b8:	84 e2       	ldi	r24, 0x24	; 36
    39ba:	90 e0       	ldi	r25, 0x00	; 0
    39bc:	fc 01       	movw	r30, r24
    39be:	10 82       	st	Z, r1
	DDRC = 0;
    39c0:	87 e2       	ldi	r24, 0x27	; 39
    39c2:	90 e0       	ldi	r25, 0x00	; 0
    39c4:	fc 01       	movw	r30, r24
    39c6:	10 82       	st	Z, r1
	DDRD = 0;
    39c8:	8a e2       	ldi	r24, 0x2A	; 42
    39ca:	90 e0       	ldi	r25, 0x00	; 0
    39cc:	fc 01       	movw	r30, r24
    39ce:	10 82       	st	Z, r1
	
	PORTA = 0;
    39d0:	82 e2       	ldi	r24, 0x22	; 34
    39d2:	90 e0       	ldi	r25, 0x00	; 0
    39d4:	fc 01       	movw	r30, r24
    39d6:	10 82       	st	Z, r1
	PORTB = 0;
    39d8:	85 e2       	ldi	r24, 0x25	; 37
    39da:	90 e0       	ldi	r25, 0x00	; 0
    39dc:	fc 01       	movw	r30, r24
    39de:	10 82       	st	Z, r1
	PORTC = 0;
    39e0:	88 e2       	ldi	r24, 0x28	; 40
    39e2:	90 e0       	ldi	r25, 0x00	; 0
    39e4:	fc 01       	movw	r30, r24
    39e6:	10 82       	st	Z, r1
	PORTD = 0;
    39e8:	8b e2       	ldi	r24, 0x2B	; 43
    39ea:	90 e0       	ldi	r25, 0x00	; 0
    39ec:	fc 01       	movw	r30, r24
    39ee:	10 82       	st	Z, r1
}
    39f0:	df 91       	pop	r29
    39f2:	cf 91       	pop	r28
    39f4:	08 95       	ret

000039f6 <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    39f6:	cf 93       	push	r28
    39f8:	df 93       	push	r29
    39fa:	00 d0       	rcall	.+0      	; 0x39fc <_Z7AppInitj+0x6>
    39fc:	cd b7       	in	r28, 0x3d	; 61
    39fe:	de b7       	in	r29, 0x3e	; 62
    3a00:	9a 83       	std	Y+2, r25	; 0x02
    3a02:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    3a04:	84 ec       	ldi	r24, 0xC4	; 196
    3a06:	90 e0       	ldi	r25, 0x00	; 0
    3a08:	29 81       	ldd	r18, Y+1	; 0x01
    3a0a:	fc 01       	movw	r30, r24
    3a0c:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    3a0e:	85 ec       	ldi	r24, 0xC5	; 197
    3a10:	90 e0       	ldi	r25, 0x00	; 0
    3a12:	29 81       	ldd	r18, Y+1	; 0x01
    3a14:	3a 81       	ldd	r19, Y+2	; 0x02
    3a16:	23 2f       	mov	r18, r19
    3a18:	33 27       	eor	r19, r19
    3a1a:	fc 01       	movw	r30, r24
    3a1c:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    3a1e:	81 ec       	ldi	r24, 0xC1	; 193
    3a20:	90 e0       	ldi	r25, 0x00	; 0
    3a22:	28 e1       	ldi	r18, 0x18	; 24
    3a24:	fc 01       	movw	r30, r24
    3a26:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    3a28:	82 ec       	ldi	r24, 0xC2	; 194
    3a2a:	90 e0       	ldi	r25, 0x00	; 0
    3a2c:	26 e0       	ldi	r18, 0x06	; 6
    3a2e:	fc 01       	movw	r30, r24
    3a30:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Set BAUD for UART1
	UBRR1L = ubrr;
    3a32:	8c ec       	ldi	r24, 0xCC	; 204
    3a34:	90 e0       	ldi	r25, 0x00	; 0
    3a36:	29 81       	ldd	r18, Y+1	; 0x01
    3a38:	fc 01       	movw	r30, r24
    3a3a:	20 83       	st	Z, r18
	UBRR1H = (ubrr >> 8);
    3a3c:	8d ec       	ldi	r24, 0xCD	; 205
    3a3e:	90 e0       	ldi	r25, 0x00	; 0
    3a40:	29 81       	ldd	r18, Y+1	; 0x01
    3a42:	3a 81       	ldd	r19, Y+2	; 0x02
    3a44:	23 2f       	mov	r18, r19
    3a46:	33 27       	eor	r19, r19
    3a48:	fc 01       	movw	r30, r24
    3a4a:	20 83       	st	Z, r18
	//UCSR1A |= (1 << U2X1);
	
	//Enable UART_TX1 and UART_RX1
	UCSR1B = (1 << TXEN1)|(1 << RXEN1);
    3a4c:	89 ec       	ldi	r24, 0xC9	; 201
    3a4e:	90 e0       	ldi	r25, 0x00	; 0
    3a50:	28 e1       	ldi	r18, 0x18	; 24
    3a52:	fc 01       	movw	r30, r24
    3a54:	20 83       	st	Z, r18
	UCSR1C = (1 << UCSZ11)|(1 << UCSZ10);
    3a56:	8a ec       	ldi	r24, 0xCA	; 202
    3a58:	90 e0       	ldi	r25, 0x00	; 0
    3a5a:	26 e0       	ldi	r18, 0x06	; 6
    3a5c:	fc 01       	movw	r30, r24
    3a5e:	20 83       	st	Z, r18
	//UCSR1B |= (1 << RXCIE1);
	__killUARTrec();
    3a60:	81 ec       	ldi	r24, 0xC1	; 193
    3a62:	90 e0       	ldi	r25, 0x00	; 0
    3a64:	21 ec       	ldi	r18, 0xC1	; 193
    3a66:	30 e0       	ldi	r19, 0x00	; 0
    3a68:	f9 01       	movw	r30, r18
    3a6a:	20 81       	ld	r18, Z
    3a6c:	20 68       	ori	r18, 0x80	; 128
    3a6e:	fc 01       	movw	r30, r24
    3a70:	20 83       	st	Z, r18
    3a72:	89 ec       	ldi	r24, 0xC9	; 201
    3a74:	90 e0       	ldi	r25, 0x00	; 0
    3a76:	29 ec       	ldi	r18, 0xC9	; 201
    3a78:	30 e0       	ldi	r19, 0x00	; 0
    3a7a:	f9 01       	movw	r30, r18
    3a7c:	20 81       	ld	r18, Z
    3a7e:	20 68       	ori	r18, 0x80	; 128
    3a80:	fc 01       	movw	r30, r24
    3a82:	20 83       	st	Z, r18
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM0)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    3a84:	84 e6       	ldi	r24, 0x64	; 100
    3a86:	90 e0       	ldi	r25, 0x00	; 0
    3a88:	24 e6       	ldi	r18, 0x64	; 100
    3a8a:	30 e0       	ldi	r19, 0x00	; 0
    3a8c:	f9 01       	movw	r30, r18
    3a8e:	20 81       	ld	r18, Z
    3a90:	2d 6a       	ori	r18, 0xAD	; 173
    3a92:	fc 01       	movw	r30, r24
    3a94:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    3a96:	8a e2       	ldi	r24, 0x2A	; 42
    3a98:	90 e0       	ldi	r25, 0x00	; 0
    3a9a:	2a e2       	ldi	r18, 0x2A	; 42
    3a9c:	30 e0       	ldi	r19, 0x00	; 0
    3a9e:	f9 01       	movw	r30, r18
    3aa0:	20 81       	ld	r18, Z
    3aa2:	20 68       	ori	r18, 0x80	; 128
    3aa4:	fc 01       	movw	r30, r24
    3aa6:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    3aa8:	87 e2       	ldi	r24, 0x27	; 39
    3aaa:	90 e0       	ldi	r25, 0x00	; 0
    3aac:	27 e2       	ldi	r18, 0x27	; 39
    3aae:	30 e0       	ldi	r19, 0x00	; 0
    3ab0:	f9 01       	movw	r30, r18
    3ab2:	20 81       	ld	r18, Z
    3ab4:	24 60       	ori	r18, 0x04	; 4
    3ab6:	fc 01       	movw	r30, r24
    3ab8:	20 83       	st	Z, r18
	prtSLEEPled |= (1 << bnSLEEPled);	//turn off initially
    3aba:	8b e2       	ldi	r24, 0x2B	; 43
    3abc:	90 e0       	ldi	r25, 0x00	; 0
    3abe:	2b e2       	ldi	r18, 0x2B	; 43
    3ac0:	30 e0       	ldi	r19, 0x00	; 0
    3ac2:	f9 01       	movw	r30, r18
    3ac4:	20 81       	ld	r18, Z
    3ac6:	20 68       	ori	r18, 0x80	; 128
    3ac8:	fc 01       	movw	r30, r24
    3aca:	20 83       	st	Z, r18
	prtSTATUSled &= ~(1 << bnSTATUSled);	//turn on initially
    3acc:	88 e2       	ldi	r24, 0x28	; 40
    3ace:	90 e0       	ldi	r25, 0x00	; 0
    3ad0:	28 e2       	ldi	r18, 0x28	; 40
    3ad2:	30 e0       	ldi	r19, 0x00	; 0
    3ad4:	f9 01       	movw	r30, r18
    3ad6:	20 81       	ld	r18, Z
    3ad8:	2b 7f       	andi	r18, 0xFB	; 251
    3ada:	fc 01       	movw	r30, r24
    3adc:	20 83       	st	Z, r18
	
	//Enable BB and GAVR interrupts for COMMUNICATION
	ddrBONEINT |= (1 << bnBONEINT);
    3ade:	81 e2       	ldi	r24, 0x21	; 33
    3ae0:	90 e0       	ldi	r25, 0x00	; 0
    3ae2:	21 e2       	ldi	r18, 0x21	; 33
    3ae4:	30 e0       	ldi	r19, 0x00	; 0
    3ae6:	f9 01       	movw	r30, r18
    3ae8:	20 81       	ld	r18, Z
    3aea:	22 60       	ori	r18, 0x02	; 2
    3aec:	fc 01       	movw	r30, r24
    3aee:	20 83       	st	Z, r18
	ddrGAVRINT |= (1 << bnGAVRINT);
    3af0:	84 e2       	ldi	r24, 0x24	; 36
    3af2:	90 e0       	ldi	r25, 0x00	; 0
    3af4:	24 e2       	ldi	r18, 0x24	; 36
    3af6:	30 e0       	ldi	r19, 0x00	; 0
    3af8:	f9 01       	movw	r30, r18
    3afa:	20 81       	ld	r18, Z
    3afc:	28 60       	ori	r18, 0x08	; 8
    3afe:	fc 01       	movw	r30, r24
    3b00:	20 83       	st	Z, r18
	prtBONEINT &= ~(1 << bnBONEINT);
    3b02:	82 e2       	ldi	r24, 0x22	; 34
    3b04:	90 e0       	ldi	r25, 0x00	; 0
    3b06:	22 e2       	ldi	r18, 0x22	; 34
    3b08:	30 e0       	ldi	r19, 0x00	; 0
    3b0a:	f9 01       	movw	r30, r18
    3b0c:	20 81       	ld	r18, Z
    3b0e:	2d 7f       	andi	r18, 0xFD	; 253
    3b10:	fc 01       	movw	r30, r24
    3b12:	20 83       	st	Z, r18
	prtGAVRINT &= ~(1 << bnGAVRINT);
    3b14:	85 e2       	ldi	r24, 0x25	; 37
    3b16:	90 e0       	ldi	r25, 0x00	; 0
    3b18:	25 e2       	ldi	r18, 0x25	; 37
    3b1a:	30 e0       	ldi	r19, 0x00	; 0
    3b1c:	f9 01       	movw	r30, r18
    3b1e:	20 81       	ld	r18, Z
    3b20:	27 7f       	andi	r18, 0xF7	; 247
    3b22:	fc 01       	movw	r30, r24
    3b24:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrInterrupts |= (1 << bnGAVRint)|(1 << bnBBint);
    3b26:	81 e2       	ldi	r24, 0x21	; 33
    3b28:	90 e0       	ldi	r25, 0x00	; 0
    3b2a:	21 e2       	ldi	r18, 0x21	; 33
    3b2c:	30 e0       	ldi	r19, 0x00	; 0
    3b2e:	f9 01       	movw	r30, r18
    3b30:	20 81       	ld	r18, Z
    3b32:	2c 60       	ori	r18, 0x0C	; 12
    3b34:	fc 01       	movw	r30, r24
    3b36:	20 83       	st	Z, r18
	prtInterrupts &= ~((1 << bnGAVRint)|(1 << bnBBint));
    3b38:	82 e2       	ldi	r24, 0x22	; 34
    3b3a:	90 e0       	ldi	r25, 0x00	; 0
    3b3c:	22 e2       	ldi	r18, 0x22	; 34
    3b3e:	30 e0       	ldi	r19, 0x00	; 0
    3b40:	f9 01       	movw	r30, r18
    3b42:	20 81       	ld	r18, Z
    3b44:	23 7f       	andi	r18, 0xF3	; 243
    3b46:	fc 01       	movw	r30, r24
    3b48:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen)|(1 << bnBBen);
    3b4a:	81 e2       	ldi	r24, 0x21	; 33
    3b4c:	90 e0       	ldi	r25, 0x00	; 0
    3b4e:	21 e2       	ldi	r18, 0x21	; 33
    3b50:	30 e0       	ldi	r19, 0x00	; 0
    3b52:	f9 01       	movw	r30, r18
    3b54:	20 81       	ld	r18, Z
    3b56:	20 6f       	ori	r18, 0xF0	; 240
    3b58:	fc 01       	movw	r30, r24
    3b5a:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    3b5c:	84 e2       	ldi	r24, 0x24	; 36
    3b5e:	90 e0       	ldi	r25, 0x00	; 0
    3b60:	24 e2       	ldi	r18, 0x24	; 36
    3b62:	30 e0       	ldi	r19, 0x00	; 0
    3b64:	f9 01       	movw	r30, r18
    3b66:	20 81       	ld	r18, Z
    3b68:	21 60       	ori	r18, 0x01	; 1
    3b6a:	fc 01       	movw	r30, r24
    3b6c:	20 83       	st	Z, r18
	ddrMAINen |= (1 << bnMAINen);
    3b6e:	87 e2       	ldi	r24, 0x27	; 39
    3b70:	90 e0       	ldi	r25, 0x00	; 0
    3b72:	27 e2       	ldi	r18, 0x27	; 39
    3b74:	30 e0       	ldi	r19, 0x00	; 0
    3b76:	f9 01       	movw	r30, r18
    3b78:	20 81       	ld	r18, Z
    3b7a:	21 60       	ori	r18, 0x01	; 1
    3b7c:	fc 01       	movw	r30, r24
    3b7e:	20 83       	st	Z, r18
	__killMain();
    3b80:	88 e2       	ldi	r24, 0x28	; 40
    3b82:	90 e0       	ldi	r25, 0x00	; 0
    3b84:	28 e2       	ldi	r18, 0x28	; 40
    3b86:	30 e0       	ldi	r19, 0x00	; 0
    3b88:	f9 01       	movw	r30, r18
    3b8a:	20 81       	ld	r18, Z
    3b8c:	2e 7f       	andi	r18, 0xFE	; 254
    3b8e:	fc 01       	movw	r30, r24
    3b90:	20 83       	st	Z, r18
	__killBeagleBone();
    3b92:	82 e2       	ldi	r24, 0x22	; 34
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	22 e2       	ldi	r18, 0x22	; 34
    3b98:	30 e0       	ldi	r19, 0x00	; 0
    3b9a:	f9 01       	movw	r30, r18
    3b9c:	20 81       	ld	r18, Z
    3b9e:	2f 7e       	andi	r18, 0xEF	; 239
    3ba0:	fc 01       	movw	r30, r24
    3ba2:	20 83       	st	Z, r18
	__enableTemp();
    3ba4:	85 e2       	ldi	r24, 0x25	; 37
    3ba6:	90 e0       	ldi	r25, 0x00	; 0
    3ba8:	25 e2       	ldi	r18, 0x25	; 37
    3baa:	30 e0       	ldi	r19, 0x00	; 0
    3bac:	f9 01       	movw	r30, r18
    3bae:	20 81       	ld	r18, Z
    3bb0:	21 60       	ori	r18, 0x01	; 1
    3bb2:	fc 01       	movw	r30, r24
    3bb4:	20 83       	st	Z, r18
	__killLCD();
    3bb6:	82 e2       	ldi	r24, 0x22	; 34
    3bb8:	90 e0       	ldi	r25, 0x00	; 0
    3bba:	22 e2       	ldi	r18, 0x22	; 34
    3bbc:	30 e0       	ldi	r19, 0x00	; 0
    3bbe:	f9 01       	movw	r30, r18
    3bc0:	20 81       	ld	r18, Z
    3bc2:	2f 7d       	andi	r18, 0xDF	; 223
    3bc4:	fc 01       	movw	r30, r24
    3bc6:	20 83       	st	Z, r18
	__killGPSandGAVR();
    3bc8:	82 e2       	ldi	r24, 0x22	; 34
    3bca:	90 e0       	ldi	r25, 0x00	; 0
    3bcc:	22 e2       	ldi	r18, 0x22	; 34
    3bce:	30 e0       	ldi	r19, 0x00	; 0
    3bd0:	f9 01       	movw	r30, r18
    3bd2:	20 81       	ld	r18, Z
    3bd4:	2f 73       	andi	r18, 0x3F	; 63
    3bd6:	fc 01       	movw	r30, r24
    3bd8:	20 83       	st	Z, r18

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	__killCommINT();
    3bda:	8d e3       	ldi	r24, 0x3D	; 61
    3bdc:	90 e0       	ldi	r25, 0x00	; 0
    3bde:	fc 01       	movw	r30, r24
    3be0:	10 82       	st	Z, r1
    3be2:	8d e6       	ldi	r24, 0x6D	; 109
    3be4:	90 e0       	ldi	r25, 0x00	; 0
    3be6:	fc 01       	movw	r30, r24
    3be8:	10 82       	st	Z, r1
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    3bea:	89 e6       	ldi	r24, 0x69	; 105
    3bec:	90 e0       	ldi	r25, 0x00	; 0
    3bee:	20 e3       	ldi	r18, 0x30	; 48
    3bf0:	fc 01       	movw	r30, r24
    3bf2:	20 83       	st	Z, r18
	//Enable PCINT17
	PCICR |= (1 << PCIE0);
    3bf4:	88 e6       	ldi	r24, 0x68	; 104
    3bf6:	90 e0       	ldi	r25, 0x00	; 0
    3bf8:	28 e6       	ldi	r18, 0x68	; 104
    3bfa:	30 e0       	ldi	r19, 0x00	; 0
    3bfc:	f9 01       	movw	r30, r18
    3bfe:	20 81       	ld	r18, Z
    3c00:	21 60       	ori	r18, 0x01	; 1
    3c02:	fc 01       	movw	r30, r24
    3c04:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    3c06:	84 e2       	ldi	r24, 0x24	; 36
    3c08:	90 e0       	ldi	r25, 0x00	; 0
    3c0a:	24 e2       	ldi	r18, 0x24	; 36
    3c0c:	30 e0       	ldi	r19, 0x00	; 0
    3c0e:	f9 01       	movw	r30, r18
    3c10:	20 81       	ld	r18, Z
    3c12:	20 6b       	ori	r18, 0xB0	; 176
    3c14:	fc 01       	movw	r30, r24
    3c16:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    3c18:	84 e2       	ldi	r24, 0x24	; 36
    3c1a:	90 e0       	ldi	r25, 0x00	; 0
    3c1c:	24 e2       	ldi	r18, 0x24	; 36
    3c1e:	30 e0       	ldi	r19, 0x00	; 0
    3c20:	f9 01       	movw	r30, r18
    3c22:	20 81       	ld	r18, Z
    3c24:	2f 7b       	andi	r18, 0xBF	; 191
    3c26:	fc 01       	movw	r30, r24
    3c28:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    3c2a:	85 e2       	ldi	r24, 0x25	; 37
    3c2c:	90 e0       	ldi	r25, 0x00	; 0
    3c2e:	25 e2       	ldi	r18, 0x25	; 37
    3c30:	30 e0       	ldi	r19, 0x00	; 0
    3c32:	f9 01       	movw	r30, r18
    3c34:	20 81       	ld	r18, Z
    3c36:	20 69       	ori	r18, 0x90	; 144
    3c38:	fc 01       	movw	r30, r24
    3c3a:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    3c3c:	85 e2       	ldi	r24, 0x25	; 37
    3c3e:	90 e0       	ldi	r25, 0x00	; 0
    3c40:	25 e2       	ldi	r18, 0x25	; 37
    3c42:	30 e0       	ldi	r19, 0x00	; 0
    3c44:	f9 01       	movw	r30, r18
    3c46:	20 81       	ld	r18, Z
    3c48:	2f 7d       	andi	r18, 0xDF	; 223
    3c4a:	fc 01       	movw	r30, r24
    3c4c:	20 83       	st	Z, r18
	
}
    3c4e:	0f 90       	pop	r0
    3c50:	0f 90       	pop	r0
    3c52:	df 91       	pop	r29
    3c54:	cf 91       	pop	r28
    3c56:	08 95       	ret

00003c58 <_Z9InitBoolsv>:
/*************************************************************************************************************/
void InitBools(){
    3c58:	cf 93       	push	r28
    3c5a:	df 93       	push	r29
    3c5c:	cd b7       	in	r28, 0x3d	; 61
    3c5e:	de b7       	in	r29, 0x3e	; 62
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    3c60:	81 e0       	ldi	r24, 0x01	; 1
    3c62:	80 93 81 01 	sts	0x0181, r24
	flagReceivingBone = fFalse;
    3c66:	10 92 ba 01 	sts	0x01BA, r1
	flagNormalMode=fTrue;
    3c6a:	81 e0       	ldi	r24, 0x01	; 1
    3c6c:	80 93 bb 01 	sts	0x01BB, r24
	flagReceivingGAVR=fFalse;
    3c70:	10 92 bc 01 	sts	0x01BC, r1
	flagWaitingForReceiveGAVR=fFalse;
    3c74:	10 92 bd 01 	sts	0x01BD, r1
	flagWaitingForSYNGAVR=fFalse;
    3c78:	10 92 be 01 	sts	0x01BE, r1
	flagWaitingForSYNBone=fFalse;
    3c7c:	10 92 bf 01 	sts	0x01BF, r1

	flagUpdateGAVRClock=fFalse;
    3c80:	10 92 c0 01 	sts	0x01C0, r1
	flagSendingGAVR=fFalse;
    3c84:	10 92 c1 01 	sts	0x01C1, r1
	flagUserClock=fFalse;
    3c88:	10 92 c2 01 	sts	0x01C2, r1
	flagInvalidDateTime=fFalse;
    3c8c:	10 92 c3 01 	sts	0x01C3, r1
	flagWaitingToSendGAVR=fFalse;
    3c90:	10 92 c4 01 	sts	0x01C4, r1
	flagGPSTime=fFalse;
    3c94:	10 92 c5 01 	sts	0x01C5, r1
	
	restart=fFalse;
    3c98:	10 92 ca 01 	sts	0x01CA, r1
	//flagNewShutdown=fFalse;
	flagShutdown=fFalse;		//Initialized in startup procedure in beginning of "main"
    3c9c:	10 92 c7 01 	sts	0x01C7, r1
	flagGoodVolts=fFalse;
    3ca0:	10 92 c9 01 	sts	0x01C9, r1
	flagGoodTemp=fFalse;
    3ca4:	10 92 c8 01 	sts	0x01C8, r1
	//flagFreshStart=fTrue;		//Initialized in startup procedure in beginning of "main"
}
    3ca8:	df 91       	pop	r29
    3caa:	cf 91       	pop	r28
    3cac:	08 95       	ret

00003cae <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    3cae:	cf 93       	push	r28
    3cb0:	df 93       	push	r29
    3cb2:	cd b7       	in	r28, 0x3d	; 61
    3cb4:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    3cb6:	84 e6       	ldi	r24, 0x64	; 100
    3cb8:	90 e0       	ldi	r25, 0x00	; 0
    3cba:	24 e6       	ldi	r18, 0x64	; 100
    3cbc:	30 e0       	ldi	r19, 0x00	; 0
    3cbe:	f9 01       	movw	r30, r18
    3cc0:	20 81       	ld	r18, Z
    3cc2:	2f 7b       	andi	r18, 0xBF	; 191
    3cc4:	fc 01       	movw	r30, r24
    3cc6:	20 83       	st	Z, r18
	Wait_ms(5);	//give it time to power on
    3cc8:	85 e0       	ldi	r24, 0x05	; 5
    3cca:	90 e0       	ldi	r25, 0x00	; 0
    3ccc:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    3cd0:	86 eb       	ldi	r24, 0xB6	; 182
    3cd2:	90 e0       	ldi	r25, 0x00	; 0
    3cd4:	26 eb       	ldi	r18, 0xB6	; 182
    3cd6:	30 e0       	ldi	r19, 0x00	; 0
    3cd8:	f9 01       	movw	r30, r18
    3cda:	20 81       	ld	r18, Z
    3cdc:	20 62       	ori	r18, 0x20	; 32
    3cde:	fc 01       	movw	r30, r24
    3ce0:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    3ce2:	81 eb       	ldi	r24, 0xB1	; 177
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	21 eb       	ldi	r18, 0xB1	; 177
    3ce8:	30 e0       	ldi	r19, 0x00	; 0
    3cea:	f9 01       	movw	r30, r18
    3cec:	20 81       	ld	r18, Z
    3cee:	25 60       	ori	r18, 0x05	; 5
    3cf0:	fc 01       	movw	r30, r24
    3cf2:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    3cf4:	86 eb       	ldi	r24, 0xB6	; 182
    3cf6:	90 e0       	ldi	r25, 0x00	; 0
    3cf8:	fc 01       	movw	r30, r24
    3cfa:	80 81       	ld	r24, Z
    3cfc:	88 2f       	mov	r24, r24
    3cfe:	90 e0       	ldi	r25, 0x00	; 0
    3d00:	81 71       	andi	r24, 0x11	; 17
    3d02:	90 70       	andi	r25, 0x00	; 0
    3d04:	21 e0       	ldi	r18, 0x01	; 1
    3d06:	00 97       	sbiw	r24, 0x00	; 0
    3d08:	09 f4       	brne	.+2      	; 0x3d0c <_Z14EnableRTCTimerv+0x5e>
    3d0a:	20 e0       	ldi	r18, 0x00	; 0
    3d0c:	22 23       	and	r18, r18
    3d0e:	91 f7       	brne	.-28     	; 0x3cf4 <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    3d10:	87 e3       	ldi	r24, 0x37	; 55
    3d12:	90 e0       	ldi	r25, 0x00	; 0
    3d14:	21 e0       	ldi	r18, 0x01	; 1
    3d16:	fc 01       	movw	r30, r24
    3d18:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    3d1a:	80 e7       	ldi	r24, 0x70	; 112
    3d1c:	90 e0       	ldi	r25, 0x00	; 0
    3d1e:	21 e0       	ldi	r18, 0x01	; 1
    3d20:	fc 01       	movw	r30, r24
    3d22:	20 83       	st	Z, r18
	
	//Away we go
}
    3d24:	df 91       	pop	r29
    3d26:	cf 91       	pop	r28
    3d28:	08 95       	ret

00003d2a <_Z7Wait_msi>:
/*************************************************************************************************************/
void Wait_ms(int delay)
{
    3d2a:	cf 93       	push	r28
    3d2c:	df 93       	push	r29
    3d2e:	00 d0       	rcall	.+0      	; 0x3d30 <_Z7Wait_msi+0x6>
    3d30:	00 d0       	rcall	.+0      	; 0x3d32 <_Z7Wait_msi+0x8>
    3d32:	cd b7       	in	r28, 0x3d	; 61
    3d34:	de b7       	in	r29, 0x3e	; 62
    3d36:	9c 83       	std	Y+4, r25	; 0x04
    3d38:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    3d3a:	17 c0       	rjmp	.+46     	; 0x3d6a <_Z7Wait_msi+0x40>
		for(i = 0; i < 200; i++){
    3d3c:	1a 82       	std	Y+2, r1	; 0x02
    3d3e:	19 82       	std	Y+1, r1	; 0x01
    3d40:	06 c0       	rjmp	.+12     	; 0x3d4e <_Z7Wait_msi+0x24>
			asm volatile("nop");
    3d42:	00 00       	nop
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 200; i++){
    3d44:	89 81       	ldd	r24, Y+1	; 0x01
    3d46:	9a 81       	ldd	r25, Y+2	; 0x02
    3d48:	01 96       	adiw	r24, 0x01	; 1
    3d4a:	9a 83       	std	Y+2, r25	; 0x02
    3d4c:	89 83       	std	Y+1, r24	; 0x01
    3d4e:	89 81       	ldd	r24, Y+1	; 0x01
    3d50:	9a 81       	ldd	r25, Y+2	; 0x02
    3d52:	21 e0       	ldi	r18, 0x01	; 1
    3d54:	88 3c       	cpi	r24, 0xC8	; 200
    3d56:	91 05       	cpc	r25, r1
    3d58:	0c f0       	brlt	.+2      	; 0x3d5c <_Z7Wait_msi+0x32>
    3d5a:	20 e0       	ldi	r18, 0x00	; 0
    3d5c:	22 23       	and	r18, r18
    3d5e:	89 f7       	brne	.-30     	; 0x3d42 <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    3d60:	8b 81       	ldd	r24, Y+3	; 0x03
    3d62:	9c 81       	ldd	r25, Y+4	; 0x04
    3d64:	01 97       	sbiw	r24, 0x01	; 1
    3d66:	9c 83       	std	Y+4, r25	; 0x04
    3d68:	8b 83       	std	Y+3, r24	; 0x03
/*************************************************************************************************************/
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
    3d6a:	21 e0       	ldi	r18, 0x01	; 1
    3d6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3d6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3d70:	18 16       	cp	r1, r24
    3d72:	19 06       	cpc	r1, r25
    3d74:	0c f0       	brlt	.+2      	; 0x3d78 <_Z7Wait_msi+0x4e>
    3d76:	20 e0       	ldi	r18, 0x00	; 0
    3d78:	22 23       	and	r18, r18
    3d7a:	01 f7       	brne	.-64     	; 0x3d3c <_Z7Wait_msi+0x12>
		for(i = 0; i < 200; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    3d7c:	0f 90       	pop	r0
    3d7e:	0f 90       	pop	r0
    3d80:	0f 90       	pop	r0
    3d82:	0f 90       	pop	r0
    3d84:	df 91       	pop	r29
    3d86:	cf 91       	pop	r28
    3d88:	08 95       	ret

00003d8a <_Z8Wait_seci>:
/************************************************************************************************************/
void Wait_sec(int sec){
    3d8a:	cf 93       	push	r28
    3d8c:	df 93       	push	r29
    3d8e:	00 d0       	rcall	.+0      	; 0x3d90 <_Z8Wait_seci+0x6>
    3d90:	00 d0       	rcall	.+0      	; 0x3d92 <_Z8Wait_seci+0x8>
    3d92:	00 d0       	rcall	.+0      	; 0x3d94 <_Z8Wait_seci+0xa>
    3d94:	cd b7       	in	r28, 0x3d	; 61
    3d96:	de b7       	in	r29, 0x3e	; 62
    3d98:	9e 83       	std	Y+6, r25	; 0x06
    3d9a:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    3d9c:	82 e9       	ldi	r24, 0x92	; 146
    3d9e:	91 e0       	ldi	r25, 0x01	; 1
    3da0:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    3da4:	88 2f       	mov	r24, r24
    3da6:	90 e0       	ldi	r25, 0x00	; 0
    3da8:	9a 83       	std	Y+2, r25	; 0x02
    3daa:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    3dac:	29 81       	ldd	r18, Y+1	; 0x01
    3dae:	3a 81       	ldd	r19, Y+2	; 0x02
    3db0:	8d 81       	ldd	r24, Y+5	; 0x05
    3db2:	9e 81       	ldd	r25, Y+6	; 0x06
    3db4:	82 0f       	add	r24, r18
    3db6:	93 1f       	adc	r25, r19
    3db8:	2c e3       	ldi	r18, 0x3C	; 60
    3dba:	30 e0       	ldi	r19, 0x00	; 0
    3dbc:	b9 01       	movw	r22, r18
    3dbe:	0e 94 ae 22 	call	0x455c	; 0x455c <__divmodhi4>
    3dc2:	9c 83       	std	Y+4, r25	; 0x04
    3dc4:	8b 83       	std	Y+3, r24	; 0x03
	while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    3dc6:	01 c0       	rjmp	.+2      	; 0x3dca <_Z8Wait_seci+0x40>
    3dc8:	00 00       	nop
    3dca:	82 e9       	ldi	r24, 0x92	; 146
    3dcc:	91 e0       	ldi	r25, 0x01	; 1
    3dce:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    3dd2:	28 2f       	mov	r18, r24
    3dd4:	30 e0       	ldi	r19, 0x00	; 0
    3dd6:	8b 81       	ldd	r24, Y+3	; 0x03
    3dd8:	9c 81       	ldd	r25, Y+4	; 0x04
    3dda:	41 e0       	ldi	r20, 0x01	; 1
    3ddc:	28 17       	cp	r18, r24
    3dde:	39 07       	cpc	r19, r25
    3de0:	09 f4       	brne	.+2      	; 0x3de4 <_Z8Wait_seci+0x5a>
    3de2:	40 e0       	ldi	r20, 0x00	; 0
    3de4:	44 23       	and	r20, r20
    3de6:	81 f7       	brne	.-32     	; 0x3dc8 <_Z8Wait_seci+0x3e>
}
    3de8:	26 96       	adiw	r28, 0x06	; 6
    3dea:	0f b6       	in	r0, 0x3f	; 63
    3dec:	f8 94       	cli
    3dee:	de bf       	out	0x3e, r29	; 62
    3df0:	0f be       	out	0x3f, r0	; 63
    3df2:	cd bf       	out	0x3d, r28	; 61
    3df4:	df 91       	pop	r29
    3df6:	cf 91       	pop	r28
    3df8:	08 95       	ret

00003dfa <_Z9GoToSleeph>:

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    3dfa:	cf 93       	push	r28
    3dfc:	df 93       	push	r29
    3dfe:	00 d0       	rcall	.+0      	; 0x3e00 <_Z9GoToSleeph+0x6>
    3e00:	00 d0       	rcall	.+0      	; 0x3e02 <_Z9GoToSleeph+0x8>
    3e02:	0f 92       	push	r0
    3e04:	cd b7       	in	r28, 0x3d	; 61
    3e06:	de b7       	in	r29, 0x3e	; 62
    3e08:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    3e0a:	78 94       	sei
		int sleepTime, sleepTicks = 0;
    3e0c:	1c 82       	std	Y+4, r1	; 0x04
    3e0e:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong){
    3e10:	8d 81       	ldd	r24, Y+5	; 0x05
    3e12:	88 23       	and	r24, r24
    3e14:	29 f0       	breq	.+10     	; 0x3e20 <_Z9GoToSleeph+0x26>
			sleepTime = SLEEP_TICKS_LOWV;
    3e16:	8c e0       	ldi	r24, 0x0C	; 12
    3e18:	90 e0       	ldi	r25, 0x00	; 0
    3e1a:	9a 83       	std	Y+2, r25	; 0x02
    3e1c:	89 83       	std	Y+1, r24	; 0x01
    3e1e:	04 c0       	rjmp	.+8      	; 0x3e28 <_Z9GoToSleeph+0x2e>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    3e20:	8a e0       	ldi	r24, 0x0A	; 10
    3e22:	90 e0       	ldi	r25, 0x00	; 0
    3e24:	9a 83       	std	Y+2, r25	; 0x02
    3e26:	89 83       	std	Y+1, r24	; 0x01
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    3e28:	88 e2       	ldi	r24, 0x28	; 40
    3e2a:	90 e0       	ldi	r25, 0x00	; 0
    3e2c:	28 e2       	ldi	r18, 0x28	; 40
    3e2e:	30 e0       	ldi	r19, 0x00	; 0
    3e30:	f9 01       	movw	r30, r18
    3e32:	20 81       	ld	r18, Z
    3e34:	2b 7f       	andi	r18, 0xFB	; 251
    3e36:	fc 01       	movw	r30, r24
    3e38:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    3e3a:	83 e5       	ldi	r24, 0x53	; 83
    3e3c:	90 e0       	ldi	r25, 0x00	; 0
    3e3e:	26 e0       	ldi	r18, 0x06	; 6
    3e40:	fc 01       	movw	r30, r24
    3e42:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    3e44:	83 e5       	ldi	r24, 0x53	; 83
    3e46:	90 e0       	ldi	r25, 0x00	; 0
    3e48:	23 e5       	ldi	r18, 0x53	; 83
    3e4a:	30 e0       	ldi	r19, 0x00	; 0
    3e4c:	f9 01       	movw	r30, r18
    3e4e:	20 81       	ld	r18, Z
    3e50:	21 60       	ori	r18, 0x01	; 1
    3e52:	fc 01       	movw	r30, r24
    3e54:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    3e56:	81 e0       	ldi	r24, 0x01	; 1
    3e58:	90 e0       	ldi	r25, 0x00	; 0
    3e5a:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3e5e:	06 c0       	rjmp	.+12     	; 0x3e6c <_Z9GoToSleeph+0x72>
			asm volatile("SLEEP");
    3e60:	88 95       	sleep
			sleepTicks++;
    3e62:	8b 81       	ldd	r24, Y+3	; 0x03
    3e64:	9c 81       	ldd	r25, Y+4	; 0x04
    3e66:	01 96       	adiw	r24, 0x01	; 1
    3e68:	9c 83       	std	Y+4, r25	; 0x04
    3e6a:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3e6c:	2b 81       	ldd	r18, Y+3	; 0x03
    3e6e:	3c 81       	ldd	r19, Y+4	; 0x04
    3e70:	89 81       	ldd	r24, Y+1	; 0x01
    3e72:	9a 81       	ldd	r25, Y+2	; 0x02
    3e74:	28 17       	cp	r18, r24
    3e76:	39 07       	cpc	r19, r25
    3e78:	34 f4       	brge	.+12     	; 0x3e86 <_Z9GoToSleeph+0x8c>
    3e7a:	80 91 81 01 	lds	r24, 0x0181
    3e7e:	88 23       	and	r24, r24
    3e80:	11 f0       	breq	.+4      	; 0x3e86 <_Z9GoToSleeph+0x8c>
    3e82:	81 e0       	ldi	r24, 0x01	; 1
    3e84:	01 c0       	rjmp	.+2      	; 0x3e88 <_Z9GoToSleeph+0x8e>
    3e86:	80 e0       	ldi	r24, 0x00	; 0
    3e88:	88 23       	and	r24, r24
    3e8a:	51 f7       	brne	.-44     	; 0x3e60 <_Z9GoToSleeph+0x66>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(1);
    3e8c:	81 e0       	ldi	r24, 0x01	; 1
    3e8e:	90 e0       	ldi	r25, 0x00	; 0
    3e90:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSTATUSled |= (1 << bnSTATUSled);
    3e94:	88 e2       	ldi	r24, 0x28	; 40
    3e96:	90 e0       	ldi	r25, 0x00	; 0
    3e98:	28 e2       	ldi	r18, 0x28	; 40
    3e9a:	30 e0       	ldi	r19, 0x00	; 0
    3e9c:	f9 01       	movw	r30, r18
    3e9e:	20 81       	ld	r18, Z
    3ea0:	24 60       	ori	r18, 0x04	; 4
    3ea2:	fc 01       	movw	r30, r24
    3ea4:	20 83       	st	Z, r18
}
    3ea6:	0f 90       	pop	r0
    3ea8:	0f 90       	pop	r0
    3eaa:	0f 90       	pop	r0
    3eac:	0f 90       	pop	r0
    3eae:	0f 90       	pop	r0
    3eb0:	df 91       	pop	r29
    3eb2:	cf 91       	pop	r28
    3eb4:	08 95       	ret

00003eb6 <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    3eb6:	cf 93       	push	r28
    3eb8:	df 93       	push	r29
    3eba:	cd b7       	in	r28, 0x3d	; 61
    3ebc:	de b7       	in	r29, 0x3e	; 62
    3ebe:	2e 97       	sbiw	r28, 0x0e	; 14
    3ec0:	0f b6       	in	r0, 0x3f	; 63
    3ec2:	f8 94       	cli
    3ec4:	de bf       	out	0x3e, r29	; 62
    3ec6:	0f be       	out	0x3f, r0	; 63
    3ec8:	cd bf       	out	0x3d, r28	; 61
	WORD adcReading = 0;
    3eca:	1c 82       	std	Y+4, r1	; 0x04
    3ecc:	1b 82       	std	Y+3, r1	; 0x03
	
	prtInterrupts |= (1 << bnBBint);
    3ece:	82 e2       	ldi	r24, 0x22	; 34
    3ed0:	90 e0       	ldi	r25, 0x00	; 0
    3ed2:	22 e2       	ldi	r18, 0x22	; 34
    3ed4:	30 e0       	ldi	r19, 0x00	; 0
    3ed6:	f9 01       	movw	r30, r18
    3ed8:	20 81       	ld	r18, Z
    3eda:	24 60       	ori	r18, 0x04	; 4
    3edc:	fc 01       	movw	r30, r24
    3ede:	20 83       	st	Z, r18
	
	__killCommINT();
    3ee0:	8d e3       	ldi	r24, 0x3D	; 61
    3ee2:	90 e0       	ldi	r25, 0x00	; 0
    3ee4:	fc 01       	movw	r30, r24
    3ee6:	10 82       	st	Z, r1
    3ee8:	8d e6       	ldi	r24, 0x6D	; 109
    3eea:	90 e0       	ldi	r25, 0x00	; 0
    3eec:	fc 01       	movw	r30, r24
    3eee:	10 82       	st	Z, r1
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    3ef0:	84 e6       	ldi	r24, 0x64	; 100
    3ef2:	90 e0       	ldi	r25, 0x00	; 0
    3ef4:	24 e6       	ldi	r18, 0x64	; 100
    3ef6:	30 e0       	ldi	r19, 0x00	; 0
    3ef8:	f9 01       	movw	r30, r18
    3efa:	20 81       	ld	r18, Z
    3efc:	2e 7f       	andi	r18, 0xFE	; 254
    3efe:	fc 01       	movw	r30, r24
    3f00:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    3f02:	8c e7       	ldi	r24, 0x7C	; 124
    3f04:	90 e0       	ldi	r25, 0x00	; 0
    3f06:	2c e7       	ldi	r18, 0x7C	; 124
    3f08:	30 e0       	ldi	r19, 0x00	; 0
    3f0a:	f9 01       	movw	r30, r18
    3f0c:	20 81       	ld	r18, Z
    3f0e:	20 68       	ori	r18, 0x80	; 128
    3f10:	fc 01       	movw	r30, r24
    3f12:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    3f14:	8a e7       	ldi	r24, 0x7A	; 122
    3f16:	90 e0       	ldi	r25, 0x00	; 0
    3f18:	2a e7       	ldi	r18, 0x7A	; 122
    3f1a:	30 e0       	ldi	r19, 0x00	; 0
    3f1c:	f9 01       	movw	r30, r18
    3f1e:	20 81       	ld	r18, Z
    3f20:	24 68       	ori	r18, 0x84	; 132
    3f22:	fc 01       	movw	r30, r24
    3f24:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    3f26:	8e e7       	ldi	r24, 0x7E	; 126
    3f28:	90 e0       	ldi	r25, 0x00	; 0
    3f2a:	2e ef       	ldi	r18, 0xFE	; 254
    3f2c:	fc 01       	movw	r30, r24
    3f2e:	20 83       	st	Z, r18
	Wait_ms(100);									//Tim for registers to setup
    3f30:	84 e6       	ldi	r24, 0x64	; 100
    3f32:	90 e0       	ldi	r25, 0x00	; 0
    3f34:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <_Z7Wait_msi>
	
	//cli();
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    3f38:	1a 82       	std	Y+2, r1	; 0x02
    3f3a:	19 82       	std	Y+1, r1	; 0x01
    3f3c:	1c c0       	rjmp	.+56     	; 0x3f76 <_Z7TakeADCv+0xc0>
    3f3e:	8a e7       	ldi	r24, 0x7A	; 122
    3f40:	90 e0       	ldi	r25, 0x00	; 0
    3f42:	2a e7       	ldi	r18, 0x7A	; 122
    3f44:	30 e0       	ldi	r19, 0x00	; 0
    3f46:	f9 01       	movw	r30, r18
    3f48:	20 81       	ld	r18, Z
    3f4a:	20 64       	ori	r18, 0x40	; 64
    3f4c:	fc 01       	movw	r30, r24
    3f4e:	20 83       	st	Z, r18
    3f50:	8a e7       	ldi	r24, 0x7A	; 122
    3f52:	90 e0       	ldi	r25, 0x00	; 0
    3f54:	fc 01       	movw	r30, r24
    3f56:	80 81       	ld	r24, Z
    3f58:	88 2f       	mov	r24, r24
    3f5a:	90 e0       	ldi	r25, 0x00	; 0
    3f5c:	80 74       	andi	r24, 0x40	; 64
    3f5e:	90 70       	andi	r25, 0x00	; 0
    3f60:	21 e0       	ldi	r18, 0x01	; 1
    3f62:	00 97       	sbiw	r24, 0x00	; 0
    3f64:	09 f4       	brne	.+2      	; 0x3f68 <_Z7TakeADCv+0xb2>
    3f66:	20 e0       	ldi	r18, 0x00	; 0
    3f68:	22 23       	and	r18, r18
    3f6a:	91 f7       	brne	.-28     	; 0x3f50 <_Z7TakeADCv+0x9a>
    3f6c:	89 81       	ldd	r24, Y+1	; 0x01
    3f6e:	9a 81       	ldd	r25, Y+2	; 0x02
    3f70:	01 96       	adiw	r24, 0x01	; 1
    3f72:	9a 83       	std	Y+2, r25	; 0x02
    3f74:	89 83       	std	Y+1, r24	; 0x01
    3f76:	21 e0       	ldi	r18, 0x01	; 1
    3f78:	89 81       	ldd	r24, Y+1	; 0x01
    3f7a:	9a 81       	ldd	r25, Y+2	; 0x02
    3f7c:	82 30       	cpi	r24, 0x02	; 2
    3f7e:	91 05       	cpc	r25, r1
    3f80:	0c f0       	brlt	.+2      	; 0x3f84 <_Z7TakeADCv+0xce>
    3f82:	20 e0       	ldi	r18, 0x00	; 0
    3f84:	22 23       	and	r18, r18
    3f86:	d9 f6       	brne	.-74     	; 0x3f3e <_Z7TakeADCv+0x88>
	
	//Re-enable interrupts	
	//sei();
	
	//Put conversion into buffer
	adcReading = ADCL;
    3f88:	88 e7       	ldi	r24, 0x78	; 120
    3f8a:	90 e0       	ldi	r25, 0x00	; 0
    3f8c:	fc 01       	movw	r30, r24
    3f8e:	80 81       	ld	r24, Z
    3f90:	88 2f       	mov	r24, r24
    3f92:	90 e0       	ldi	r25, 0x00	; 0
    3f94:	9c 83       	std	Y+4, r25	; 0x04
    3f96:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    3f98:	89 e7       	ldi	r24, 0x79	; 121
    3f9a:	90 e0       	ldi	r25, 0x00	; 0
    3f9c:	fc 01       	movw	r30, r24
    3f9e:	80 81       	ld	r24, Z
    3fa0:	88 2f       	mov	r24, r24
    3fa2:	90 e0       	ldi	r25, 0x00	; 0
    3fa4:	98 2f       	mov	r25, r24
    3fa6:	88 27       	eor	r24, r24
    3fa8:	2b 81       	ldd	r18, Y+3	; 0x03
    3faa:	3c 81       	ldd	r19, Y+4	; 0x04
    3fac:	82 2b       	or	r24, r18
    3fae:	93 2b       	or	r25, r19
    3fb0:	9c 83       	std	Y+4, r25	; 0x04
    3fb2:	8b 83       	std	Y+3, r24	; 0x03
		
	//Assign global reading and set flag
	globalADC=adcReading;
    3fb4:	8b 81       	ldd	r24, Y+3	; 0x03
    3fb6:	9c 81       	ldd	r25, Y+4	; 0x04
    3fb8:	90 93 8f 01 	sts	0x018F, r25
    3fbc:	80 93 8e 01 	sts	0x018E, r24
	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    3fc0:	21 e0       	ldi	r18, 0x01	; 1
    3fc2:	8b 81       	ldd	r24, Y+3	; 0x03
    3fc4:	9c 81       	ldd	r25, Y+4	; 0x04
    3fc6:	f3 e0       	ldi	r31, 0x03	; 3
    3fc8:	82 37       	cpi	r24, 0x72	; 114
    3fca:	9f 07       	cpc	r25, r31
    3fcc:	08 f4       	brcc	.+2      	; 0x3fd0 <_Z7TakeADCv+0x11a>
    3fce:	20 e0       	ldi	r18, 0x00	; 0
    3fd0:	20 93 c9 01 	sts	0x01C9, r18
		
	//Disable ADC hardware/registers
	ADCSRA = 0;
    3fd4:	8a e7       	ldi	r24, 0x7A	; 122
    3fd6:	90 e0       	ldi	r25, 0x00	; 0
    3fd8:	fc 01       	movw	r30, r24
    3fda:	10 82       	st	Z, r1
	ADMUX = 0;
    3fdc:	8c e7       	ldi	r24, 0x7C	; 124
    3fde:	90 e0       	ldi	r25, 0x00	; 0
    3fe0:	fc 01       	movw	r30, r24
    3fe2:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    3fe4:	8e e7       	ldi	r24, 0x7E	; 126
    3fe6:	90 e0       	ldi	r25, 0x00	; 0
    3fe8:	2e e7       	ldi	r18, 0x7E	; 126
    3fea:	30 e0       	ldi	r19, 0x00	; 0
    3fec:	f9 01       	movw	r30, r18
    3fee:	20 81       	ld	r18, Z
    3ff0:	21 60       	ori	r18, 0x01	; 1
    3ff2:	fc 01       	movw	r30, r24
    3ff4:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    3ff6:	84 e6       	ldi	r24, 0x64	; 100
    3ff8:	90 e0       	ldi	r25, 0x00	; 0
    3ffa:	24 e6       	ldi	r18, 0x64	; 100
    3ffc:	30 e0       	ldi	r19, 0x00	; 0
    3ffe:	f9 01       	movw	r30, r18
    4000:	20 81       	ld	r18, Z
    4002:	21 60       	ori	r18, 0x01	; 1
    4004:	fc 01       	movw	r30, r24
    4006:	20 83       	st	Z, r18

	char tempString[10];
	itoa(globalADC,tempString,10);
    4008:	80 91 8e 01 	lds	r24, 0x018E
    400c:	90 91 8f 01 	lds	r25, 0x018F
    4010:	9e 01       	movw	r18, r28
    4012:	2b 5f       	subi	r18, 0xFB	; 251
    4014:	3f 4f       	sbci	r19, 0xFF	; 255
    4016:	b9 01       	movw	r22, r18
    4018:	4a e0       	ldi	r20, 0x0A	; 10
    401a:	50 e0       	ldi	r21, 0x00	; 0
    401c:	0e 94 22 23 	call	0x4644	; 0x4644 <itoa>
	tempString[9]='\0';
    4020:	1e 86       	std	Y+14, r1	; 0x0e
	//PrintBone("ADC: ");
	//PrintBone(tempString);
	prtInterrupts &= ~(1 << bnBBint);
    4022:	82 e2       	ldi	r24, 0x22	; 34
    4024:	90 e0       	ldi	r25, 0x00	; 0
    4026:	22 e2       	ldi	r18, 0x22	; 34
    4028:	30 e0       	ldi	r19, 0x00	; 0
    402a:	f9 01       	movw	r30, r18
    402c:	20 81       	ld	r18, Z
    402e:	2b 7f       	andi	r18, 0xFB	; 251
    4030:	fc 01       	movw	r30, r24
    4032:	20 83       	st	Z, r18
	__enableCommINT();
    4034:	8d e3       	ldi	r24, 0x3D	; 61
    4036:	90 e0       	ldi	r25, 0x00	; 0
    4038:	2d e3       	ldi	r18, 0x3D	; 61
    403a:	30 e0       	ldi	r19, 0x00	; 0
    403c:	f9 01       	movw	r30, r18
    403e:	20 81       	ld	r18, Z
    4040:	24 60       	ori	r18, 0x04	; 4
    4042:	fc 01       	movw	r30, r24
    4044:	20 83       	st	Z, r18
    4046:	8d e6       	ldi	r24, 0x6D	; 109
    4048:	90 e0       	ldi	r25, 0x00	; 0
    404a:	22 e0       	ldi	r18, 0x02	; 2
    404c:	fc 01       	movw	r30, r24
    404e:	20 83       	st	Z, r18
}
    4050:	2e 96       	adiw	r28, 0x0e	; 14
    4052:	0f b6       	in	r0, 0x3f	; 63
    4054:	f8 94       	cli
    4056:	de bf       	out	0x3e, r29	; 62
    4058:	0f be       	out	0x3f, r0	; 63
    405a:	cd bf       	out	0x3d, r28	; 61
    405c:	df 91       	pop	r29
    405e:	cf 91       	pop	r28
    4060:	08 95       	ret

00004062 <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    4062:	cf 93       	push	r28
    4064:	df 93       	push	r29
    4066:	cd b7       	in	r28, 0x3d	; 61
    4068:	de b7       	in	r29, 0x3e	; 62
    406a:	2b 97       	sbiw	r28, 0x0b	; 11
    406c:	0f b6       	in	r0, 0x3f	; 63
    406e:	f8 94       	cli
    4070:	de bf       	out	0x3e, r29	; 62
    4072:	0f be       	out	0x3f, r0	; 63
    4074:	cd bf       	out	0x3d, r28	; 61
	WORD rawTemp = 0;
    4076:	1a 82       	std	Y+2, r1	; 0x02
    4078:	19 82       	std	Y+1, r1	; 0x01

	__killCommINT();
    407a:	8d e3       	ldi	r24, 0x3D	; 61
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	fc 01       	movw	r30, r24
    4080:	10 82       	st	Z, r1
    4082:	8d e6       	ldi	r24, 0x6D	; 109
    4084:	90 e0       	ldi	r25, 0x00	; 0
    4086:	fc 01       	movw	r30, r24
    4088:	10 82       	st	Z, r1

	PRR0 &= ~(1 << PRSPI);	
    408a:	84 e6       	ldi	r24, 0x64	; 100
    408c:	90 e0       	ldi	r25, 0x00	; 0
    408e:	24 e6       	ldi	r18, 0x64	; 100
    4090:	30 e0       	ldi	r19, 0x00	; 0
    4092:	f9 01       	movw	r30, r18
    4094:	20 81       	ld	r18, Z
    4096:	2b 7f       	andi	r18, 0xFB	; 251
    4098:	fc 01       	movw	r30, r24
    409a:	20 83       	st	Z, r18
	SPCR |= (1 << MSTR)|(1 << SPE)|(1 << SPR0);			//enables SPI, master, fck/64
    409c:	8c e4       	ldi	r24, 0x4C	; 76
    409e:	90 e0       	ldi	r25, 0x00	; 0
    40a0:	2c e4       	ldi	r18, 0x4C	; 76
    40a2:	30 e0       	ldi	r19, 0x00	; 0
    40a4:	f9 01       	movw	r30, r18
    40a6:	20 81       	ld	r18, Z
    40a8:	21 65       	ori	r18, 0x51	; 81
    40aa:	fc 01       	movw	r30, r24
    40ac:	20 83       	st	Z, r18
	Wait_sec(2);
    40ae:	82 e0       	ldi	r24, 0x02	; 2
    40b0:	90 e0       	ldi	r25, 0x00	; 0
    40b2:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <_Z8Wait_seci>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    40b6:	85 e2       	ldi	r24, 0x25	; 37
    40b8:	90 e0       	ldi	r25, 0x00	; 0
    40ba:	25 e2       	ldi	r18, 0x25	; 37
    40bc:	30 e0       	ldi	r19, 0x00	; 0
    40be:	f9 01       	movw	r30, r18
    40c0:	20 81       	ld	r18, Z
    40c2:	2f 76       	andi	r18, 0x6F	; 111
    40c4:	fc 01       	movw	r30, r24
    40c6:	20 83       	st	Z, r18
	
	cli();
    40c8:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR = 0x00;
    40ca:	8e e4       	ldi	r24, 0x4E	; 78
    40cc:	90 e0       	ldi	r25, 0x00	; 0
    40ce:	fc 01       	movw	r30, r24
    40d0:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR & (1 << SPIF)));
    40d2:	00 00       	nop
    40d4:	8d e4       	ldi	r24, 0x4D	; 77
    40d6:	90 e0       	ldi	r25, 0x00	; 0
    40d8:	fc 01       	movw	r30, r24
    40da:	80 81       	ld	r24, Z
    40dc:	80 95       	com	r24
    40de:	88 1f       	adc	r24, r24
    40e0:	88 27       	eor	r24, r24
    40e2:	88 1f       	adc	r24, r24
    40e4:	88 23       	and	r24, r24
    40e6:	b1 f7       	brne	.-20     	; 0x40d4 <_Z7GetTempv+0x72>
	rawTemp = (SPDR0 << 8);
    40e8:	1a 82       	std	Y+2, r1	; 0x02
    40ea:	19 82       	std	Y+1, r1	; 0x01
	SPDR = 0x00;
    40ec:	8e e4       	ldi	r24, 0x4E	; 78
    40ee:	90 e0       	ldi	r25, 0x00	; 0
    40f0:	fc 01       	movw	r30, r24
    40f2:	10 82       	st	Z, r1
	while (!(SPSR & (1 << SPIF)));
    40f4:	00 00       	nop
    40f6:	8d e4       	ldi	r24, 0x4D	; 77
    40f8:	90 e0       	ldi	r25, 0x00	; 0
    40fa:	fc 01       	movw	r30, r24
    40fc:	80 81       	ld	r24, Z
    40fe:	80 95       	com	r24
    4100:	88 1f       	adc	r24, r24
    4102:	88 27       	eor	r24, r24
    4104:	88 1f       	adc	r24, r24
    4106:	88 23       	and	r24, r24
    4108:	b1 f7       	brne	.-20     	; 0x40f6 <_Z7GetTempv+0x94>
	rawTemp |= SPDR0;
	
	//Set flag to correct value, update global value
	//flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
	globalTemp=rawTemp;
    410a:	89 81       	ldd	r24, Y+1	; 0x01
    410c:	9a 81       	ldd	r25, Y+2	; 0x02
    410e:	90 93 91 01 	sts	0x0191, r25
    4112:	80 93 90 01 	sts	0x0190, r24
	
	//re enable interrupts
	sei();
    4116:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    4118:	85 e2       	ldi	r24, 0x25	; 37
    411a:	90 e0       	ldi	r25, 0x00	; 0
    411c:	25 e2       	ldi	r18, 0x25	; 37
    411e:	30 e0       	ldi	r19, 0x00	; 0
    4120:	f9 01       	movw	r30, r18
    4122:	20 81       	ld	r18, Z
    4124:	20 69       	ori	r18, 0x90	; 144
    4126:	fc 01       	movw	r30, r24
    4128:	20 83       	st	Z, r18
	SPCR=0x00;	
    412a:	8c e4       	ldi	r24, 0x4C	; 76
    412c:	90 e0       	ldi	r25, 0x00	; 0
    412e:	fc 01       	movw	r30, r24
    4130:	10 82       	st	Z, r1
	//__killTemp();
	PRR0 |= (1 << PRSPI);
    4132:	84 e6       	ldi	r24, 0x64	; 100
    4134:	90 e0       	ldi	r25, 0x00	; 0
    4136:	24 e6       	ldi	r18, 0x64	; 100
    4138:	30 e0       	ldi	r19, 0x00	; 0
    413a:	f9 01       	movw	r30, r18
    413c:	20 81       	ld	r18, Z
    413e:	24 60       	ori	r18, 0x04	; 4
    4140:	fc 01       	movw	r30, r24
    4142:	20 83       	st	Z, r18
	
	char tempString[9];
	itoa(globalTemp,tempString,10);
    4144:	80 91 90 01 	lds	r24, 0x0190
    4148:	90 91 91 01 	lds	r25, 0x0191
    414c:	9e 01       	movw	r18, r28
    414e:	2d 5f       	subi	r18, 0xFD	; 253
    4150:	3f 4f       	sbci	r19, 0xFF	; 255
    4152:	b9 01       	movw	r22, r18
    4154:	4a e0       	ldi	r20, 0x0A	; 10
    4156:	50 e0       	ldi	r21, 0x00	; 0
    4158:	0e 94 22 23 	call	0x4644	; 0x4644 <itoa>
	tempString[8]='\0';
    415c:	1b 86       	std	Y+11, r1	; 0x0b

	__enableCommINT();
    415e:	8d e3       	ldi	r24, 0x3D	; 61
    4160:	90 e0       	ldi	r25, 0x00	; 0
    4162:	2d e3       	ldi	r18, 0x3D	; 61
    4164:	30 e0       	ldi	r19, 0x00	; 0
    4166:	f9 01       	movw	r30, r18
    4168:	20 81       	ld	r18, Z
    416a:	24 60       	ori	r18, 0x04	; 4
    416c:	fc 01       	movw	r30, r24
    416e:	20 83       	st	Z, r18
    4170:	8d e6       	ldi	r24, 0x6D	; 109
    4172:	90 e0       	ldi	r25, 0x00	; 0
    4174:	22 e0       	ldi	r18, 0x02	; 2
    4176:	fc 01       	movw	r30, r24
    4178:	20 83       	st	Z, r18
}
    417a:	2b 96       	adiw	r28, 0x0b	; 11
    417c:	0f b6       	in	r0, 0x3f	; 63
    417e:	f8 94       	cli
    4180:	de bf       	out	0x3e, r29	; 62
    4182:	0f be       	out	0x3f, r0	; 63
    4184:	cd bf       	out	0x3d, r28	; 61
    4186:	df 91       	pop	r29
    4188:	cf 91       	pop	r28
    418a:	08 95       	ret

0000418c <_Z7PowerUpj>:
/*************************************************************************************************************/
void PowerUp(WORD interval){
    418c:	cf 93       	push	r28
    418e:	df 93       	push	r29
    4190:	00 d0       	rcall	.+0      	; 0x4192 <_Z7PowerUpj+0x6>
    4192:	cd b7       	in	r28, 0x3d	; 61
    4194:	de b7       	in	r29, 0x3e	; 62
    4196:	9a 83       	std	Y+2, r25	; 0x02
    4198:	89 83       	std	Y+1, r24	; 0x01
	__killCommINT();
    419a:	8d e3       	ldi	r24, 0x3D	; 61
    419c:	90 e0       	ldi	r25, 0x00	; 0
    419e:	fc 01       	movw	r30, r24
    41a0:	10 82       	st	Z, r1
    41a2:	8d e6       	ldi	r24, 0x6D	; 109
    41a4:	90 e0       	ldi	r25, 0x00	; 0
    41a6:	fc 01       	movw	r30, r24
    41a8:	10 82       	st	Z, r1
	
	//First power on main regulator
	__enableMain();
    41aa:	88 e2       	ldi	r24, 0x28	; 40
    41ac:	90 e0       	ldi	r25, 0x00	; 0
    41ae:	28 e2       	ldi	r18, 0x28	; 40
    41b0:	30 e0       	ldi	r19, 0x00	; 0
    41b2:	f9 01       	movw	r30, r18
    41b4:	20 81       	ld	r18, Z
    41b6:	21 60       	ori	r18, 0x01	; 1
    41b8:	fc 01       	movw	r30, r24
    41ba:	20 83       	st	Z, r18
	Wait_sec(interval);
    41bc:	89 81       	ldd	r24, Y+1	; 0x01
    41be:	9a 81       	ldd	r25, Y+2	; 0x02
    41c0:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <_Z8Wait_seci>
	//__enableBeagleBone();
	//Wait_sec(interval);
	//while (!(pinBBio & (1 << bnW0B9)));	//Wait for GPIO line to go high
	
	//Power on GAVR and Enable GPS
	__enableGPSandGAVR();
    41c4:	82 e2       	ldi	r24, 0x22	; 34
    41c6:	90 e0       	ldi	r25, 0x00	; 0
    41c8:	22 e2       	ldi	r18, 0x22	; 34
    41ca:	30 e0       	ldi	r19, 0x00	; 0
    41cc:	f9 01       	movw	r30, r18
    41ce:	20 81       	ld	r18, Z
    41d0:	20 6c       	ori	r18, 0xC0	; 192
    41d2:	fc 01       	movw	r30, r24
    41d4:	20 83       	st	Z, r18
	//Wait_sec(interval);
	//while (!(pinGAVRio & (1 << bnW3G0)));	//Wait for GPIO line to go high signifying correct boot
	if (restart){
    41d6:	80 91 ca 01 	lds	r24, 0x01CA
    41da:	88 23       	and	r24, r24
    41dc:	b1 f0       	breq	.+44     	; 0x420a <_Z7PowerUpj+0x7e>
		prtInterrupts |= (1 << bnGAVRint);
    41de:	82 e2       	ldi	r24, 0x22	; 34
    41e0:	90 e0       	ldi	r25, 0x00	; 0
    41e2:	22 e2       	ldi	r18, 0x22	; 34
    41e4:	30 e0       	ldi	r19, 0x00	; 0
    41e6:	f9 01       	movw	r30, r18
    41e8:	20 81       	ld	r18, Z
    41ea:	28 60       	ori	r18, 0x08	; 8
    41ec:	fc 01       	movw	r30, r24
    41ee:	20 83       	st	Z, r18
		Wait_ms(200); 
    41f0:	88 ec       	ldi	r24, 0xC8	; 200
    41f2:	90 e0       	ldi	r25, 0x00	; 0
    41f4:	0e 94 95 1e 	call	0x3d2a	; 0x3d2a <_Z7Wait_msi>
		prtInterrupts  &= ~(1 << bnGAVRint);	//sends interrupt to come out of power-down, waits, goes forward.
    41f8:	82 e2       	ldi	r24, 0x22	; 34
    41fa:	90 e0       	ldi	r25, 0x00	; 0
    41fc:	22 e2       	ldi	r18, 0x22	; 34
    41fe:	30 e0       	ldi	r19, 0x00	; 0
    4200:	f9 01       	movw	r30, r18
    4202:	20 81       	ld	r18, Z
    4204:	27 7f       	andi	r18, 0xF7	; 247
    4206:	fc 01       	movw	r30, r24
    4208:	20 83       	st	Z, r18
	}
	//Power on LCD
	//__enableLCD();
	Wait_sec(interval);
    420a:	89 81       	ldd	r24, Y+1	; 0x01
    420c:	9a 81       	ldd	r25, Y+2	; 0x02
    420e:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <_Z8Wait_seci>
	
	__enableCommINT();
    4212:	8d e3       	ldi	r24, 0x3D	; 61
    4214:	90 e0       	ldi	r25, 0x00	; 0
    4216:	2d e3       	ldi	r18, 0x3D	; 61
    4218:	30 e0       	ldi	r19, 0x00	; 0
    421a:	f9 01       	movw	r30, r18
    421c:	20 81       	ld	r18, Z
    421e:	24 60       	ori	r18, 0x04	; 4
    4220:	fc 01       	movw	r30, r24
    4222:	20 83       	st	Z, r18
    4224:	8d e6       	ldi	r24, 0x6D	; 109
    4226:	90 e0       	ldi	r25, 0x00	; 0
    4228:	22 e0       	ldi	r18, 0x02	; 2
    422a:	fc 01       	movw	r30, r24
    422c:	20 83       	st	Z, r18
	
}
    422e:	0f 90       	pop	r0
    4230:	0f 90       	pop	r0
    4232:	df 91       	pop	r29
    4234:	cf 91       	pop	r28
    4236:	08 95       	ret

00004238 <_Z9PowerDownv>:
/*************************************************************************************************************/
void PowerDown(){
    4238:	cf 93       	push	r28
    423a:	df 93       	push	r29
    423c:	cd b7       	in	r28, 0x3d	; 61
    423e:	de b7       	in	r29, 0x3e	; 62
	__killCommINT();
    4240:	8d e3       	ldi	r24, 0x3D	; 61
    4242:	90 e0       	ldi	r25, 0x00	; 0
    4244:	fc 01       	movw	r30, r24
    4246:	10 82       	st	Z, r1
    4248:	8d e6       	ldi	r24, 0x6D	; 109
    424a:	90 e0       	ldi	r25, 0x00	; 0
    424c:	fc 01       	movw	r30, r24
    424e:	10 82       	st	Z, r1

	//Signify interrupts, wait 6 seconds for all processing to stop.
	prtInterrupts |= (1 << bnBBint)|(1 << bnGAVRint);
    4250:	82 e2       	ldi	r24, 0x22	; 34
    4252:	90 e0       	ldi	r25, 0x00	; 0
    4254:	22 e2       	ldi	r18, 0x22	; 34
    4256:	30 e0       	ldi	r19, 0x00	; 0
    4258:	f9 01       	movw	r30, r18
    425a:	20 81       	ld	r18, Z
    425c:	2c 60       	ori	r18, 0x0C	; 12
    425e:	fc 01       	movw	r30, r24
    4260:	20 83       	st	Z, r18
	Wait_sec(6);
    4262:	86 e0       	ldi	r24, 0x06	; 6
    4264:	90 e0       	ldi	r25, 0x00	; 0
    4266:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <_Z8Wait_seci>
	prtInterrupts &= ~((1 << bnBBint)|(1 << bnGAVRint));
    426a:	82 e2       	ldi	r24, 0x22	; 34
    426c:	90 e0       	ldi	r25, 0x00	; 0
    426e:	22 e2       	ldi	r18, 0x22	; 34
    4270:	30 e0       	ldi	r19, 0x00	; 0
    4272:	f9 01       	movw	r30, r18
    4274:	20 81       	ld	r18, Z
    4276:	23 7f       	andi	r18, 0xF3	; 243
    4278:	fc 01       	movw	r30, r24
    427a:	20 83       	st	Z, r18
	__killLCD();
    427c:	82 e2       	ldi	r24, 0x22	; 34
    427e:	90 e0       	ldi	r25, 0x00	; 0
    4280:	22 e2       	ldi	r18, 0x22	; 34
    4282:	30 e0       	ldi	r19, 0x00	; 0
    4284:	f9 01       	movw	r30, r18
    4286:	20 81       	ld	r18, Z
    4288:	2f 7d       	andi	r18, 0xDF	; 223
    428a:	fc 01       	movw	r30, r24
    428c:	20 83       	st	Z, r18
	__killGPSandGAVR();
    428e:	82 e2       	ldi	r24, 0x22	; 34
    4290:	90 e0       	ldi	r25, 0x00	; 0
    4292:	22 e2       	ldi	r18, 0x22	; 34
    4294:	30 e0       	ldi	r19, 0x00	; 0
    4296:	f9 01       	movw	r30, r18
    4298:	20 81       	ld	r18, Z
    429a:	2f 73       	andi	r18, 0x3F	; 63
    429c:	fc 01       	movw	r30, r24
    429e:	20 83       	st	Z, r18
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
    42a0:	86 e0       	ldi	r24, 0x06	; 6
    42a2:	90 e0       	ldi	r25, 0x00	; 0
    42a4:	0e 94 c5 1e 	call	0x3d8a	; 0x3d8a <_Z8Wait_seci>
	__killBeagleBone();
    42a8:	82 e2       	ldi	r24, 0x22	; 34
    42aa:	90 e0       	ldi	r25, 0x00	; 0
    42ac:	22 e2       	ldi	r18, 0x22	; 34
    42ae:	30 e0       	ldi	r19, 0x00	; 0
    42b0:	f9 01       	movw	r30, r18
    42b2:	20 81       	ld	r18, Z
    42b4:	2f 7e       	andi	r18, 0xEF	; 239
    42b6:	fc 01       	movw	r30, r24
    42b8:	20 83       	st	Z, r18
	__killMain();
    42ba:	88 e2       	ldi	r24, 0x28	; 40
    42bc:	90 e0       	ldi	r25, 0x00	; 0
    42be:	28 e2       	ldi	r18, 0x28	; 40
    42c0:	30 e0       	ldi	r19, 0x00	; 0
    42c2:	f9 01       	movw	r30, r18
    42c4:	20 81       	ld	r18, Z
    42c6:	2e 7f       	andi	r18, 0xFE	; 254
    42c8:	fc 01       	movw	r30, r24
    42ca:	20 83       	st	Z, r18
}
    42cc:	df 91       	pop	r29
    42ce:	cf 91       	pop	r28
    42d0:	08 95       	ret

000042d2 <_Z41__static_initialization_and_destruction_0ii>:
    42d2:	cf 93       	push	r28
    42d4:	df 93       	push	r29
    42d6:	00 d0       	rcall	.+0      	; 0x42d8 <_Z41__static_initialization_and_destruction_0ii+0x6>
    42d8:	00 d0       	rcall	.+0      	; 0x42da <_Z41__static_initialization_and_destruction_0ii+0x8>
    42da:	cd b7       	in	r28, 0x3d	; 61
    42dc:	de b7       	in	r29, 0x3e	; 62
    42de:	9a 83       	std	Y+2, r25	; 0x02
    42e0:	89 83       	std	Y+1, r24	; 0x01
    42e2:	7c 83       	std	Y+4, r23	; 0x04
    42e4:	6b 83       	std	Y+3, r22	; 0x03
    42e6:	89 81       	ldd	r24, Y+1	; 0x01
    42e8:	9a 81       	ldd	r25, Y+2	; 0x02
    42ea:	81 30       	cpi	r24, 0x01	; 1
    42ec:	91 05       	cpc	r25, r1
    42ee:	51 f4       	brne	.+20     	; 0x4304 <_Z41__static_initialization_and_destruction_0ii+0x32>
    42f0:	8b 81       	ldd	r24, Y+3	; 0x03
    42f2:	9c 81       	ldd	r25, Y+4	; 0x04
    42f4:	2f ef       	ldi	r18, 0xFF	; 255
    42f6:	8f 3f       	cpi	r24, 0xFF	; 255
    42f8:	92 07       	cpc	r25, r18
    42fa:	21 f4       	brne	.+8      	; 0x4304 <_Z41__static_initialization_and_destruction_0ii+0x32>

/*********************************************GLOBAL VARIABLES***************************************************/
/****************************************************************************************************************/
WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    42fc:	82 e9       	ldi	r24, 0x92	; 146
    42fe:	91 e0       	ldi	r25, 0x01	; 1
    4300:	0e 94 10 04 	call	0x820	; 0x820 <_ZN6myTimeC1Ev>
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
	__killBeagleBone();
	__killMain();
}
    4304:	0f 90       	pop	r0
    4306:	0f 90       	pop	r0
    4308:	0f 90       	pop	r0
    430a:	0f 90       	pop	r0
    430c:	df 91       	pop	r29
    430e:	cf 91       	pop	r28
    4310:	08 95       	ret

00004312 <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    4312:	cf 93       	push	r28
    4314:	df 93       	push	r29
    4316:	cd b7       	in	r28, 0x3d	; 61
    4318:	de b7       	in	r29, 0x3e	; 62
    431a:	81 e0       	ldi	r24, 0x01	; 1
    431c:	90 e0       	ldi	r25, 0x00	; 0
    431e:	6f ef       	ldi	r22, 0xFF	; 255
    4320:	7f ef       	ldi	r23, 0xFF	; 255
    4322:	0e 94 69 21 	call	0x42d2	; 0x42d2 <_Z41__static_initialization_and_destruction_0ii>
    4326:	df 91       	pop	r29
    4328:	cf 91       	pop	r28
    432a:	08 95       	ret

0000432c <__cmpsf2>:
    432c:	2f d0       	rcall	.+94     	; 0x438c <__fp_cmp>
    432e:	08 f4       	brcc	.+2      	; 0x4332 <__cmpsf2+0x6>
    4330:	81 e0       	ldi	r24, 0x01	; 1
    4332:	08 95       	ret

00004334 <__fixunssfsi>:
    4334:	57 d0       	rcall	.+174    	; 0x43e4 <__fp_splitA>
    4336:	88 f0       	brcs	.+34     	; 0x435a <__fixunssfsi+0x26>
    4338:	9f 57       	subi	r25, 0x7F	; 127
    433a:	90 f0       	brcs	.+36     	; 0x4360 <__fixunssfsi+0x2c>
    433c:	b9 2f       	mov	r27, r25
    433e:	99 27       	eor	r25, r25
    4340:	b7 51       	subi	r27, 0x17	; 23
    4342:	a0 f0       	brcs	.+40     	; 0x436c <__fixunssfsi+0x38>
    4344:	d1 f0       	breq	.+52     	; 0x437a <__fixunssfsi+0x46>
    4346:	66 0f       	add	r22, r22
    4348:	77 1f       	adc	r23, r23
    434a:	88 1f       	adc	r24, r24
    434c:	99 1f       	adc	r25, r25
    434e:	1a f0       	brmi	.+6      	; 0x4356 <__fixunssfsi+0x22>
    4350:	ba 95       	dec	r27
    4352:	c9 f7       	brne	.-14     	; 0x4346 <__fixunssfsi+0x12>
    4354:	12 c0       	rjmp	.+36     	; 0x437a <__fixunssfsi+0x46>
    4356:	b1 30       	cpi	r27, 0x01	; 1
    4358:	81 f0       	breq	.+32     	; 0x437a <__fixunssfsi+0x46>
    435a:	5e d0       	rcall	.+188    	; 0x4418 <__fp_zero>
    435c:	b1 e0       	ldi	r27, 0x01	; 1
    435e:	08 95       	ret
    4360:	5b c0       	rjmp	.+182    	; 0x4418 <__fp_zero>
    4362:	67 2f       	mov	r22, r23
    4364:	78 2f       	mov	r23, r24
    4366:	88 27       	eor	r24, r24
    4368:	b8 5f       	subi	r27, 0xF8	; 248
    436a:	39 f0       	breq	.+14     	; 0x437a <__fixunssfsi+0x46>
    436c:	b9 3f       	cpi	r27, 0xF9	; 249
    436e:	cc f3       	brlt	.-14     	; 0x4362 <__fixunssfsi+0x2e>
    4370:	86 95       	lsr	r24
    4372:	77 95       	ror	r23
    4374:	67 95       	ror	r22
    4376:	b3 95       	inc	r27
    4378:	d9 f7       	brne	.-10     	; 0x4370 <__fixunssfsi+0x3c>
    437a:	3e f4       	brtc	.+14     	; 0x438a <__fixunssfsi+0x56>
    437c:	90 95       	com	r25
    437e:	80 95       	com	r24
    4380:	70 95       	com	r23
    4382:	61 95       	neg	r22
    4384:	7f 4f       	sbci	r23, 0xFF	; 255
    4386:	8f 4f       	sbci	r24, 0xFF	; 255
    4388:	9f 4f       	sbci	r25, 0xFF	; 255
    438a:	08 95       	ret

0000438c <__fp_cmp>:
    438c:	99 0f       	add	r25, r25
    438e:	00 08       	sbc	r0, r0
    4390:	55 0f       	add	r21, r21
    4392:	aa 0b       	sbc	r26, r26
    4394:	e0 e8       	ldi	r30, 0x80	; 128
    4396:	fe ef       	ldi	r31, 0xFE	; 254
    4398:	16 16       	cp	r1, r22
    439a:	17 06       	cpc	r1, r23
    439c:	e8 07       	cpc	r30, r24
    439e:	f9 07       	cpc	r31, r25
    43a0:	c0 f0       	brcs	.+48     	; 0x43d2 <__fp_cmp+0x46>
    43a2:	12 16       	cp	r1, r18
    43a4:	13 06       	cpc	r1, r19
    43a6:	e4 07       	cpc	r30, r20
    43a8:	f5 07       	cpc	r31, r21
    43aa:	98 f0       	brcs	.+38     	; 0x43d2 <__fp_cmp+0x46>
    43ac:	62 1b       	sub	r22, r18
    43ae:	73 0b       	sbc	r23, r19
    43b0:	84 0b       	sbc	r24, r20
    43b2:	95 0b       	sbc	r25, r21
    43b4:	39 f4       	brne	.+14     	; 0x43c4 <__fp_cmp+0x38>
    43b6:	0a 26       	eor	r0, r26
    43b8:	61 f0       	breq	.+24     	; 0x43d2 <__fp_cmp+0x46>
    43ba:	23 2b       	or	r18, r19
    43bc:	24 2b       	or	r18, r20
    43be:	25 2b       	or	r18, r21
    43c0:	21 f4       	brne	.+8      	; 0x43ca <__fp_cmp+0x3e>
    43c2:	08 95       	ret
    43c4:	0a 26       	eor	r0, r26
    43c6:	09 f4       	brne	.+2      	; 0x43ca <__fp_cmp+0x3e>
    43c8:	a1 40       	sbci	r26, 0x01	; 1
    43ca:	a6 95       	lsr	r26
    43cc:	8f ef       	ldi	r24, 0xFF	; 255
    43ce:	81 1d       	adc	r24, r1
    43d0:	81 1d       	adc	r24, r1
    43d2:	08 95       	ret

000043d4 <__fp_split3>:
    43d4:	57 fd       	sbrc	r21, 7
    43d6:	90 58       	subi	r25, 0x80	; 128
    43d8:	44 0f       	add	r20, r20
    43da:	55 1f       	adc	r21, r21
    43dc:	59 f0       	breq	.+22     	; 0x43f4 <__fp_splitA+0x10>
    43de:	5f 3f       	cpi	r21, 0xFF	; 255
    43e0:	71 f0       	breq	.+28     	; 0x43fe <__fp_splitA+0x1a>
    43e2:	47 95       	ror	r20

000043e4 <__fp_splitA>:
    43e4:	88 0f       	add	r24, r24
    43e6:	97 fb       	bst	r25, 7
    43e8:	99 1f       	adc	r25, r25
    43ea:	61 f0       	breq	.+24     	; 0x4404 <__fp_splitA+0x20>
    43ec:	9f 3f       	cpi	r25, 0xFF	; 255
    43ee:	79 f0       	breq	.+30     	; 0x440e <__fp_splitA+0x2a>
    43f0:	87 95       	ror	r24
    43f2:	08 95       	ret
    43f4:	12 16       	cp	r1, r18
    43f6:	13 06       	cpc	r1, r19
    43f8:	14 06       	cpc	r1, r20
    43fa:	55 1f       	adc	r21, r21
    43fc:	f2 cf       	rjmp	.-28     	; 0x43e2 <__fp_split3+0xe>
    43fe:	46 95       	lsr	r20
    4400:	f1 df       	rcall	.-30     	; 0x43e4 <__fp_splitA>
    4402:	08 c0       	rjmp	.+16     	; 0x4414 <__fp_splitA+0x30>
    4404:	16 16       	cp	r1, r22
    4406:	17 06       	cpc	r1, r23
    4408:	18 06       	cpc	r1, r24
    440a:	99 1f       	adc	r25, r25
    440c:	f1 cf       	rjmp	.-30     	; 0x43f0 <__fp_splitA+0xc>
    440e:	86 95       	lsr	r24
    4410:	71 05       	cpc	r23, r1
    4412:	61 05       	cpc	r22, r1
    4414:	08 94       	sec
    4416:	08 95       	ret

00004418 <__fp_zero>:
    4418:	e8 94       	clt

0000441a <__fp_szero>:
    441a:	bb 27       	eor	r27, r27
    441c:	66 27       	eor	r22, r22
    441e:	77 27       	eor	r23, r23
    4420:	cb 01       	movw	r24, r22
    4422:	97 f9       	bld	r25, 7
    4424:	08 95       	ret

00004426 <__gesf2>:
    4426:	b2 df       	rcall	.-156    	; 0x438c <__fp_cmp>
    4428:	08 f4       	brcc	.+2      	; 0x442c <__gesf2+0x6>
    442a:	8f ef       	ldi	r24, 0xFF	; 255
    442c:	08 95       	ret

0000442e <__mulsf3>:
    442e:	0b d0       	rcall	.+22     	; 0x4446 <__mulsf3x>
    4430:	78 c0       	rjmp	.+240    	; 0x4522 <__fp_round>
    4432:	69 d0       	rcall	.+210    	; 0x4506 <__fp_pscA>
    4434:	28 f0       	brcs	.+10     	; 0x4440 <__mulsf3+0x12>
    4436:	6e d0       	rcall	.+220    	; 0x4514 <__fp_pscB>
    4438:	18 f0       	brcs	.+6      	; 0x4440 <__mulsf3+0x12>
    443a:	95 23       	and	r25, r21
    443c:	09 f0       	breq	.+2      	; 0x4440 <__mulsf3+0x12>
    443e:	5a c0       	rjmp	.+180    	; 0x44f4 <__fp_inf>
    4440:	5f c0       	rjmp	.+190    	; 0x4500 <__fp_nan>
    4442:	11 24       	eor	r1, r1
    4444:	ea cf       	rjmp	.-44     	; 0x441a <__fp_szero>

00004446 <__mulsf3x>:
    4446:	c6 df       	rcall	.-116    	; 0x43d4 <__fp_split3>
    4448:	a0 f3       	brcs	.-24     	; 0x4432 <__mulsf3+0x4>

0000444a <__mulsf3_pse>:
    444a:	95 9f       	mul	r25, r21
    444c:	d1 f3       	breq	.-12     	; 0x4442 <__mulsf3+0x14>
    444e:	95 0f       	add	r25, r21
    4450:	50 e0       	ldi	r21, 0x00	; 0
    4452:	55 1f       	adc	r21, r21
    4454:	62 9f       	mul	r22, r18
    4456:	f0 01       	movw	r30, r0
    4458:	72 9f       	mul	r23, r18
    445a:	bb 27       	eor	r27, r27
    445c:	f0 0d       	add	r31, r0
    445e:	b1 1d       	adc	r27, r1
    4460:	63 9f       	mul	r22, r19
    4462:	aa 27       	eor	r26, r26
    4464:	f0 0d       	add	r31, r0
    4466:	b1 1d       	adc	r27, r1
    4468:	aa 1f       	adc	r26, r26
    446a:	64 9f       	mul	r22, r20
    446c:	66 27       	eor	r22, r22
    446e:	b0 0d       	add	r27, r0
    4470:	a1 1d       	adc	r26, r1
    4472:	66 1f       	adc	r22, r22
    4474:	82 9f       	mul	r24, r18
    4476:	22 27       	eor	r18, r18
    4478:	b0 0d       	add	r27, r0
    447a:	a1 1d       	adc	r26, r1
    447c:	62 1f       	adc	r22, r18
    447e:	73 9f       	mul	r23, r19
    4480:	b0 0d       	add	r27, r0
    4482:	a1 1d       	adc	r26, r1
    4484:	62 1f       	adc	r22, r18
    4486:	83 9f       	mul	r24, r19
    4488:	a0 0d       	add	r26, r0
    448a:	61 1d       	adc	r22, r1
    448c:	22 1f       	adc	r18, r18
    448e:	74 9f       	mul	r23, r20
    4490:	33 27       	eor	r19, r19
    4492:	a0 0d       	add	r26, r0
    4494:	61 1d       	adc	r22, r1
    4496:	23 1f       	adc	r18, r19
    4498:	84 9f       	mul	r24, r20
    449a:	60 0d       	add	r22, r0
    449c:	21 1d       	adc	r18, r1
    449e:	82 2f       	mov	r24, r18
    44a0:	76 2f       	mov	r23, r22
    44a2:	6a 2f       	mov	r22, r26
    44a4:	11 24       	eor	r1, r1
    44a6:	9f 57       	subi	r25, 0x7F	; 127
    44a8:	50 40       	sbci	r21, 0x00	; 0
    44aa:	8a f0       	brmi	.+34     	; 0x44ce <__mulsf3_pse+0x84>
    44ac:	e1 f0       	breq	.+56     	; 0x44e6 <__mulsf3_pse+0x9c>
    44ae:	88 23       	and	r24, r24
    44b0:	4a f0       	brmi	.+18     	; 0x44c4 <__mulsf3_pse+0x7a>
    44b2:	ee 0f       	add	r30, r30
    44b4:	ff 1f       	adc	r31, r31
    44b6:	bb 1f       	adc	r27, r27
    44b8:	66 1f       	adc	r22, r22
    44ba:	77 1f       	adc	r23, r23
    44bc:	88 1f       	adc	r24, r24
    44be:	91 50       	subi	r25, 0x01	; 1
    44c0:	50 40       	sbci	r21, 0x00	; 0
    44c2:	a9 f7       	brne	.-22     	; 0x44ae <__mulsf3_pse+0x64>
    44c4:	9e 3f       	cpi	r25, 0xFE	; 254
    44c6:	51 05       	cpc	r21, r1
    44c8:	70 f0       	brcs	.+28     	; 0x44e6 <__mulsf3_pse+0x9c>
    44ca:	14 c0       	rjmp	.+40     	; 0x44f4 <__fp_inf>
    44cc:	a6 cf       	rjmp	.-180    	; 0x441a <__fp_szero>
    44ce:	5f 3f       	cpi	r21, 0xFF	; 255
    44d0:	ec f3       	brlt	.-6      	; 0x44cc <__mulsf3_pse+0x82>
    44d2:	98 3e       	cpi	r25, 0xE8	; 232
    44d4:	dc f3       	brlt	.-10     	; 0x44cc <__mulsf3_pse+0x82>
    44d6:	86 95       	lsr	r24
    44d8:	77 95       	ror	r23
    44da:	67 95       	ror	r22
    44dc:	b7 95       	ror	r27
    44de:	f7 95       	ror	r31
    44e0:	e7 95       	ror	r30
    44e2:	9f 5f       	subi	r25, 0xFF	; 255
    44e4:	c1 f7       	brne	.-16     	; 0x44d6 <__mulsf3_pse+0x8c>
    44e6:	fe 2b       	or	r31, r30
    44e8:	88 0f       	add	r24, r24
    44ea:	91 1d       	adc	r25, r1
    44ec:	96 95       	lsr	r25
    44ee:	87 95       	ror	r24
    44f0:	97 f9       	bld	r25, 7
    44f2:	08 95       	ret

000044f4 <__fp_inf>:
    44f4:	97 f9       	bld	r25, 7
    44f6:	9f 67       	ori	r25, 0x7F	; 127
    44f8:	80 e8       	ldi	r24, 0x80	; 128
    44fa:	70 e0       	ldi	r23, 0x00	; 0
    44fc:	60 e0       	ldi	r22, 0x00	; 0
    44fe:	08 95       	ret

00004500 <__fp_nan>:
    4500:	9f ef       	ldi	r25, 0xFF	; 255
    4502:	80 ec       	ldi	r24, 0xC0	; 192
    4504:	08 95       	ret

00004506 <__fp_pscA>:
    4506:	00 24       	eor	r0, r0
    4508:	0a 94       	dec	r0
    450a:	16 16       	cp	r1, r22
    450c:	17 06       	cpc	r1, r23
    450e:	18 06       	cpc	r1, r24
    4510:	09 06       	cpc	r0, r25
    4512:	08 95       	ret

00004514 <__fp_pscB>:
    4514:	00 24       	eor	r0, r0
    4516:	0a 94       	dec	r0
    4518:	12 16       	cp	r1, r18
    451a:	13 06       	cpc	r1, r19
    451c:	14 06       	cpc	r1, r20
    451e:	05 06       	cpc	r0, r21
    4520:	08 95       	ret

00004522 <__fp_round>:
    4522:	09 2e       	mov	r0, r25
    4524:	03 94       	inc	r0
    4526:	00 0c       	add	r0, r0
    4528:	11 f4       	brne	.+4      	; 0x452e <__fp_round+0xc>
    452a:	88 23       	and	r24, r24
    452c:	52 f0       	brmi	.+20     	; 0x4542 <__fp_round+0x20>
    452e:	bb 0f       	add	r27, r27
    4530:	40 f4       	brcc	.+16     	; 0x4542 <__fp_round+0x20>
    4532:	bf 2b       	or	r27, r31
    4534:	11 f4       	brne	.+4      	; 0x453a <__fp_round+0x18>
    4536:	60 ff       	sbrs	r22, 0
    4538:	04 c0       	rjmp	.+8      	; 0x4542 <__fp_round+0x20>
    453a:	6f 5f       	subi	r22, 0xFF	; 255
    453c:	7f 4f       	sbci	r23, 0xFF	; 255
    453e:	8f 4f       	sbci	r24, 0xFF	; 255
    4540:	9f 4f       	sbci	r25, 0xFF	; 255
    4542:	08 95       	ret

00004544 <__udivmodqi4>:
    4544:	99 1b       	sub	r25, r25
    4546:	79 e0       	ldi	r23, 0x09	; 9
    4548:	04 c0       	rjmp	.+8      	; 0x4552 <__udivmodqi4_ep>

0000454a <__udivmodqi4_loop>:
    454a:	99 1f       	adc	r25, r25
    454c:	96 17       	cp	r25, r22
    454e:	08 f0       	brcs	.+2      	; 0x4552 <__udivmodqi4_ep>
    4550:	96 1b       	sub	r25, r22

00004552 <__udivmodqi4_ep>:
    4552:	88 1f       	adc	r24, r24
    4554:	7a 95       	dec	r23
    4556:	c9 f7       	brne	.-14     	; 0x454a <__udivmodqi4_loop>
    4558:	80 95       	com	r24
    455a:	08 95       	ret

0000455c <__divmodhi4>:
    455c:	97 fb       	bst	r25, 7
    455e:	09 2e       	mov	r0, r25
    4560:	07 26       	eor	r0, r23
    4562:	0a d0       	rcall	.+20     	; 0x4578 <__divmodhi4_neg1>
    4564:	77 fd       	sbrc	r23, 7
    4566:	04 d0       	rcall	.+8      	; 0x4570 <__divmodhi4_neg2>
    4568:	0c d0       	rcall	.+24     	; 0x4582 <__udivmodhi4>
    456a:	06 d0       	rcall	.+12     	; 0x4578 <__divmodhi4_neg1>
    456c:	00 20       	and	r0, r0
    456e:	1a f4       	brpl	.+6      	; 0x4576 <__divmodhi4_exit>

00004570 <__divmodhi4_neg2>:
    4570:	70 95       	com	r23
    4572:	61 95       	neg	r22
    4574:	7f 4f       	sbci	r23, 0xFF	; 255

00004576 <__divmodhi4_exit>:
    4576:	08 95       	ret

00004578 <__divmodhi4_neg1>:
    4578:	f6 f7       	brtc	.-4      	; 0x4576 <__divmodhi4_exit>
    457a:	90 95       	com	r25
    457c:	81 95       	neg	r24
    457e:	9f 4f       	sbci	r25, 0xFF	; 255
    4580:	08 95       	ret

00004582 <__udivmodhi4>:
    4582:	aa 1b       	sub	r26, r26
    4584:	bb 1b       	sub	r27, r27
    4586:	51 e1       	ldi	r21, 0x11	; 17
    4588:	07 c0       	rjmp	.+14     	; 0x4598 <__udivmodhi4_ep>

0000458a <__udivmodhi4_loop>:
    458a:	aa 1f       	adc	r26, r26
    458c:	bb 1f       	adc	r27, r27
    458e:	a6 17       	cp	r26, r22
    4590:	b7 07       	cpc	r27, r23
    4592:	10 f0       	brcs	.+4      	; 0x4598 <__udivmodhi4_ep>
    4594:	a6 1b       	sub	r26, r22
    4596:	b7 0b       	sbc	r27, r23

00004598 <__udivmodhi4_ep>:
    4598:	88 1f       	adc	r24, r24
    459a:	99 1f       	adc	r25, r25
    459c:	5a 95       	dec	r21
    459e:	a9 f7       	brne	.-22     	; 0x458a <__udivmodhi4_loop>
    45a0:	80 95       	com	r24
    45a2:	90 95       	com	r25
    45a4:	bc 01       	movw	r22, r24
    45a6:	cd 01       	movw	r24, r26
    45a8:	08 95       	ret

000045aa <__tablejump2__>:
    45aa:	ee 0f       	add	r30, r30
    45ac:	ff 1f       	adc	r31, r31

000045ae <__tablejump__>:
    45ae:	05 90       	lpm	r0, Z+
    45b0:	f4 91       	lpm	r31, Z
    45b2:	e0 2d       	mov	r30, r0
    45b4:	09 94       	ijmp

000045b6 <atoi>:
    45b6:	fc 01       	movw	r30, r24
    45b8:	88 27       	eor	r24, r24
    45ba:	99 27       	eor	r25, r25
    45bc:	e8 94       	clt
    45be:	21 91       	ld	r18, Z+
    45c0:	20 32       	cpi	r18, 0x20	; 32
    45c2:	e9 f3       	breq	.-6      	; 0x45be <atoi+0x8>
    45c4:	29 30       	cpi	r18, 0x09	; 9
    45c6:	10 f0       	brcs	.+4      	; 0x45cc <atoi+0x16>
    45c8:	2e 30       	cpi	r18, 0x0E	; 14
    45ca:	c8 f3       	brcs	.-14     	; 0x45be <atoi+0x8>
    45cc:	2b 32       	cpi	r18, 0x2B	; 43
    45ce:	41 f0       	breq	.+16     	; 0x45e0 <atoi+0x2a>
    45d0:	2d 32       	cpi	r18, 0x2D	; 45
    45d2:	39 f4       	brne	.+14     	; 0x45e2 <atoi+0x2c>
    45d4:	68 94       	set
    45d6:	04 c0       	rjmp	.+8      	; 0x45e0 <atoi+0x2a>
    45d8:	0e 94 43 23 	call	0x4686	; 0x4686 <__mulhi_const_10>
    45dc:	82 0f       	add	r24, r18
    45de:	91 1d       	adc	r25, r1
    45e0:	21 91       	ld	r18, Z+
    45e2:	20 53       	subi	r18, 0x30	; 48
    45e4:	2a 30       	cpi	r18, 0x0A	; 10
    45e6:	c0 f3       	brcs	.-16     	; 0x45d8 <atoi+0x22>
    45e8:	1e f4       	brtc	.+6      	; 0x45f0 <atoi+0x3a>
    45ea:	90 95       	com	r25
    45ec:	81 95       	neg	r24
    45ee:	9f 4f       	sbci	r25, 0xFF	; 255
    45f0:	08 95       	ret

000045f2 <strcat>:
    45f2:	fb 01       	movw	r30, r22
    45f4:	dc 01       	movw	r26, r24
    45f6:	0d 90       	ld	r0, X+
    45f8:	00 20       	and	r0, r0
    45fa:	e9 f7       	brne	.-6      	; 0x45f6 <strcat+0x4>
    45fc:	11 97       	sbiw	r26, 0x01	; 1
    45fe:	01 90       	ld	r0, Z+
    4600:	0d 92       	st	X+, r0
    4602:	00 20       	and	r0, r0
    4604:	e1 f7       	brne	.-8      	; 0x45fe <strcat+0xc>
    4606:	08 95       	ret

00004608 <strcmp>:
    4608:	fb 01       	movw	r30, r22
    460a:	dc 01       	movw	r26, r24
    460c:	8d 91       	ld	r24, X+
    460e:	01 90       	ld	r0, Z+
    4610:	80 19       	sub	r24, r0
    4612:	01 10       	cpse	r0, r1
    4614:	d9 f3       	breq	.-10     	; 0x460c <strcmp+0x4>
    4616:	99 0b       	sbc	r25, r25
    4618:	08 95       	ret

0000461a <strcpy>:
    461a:	fb 01       	movw	r30, r22
    461c:	dc 01       	movw	r26, r24
    461e:	01 90       	ld	r0, Z+
    4620:	0d 92       	st	X+, r0
    4622:	00 20       	and	r0, r0
    4624:	e1 f7       	brne	.-8      	; 0x461e <strcpy+0x4>
    4626:	08 95       	ret

00004628 <strncmp>:
    4628:	fb 01       	movw	r30, r22
    462a:	dc 01       	movw	r26, r24
    462c:	41 50       	subi	r20, 0x01	; 1
    462e:	50 40       	sbci	r21, 0x00	; 0
    4630:	30 f0       	brcs	.+12     	; 0x463e <strncmp+0x16>
    4632:	8d 91       	ld	r24, X+
    4634:	01 90       	ld	r0, Z+
    4636:	80 19       	sub	r24, r0
    4638:	19 f4       	brne	.+6      	; 0x4640 <strncmp+0x18>
    463a:	00 20       	and	r0, r0
    463c:	b9 f7       	brne	.-18     	; 0x462c <strncmp+0x4>
    463e:	88 1b       	sub	r24, r24
    4640:	99 0b       	sbc	r25, r25
    4642:	08 95       	ret

00004644 <itoa>:
    4644:	fb 01       	movw	r30, r22
    4646:	9f 01       	movw	r18, r30
    4648:	e8 94       	clt
    464a:	42 30       	cpi	r20, 0x02	; 2
    464c:	c4 f0       	brlt	.+48     	; 0x467e <itoa+0x3a>
    464e:	45 32       	cpi	r20, 0x25	; 37
    4650:	b4 f4       	brge	.+44     	; 0x467e <itoa+0x3a>
    4652:	4a 30       	cpi	r20, 0x0A	; 10
    4654:	29 f4       	brne	.+10     	; 0x4660 <itoa+0x1c>
    4656:	97 fb       	bst	r25, 7
    4658:	1e f4       	brtc	.+6      	; 0x4660 <itoa+0x1c>
    465a:	90 95       	com	r25
    465c:	81 95       	neg	r24
    465e:	9f 4f       	sbci	r25, 0xFF	; 255
    4660:	64 2f       	mov	r22, r20
    4662:	77 27       	eor	r23, r23
    4664:	0e 94 c1 22 	call	0x4582	; 0x4582 <__udivmodhi4>
    4668:	80 5d       	subi	r24, 0xD0	; 208
    466a:	8a 33       	cpi	r24, 0x3A	; 58
    466c:	0c f0       	brlt	.+2      	; 0x4670 <itoa+0x2c>
    466e:	89 5d       	subi	r24, 0xD9	; 217
    4670:	81 93       	st	Z+, r24
    4672:	cb 01       	movw	r24, r22
    4674:	00 97       	sbiw	r24, 0x00	; 0
    4676:	a1 f7       	brne	.-24     	; 0x4660 <itoa+0x1c>
    4678:	16 f4       	brtc	.+4      	; 0x467e <itoa+0x3a>
    467a:	5d e2       	ldi	r21, 0x2D	; 45
    467c:	51 93       	st	Z+, r21
    467e:	10 82       	st	Z, r1
    4680:	c9 01       	movw	r24, r18
    4682:	0c 94 82 23 	jmp	0x4704	; 0x4704 <strrev>

00004686 <__mulhi_const_10>:
    4686:	7a e0       	ldi	r23, 0x0A	; 10
    4688:	97 9f       	mul	r25, r23
    468a:	90 2d       	mov	r25, r0
    468c:	87 9f       	mul	r24, r23
    468e:	80 2d       	mov	r24, r0
    4690:	91 0d       	add	r25, r1
    4692:	11 24       	eor	r1, r1
    4694:	08 95       	ret

00004696 <utoa>:
    4696:	fb 01       	movw	r30, r22
    4698:	9f 01       	movw	r18, r30
    469a:	42 30       	cpi	r20, 0x02	; 2
    469c:	74 f0       	brlt	.+28     	; 0x46ba <utoa+0x24>
    469e:	45 32       	cpi	r20, 0x25	; 37
    46a0:	64 f4       	brge	.+24     	; 0x46ba <utoa+0x24>
    46a2:	64 2f       	mov	r22, r20
    46a4:	77 27       	eor	r23, r23
    46a6:	0e 94 c1 22 	call	0x4582	; 0x4582 <__udivmodhi4>
    46aa:	80 5d       	subi	r24, 0xD0	; 208
    46ac:	8a 33       	cpi	r24, 0x3A	; 58
    46ae:	0c f0       	brlt	.+2      	; 0x46b2 <utoa+0x1c>
    46b0:	89 5d       	subi	r24, 0xD9	; 217
    46b2:	81 93       	st	Z+, r24
    46b4:	cb 01       	movw	r24, r22
    46b6:	00 97       	sbiw	r24, 0x00	; 0
    46b8:	a1 f7       	brne	.-24     	; 0x46a2 <utoa+0xc>
    46ba:	10 82       	st	Z, r1
    46bc:	c9 01       	movw	r24, r18
    46be:	0c 94 82 23 	jmp	0x4704	; 0x4704 <strrev>

000046c2 <__eerd_byte_m644pa>:
    46c2:	f9 99       	sbic	0x1f, 1	; 31
    46c4:	fe cf       	rjmp	.-4      	; 0x46c2 <__eerd_byte_m644pa>
    46c6:	92 bd       	out	0x22, r25	; 34
    46c8:	81 bd       	out	0x21, r24	; 33
    46ca:	f8 9a       	sbi	0x1f, 0	; 31
    46cc:	99 27       	eor	r25, r25
    46ce:	80 b5       	in	r24, 0x20	; 32
    46d0:	08 95       	ret

000046d2 <__eerd_word_m644pa>:
    46d2:	a8 e1       	ldi	r26, 0x18	; 24
    46d4:	b0 e0       	ldi	r27, 0x00	; 0
    46d6:	42 e0       	ldi	r20, 0x02	; 2
    46d8:	50 e0       	ldi	r21, 0x00	; 0
    46da:	0c 94 94 23 	jmp	0x4728	; 0x4728 <__eerd_blraw_m644pa>

000046de <__eewr_byte_m644pa>:
    46de:	26 2f       	mov	r18, r22

000046e0 <__eewr_r18_m644pa>:
    46e0:	f9 99       	sbic	0x1f, 1	; 31
    46e2:	fe cf       	rjmp	.-4      	; 0x46e0 <__eewr_r18_m644pa>
    46e4:	1f ba       	out	0x1f, r1	; 31
    46e6:	92 bd       	out	0x22, r25	; 34
    46e8:	81 bd       	out	0x21, r24	; 33
    46ea:	20 bd       	out	0x20, r18	; 32
    46ec:	0f b6       	in	r0, 0x3f	; 63
    46ee:	f8 94       	cli
    46f0:	fa 9a       	sbi	0x1f, 2	; 31
    46f2:	f9 9a       	sbi	0x1f, 1	; 31
    46f4:	0f be       	out	0x3f, r0	; 63
    46f6:	01 96       	adiw	r24, 0x01	; 1
    46f8:	08 95       	ret

000046fa <__eewr_word_m644pa>:
    46fa:	0e 94 6f 23 	call	0x46de	; 0x46de <__eewr_byte_m644pa>
    46fe:	27 2f       	mov	r18, r23
    4700:	0c 94 70 23 	jmp	0x46e0	; 0x46e0 <__eewr_r18_m644pa>

00004704 <strrev>:
    4704:	dc 01       	movw	r26, r24
    4706:	fc 01       	movw	r30, r24
    4708:	67 2f       	mov	r22, r23
    470a:	71 91       	ld	r23, Z+
    470c:	77 23       	and	r23, r23
    470e:	e1 f7       	brne	.-8      	; 0x4708 <strrev+0x4>
    4710:	32 97       	sbiw	r30, 0x02	; 2
    4712:	04 c0       	rjmp	.+8      	; 0x471c <strrev+0x18>
    4714:	7c 91       	ld	r23, X
    4716:	6d 93       	st	X+, r22
    4718:	70 83       	st	Z, r23
    471a:	62 91       	ld	r22, -Z
    471c:	ae 17       	cp	r26, r30
    471e:	bf 07       	cpc	r27, r31
    4720:	c8 f3       	brcs	.-14     	; 0x4714 <strrev+0x10>
    4722:	08 95       	ret

00004724 <__eerd_block_m644pa>:
    4724:	dc 01       	movw	r26, r24
    4726:	cb 01       	movw	r24, r22

00004728 <__eerd_blraw_m644pa>:
    4728:	fc 01       	movw	r30, r24
    472a:	f9 99       	sbic	0x1f, 1	; 31
    472c:	fe cf       	rjmp	.-4      	; 0x472a <__eerd_blraw_m644pa+0x2>
    472e:	06 c0       	rjmp	.+12     	; 0x473c <__eerd_blraw_m644pa+0x14>
    4730:	f2 bd       	out	0x22, r31	; 34
    4732:	e1 bd       	out	0x21, r30	; 33
    4734:	f8 9a       	sbi	0x1f, 0	; 31
    4736:	31 96       	adiw	r30, 0x01	; 1
    4738:	00 b4       	in	r0, 0x20	; 32
    473a:	0d 92       	st	X+, r0
    473c:	41 50       	subi	r20, 0x01	; 1
    473e:	50 40       	sbci	r21, 0x00	; 0
    4740:	b8 f7       	brcc	.-18     	; 0x4730 <__eerd_blraw_m644pa+0x8>
    4742:	08 95       	ret

00004744 <_exit>:
    4744:	f8 94       	cli

00004746 <__stop_program>:
    4746:	ff cf       	rjmp	.-2      	; 0x4746 <__stop_program>
