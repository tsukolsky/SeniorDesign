
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000008c  00800100  00003876  0000392a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003876  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004b  0080018c  0080018c  000039b6  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  000039b6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000011f4  00000000  00000000  000039c0  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000005eb  00000000  00000000  00004bb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  000051a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000021a0  00000000  00000000  000052c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000003a0  00000000  00000000  00007460  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001061  00000000  00000000  00007800  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000088c  00000000  00000000  00008864  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000afe  00000000  00000000  000090f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001227  00000000  00000000  00009bee  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000018  00000000  00000000  0000ae15  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 80 13 	jmp	0x2700	; 0x2700 <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 2c 13 	jmp	0x2658	; 0x2658 <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 c5 13 	jmp	0x278a	; 0x278a <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 60 15 	jmp	0x2ac0	; 0x2ac0 <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 90 15 	jmp	0x2b20	; 0x2b20 <__vector_28>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	2c 1b       	sub	r18, r28

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d0 e1       	ldi	r29, 0x10	; 16
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	e6 e7       	ldi	r30, 0x76	; 118
      92:	f8 e3       	ldi	r31, 0x38	; 56
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	ac 38       	cpi	r26, 0x8C	; 140
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	ac e8       	ldi	r26, 0x8C	; 140
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	a7 3d       	cpi	r26, 0xD7	; 215
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 6e 1b 	call	0x36dc	; 0x36dc <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 c0 15 	call	0x2b80	; 0x2b80 <main>
      ca:	0c 94 39 1c 	jmp	0x3872	; 0x3872 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate17checkValidityDateEv>:

BOOL myDate::checkValidityDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	00 d0       	rcall	.+0      	; 0x60a <_ZN6myDate17checkValidityDateEv+0x6>
     60a:	0f 92       	push	r0
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	9b 83       	std	Y+3, r25	; 0x03
     612:	8a 83       	std	Y+2, r24	; 0x02
	BOOL checkYear=fFalse;
     614:	19 82       	std	Y+1, r1	; 0x01
	if (month/13==0){
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	9b 81       	ldd	r25, Y+3	; 0x03
     61a:	fc 01       	movw	r30, r24
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	0c 96       	adiw	r24, 0x0c	; 12
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	89 31       	cpi	r24, 0x19	; 25
     626:	91 05       	cpc	r25, r1
     628:	08 f0       	brcs	.+2      	; 0x62c <_ZN6myDate17checkValidityDateEv+0x28>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	22 23       	and	r18, r18
     62e:	09 f4       	brne	.+2      	; 0x632 <_ZN6myDate17checkValidityDateEv+0x2e>
     630:	66 c0       	rjmp	.+204    	; 0x6fe <_ZN6myDate17checkValidityDateEv+0xfa>
			if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	89 30       	cpi	r24, 0x09	; 9
     63e:	91 05       	cpc	r25, r1
     640:	81 f0       	breq	.+32     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     642:	8a 81       	ldd	r24, Y+2	; 0x02
     644:	9b 81       	ldd	r25, Y+3	; 0x03
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
     64a:	91 81       	ldd	r25, Z+1	; 0x01
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	91 05       	cpc	r25, r1
     650:	41 f0       	breq	.+16     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	9b 81       	ldd	r25, Y+3	; 0x03
     656:	fc 01       	movw	r30, r24
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	86 30       	cpi	r24, 0x06	; 6
     65e:	91 05       	cpc	r25, r1
     660:	59 f4       	brne	.+22     	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	4e 96       	adiw	r24, 0x1e	; 30
     66e:	8d 33       	cpi	r24, 0x3D	; 61
     670:	91 05       	cpc	r25, r1
     672:	10 f4       	brcc	.+4      	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	01 c0       	rjmp	.+2      	; 0x67a <_ZN6myDate17checkValidityDateEv+0x76>
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	88 23       	and	r24, r24
     67c:	19 f0       	breq	.+6      	; 0x684 <_ZN6myDate17checkValidityDateEv+0x80>
				checkYear=fTrue;
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	89 83       	std	Y+1, r24	; 0x01
     682:	28 c0       	rjmp	.+80     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else if (month == 2 && day/29 == 0){
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	fc 01       	movw	r30, r24
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	91 05       	cpc	r25, r1
     692:	59 f4       	brne	.+22     	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     694:	8a 81       	ldd	r24, Y+2	; 0x02
     696:	9b 81       	ldd	r25, Y+3	; 0x03
     698:	fc 01       	movw	r30, r24
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	4c 96       	adiw	r24, 0x1c	; 28
     6a0:	89 33       	cpi	r24, 0x39	; 57
     6a2:	91 05       	cpc	r25, r1
     6a4:	10 f4       	brcc	.+4      	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_ZN6myDate17checkValidityDateEv+0xa8>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	88 23       	and	r24, r24
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_ZN6myDate17checkValidityDateEv+0xb2>
				checkYear=fTrue;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	89 83       	std	Y+1, r24	; 0x01
     6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else{
				if (day/32 == 0){
     6b6:	8a 81       	ldd	r24, Y+2	; 0x02
     6b8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ba:	fc 01       	movw	r30, r24
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	4f 96       	adiw	r24, 0x1f	; 31
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	8f 33       	cpi	r24, 0x3F	; 63
     6c6:	91 05       	cpc	r25, r1
     6c8:	08 f0       	brcs	.+2      	; 0x6cc <_ZN6myDate17checkValidityDateEv+0xc8>
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	22 23       	and	r18, r18
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
					checkYear=fTrue;
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
			
			//Check year
			if (checkYear && year>=2013){return fTrue;}
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	88 23       	and	r24, r24
     6d8:	59 f0       	breq	.+22     	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	84 81       	ldd	r24, Z+4	; 0x04
     6e2:	95 81       	ldd	r25, Z+5	; 0x05
     6e4:	f7 e0       	ldi	r31, 0x07	; 7
     6e6:	8d 3d       	cpi	r24, 0xDD	; 221
     6e8:	9f 07       	cpc	r25, r31
     6ea:	14 f0       	brlt	.+4      	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <_ZN6myDate17checkValidityDateEv+0xee>
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	88 23       	and	r24, r24
     6f4:	11 f0       	breq	.+4      	; 0x6fa <_ZN6myDate17checkValidityDateEv+0xf6>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	03 c0       	rjmp	.+6      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
			else {return fFalse;}
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
	} else {return fFalse;}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	cd b7       	in	r28, 0x3d	; 61
     712:	de b7       	in	r29, 0x3e	; 62
     714:	2d 97       	sbiw	r28, 0x0d	; 13
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	9d 87       	std	Y+13, r25	; 0x0d
     722:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     724:	8c 85       	ldd	r24, Y+12	; 0x0c
     726:	9d 85       	ldd	r25, Y+13	; 0x0d
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	91 81       	ldd	r25, Z+1	; 0x01
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 b9 1b 	call	0x3772	; 0x3772 <itoa>
	itoa(day,dayString,10);
     73e:	8c 85       	ldd	r24, Y+12	; 0x0c
     740:	9d 85       	ldd	r25, Y+13	; 0x0d
     742:	fc 01       	movw	r30, r24
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9e 01       	movw	r18, r28
     74a:	2c 5f       	subi	r18, 0xFC	; 252
     74c:	3f 4f       	sbci	r19, 0xFF	; 255
     74e:	b9 01       	movw	r22, r18
     750:	4a e0       	ldi	r20, 0x0A	; 10
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	0e 94 b9 1b 	call	0x3772	; 0x3772 <itoa>
	itoa(year,yearString,10);
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	fc 01       	movw	r30, r24
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9e 01       	movw	r18, r28
     764:	29 5f       	subi	r18, 0xF9	; 249
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	4a e0       	ldi	r20, 0x0A	; 10
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	0e 94 b9 1b 	call	0x3772	; 0x3772 <itoa>
	strcpy(dateString,monthString);
     772:	8c 85       	ldd	r24, Y+12	; 0x0c
     774:	9d 85       	ldd	r25, Y+13	; 0x0d
     776:	06 96       	adiw	r24, 0x06	; 6
     778:	9e 01       	movw	r18, r28
     77a:	2f 5f       	subi	r18, 0xFF	; 255
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	0e 94 a4 1b 	call	0x3748	; 0x3748 <strcpy>
	strcat(dateString,",");
     784:	8c 85       	ldd	r24, Y+12	; 0x0c
     786:	9d 85       	ldd	r25, Y+13	; 0x0d
     788:	9c 01       	movw	r18, r24
     78a:	2a 5f       	subi	r18, 0xFA	; 250
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	c9 01       	movw	r24, r18
     790:	ac 01       	movw	r20, r24
     792:	fa 01       	movw	r30, r20
     794:	01 90       	ld	r0, Z+
     796:	00 20       	and	r0, r0
     798:	e9 f7       	brne	.-6      	; 0x794 <_ZN6myDate7getDateEv+0x88>
     79a:	cf 01       	movw	r24, r30
     79c:	01 97       	sbiw	r24, 0x01	; 1
     79e:	84 1b       	sub	r24, r20
     7a0:	95 0b       	sbc	r25, r21
     7a2:	82 0f       	add	r24, r18
     7a4:	93 1f       	adc	r25, r19
     7a6:	2c e2       	ldi	r18, 0x2C	; 44
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	fc 01       	movw	r30, r24
     7ac:	31 83       	std	Z+1, r19	; 0x01
     7ae:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     7b0:	8c 85       	ldd	r24, Y+12	; 0x0c
     7b2:	9d 85       	ldd	r25, Y+13	; 0x0d
     7b4:	06 96       	adiw	r24, 0x06	; 6
     7b6:	9e 01       	movw	r18, r28
     7b8:	2c 5f       	subi	r18, 0xFC	; 252
     7ba:	3f 4f       	sbci	r19, 0xFF	; 255
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 90 1b 	call	0x3720	; 0x3720 <strcat>
	strcat(dateString,",");
     7c2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7c4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7c6:	9c 01       	movw	r18, r24
     7c8:	2a 5f       	subi	r18, 0xFA	; 250
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	c9 01       	movw	r24, r18
     7ce:	ac 01       	movw	r20, r24
     7d0:	fa 01       	movw	r30, r20
     7d2:	01 90       	ld	r0, Z+
     7d4:	00 20       	and	r0, r0
     7d6:	e9 f7       	brne	.-6      	; 0x7d2 <_ZN6myDate7getDateEv+0xc6>
     7d8:	cf 01       	movw	r24, r30
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	84 1b       	sub	r24, r20
     7de:	95 0b       	sbc	r25, r21
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	2c e2       	ldi	r18, 0x2C	; 44
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	fc 01       	movw	r30, r24
     7ea:	31 83       	std	Z+1, r19	; 0x01
     7ec:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     7ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     7f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f2:	06 96       	adiw	r24, 0x06	; 6
     7f4:	9e 01       	movw	r18, r28
     7f6:	29 5f       	subi	r18, 0xF9	; 249
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 90 1b 	call	0x3720	; 0x3720 <strcat>
	dateString[16] = '\0';
     800:	8c 85       	ldd	r24, Y+12	; 0x0c
     802:	9d 85       	ldd	r25, Y+13	; 0x0d
     804:	fc 01       	movw	r30, r24
     806:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     808:	8c 85       	ldd	r24, Y+12	; 0x0c
     80a:	9d 85       	ldd	r25, Y+13	; 0x0d
     80c:	06 96       	adiw	r24, 0x06	; 6
     80e:	2d 96       	adiw	r28, 0x0d	; 13
     810:	0f b6       	in	r0, 0x3f	; 63
     812:	f8 94       	cli
     814:	de bf       	out	0x3e, r29	; 62
     816:	0f be       	out	0x3f, r0	; 63
     818:	cd bf       	out	0x3d, r28	; 61
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	08 95       	ret

00000820 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	00 d0       	rcall	.+0      	; 0x826 <_ZN6myTimeC1Ev+0x6>
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	9a 83       	std	Y+2, r25	; 0x02
     82c:	89 83       	std	Y+1, r24	; 0x01
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     836:	89 81       	ldd	r24, Y+1	; 0x01
     838:	9a 81       	ldd	r25, Y+2	; 0x02
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	40 e0       	ldi	r20, 0x00	; 0
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	08 95       	ret

00000854 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	28 97       	sbiw	r28, 0x08	; 8
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 83       	std	Y+2, r25	; 0x02
     86a:	89 83       	std	Y+1, r24	; 0x01
     86c:	7c 83       	std	Y+4, r23	; 0x04
     86e:	6b 83       	std	Y+3, r22	; 0x03
     870:	5e 83       	std	Y+6, r21	; 0x06
     872:	4d 83       	std	Y+5, r20	; 0x05
     874:	38 87       	std	Y+8, r19	; 0x08
     876:	2f 83       	std	Y+7, r18	; 0x07
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	9a 81       	ldd	r25, Y+2	; 0x02
     87c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	9a 81       	ldd	r25, Y+2	; 0x02
     884:	6b 81       	ldd	r22, Y+3	; 0x03
     886:	7c 81       	ldd	r23, Y+4	; 0x04
     888:	4d 81       	ldd	r20, Y+5	; 0x05
     88a:	5e 81       	ldd	r21, Y+6	; 0x06
     88c:	2f 81       	ldd	r18, Y+7	; 0x07
     88e:	38 85       	ldd	r19, Y+8	; 0x08
     890:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     894:	28 96       	adiw	r28, 0x08	; 8
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	de bf       	out	0x3e, r29	; 62
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	cd bf       	out	0x3d, r28	; 61
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	08 95       	ret

000008a6 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     8a6:	cf 92       	push	r12
     8a8:	df 92       	push	r13
     8aa:	ef 92       	push	r14
     8ac:	ff 92       	push	r15
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
     8ba:	2e 97       	sbiw	r28, 0x0e	; 14
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	f8 94       	cli
     8c0:	de bf       	out	0x3e, r29	; 62
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	cd bf       	out	0x3d, r28	; 61
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01
     8ca:	7c 83       	std	Y+4, r23	; 0x04
     8cc:	6b 83       	std	Y+3, r22	; 0x03
     8ce:	5e 83       	std	Y+6, r21	; 0x06
     8d0:	4d 83       	std	Y+5, r20	; 0x05
     8d2:	38 87       	std	Y+8, r19	; 0x08
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	1a 87       	std	Y+10, r17	; 0x0a
     8d8:	09 87       	std	Y+9, r16	; 0x09
     8da:	fc 86       	std	Y+12, r15	; 0x0c
     8dc:	eb 86       	std	Y+11, r14	; 0x0b
     8de:	de 86       	std	Y+14, r13	; 0x0e
     8e0:	cd 86       	std	Y+13, r12	; 0x0d
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	69 85       	ldd	r22, Y+9	; 0x09
     8e8:	7a 85       	ldd	r23, Y+10	; 0x0a
     8ea:	4b 85       	ldd	r20, Y+11	; 0x0b
     8ec:	5c 85       	ldd	r21, Y+12	; 0x0c
     8ee:	2d 85       	ldd	r18, Y+13	; 0x0d
     8f0:	3e 85       	ldd	r19, Y+14	; 0x0e
     8f2:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	9a 81       	ldd	r25, Y+2	; 0x02
     8fa:	6b 81       	ldd	r22, Y+3	; 0x03
     8fc:	7c 81       	ldd	r23, Y+4	; 0x04
     8fe:	4d 81       	ldd	r20, Y+5	; 0x05
     900:	5e 81       	ldd	r21, Y+6	; 0x06
     902:	2f 81       	ldd	r18, Y+7	; 0x07
     904:	38 85       	ldd	r19, Y+8	; 0x08
     906:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     90a:	2e 96       	adiw	r28, 0x0e	; 14
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	de bf       	out	0x3e, r29	; 62
     912:	0f be       	out	0x3f, r0	; 63
     914:	cd bf       	out	0x3d, r28	; 61
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	08 95       	ret

00000928 <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	00 d0       	rcall	.+0      	; 0x92e <_ZN6myTime10getSecondsEv+0x6>
     92e:	cd b7       	in	r28, 0x3d	; 61
     930:	de b7       	in	r29, 0x3e	; 62
     932:	9a 83       	std	Y+2, r25	; 0x02
     934:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     936:	89 81       	ldd	r24, Y+1	; 0x01
     938:	9a 81       	ldd	r25, Y+2	; 0x02
     93a:	fc 01       	movw	r30, r24
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	00 d0       	rcall	.+0      	; 0x950 <_ZN6myTime10getMinutesEv+0x6>
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	9a 83       	std	Y+2, r25	; 0x02
     956:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	9a 81       	ldd	r25, Y+2	; 0x02
     95c:	fc 01       	movw	r30, r24
     95e:	81 8d       	ldd	r24, Z+25	; 0x19
     960:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	00 d0       	rcall	.+0      	; 0x972 <_ZN6myTime8getHoursEv+0x6>
     972:	cd b7       	in	r28, 0x3d	; 61
     974:	de b7       	in	r29, 0x3e	; 62
     976:	9a 83       	std	Y+2, r25	; 0x02
     978:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	87 89       	ldd	r24, Z+23	; 0x17
     982:	90 8d       	ldd	r25, Z+24	; 0x18
}
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
     996:	a2 97       	sbiw	r28, 0x22	; 34
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	f8 94       	cli
     99c:	de bf       	out	0x3e, r29	; 62
     99e:	0f be       	out	0x3f, r0	; 63
     9a0:	cd bf       	out	0x3d, r28	; 61
     9a2:	98 a3       	lds	r25, 0x58
     9a4:	8f 8f       	std	Y+31, r24	; 0x1f
     9a6:	7a a3       	lds	r23, 0x5a
     9a8:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     9aa:	ce 01       	movw	r24, r28
     9ac:	0b 96       	adiw	r24, 0x0b	; 11
     9ae:	29 a1       	lds	r18, 0x49
     9b0:	3a a1       	lds	r19, 0x4a
     9b2:	b9 01       	movw	r22, r18
     9b4:	0e 94 a4 1b 	call	0x3748	; 0x3748 <strcpy>
	for (int j=0; j<3; j++){
     9b8:	1a 82       	std	Y+2, r1	; 0x02
     9ba:	19 82       	std	Y+1, r1	; 0x01
     9bc:	43 c0       	rjmp	.+134    	; 0xa44 <_ZN6myTime7setTimeEPc+0xb6>
		for (int i=0; i<2; i++){
     9be:	1c 82       	std	Y+4, r1	; 0x04
     9c0:	1b 82       	std	Y+3, r1	; 0x03
     9c2:	20 c0       	rjmp	.+64     	; 0xa04 <_ZN6myTime7setTimeEPc+0x76>
				tempString[i]=currentString[i+j*3];
     9c4:	29 81       	ldd	r18, Y+1	; 0x01
     9c6:	3a 81       	ldd	r19, Y+2	; 0x02
     9c8:	c9 01       	movw	r24, r18
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	28 0f       	add	r18, r24
     9d0:	39 1f       	adc	r19, r25
     9d2:	8b 81       	ldd	r24, Y+3	; 0x03
     9d4:	9c 81       	ldd	r25, Y+4	; 0x04
     9d6:	82 0f       	add	r24, r18
     9d8:	93 1f       	adc	r25, r19
     9da:	9e 01       	movw	r18, r28
     9dc:	25 5f       	subi	r18, 0xF5	; 245
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	fc 01       	movw	r30, r24
     9e6:	40 81       	ld	r20, Z
     9e8:	9e 01       	movw	r18, r28
     9ea:	2b 5e       	subi	r18, 0xEB	; 235
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	8b 81       	ldd	r24, Y+3	; 0x03
     9f0:	9c 81       	ldd	r25, Y+4	; 0x04
     9f2:	82 0f       	add	r24, r18
     9f4:	93 1f       	adc	r25, r19
     9f6:	fc 01       	movw	r30, r24
     9f8:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
     9fc:	9c 81       	ldd	r25, Y+4	; 0x04
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	9c 83       	std	Y+4, r25	; 0x04
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	21 e0       	ldi	r18, 0x01	; 1
     a06:	8b 81       	ldd	r24, Y+3	; 0x03
     a08:	9c 81       	ldd	r25, Y+4	; 0x04
     a0a:	82 30       	cpi	r24, 0x02	; 2
     a0c:	91 05       	cpc	r25, r1
     a0e:	0c f0       	brlt	.+2      	; 0xa12 <_ZN6myTime7setTimeEPc+0x84>
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	22 23       	and	r18, r18
     a14:	b9 f6       	brne	.-82     	; 0x9c4 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     a16:	ce 01       	movw	r24, r28
     a18:	45 96       	adiw	r24, 0x15	; 21
     a1a:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
     a1e:	9c 01       	movw	r18, r24
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	ae 01       	movw	r20, r28
     a2a:	4f 5f       	subi	r20, 0xFF	; 255
     a2c:	5f 4f       	sbci	r21, 0xFF	; 255
     a2e:	84 0f       	add	r24, r20
     a30:	95 1f       	adc	r25, r21
     a32:	04 96       	adiw	r24, 0x04	; 4
     a34:	fc 01       	movw	r30, r24
     a36:	31 83       	std	Z+1, r19	; 0x01
     a38:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	9a 81       	ldd	r25, Y+2	; 0x02
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	9a 83       	std	Y+2, r25	; 0x02
     a42:	89 83       	std	Y+1, r24	; 0x01
     a44:	21 e0       	ldi	r18, 0x01	; 1
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	9a 81       	ldd	r25, Y+2	; 0x02
     a4a:	83 30       	cpi	r24, 0x03	; 3
     a4c:	91 05       	cpc	r25, r1
     a4e:	0c f0       	brlt	.+2      	; 0xa52 <_ZN6myTime7setTimeEPc+0xc4>
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	22 23       	and	r18, r18
     a54:	09 f0       	breq	.+2      	; 0xa58 <_ZN6myTime7setTimeEPc+0xca>
     a56:	b3 cf       	rjmp	.-154    	; 0x9be <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	9e 81       	ldd	r25, Y+6	; 0x06
     a5c:	47 96       	adiw	r24, 0x17	; 23
     a5e:	8f 32       	cpi	r24, 0x2F	; 47
     a60:	91 05       	cpc	r25, r1
     a62:	c0 f4       	brcc	.+48     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a64:	8f 81       	ldd	r24, Y+7	; 0x07
     a66:	98 85       	ldd	r25, Y+8	; 0x08
     a68:	cb 96       	adiw	r24, 0x3b	; 59
     a6a:	87 37       	cpi	r24, 0x77	; 119
     a6c:	91 05       	cpc	r25, r1
     a6e:	90 f4       	brcc	.+36     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a70:	89 85       	ldd	r24, Y+9	; 0x09
     a72:	9a 85       	ldd	r25, Y+10	; 0x0a
     a74:	cb 96       	adiw	r24, 0x3b	; 59
     a76:	87 37       	cpi	r24, 0x77	; 119
     a78:	91 05       	cpc	r25, r1
     a7a:	60 f4       	brcc	.+24     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     a7c:	6d 81       	ldd	r22, Y+5	; 0x05
     a7e:	7e 81       	ldd	r23, Y+6	; 0x06
     a80:	4f 81       	ldd	r20, Y+7	; 0x07
     a82:	58 85       	ldd	r21, Y+8	; 0x08
     a84:	29 85       	ldd	r18, Y+9	; 0x09
     a86:	3a 85       	ldd	r19, Y+10	; 0x0a
     a88:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a8a:	98 a1       	lds	r25, 0x48
     a8c:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
		return fTrue;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	01 c0       	rjmp	.+2      	; 0xa96 <_ZN6myTime7setTimeEPc+0x108>
	} 
	return fFalse;
     a94:	80 e0       	ldi	r24, 0x00	; 0
}
     a96:	a2 96       	adiw	r28, 0x22	; 34
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	cd bf       	out	0x3d, r28	; 61
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	cd b7       	in	r28, 0x3d	; 61
     aae:	de b7       	in	r29, 0x3e	; 62
     ab0:	28 97       	sbiw	r28, 0x08	; 8
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	9a 83       	std	Y+2, r25	; 0x02
     abe:	89 83       	std	Y+1, r24	; 0x01
     ac0:	7c 83       	std	Y+4, r23	; 0x04
     ac2:	6b 83       	std	Y+3, r22	; 0x03
     ac4:	5e 83       	std	Y+6, r21	; 0x06
     ac6:	4d 83       	std	Y+5, r20	; 0x05
     ac8:	38 87       	std	Y+8, r19	; 0x08
     aca:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
     ad0:	2b 81       	ldd	r18, Y+3	; 0x03
     ad2:	3c 81       	ldd	r19, Y+4	; 0x04
     ad4:	b9 01       	movw	r22, r18
     ad6:	0e 94 84 05 	call	0xb08	; 0xb08 <_ZN6myTime7setHourEi>
	setMinute(minute);
     ada:	89 81       	ldd	r24, Y+1	; 0x01
     adc:	9a 81       	ldd	r25, Y+2	; 0x02
     ade:	2d 81       	ldd	r18, Y+5	; 0x05
     ae0:	3e 81       	ldd	r19, Y+6	; 0x06
     ae2:	b9 01       	movw	r22, r18
     ae4:	0e 94 a2 05 	call	0xb44	; 0xb44 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     ae8:	89 81       	ldd	r24, Y+1	; 0x01
     aea:	9a 81       	ldd	r25, Y+2	; 0x02
     aec:	2f 81       	ldd	r18, Y+7	; 0x07
     aee:	38 85       	ldd	r19, Y+8	; 0x08
     af0:	b9 01       	movw	r22, r18
     af2:	0e 94 c0 05 	call	0xb80	; 0xb80 <_ZN6myTime9setSecondEi>
}
     af6:	28 96       	adiw	r28, 0x08	; 8
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	de bf       	out	0x3e, r29	; 62
     afe:	0f be       	out	0x3f, r0	; 63
     b00:	cd bf       	out	0x3d, r28	; 61
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     b08:	cf 93       	push	r28
     b0a:	df 93       	push	r29
     b0c:	00 d0       	rcall	.+0      	; 0xb0e <_ZN6myTime7setHourEi+0x6>
     b0e:	00 d0       	rcall	.+0      	; 0xb10 <_ZN6myTime7setHourEi+0x8>
     b10:	cd b7       	in	r28, 0x3d	; 61
     b12:	de b7       	in	r29, 0x3e	; 62
     b14:	9a 83       	std	Y+2, r25	; 0x02
     b16:	89 83       	std	Y+1, r24	; 0x01
     b18:	7c 83       	std	Y+4, r23	; 0x04
     b1a:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     b1c:	8b 81       	ldd	r24, Y+3	; 0x03
     b1e:	9c 81       	ldd	r25, Y+4	; 0x04
     b20:	47 96       	adiw	r24, 0x17	; 23
     b22:	8f 32       	cpi	r24, 0x2F	; 47
     b24:	91 05       	cpc	r25, r1
     b26:	38 f4       	brcc	.+14     	; 0xb36 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     b28:	89 81       	ldd	r24, Y+1	; 0x01
     b2a:	9a 81       	ldd	r25, Y+2	; 0x02
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	3c 81       	ldd	r19, Y+4	; 0x04
     b30:	fc 01       	movw	r30, r24
     b32:	30 8f       	std	Z+24, r19	; 0x18
     b34:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	0f 90       	pop	r0
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <_ZN6myTime9setMinuteEi+0x6>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <_ZN6myTime9setMinuteEi+0x8>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01
     b54:	7c 83       	std	Y+4, r23	; 0x04
     b56:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	cb 96       	adiw	r24, 0x3b	; 59
     b5e:	87 37       	cpi	r24, 0x77	; 119
     b60:	91 05       	cpc	r25, r1
     b62:	38 f4       	brcc	.+14     	; 0xb72 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	2b 81       	ldd	r18, Y+3	; 0x03
     b6a:	3c 81       	ldd	r19, Y+4	; 0x04
     b6c:	fc 01       	movw	r30, r24
     b6e:	32 8f       	std	Z+26, r19	; 0x1a
     b70:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     b72:	0f 90       	pop	r0
     b74:	0f 90       	pop	r0
     b76:	0f 90       	pop	r0
     b78:	0f 90       	pop	r0
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	00 d0       	rcall	.+0      	; 0xb86 <_ZN6myTime9setSecondEi+0x6>
     b86:	00 d0       	rcall	.+0      	; 0xb88 <_ZN6myTime9setSecondEi+0x8>
     b88:	cd b7       	in	r28, 0x3d	; 61
     b8a:	de b7       	in	r29, 0x3e	; 62
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
     b90:	7c 83       	std	Y+4, r23	; 0x04
     b92:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	cb 96       	adiw	r24, 0x3b	; 59
     b9a:	87 37       	cpi	r24, 0x77	; 119
     b9c:	91 05       	cpc	r25, r1
     b9e:	38 f4       	brcc	.+14     	; 0xbae <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	9a 81       	ldd	r25, Y+2	; 0x02
     ba4:	2b 81       	ldd	r18, Y+3	; 0x03
     ba6:	3c 81       	ldd	r19, Y+4	; 0x04
     ba8:	fc 01       	movw	r30, r24
     baa:	34 8f       	std	Z+28, r19	; 0x1c
     bac:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	28 97       	sbiw	r28, 0x08	; 8
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	de bf       	out	0x3e, r29	; 62
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	cd bf       	out	0x3d, r28	; 61
     bd0:	9e 83       	std	Y+6, r25	; 0x06
     bd2:	8d 83       	std	Y+5, r24	; 0x05
     bd4:	78 87       	std	Y+8, r23	; 0x08
     bd6:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     bd8:	8d 81       	ldd	r24, Y+5	; 0x05
     bda:	9e 81       	ldd	r25, Y+6	; 0x06
     bdc:	fc 01       	movw	r30, r24
     bde:	27 89       	ldd	r18, Z+23	; 0x17
     be0:	30 8d       	ldd	r19, Z+24	; 0x18
     be2:	8f 81       	ldd	r24, Y+7	; 0x07
     be4:	98 85       	ldd	r25, Y+8	; 0x08
     be6:	82 0f       	add	r24, r18
     be8:	93 1f       	adc	r25, r19
     bea:	9a 83       	std	Y+2, r25	; 0x02
     bec:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	9a 81       	ldd	r25, Y+2	; 0x02
     bf2:	28 e1       	ldi	r18, 0x18	; 24
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	b9 01       	movw	r22, r18
     bf8:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     bfc:	9c 01       	movw	r18, r24
     bfe:	8d 81       	ldd	r24, Y+5	; 0x05
     c00:	9e 81       	ldd	r25, Y+6	; 0x06
     c02:	fc 01       	movw	r30, r24
     c04:	30 8f       	std	Z+24, r19	; 0x18
     c06:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a 81       	ldd	r25, Y+2	; 0x02
     c0c:	21 e0       	ldi	r18, 0x01	; 1
     c0e:	88 31       	cpi	r24, 0x18	; 24
     c10:	91 05       	cpc	r25, r1
     c12:	0c f4       	brge	.+2      	; 0xc16 <_ZN6myTime8addHoursEi+0x5a>
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	22 23       	and	r18, r18
     c18:	91 f0       	breq	.+36     	; 0xc3e <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	28 e1       	ldi	r18, 0x18	; 24
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	b9 01       	movw	r22, r18
     c24:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     c28:	9b 01       	movw	r18, r22
     c2a:	c9 01       	movw	r24, r18
     c2c:	9c 83       	std	Y+4, r25	; 0x04
     c2e:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     c30:	8d 81       	ldd	r24, Y+5	; 0x05
     c32:	9e 81       	ldd	r25, Y+6	; 0x06
     c34:	2b 81       	ldd	r18, Y+3	; 0x03
     c36:	3c 81       	ldd	r19, Y+4	; 0x04
     c38:	b9 01       	movw	r22, r18
     c3a:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     c3e:	28 96       	adiw	r28, 0x08	; 8
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	08 95       	ret

00000c50 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
     c58:	28 97       	sbiw	r28, 0x08	; 8
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	9e 83       	std	Y+6, r25	; 0x06
     c66:	8d 83       	std	Y+5, r24	; 0x05
     c68:	78 87       	std	Y+8, r23	; 0x08
     c6a:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     c6c:	8d 81       	ldd	r24, Y+5	; 0x05
     c6e:	9e 81       	ldd	r25, Y+6	; 0x06
     c70:	fc 01       	movw	r30, r24
     c72:	21 8d       	ldd	r18, Z+25	; 0x19
     c74:	32 8d       	ldd	r19, Z+26	; 0x1a
     c76:	8f 81       	ldd	r24, Y+7	; 0x07
     c78:	98 85       	ldd	r25, Y+8	; 0x08
     c7a:	82 0f       	add	r24, r18
     c7c:	93 1f       	adc	r25, r19
     c7e:	9a 83       	std	Y+2, r25	; 0x02
     c80:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	9a 81       	ldd	r25, Y+2	; 0x02
     c86:	2c e3       	ldi	r18, 0x3C	; 60
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	b9 01       	movw	r22, r18
     c8c:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     c90:	9c 01       	movw	r18, r24
     c92:	8d 81       	ldd	r24, Y+5	; 0x05
     c94:	9e 81       	ldd	r25, Y+6	; 0x06
     c96:	fc 01       	movw	r30, r24
     c98:	32 8f       	std	Z+26, r19	; 0x1a
     c9a:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ca0:	21 e0       	ldi	r18, 0x01	; 1
     ca2:	8c 33       	cpi	r24, 0x3C	; 60
     ca4:	91 05       	cpc	r25, r1
     ca6:	0c f4       	brge	.+2      	; 0xcaa <_ZN6myTime10addMinutesEi+0x5a>
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	22 23       	and	r18, r18
     cac:	91 f0       	breq	.+36     	; 0xcd2 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	2c e3       	ldi	r18, 0x3C	; 60
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	b9 01       	movw	r22, r18
     cb8:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     cbc:	9b 01       	movw	r18, r22
     cbe:	c9 01       	movw	r24, r18
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     cc4:	2b 81       	ldd	r18, Y+3	; 0x03
     cc6:	3c 81       	ldd	r19, Y+4	; 0x04
     cc8:	8d 81       	ldd	r24, Y+5	; 0x05
     cca:	9e 81       	ldd	r25, Y+6	; 0x06
     ccc:	b9 01       	movw	r22, r18
     cce:	0e 94 de 05 	call	0xbbc	; 0xbbc <_ZN6myTime8addHoursEi>
	}
}
     cd2:	28 96       	adiw	r28, 0x08	; 8
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	cd b7       	in	r28, 0x3d	; 61
     cea:	de b7       	in	r29, 0x3e	; 62
     cec:	28 97       	sbiw	r28, 0x08	; 8
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	de bf       	out	0x3e, r29	; 62
     cf4:	0f be       	out	0x3f, r0	; 63
     cf6:	cd bf       	out	0x3d, r28	; 61
     cf8:	9e 83       	std	Y+6, r25	; 0x06
     cfa:	8d 83       	std	Y+5, r24	; 0x05
     cfc:	78 87       	std	Y+8, r23	; 0x08
     cfe:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	9e 81       	ldd	r25, Y+6	; 0x06
     d04:	fc 01       	movw	r30, r24
     d06:	23 8d       	ldd	r18, Z+27	; 0x1b
     d08:	34 8d       	ldd	r19, Z+28	; 0x1c
     d0a:	8f 81       	ldd	r24, Y+7	; 0x07
     d0c:	98 85       	ldd	r25, Y+8	; 0x08
     d0e:	82 0f       	add	r24, r18
     d10:	93 1f       	adc	r25, r19
     d12:	9a 83       	std	Y+2, r25	; 0x02
     d14:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     d16:	89 81       	ldd	r24, Y+1	; 0x01
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	2c e3       	ldi	r18, 0x3C	; 60
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	b9 01       	movw	r22, r18
     d20:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     d24:	9c 01       	movw	r18, r24
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	fc 01       	movw	r30, r24
     d2c:	34 8f       	std	Z+28, r19	; 0x1c
     d2e:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	9a 81       	ldd	r25, Y+2	; 0x02
     d34:	21 e0       	ldi	r18, 0x01	; 1
     d36:	8c 33       	cpi	r24, 0x3C	; 60
     d38:	91 05       	cpc	r25, r1
     d3a:	0c f4       	brge	.+2      	; 0xd3e <_ZN6myTime10addSecondsEi+0x5a>
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	22 23       	and	r18, r18
     d40:	91 f0       	breq	.+36     	; 0xd66 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     d42:	89 81       	ldd	r24, Y+1	; 0x01
     d44:	9a 81       	ldd	r25, Y+2	; 0x02
     d46:	2c e3       	ldi	r18, 0x3C	; 60
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	b9 01       	movw	r22, r18
     d4c:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
     d50:	9b 01       	movw	r18, r22
     d52:	c9 01       	movw	r24, r18
     d54:	9c 83       	std	Y+4, r25	; 0x04
     d56:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     d58:	2b 81       	ldd	r18, Y+3	; 0x03
     d5a:	3c 81       	ldd	r19, Y+4	; 0x04
     d5c:	8d 81       	ldd	r24, Y+5	; 0x05
     d5e:	9e 81       	ldd	r25, Y+6	; 0x06
     d60:	b9 01       	movw	r22, r18
     d62:	0e 94 28 06 	call	0xc50	; 0xc50 <_ZN6myTime10addMinutesEi>
	}
}
     d66:	28 96       	adiw	r28, 0x08	; 8
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	08 95       	ret

00000d78 <_ZN6myTime13checkValidityEv>:

BOOL myTime::checkValidity(){
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	00 d0       	rcall	.+0      	; 0xd7e <_ZN6myTime13checkValidityEv+0x6>
     d7e:	0f 92       	push	r0
     d80:	cd b7       	in	r28, 0x3d	; 61
     d82:	de b7       	in	r29, 0x3e	; 62
     d84:	9b 83       	std	Y+3, r25	; 0x03
     d86:	8a 83       	std	Y+2, r24	; 0x02
	BOOL stillValid=fTrue;
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	89 83       	std	Y+1, r24	; 0x01
	if (second/60==0 && minute/60==0 && hour/24==0){
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	fc 01       	movw	r30, r24
     d92:	83 8d       	ldd	r24, Z+27	; 0x1b
     d94:	94 8d       	ldd	r25, Z+28	; 0x1c
     d96:	cb 96       	adiw	r24, 0x3b	; 59
     d98:	87 37       	cpi	r24, 0x77	; 119
     d9a:	91 05       	cpc	r25, r1
     d9c:	a0 f4       	brcc	.+40     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	fc 01       	movw	r30, r24
     da4:	81 8d       	ldd	r24, Z+25	; 0x19
     da6:	92 8d       	ldd	r25, Z+26	; 0x1a
     da8:	cb 96       	adiw	r24, 0x3b	; 59
     daa:	87 37       	cpi	r24, 0x77	; 119
     dac:	91 05       	cpc	r25, r1
     dae:	58 f4       	brcc	.+22     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	9b 81       	ldd	r25, Y+3	; 0x03
     db4:	fc 01       	movw	r30, r24
     db6:	87 89       	ldd	r24, Z+23	; 0x17
     db8:	90 8d       	ldd	r25, Z+24	; 0x18
     dba:	47 96       	adiw	r24, 0x17	; 23
     dbc:	8f 32       	cpi	r24, 0x2F	; 47
     dbe:	91 05       	cpc	r25, r1
     dc0:	10 f4       	brcc	.+4      	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <_ZN6myTime13checkValidityEv+0x50>
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	88 23       	and	r24, r24
     dca:	69 f0       	breq	.+26     	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
		if (checkValidityDate()){return fTrue;}
     dcc:	8a 81       	ldd	r24, Y+2	; 0x02
     dce:	9b 81       	ldd	r25, Y+3	; 0x03
     dd0:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate17checkValidityDateEv>
     dd4:	98 2f       	mov	r25, r24
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	99 23       	and	r25, r25
     dda:	09 f4       	brne	.+2      	; 0xdde <_ZN6myTime13checkValidityEv+0x66>
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	88 23       	and	r24, r24
     de0:	11 f0       	breq	.+4      	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	01 c0       	rjmp	.+2      	; 0xde8 <_ZN6myTime13checkValidityEv+0x70>
	}
	return fFalse;
     de6:	80 e0       	ldi	r24, 0x00	; 0
}
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	cd b7       	in	r28, 0x3d	; 61
     dfa:	de b7       	in	r29, 0x3e	; 62
     dfc:	2b 97       	sbiw	r28, 0x0b	; 11
     dfe:	0f b6       	in	r0, 0x3f	; 63
     e00:	f8 94       	cli
     e02:	de bf       	out	0x3e, r29	; 62
     e04:	0f be       	out	0x3f, r0	; 63
     e06:	cd bf       	out	0x3d, r28	; 61
     e08:	9b 87       	std	Y+11, r25	; 0x0b
     e0a:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e10:	fc 01       	movw	r30, r24
     e12:	87 89       	ldd	r24, Z+23	; 0x17
     e14:	90 8d       	ldd	r25, Z+24	; 0x18
     e16:	9e 01       	movw	r18, r28
     e18:	2f 5f       	subi	r18, 0xFF	; 255
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	b9 01       	movw	r22, r18
     e1e:	4a e0       	ldi	r20, 0x0A	; 10
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	0e 94 b9 1b 	call	0x3772	; 0x3772 <itoa>
	itoa(minute,minuteString,10);
     e26:	8a 85       	ldd	r24, Y+10	; 0x0a
     e28:	9b 85       	ldd	r25, Y+11	; 0x0b
     e2a:	fc 01       	movw	r30, r24
     e2c:	81 8d       	ldd	r24, Z+25	; 0x19
     e2e:	92 8d       	ldd	r25, Z+26	; 0x1a
     e30:	9e 01       	movw	r18, r28
     e32:	2c 5f       	subi	r18, 0xFC	; 252
     e34:	3f 4f       	sbci	r19, 0xFF	; 255
     e36:	b9 01       	movw	r22, r18
     e38:	4a e0       	ldi	r20, 0x0A	; 10
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 b9 1b 	call	0x3772	; 0x3772 <itoa>
	itoa(second,secondString,10);
     e40:	8a 85       	ldd	r24, Y+10	; 0x0a
     e42:	9b 85       	ldd	r25, Y+11	; 0x0b
     e44:	fc 01       	movw	r30, r24
     e46:	83 8d       	ldd	r24, Z+27	; 0x1b
     e48:	94 8d       	ldd	r25, Z+28	; 0x1c
     e4a:	9e 01       	movw	r18, r28
     e4c:	29 5f       	subi	r18, 0xF9	; 249
     e4e:	3f 4f       	sbci	r19, 0xFF	; 255
     e50:	b9 01       	movw	r22, r18
     e52:	4a e0       	ldi	r20, 0x0A	; 10
     e54:	50 e0       	ldi	r21, 0x00	; 0
     e56:	0e 94 b9 1b 	call	0x3772	; 0x3772 <itoa>
	strcpy(timeString,hourString);
     e5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e5e:	4d 96       	adiw	r24, 0x1d	; 29
     e60:	9e 01       	movw	r18, r28
     e62:	2f 5f       	subi	r18, 0xFF	; 255
     e64:	3f 4f       	sbci	r19, 0xFF	; 255
     e66:	b9 01       	movw	r22, r18
     e68:	0e 94 a4 1b 	call	0x3748	; 0x3748 <strcpy>
	strcat(timeString,":");
     e6c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e6e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e70:	9c 01       	movw	r18, r24
     e72:	23 5e       	subi	r18, 0xE3	; 227
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	c9 01       	movw	r24, r18
     e78:	ac 01       	movw	r20, r24
     e7a:	fa 01       	movw	r30, r20
     e7c:	01 90       	ld	r0, Z+
     e7e:	00 20       	and	r0, r0
     e80:	e9 f7       	brne	.-6      	; 0xe7c <_ZN6myTime7getTimeEv+0x88>
     e82:	cf 01       	movw	r24, r30
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	84 1b       	sub	r24, r20
     e88:	95 0b       	sbc	r25, r21
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	2a e3       	ldi	r18, 0x3A	; 58
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	fc 01       	movw	r30, r24
     e94:	31 83       	std	Z+1, r19	; 0x01
     e96:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     e98:	8a 85       	ldd	r24, Y+10	; 0x0a
     e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9c:	4d 96       	adiw	r24, 0x1d	; 29
     e9e:	9e 01       	movw	r18, r28
     ea0:	2c 5f       	subi	r18, 0xFC	; 252
     ea2:	3f 4f       	sbci	r19, 0xFF	; 255
     ea4:	b9 01       	movw	r22, r18
     ea6:	0e 94 90 1b 	call	0x3720	; 0x3720 <strcat>
	strcat(timeString,":");
     eaa:	8a 85       	ldd	r24, Y+10	; 0x0a
     eac:	9b 85       	ldd	r25, Y+11	; 0x0b
     eae:	9c 01       	movw	r18, r24
     eb0:	23 5e       	subi	r18, 0xE3	; 227
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	c9 01       	movw	r24, r18
     eb6:	ac 01       	movw	r20, r24
     eb8:	fa 01       	movw	r30, r20
     eba:	01 90       	ld	r0, Z+
     ebc:	00 20       	and	r0, r0
     ebe:	e9 f7       	brne	.-6      	; 0xeba <_ZN6myTime7getTimeEv+0xc6>
     ec0:	cf 01       	movw	r24, r30
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	84 1b       	sub	r24, r20
     ec6:	95 0b       	sbc	r25, r21
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	2a e3       	ldi	r18, 0x3A	; 58
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	fc 01       	movw	r30, r24
     ed2:	31 83       	std	Z+1, r19	; 0x01
     ed4:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
     eda:	4d 96       	adiw	r24, 0x1d	; 29
     edc:	9e 01       	movw	r18, r28
     ede:	29 5f       	subi	r18, 0xF9	; 249
     ee0:	3f 4f       	sbci	r19, 0xFF	; 255
     ee2:	b9 01       	movw	r22, r18
     ee4:	0e 94 90 1b 	call	0x3720	; 0x3720 <strcat>
	timeString[11] = '\0';
     ee8:	8a 85       	ldd	r24, Y+10	; 0x0a
     eea:	9b 85       	ldd	r25, Y+11	; 0x0b
     eec:	fc 01       	movw	r30, r24
     eee:	10 a6       	lds	r17, 0xb0
	return timeString;
     ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ef4:	4d 96       	adiw	r24, 0x1d	; 29
     ef6:	2b 96       	adiw	r28, 0x0b	; 11
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 10;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	2f 97       	sbiw	r28, 0x0f	; 15
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	8e 87       	std	Y+14, r24	; 0x0e
     f1e:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     f20:	f8 94       	cli
	if (gTime){
     f22:	8e 85       	ldd	r24, Y+14	; 0x0e
     f24:	88 23       	and	r24, r24
     f26:	09 f4       	brne	.+2      	; 0xf2a <_Z18getDateTime_eepromhh+0x22>
     f28:	4b c0       	rjmp	.+150    	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     f2a:	1a 82       	std	Y+2, r1	; 0x02
     f2c:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     f32:	2c c0       	rjmp	.+88     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <__eerd_byte_m644pa>
     f3c:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <__eerd_byte_m644pa>
     f46:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <__eerd_byte_m644pa>
     f50:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     f52:	8f 81       	ldd	r24, Y+7	; 0x07
     f54:	8c 33       	cpi	r24, 0x3C	; 60
     f56:	a8 f4       	brcc	.+42     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f58:	88 85       	ldd	r24, Y+8	; 0x08
     f5a:	8c 33       	cpi	r24, 0x3C	; 60
     f5c:	90 f4       	brcc	.+36     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f5e:	89 85       	ldd	r24, Y+9	; 0x09
     f60:	88 31       	cpi	r24, 0x18	; 24
     f62:	78 f4       	brcc	.+30     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	68 2f       	mov	r22, r24
     f68:	70 e0       	ldi	r23, 0x00	; 0
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	48 2f       	mov	r20, r24
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	8f 81       	ldd	r24, Y+7	; 0x07
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	80 e9       	ldi	r24, 0x90	; 144
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
     f7e:	1b 82       	std	Y+3, r1	; 0x03
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	9a 81       	ldd	r25, Y+2	; 0x02
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     f8c:	8b 81       	ldd	r24, Y+3	; 0x03
     f8e:	88 23       	and	r24, r24
     f90:	39 f0       	breq	.+14     	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	9a 81       	ldd	r25, Y+2	; 0x02
     f96:	83 30       	cpi	r24, 0x03	; 3
     f98:	91 05       	cpc	r25, r1
     f9a:	14 f4       	brge	.+4      	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <_Z18getDateTime_eepromhh+0x9a>
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	88 23       	and	r24, r24
     fa4:	39 f6       	brne	.-114    	; 0xf34 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     fa6:	8b 81       	ldd	r24, Y+3	; 0x03
     fa8:	88 23       	and	r24, r24
     faa:	51 f0       	breq	.+20     	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
     fac:	80 e9       	ldi	r24, 0x90	; 144
     fae:	91 e0       	ldi	r25, 0x01	; 1
     fb0:	61 e0       	ldi	r22, 0x01	; 1
     fb2:	70 e0       	ldi	r23, 0x00	; 0
     fb4:	41 e0       	ldi	r20, 0x01	; 1
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	21 e0       	ldi	r18, 0x01	; 1
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
     fc2:	88 23       	and	r24, r24
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <_Z18getDateTime_eepromhh+0xc0>
     fc6:	4e c0       	rjmp	.+156    	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     fc8:	1d 82       	std	Y+5, r1	; 0x05
     fca:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     fcc:	81 e0       	ldi	r24, 0x01	; 1
     fce:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     fd0:	2f c0       	rjmp	.+94     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     fd2:	84 e0       	ldi	r24, 0x04	; 4
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <__eerd_byte_m644pa>
     fda:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 f8 1b 	call	0x37f0	; 0x37f0 <__eerd_byte_m644pa>
     fe4:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     fe6:	85 e0       	ldi	r24, 0x05	; 5
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	0e 94 00 1c 	call	0x3800	; 0x3800 <__eerd_word_m644pa>
     fee:	9d 87       	std	Y+13, r25	; 0x0d
     ff0:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     ff2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff4:	8f 31       	cpi	r24, 0x1F	; 31
     ff6:	b8 f4       	brcc	.+46     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ff8:	8b 85       	ldd	r24, Y+11	; 0x0b
     ffa:	8d 30       	cpi	r24, 0x0D	; 13
     ffc:	a0 f4       	brcc	.+40     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ffe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1000:	9d 85       	ldd	r25, Y+13	; 0x0d
    1002:	27 e2       	ldi	r18, 0x27	; 39
    1004:	80 31       	cpi	r24, 0x10	; 16
    1006:	92 07       	cpc	r25, r18
    1008:	70 f4       	brcc	.+28     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
    100a:	8b 85       	ldd	r24, Y+11	; 0x0b
    100c:	68 2f       	mov	r22, r24
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	8a 85       	ldd	r24, Y+10	; 0x0a
    1012:	48 2f       	mov	r20, r24
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	2c 85       	ldd	r18, Y+12	; 0x0c
    1018:	3d 85       	ldd	r19, Y+13	; 0x0d
    101a:	80 e9       	ldi	r24, 0x90	; 144
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
    1022:	1e 82       	std	Y+6, r1	; 0x06
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
    1026:	8c 81       	ldd	r24, Y+4	; 0x04
    1028:	9d 81       	ldd	r25, Y+5	; 0x05
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	9d 83       	std	Y+5, r25	; 0x05
    102e:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
    1030:	8e 81       	ldd	r24, Y+6	; 0x06
    1032:	88 23       	and	r24, r24
    1034:	39 f0       	breq	.+14     	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	9d 81       	ldd	r25, Y+5	; 0x05
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	91 05       	cpc	r25, r1
    103e:	14 f4       	brge	.+4      	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <_Z18getDateTime_eepromhh+0x13e>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	88 23       	and	r24, r24
    1048:	21 f6       	brne	.-120    	; 0xfd2 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	88 23       	and	r24, r24
    104e:	51 f0       	breq	.+20     	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
    1050:	80 e9       	ldi	r24, 0x90	; 144
    1052:	91 e0       	ldi	r25, 0x01	; 1
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	70 e0       	ldi	r23, 0x00	; 0
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	21 ed       	ldi	r18, 0xD1	; 209
    105e:	37 e0       	ldi	r19, 0x07	; 7
    1060:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
    1064:	78 94       	sei
}
    1066:	2f 96       	adiw	r28, 0x0f	; 15
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	29 97       	sbiw	r28, 0x09	; 9
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	88 87       	std	Y+8, r24	; 0x08
    108e:	69 87       	std	Y+9, r22	; 0x09
	cli();
    1090:	f8 94       	cli
	if (sTime){
    1092:	88 85       	ldd	r24, Y+8	; 0x08
    1094:	88 23       	and	r24, r24
    1096:	f1 f0       	breq	.+60     	; 0x10d4 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
    1098:	80 e9       	ldi	r24, 0x90	; 144
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    10a0:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
    10a2:	80 e9       	ldi	r24, 0x90	; 144
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    10aa:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
    10ac:	80 e9       	ldi	r24, 0x90	; 144
    10ae:	91 e0       	ldi	r25, 0x01	; 1
    10b0:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    10b4:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	6b 81       	ldd	r22, Y+3	; 0x03
    10bc:	0e 94 06 1c 	call	0x380c	; 0x380c <__eewr_byte_m644pa>
		eeprom_write_byte(&eeMinute,tempMin);
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	6a 81       	ldd	r22, Y+2	; 0x02
    10c6:	0e 94 06 1c 	call	0x380c	; 0x380c <__eewr_byte_m644pa>
		eeprom_write_byte(&eeHour,tempHour);
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	69 81       	ldd	r22, Y+1	; 0x01
    10d0:	0e 94 06 1c 	call	0x380c	; 0x380c <__eewr_byte_m644pa>
	}
	if (sDate){
    10d4:	89 85       	ldd	r24, Y+9	; 0x09
    10d6:	88 23       	and	r24, r24
    10d8:	09 f1       	breq	.+66     	; 0x111c <__stack+0x1d>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
    10da:	80 e9       	ldi	r24, 0x90	; 144
    10dc:	91 e0       	ldi	r25, 0x01	; 1
    10de:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
    10e2:	9d 83       	std	Y+5, r25	; 0x05
    10e4:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
    10e6:	80 e9       	ldi	r24, 0x90	; 144
    10e8:	91 e0       	ldi	r25, 0x01	; 1
    10ea:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
    10ee:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
    10f0:	80 e9       	ldi	r24, 0x90	; 144
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
    10f8:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
    10fa:	85 e0       	ldi	r24, 0x05	; 5
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1100:	3d 81       	ldd	r19, Y+5	; 0x05
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 14 1c 	call	0x3828	; 0x3828 <__eewr_word_m644pa>
		eeprom_write_byte(&eeMonth,tempMonth);
    1108:	83 e0       	ldi	r24, 0x03	; 3
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	6e 81       	ldd	r22, Y+6	; 0x06
    110e:	0e 94 06 1c 	call	0x380c	; 0x380c <__eewr_byte_m644pa>
		eeprom_write_byte(&eeDay,tempDay);
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	6f 81       	ldd	r22, Y+7	; 0x07
    1118:	0e 94 06 1c 	call	0x380c	; 0x380c <__eewr_byte_m644pa>
	}
	sei();
    111c:	78 94       	sei
}
    111e:	29 96       	adiw	r28, 0x09	; 9
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	cd bf       	out	0x3d, r28	; 61
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	08 95       	ret

00001130 <_Z13PutUartChBonec>:
extern BOOL flagReceivingBone, flagFreshStart, restart, flagReceivingGAVR,flagWaitingForReceiveGAVR;
extern WORD globalADC, globalTemp;
extern myTime currentTime;

/**************************************************************************************************************/
void PutUartChBone(char ch){
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	0f 92       	push	r0
    1136:	cd b7       	in	r28, 0x3d	; 61
    1138:	de b7       	in	r29, 0x3e	; 62
    113a:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
    113c:	00 00       	nop
    113e:	80 ec       	ldi	r24, 0xC0	; 192
    1140:	90 e0       	ldi	r25, 0x00	; 0
    1142:	fc 01       	movw	r30, r24
    1144:	80 81       	ld	r24, Z
    1146:	88 2f       	mov	r24, r24
    1148:	90 e0       	ldi	r25, 0x00	; 0
    114a:	80 72       	andi	r24, 0x20	; 32
    114c:	90 70       	andi	r25, 0x00	; 0
    114e:	21 e0       	ldi	r18, 0x01	; 1
    1150:	00 97       	sbiw	r24, 0x00	; 0
    1152:	09 f0       	breq	.+2      	; 0x1156 <_Z13PutUartChBonec+0x26>
    1154:	20 e0       	ldi	r18, 0x00	; 0
    1156:	22 23       	and	r18, r18
    1158:	91 f7       	brne	.-28     	; 0x113e <_Z13PutUartChBonec+0xe>
	UDR0=ch;
    115a:	86 ec       	ldi	r24, 0xC6	; 198
    115c:	90 e0       	ldi	r25, 0x00	; 0
    115e:	29 81       	ldd	r18, Y+1	; 0x01
    1160:	fc 01       	movw	r30, r24
    1162:	20 83       	st	Z, r18
}
    1164:	0f 90       	pop	r0
    1166:	df 91       	pop	r29
    1168:	cf 91       	pop	r28
    116a:	08 95       	ret

0000116c <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
    116c:	cf 93       	push	r28
    116e:	df 93       	push	r29
    1170:	00 d0       	rcall	.+0      	; 0x1172 <_Z9PrintBonePc+0x6>
    1172:	0f 92       	push	r0
    1174:	cd b7       	in	r28, 0x3d	; 61
    1176:	de b7       	in	r29, 0x3e	; 62
    1178:	9b 83       	std	Y+3, r25	; 0x03
    117a:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    117c:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    117e:	0e c0       	rjmp	.+28     	; 0x119c <_Z9PrintBonePc+0x30>
		PutUartChBone(string[i++]);
    1180:	89 81       	ldd	r24, Y+1	; 0x01
    1182:	88 2f       	mov	r24, r24
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	2a 81       	ldd	r18, Y+2	; 0x02
    1188:	3b 81       	ldd	r19, Y+3	; 0x03
    118a:	82 0f       	add	r24, r18
    118c:	93 1f       	adc	r25, r19
    118e:	fc 01       	movw	r30, r24
    1190:	80 81       	ld	r24, Z
    1192:	99 81       	ldd	r25, Y+1	; 0x01
    1194:	9f 5f       	subi	r25, 0xFF	; 255
    1196:	99 83       	std	Y+1, r25	; 0x01
    1198:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z13PutUartChBonec>
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    119c:	89 81       	ldd	r24, Y+1	; 0x01
    119e:	88 2f       	mov	r24, r24
    11a0:	90 e0       	ldi	r25, 0x00	; 0
    11a2:	2a 81       	ldd	r18, Y+2	; 0x02
    11a4:	3b 81       	ldd	r19, Y+3	; 0x03
    11a6:	82 0f       	add	r24, r18
    11a8:	93 1f       	adc	r25, r19
    11aa:	fc 01       	movw	r30, r24
    11ac:	90 81       	ld	r25, Z
    11ae:	81 e0       	ldi	r24, 0x01	; 1
    11b0:	99 23       	and	r25, r25
    11b2:	09 f4       	brne	.+2      	; 0x11b6 <_Z9PrintBonePc+0x4a>
    11b4:	80 e0       	ldi	r24, 0x00	; 0
    11b6:	88 23       	and	r24, r24
    11b8:	19 f7       	brne	.-58     	; 0x1180 <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i++]);
	}
}
    11ba:	0f 90       	pop	r0
    11bc:	0f 90       	pop	r0
    11be:	0f 90       	pop	r0
    11c0:	df 91       	pop	r29
    11c2:	cf 91       	pop	r28
    11c4:	08 95       	ret

000011c6 <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    11c6:	cf 93       	push	r28
    11c8:	df 93       	push	r29
    11ca:	0f 92       	push	r0
    11cc:	cd b7       	in	r28, 0x3d	; 61
    11ce:	de b7       	in	r29, 0x3e	; 62
    11d0:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    11d2:	00 00       	nop
    11d4:	88 ec       	ldi	r24, 0xC8	; 200
    11d6:	90 e0       	ldi	r25, 0x00	; 0
    11d8:	fc 01       	movw	r30, r24
    11da:	80 81       	ld	r24, Z
    11dc:	88 2f       	mov	r24, r24
    11de:	90 e0       	ldi	r25, 0x00	; 0
    11e0:	80 72       	andi	r24, 0x20	; 32
    11e2:	90 70       	andi	r25, 0x00	; 0
    11e4:	21 e0       	ldi	r18, 0x01	; 1
    11e6:	00 97       	sbiw	r24, 0x00	; 0
    11e8:	09 f0       	breq	.+2      	; 0x11ec <_Z13PutUartChGAVRc+0x26>
    11ea:	20 e0       	ldi	r18, 0x00	; 0
    11ec:	22 23       	and	r18, r18
    11ee:	91 f7       	brne	.-28     	; 0x11d4 <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    11f0:	8e ec       	ldi	r24, 0xCE	; 206
    11f2:	90 e0       	ldi	r25, 0x00	; 0
    11f4:	29 81       	ldd	r18, Y+1	; 0x01
    11f6:	fc 01       	movw	r30, r24
    11f8:	20 83       	st	Z, r18
}
    11fa:	0f 90       	pop	r0
    11fc:	df 91       	pop	r29
    11fe:	cf 91       	pop	r28
    1200:	08 95       	ret

00001202 <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    1202:	cf 93       	push	r28
    1204:	df 93       	push	r29
    1206:	00 d0       	rcall	.+0      	; 0x1208 <_Z9PrintGAVRPc+0x6>
    1208:	0f 92       	push	r0
    120a:	cd b7       	in	r28, 0x3d	; 61
    120c:	de b7       	in	r29, 0x3e	; 62
    120e:	9b 83       	std	Y+3, r25	; 0x03
    1210:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    1212:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    1214:	0e c0       	rjmp	.+28     	; 0x1232 <_Z9PrintGAVRPc+0x30>
		PutUartChGAVR(string[i++]);
    1216:	89 81       	ldd	r24, Y+1	; 0x01
    1218:	88 2f       	mov	r24, r24
    121a:	90 e0       	ldi	r25, 0x00	; 0
    121c:	2a 81       	ldd	r18, Y+2	; 0x02
    121e:	3b 81       	ldd	r19, Y+3	; 0x03
    1220:	82 0f       	add	r24, r18
    1222:	93 1f       	adc	r25, r19
    1224:	fc 01       	movw	r30, r24
    1226:	80 81       	ld	r24, Z
    1228:	99 81       	ldd	r25, Y+1	; 0x01
    122a:	9f 5f       	subi	r25, 0xFF	; 255
    122c:	99 83       	std	Y+1, r25	; 0x01
    122e:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_Z13PutUartChGAVRc>
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    1232:	89 81       	ldd	r24, Y+1	; 0x01
    1234:	88 2f       	mov	r24, r24
    1236:	90 e0       	ldi	r25, 0x00	; 0
    1238:	2a 81       	ldd	r18, Y+2	; 0x02
    123a:	3b 81       	ldd	r19, Y+3	; 0x03
    123c:	82 0f       	add	r24, r18
    123e:	93 1f       	adc	r25, r19
    1240:	fc 01       	movw	r30, r24
    1242:	90 81       	ld	r25, Z
    1244:	81 e0       	ldi	r24, 0x01	; 1
    1246:	99 23       	and	r25, r25
    1248:	09 f4       	brne	.+2      	; 0x124c <_Z9PrintGAVRPc+0x4a>
    124a:	80 e0       	ldi	r24, 0x00	; 0
    124c:	88 23       	and	r24, r24
    124e:	19 f7       	brne	.-58     	; 0x1216 <_Z9PrintGAVRPc+0x14>
		PutUartChGAVR(string[i++]);
	}
}
    1250:	0f 90       	pop	r0
    1252:	0f 90       	pop	r0
    1254:	0f 90       	pop	r0
    1256:	df 91       	pop	r29
    1258:	cf 91       	pop	r28
    125a:	08 95       	ret

0000125c <_Z8sendGAVRv>:
/*************************************************************************************************************/
void sendGAVR(){
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	cd b7       	in	r28, 0x3d	; 61
    1262:	de b7       	in	r29, 0x3e	; 62
    1264:	ca 55       	subi	r28, 0x5A	; 90
    1266:	d0 40       	sbci	r29, 0x00	; 0
    1268:	0f b6       	in	r0, 0x3f	; 63
    126a:	f8 94       	cli
    126c:	de bf       	out	0x3e, r29	; 62
    126e:	0f be       	out	0x3f, r0	; 63
    1270:	cd bf       	out	0x3d, r28	; 61
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    1272:	81 e0       	ldi	r24, 0x01	; 1
    1274:	8a 87       	std	Y+10, r24	; 0x0a
	char recChar, recString[40], sentString[40];
	unsigned int strLoc=0;
    1276:	1a 82       	std	Y+2, r1	; 0x02
    1278:	19 82       	std	Y+1, r1	; 0x01
	
	//Used for shutdown connection logic if there was a timeout in sending or receiving
	BOOL flagTimeout=fFalse;
    127a:	1b 82       	std	Y+3, r1	; 0x03
	
	//Transmission protocol
	while (flagSendingGAVR && !flagTimeout){
    127c:	fb c1       	rjmp	.+1014   	; 0x1674 <_Z8sendGAVRv+0x418>
		/* State 5: Successful transmission and reception. Kill sending flag, reset state, exit.					 */
		/* State 6: ACKBAD received, check to see if we have an invalid date/time in our clock or it was just noisy  */
		/*			and had error in transmission/reception. If valid, go to waiting state. Else exit and set flag.	 */
		/* State 7: Got the wrong ack for something, set a flag to let the WAVR do its thing then try again.		 */
		/*************************************************************************************************************/
		switch (state){
    127e:	80 91 d5 01 	lds	r24, 0x01D5
    1282:	90 91 d6 01 	lds	r25, 0x01D6
    1286:	83 30       	cpi	r24, 0x03	; 3
    1288:	91 05       	cpc	r25, r1
    128a:	09 f4       	brne	.+2      	; 0x128e <_Z8sendGAVRv+0x32>
    128c:	1d c1       	rjmp	.+570    	; 0x14c8 <_Z8sendGAVRv+0x26c>
    128e:	84 30       	cpi	r24, 0x04	; 4
    1290:	91 05       	cpc	r25, r1
    1292:	48 f4       	brcc	.+18     	; 0x12a6 <_Z8sendGAVRv+0x4a>
    1294:	81 30       	cpi	r24, 0x01	; 1
    1296:	91 05       	cpc	r25, r1
    1298:	09 f4       	brne	.+2      	; 0x129c <_Z8sendGAVRv+0x40>
    129a:	97 c0       	rjmp	.+302    	; 0x13ca <_Z8sendGAVRv+0x16e>
    129c:	82 30       	cpi	r24, 0x02	; 2
    129e:	91 05       	cpc	r25, r1
    12a0:	08 f0       	brcs	.+2      	; 0x12a4 <_Z8sendGAVRv+0x48>
    12a2:	a1 c0       	rjmp	.+322    	; 0x13e6 <_Z8sendGAVRv+0x18a>
    12a4:	11 c0       	rjmp	.+34     	; 0x12c8 <_Z8sendGAVRv+0x6c>
    12a6:	85 30       	cpi	r24, 0x05	; 5
    12a8:	91 05       	cpc	r25, r1
    12aa:	09 f4       	brne	.+2      	; 0x12ae <_Z8sendGAVRv+0x52>
    12ac:	ac c1       	rjmp	.+856    	; 0x1606 <_Z8sendGAVRv+0x3aa>
    12ae:	85 30       	cpi	r24, 0x05	; 5
    12b0:	91 05       	cpc	r25, r1
    12b2:	08 f4       	brcc	.+2      	; 0x12b6 <_Z8sendGAVRv+0x5a>
    12b4:	9d c1       	rjmp	.+826    	; 0x15f0 <_Z8sendGAVRv+0x394>
    12b6:	86 30       	cpi	r24, 0x06	; 6
    12b8:	91 05       	cpc	r25, r1
    12ba:	09 f4       	brne	.+2      	; 0x12be <_Z8sendGAVRv+0x62>
    12bc:	ae c1       	rjmp	.+860    	; 0x161a <_Z8sendGAVRv+0x3be>
    12be:	87 30       	cpi	r24, 0x07	; 7
    12c0:	91 05       	cpc	r25, r1
    12c2:	09 f4       	brne	.+2      	; 0x12c6 <_Z8sendGAVRv+0x6a>
    12c4:	c3 c1       	rjmp	.+902    	; 0x164c <_Z8sendGAVRv+0x3f0>
    12c6:	cd c1       	rjmp	.+922    	; 0x1662 <_Z8sendGAVRv+0x406>
			case 0: {
				//Raise interrupts to GAVR for three ish clock cycles.
				prtGAVRINT |= (1 << bnGAVRINT);
    12c8:	85 e2       	ldi	r24, 0x25	; 37
    12ca:	90 e0       	ldi	r25, 0x00	; 0
    12cc:	25 e2       	ldi	r18, 0x25	; 37
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	f9 01       	movw	r30, r18
    12d2:	20 81       	ld	r18, Z
    12d4:	28 60       	ori	r18, 0x08	; 8
    12d6:	fc 01       	movw	r30, r24
    12d8:	20 83       	st	Z, r18
				for (int i=0; i<2; i++){asm volatile("nop");}
    12da:	1d 82       	std	Y+5, r1	; 0x05
    12dc:	1c 82       	std	Y+4, r1	; 0x04
    12de:	06 c0       	rjmp	.+12     	; 0x12ec <_Z8sendGAVRv+0x90>
    12e0:	00 00       	nop
    12e2:	8c 81       	ldd	r24, Y+4	; 0x04
    12e4:	9d 81       	ldd	r25, Y+5	; 0x05
    12e6:	01 96       	adiw	r24, 0x01	; 1
    12e8:	9d 83       	std	Y+5, r25	; 0x05
    12ea:	8c 83       	std	Y+4, r24	; 0x04
    12ec:	21 e0       	ldi	r18, 0x01	; 1
    12ee:	8c 81       	ldd	r24, Y+4	; 0x04
    12f0:	9d 81       	ldd	r25, Y+5	; 0x05
    12f2:	82 30       	cpi	r24, 0x02	; 2
    12f4:	91 05       	cpc	r25, r1
    12f6:	0c f0       	brlt	.+2      	; 0x12fa <_Z8sendGAVRv+0x9e>
    12f8:	20 e0       	ldi	r18, 0x00	; 0
    12fa:	22 23       	and	r18, r18
    12fc:	89 f7       	brne	.-30     	; 0x12e0 <_Z8sendGAVRv+0x84>
				prtGAVRINT &= ~(1 << bnGAVRINT);
    12fe:	85 e2       	ldi	r24, 0x25	; 37
    1300:	90 e0       	ldi	r25, 0x00	; 0
    1302:	25 e2       	ldi	r18, 0x25	; 37
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	f9 01       	movw	r30, r18
    1308:	20 81       	ld	r18, Z
    130a:	27 7f       	andi	r18, 0xF7	; 247
    130c:	fc 01       	movw	r30, r24
    130e:	20 83       	st	Z, r18
				state=1;
    1310:	81 e0       	ldi	r24, 0x01	; 1
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	90 93 d6 01 	sts	0x01D6, r25
    1318:	80 93 d5 01 	sts	0x01D5, r24
				break;
    131c:	ab c1       	rjmp	.+854    	; 0x1674 <_Z8sendGAVRv+0x418>
			}//end case 0
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
    131e:	00 00       	nop
    1320:	88 ec       	ldi	r24, 0xC8	; 200
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	fc 01       	movw	r30, r24
    1326:	80 81       	ld	r24, Z
    1328:	88 23       	and	r24, r24
    132a:	34 f0       	brlt	.+12     	; 0x1338 <_Z8sendGAVRv+0xdc>
    132c:	80 91 be 01 	lds	r24, 0x01BE
    1330:	88 23       	and	r24, r24
    1332:	11 f0       	breq	.+4      	; 0x1338 <_Z8sendGAVRv+0xdc>
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	01 c0       	rjmp	.+2      	; 0x133a <_Z8sendGAVRv+0xde>
    1338:	80 e0       	ldi	r24, 0x00	; 0
    133a:	88 23       	and	r24, r24
    133c:	89 f7       	brne	.-30     	; 0x1320 <_Z8sendGAVRv+0xc4>
					if (!flagSendingGAVR){state=0; flagTimeout=fTrue; break;}		//if timeout is why we broke, just exit
    133e:	80 91 be 01 	lds	r24, 0x01BE
    1342:	88 23       	and	r24, r24
    1344:	41 f4       	brne	.+16     	; 0x1356 <_Z8sendGAVRv+0xfa>
    1346:	10 92 d6 01 	sts	0x01D6, r1
    134a:	10 92 d5 01 	sts	0x01D5, r1
    134e:	81 e0       	ldi	r24, 0x01	; 1
    1350:	8b 83       	std	Y+3, r24	; 0x03
    1352:	00 00       	nop
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    1354:	8f c1       	rjmp	.+798    	; 0x1674 <_Z8sendGAVRv+0x418>
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
					if (!flagSendingGAVR){state=0; flagTimeout=fTrue; break;}		//if timeout is why we broke, just exit
					recChar=UDR1;
    1356:	8e ec       	ldi	r24, 0xCE	; 206
    1358:	90 e0       	ldi	r25, 0x00	; 0
    135a:	fc 01       	movw	r30, r24
    135c:	80 81       	ld	r24, Z
    135e:	88 87       	std	Y+8, r24	; 0x08
					recString[strLoc++]=recChar;
    1360:	9e 01       	movw	r18, r28
    1362:	2d 5c       	subi	r18, 0xCD	; 205
    1364:	3f 4f       	sbci	r19, 0xFF	; 255
    1366:	89 81       	ldd	r24, Y+1	; 0x01
    1368:	9a 81       	ldd	r25, Y+2	; 0x02
    136a:	82 0f       	add	r24, r18
    136c:	93 1f       	adc	r25, r19
    136e:	28 85       	ldd	r18, Y+8	; 0x08
    1370:	fc 01       	movw	r30, r24
    1372:	20 83       	st	Z, r18
    1374:	89 81       	ldd	r24, Y+1	; 0x01
    1376:	9a 81       	ldd	r25, Y+2	; 0x02
    1378:	01 96       	adiw	r24, 0x01	; 1
    137a:	9a 83       	std	Y+2, r25	; 0x02
    137c:	89 83       	std	Y+1, r24	; 0x01
					if (recChar=='.'){recString[strLoc++]='\0'; state=2;}
    137e:	88 85       	ldd	r24, Y+8	; 0x08
    1380:	8e 32       	cpi	r24, 0x2E	; 46
    1382:	a9 f4       	brne	.+42     	; 0x13ae <_Z8sendGAVRv+0x152>
    1384:	9e 01       	movw	r18, r28
    1386:	2d 5c       	subi	r18, 0xCD	; 205
    1388:	3f 4f       	sbci	r19, 0xFF	; 255
    138a:	89 81       	ldd	r24, Y+1	; 0x01
    138c:	9a 81       	ldd	r25, Y+2	; 0x02
    138e:	82 0f       	add	r24, r18
    1390:	93 1f       	adc	r25, r19
    1392:	fc 01       	movw	r30, r24
    1394:	10 82       	st	Z, r1
    1396:	89 81       	ldd	r24, Y+1	; 0x01
    1398:	9a 81       	ldd	r25, Y+2	; 0x02
    139a:	01 96       	adiw	r24, 0x01	; 1
    139c:	9a 83       	std	Y+2, r25	; 0x02
    139e:	89 83       	std	Y+1, r24	; 0x01
    13a0:	82 e0       	ldi	r24, 0x02	; 2
    13a2:	90 e0       	ldi	r25, 0x00	; 0
    13a4:	90 93 d6 01 	sts	0x01D6, r25
    13a8:	80 93 d5 01 	sts	0x01D5, r24
    13ac:	0e c0       	rjmp	.+28     	; 0x13ca <_Z8sendGAVRv+0x16e>
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
    13ae:	89 81       	ldd	r24, Y+1	; 0x01
    13b0:	9a 81       	ldd	r25, Y+2	; 0x02
    13b2:	87 32       	cpi	r24, 0x27	; 39
    13b4:	91 05       	cpc	r25, r1
    13b6:	48 f0       	brcs	.+18     	; 0x13ca <_Z8sendGAVRv+0x16e>
    13b8:	1a 82       	std	Y+2, r1	; 0x02
    13ba:	19 82       	std	Y+1, r1	; 0x01
    13bc:	1a 86       	std	Y+10, r1	; 0x0a
    13be:	87 e0       	ldi	r24, 0x07	; 7
    13c0:	90 e0       	ldi	r25, 0x00	; 0
    13c2:	90 93 d6 01 	sts	0x01D6, r25
    13c6:	80 93 d5 01 	sts	0x01D5, r24
				state=1;
				break;
			}//end case 0
			case 1: {
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    13ca:	8a 85       	ldd	r24, Y+10	; 0x0a
    13cc:	88 23       	and	r24, r24
    13ce:	31 f0       	breq	.+12     	; 0x13dc <_Z8sendGAVRv+0x180>
    13d0:	80 91 be 01 	lds	r24, 0x01BE
    13d4:	88 23       	and	r24, r24
    13d6:	11 f0       	breq	.+4      	; 0x13dc <_Z8sendGAVRv+0x180>
    13d8:	81 e0       	ldi	r24, 0x01	; 1
    13da:	01 c0       	rjmp	.+2      	; 0x13de <_Z8sendGAVRv+0x182>
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	88 23       	and	r24, r24
    13e0:	09 f0       	breq	.+2      	; 0x13e4 <_Z8sendGAVRv+0x188>
    13e2:	9d cf       	rjmp	.-198    	; 0x131e <_Z8sendGAVRv+0xc2>
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    13e4:	47 c1       	rjmp	.+654    	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
    13e6:	ce 01       	movw	r24, r28
    13e8:	c3 96       	adiw	r24, 0x33	; 51
    13ea:	20 e0       	ldi	r18, 0x00	; 0
    13ec:	31 e0       	ldi	r19, 0x01	; 1
    13ee:	b9 01       	movw	r22, r18
    13f0:	45 e0       	ldi	r20, 0x05	; 5
    13f2:	50 e0       	ldi	r21, 0x00	; 0
    13f4:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    13f8:	00 97       	sbiw	r24, 0x00	; 0
    13fa:	39 f4       	brne	.+14     	; 0x140a <_Z8sendGAVRv+0x1ae>
    13fc:	83 e0       	ldi	r24, 0x03	; 3
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	90 93 d6 01 	sts	0x01D6, r25
    1404:	80 93 d5 01 	sts	0x01D5, r24
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1408:	35 c1       	rjmp	.+618    	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
    140a:	ce 01       	movw	r24, r28
    140c:	c3 96       	adiw	r24, 0x33	; 51
    140e:	26 e0       	ldi	r18, 0x06	; 6
    1410:	31 e0       	ldi	r19, 0x01	; 1
    1412:	b9 01       	movw	r22, r18
    1414:	46 e0       	ldi	r20, 0x06	; 6
    1416:	50 e0       	ldi	r21, 0x00	; 0
    1418:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    141c:	00 97       	sbiw	r24, 0x00	; 0
    141e:	39 f4       	brne	.+14     	; 0x142e <_Z8sendGAVRv+0x1d2>
    1420:	84 e0       	ldi	r24, 0x04	; 4
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	90 93 d6 01 	sts	0x01D6, r25
    1428:	80 93 d5 01 	sts	0x01D5, r24
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    142c:	23 c1       	rjmp	.+582    	; 0x1674 <_Z8sendGAVRv+0x418>
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
    142e:	ce 01       	movw	r24, r28
    1430:	c3 96       	adiw	r24, 0x33	; 51
    1432:	2d e0       	ldi	r18, 0x0D	; 13
    1434:	31 e0       	ldi	r19, 0x01	; 1
    1436:	b9 01       	movw	r22, r18
    1438:	47 e0       	ldi	r20, 0x07	; 7
    143a:	50 e0       	ldi	r21, 0x00	; 0
    143c:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    1440:	00 97       	sbiw	r24, 0x00	; 0
    1442:	39 f4       	brne	.+14     	; 0x1452 <_Z8sendGAVRv+0x1f6>
    1444:	86 e0       	ldi	r24, 0x06	; 6
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	90 93 d6 01 	sts	0x01D6, r25
    144c:	80 93 d5 01 	sts	0x01D5, r24
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
				else{state=7;} //invalid ack. ACKERROR goes here.
				break;
    1450:	11 c1       	rjmp	.+546    	; 0x1674 <_Z8sendGAVRv+0x418>
			case 2: {
				if (!strncmp(recString,"ACKW.",5)){state=3;}
				else if (!strncmp(recString,"ACKGB.",6)){state=4;}
				else if (!strncmp(recString,"ACKBAD.",7)){state=6;}
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){state=5;}		//they match, successful send.
    1452:	80 91 bd 01 	lds	r24, 0x01BD
    1456:	88 23       	and	r24, r24
    1458:	89 f0       	breq	.+34     	; 0x147c <_Z8sendGAVRv+0x220>
    145a:	ce 01       	movw	r24, r28
    145c:	c3 96       	adiw	r24, 0x33	; 51
    145e:	9e 01       	movw	r18, r28
    1460:	25 5f       	subi	r18, 0xF5	; 245
    1462:	3f 4f       	sbci	r19, 0xFF	; 255
    1464:	b9 01       	movw	r22, r18
    1466:	0e 94 9b 1b 	call	0x3736	; 0x3736 <strcmp>
    146a:	00 97       	sbiw	r24, 0x00	; 0
    146c:	39 f4       	brne	.+14     	; 0x147c <_Z8sendGAVRv+0x220>
    146e:	85 e0       	ldi	r24, 0x05	; 5
    1470:	90 e0       	ldi	r25, 0x00	; 0
    1472:	90 93 d6 01 	sts	0x01D6, r25
    1476:	80 93 d5 01 	sts	0x01D5, r24
    147a:	25 c0       	rjmp	.+74     	; 0x14c6 <_Z8sendGAVRv+0x26a>
				else if (flagUpdateGAVRClock && strcmp(recString,sentString) && strcmp(recString,"ACKBAD.")){state=7;}	//string isnt the same as ACKBAD or what we sent.
    147c:	80 91 bd 01 	lds	r24, 0x01BD
    1480:	88 23       	and	r24, r24
    1482:	d1 f0       	breq	.+52     	; 0x14b8 <_Z8sendGAVRv+0x25c>
    1484:	ce 01       	movw	r24, r28
    1486:	c3 96       	adiw	r24, 0x33	; 51
    1488:	9e 01       	movw	r18, r28
    148a:	25 5f       	subi	r18, 0xF5	; 245
    148c:	3f 4f       	sbci	r19, 0xFF	; 255
    148e:	b9 01       	movw	r22, r18
    1490:	0e 94 9b 1b 	call	0x3736	; 0x3736 <strcmp>
    1494:	00 97       	sbiw	r24, 0x00	; 0
    1496:	81 f0       	breq	.+32     	; 0x14b8 <_Z8sendGAVRv+0x25c>
    1498:	ce 01       	movw	r24, r28
    149a:	c3 96       	adiw	r24, 0x33	; 51
    149c:	2d e0       	ldi	r18, 0x0D	; 13
    149e:	31 e0       	ldi	r19, 0x01	; 1
    14a0:	b9 01       	movw	r22, r18
    14a2:	0e 94 9b 1b 	call	0x3736	; 0x3736 <strcmp>
    14a6:	00 97       	sbiw	r24, 0x00	; 0
    14a8:	39 f0       	breq	.+14     	; 0x14b8 <_Z8sendGAVRv+0x25c>
    14aa:	87 e0       	ldi	r24, 0x07	; 7
    14ac:	90 e0       	ldi	r25, 0x00	; 0
    14ae:	90 93 d6 01 	sts	0x01D6, r25
    14b2:	80 93 d5 01 	sts	0x01D5, r24
    14b6:	07 c0       	rjmp	.+14     	; 0x14c6 <_Z8sendGAVRv+0x26a>
				else{state=7;} //invalid ack. ACKERROR goes here.
    14b8:	87 e0       	ldi	r24, 0x07	; 7
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	90 93 d6 01 	sts	0x01D6, r25
    14c0:	80 93 d5 01 	sts	0x01D5, r24
				break;
    14c4:	d7 c0       	rjmp	.+430    	; 0x1674 <_Z8sendGAVRv+0x418>
    14c6:	d6 c0       	rjmp	.+428    	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end case 2
			case 3:{
				if (flagUserClock && !flagUpdateGAVRClock){
    14c8:	80 91 bf 01 	lds	r24, 0x01BF
    14cc:	88 23       	and	r24, r24
    14ce:	61 f0       	breq	.+24     	; 0x14e8 <_Z8sendGAVRv+0x28c>
    14d0:	80 91 bd 01 	lds	r24, 0x01BD
    14d4:	88 23       	and	r24, r24
    14d6:	41 f4       	brne	.+16     	; 0x14e8 <_Z8sendGAVRv+0x28c>
					PrintGAVR("SYNGB.");
    14d8:	85 e1       	ldi	r24, 0x15	; 21
    14da:	91 e0       	ldi	r25, 0x01	; 1
    14dc:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
					flagWaitingForReceiveGAVR=fTrue;				
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	80 93 bc 01 	sts	0x01BC, r24
    14e6:	5d c0       	rjmp	.+186    	; 0x15a2 <_Z8sendGAVRv+0x346>
				//If we are updating the gavr, send the time and date together regardless. preface with SYN
				} else if (flagUpdateGAVRClock && !flagUserClock){
    14e8:	80 91 bd 01 	lds	r24, 0x01BD
    14ec:	88 23       	and	r24, r24
    14ee:	09 f4       	brne	.+2      	; 0x14f2 <_Z8sendGAVRv+0x296>
    14f0:	58 c0       	rjmp	.+176    	; 0x15a2 <_Z8sendGAVRv+0x346>
    14f2:	80 91 bf 01 	lds	r24, 0x01BF
    14f6:	88 23       	and	r24, r24
    14f8:	09 f0       	breq	.+2      	; 0x14fc <_Z8sendGAVRv+0x2a0>
    14fa:	53 c0       	rjmp	.+166    	; 0x15a2 <_Z8sendGAVRv+0x346>
					strcpy(sentString,"SYN");			//this is a syn, not ack to save logic in GAVR code. Can change if we want.
    14fc:	9e 01       	movw	r18, r28
    14fe:	25 5f       	subi	r18, 0xF5	; 245
    1500:	3f 4f       	sbci	r19, 0xFF	; 255
    1502:	83 e5       	ldi	r24, 0x53	; 83
    1504:	99 e5       	ldi	r25, 0x59	; 89
    1506:	ae e4       	ldi	r26, 0x4E	; 78
    1508:	b0 e0       	ldi	r27, 0x00	; 0
    150a:	f9 01       	movw	r30, r18
    150c:	80 83       	st	Z, r24
    150e:	91 83       	std	Z+1, r25	; 0x01
    1510:	a2 83       	std	Z+2, r26	; 0x02
    1512:	b3 83       	std	Z+3, r27	; 0x03
					strcat(sentString,currentTime.getTime());
    1514:	80 e9       	ldi	r24, 0x90	; 144
    1516:	91 e0       	ldi	r25, 0x01	; 1
    1518:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    151c:	9c 01       	movw	r18, r24
    151e:	ce 01       	movw	r24, r28
    1520:	0b 96       	adiw	r24, 0x0b	; 11
    1522:	b9 01       	movw	r22, r18
    1524:	0e 94 90 1b 	call	0x3720	; 0x3720 <strcat>
					strcat(sentString,"/");	//add delimiter.
    1528:	ce 01       	movw	r24, r28
    152a:	0b 96       	adiw	r24, 0x0b	; 11
    152c:	9c 01       	movw	r18, r24
    152e:	f9 01       	movw	r30, r18
    1530:	01 90       	ld	r0, Z+
    1532:	00 20       	and	r0, r0
    1534:	e9 f7       	brne	.-6      	; 0x1530 <_Z8sendGAVRv+0x2d4>
    1536:	cf 01       	movw	r24, r30
    1538:	01 97       	sbiw	r24, 0x01	; 1
    153a:	82 1b       	sub	r24, r18
    153c:	93 0b       	sbc	r25, r19
    153e:	9e 01       	movw	r18, r28
    1540:	25 5f       	subi	r18, 0xF5	; 245
    1542:	3f 4f       	sbci	r19, 0xFF	; 255
    1544:	82 0f       	add	r24, r18
    1546:	93 1f       	adc	r25, r19
    1548:	2f e2       	ldi	r18, 0x2F	; 47
    154a:	30 e0       	ldi	r19, 0x00	; 0
    154c:	fc 01       	movw	r30, r24
    154e:	31 83       	std	Z+1, r19	; 0x01
    1550:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getDate());
    1552:	80 e9       	ldi	r24, 0x90	; 144
    1554:	91 e0       	ldi	r25, 0x01	; 1
    1556:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    155a:	9c 01       	movw	r18, r24
    155c:	ce 01       	movw	r24, r28
    155e:	0b 96       	adiw	r24, 0x0b	; 11
    1560:	b9 01       	movw	r22, r18
    1562:	0e 94 90 1b 	call	0x3720	; 0x3720 <strcat>
					strcat(sentString,".\0");
    1566:	ce 01       	movw	r24, r28
    1568:	0b 96       	adiw	r24, 0x0b	; 11
    156a:	9c 01       	movw	r18, r24
    156c:	f9 01       	movw	r30, r18
    156e:	01 90       	ld	r0, Z+
    1570:	00 20       	and	r0, r0
    1572:	e9 f7       	brne	.-6      	; 0x156e <_Z8sendGAVRv+0x312>
    1574:	cf 01       	movw	r24, r30
    1576:	01 97       	sbiw	r24, 0x01	; 1
    1578:	82 1b       	sub	r24, r18
    157a:	93 0b       	sbc	r25, r19
    157c:	9e 01       	movw	r18, r28
    157e:	25 5f       	subi	r18, 0xF5	; 245
    1580:	3f 4f       	sbci	r19, 0xFF	; 255
    1582:	82 0f       	add	r24, r18
    1584:	93 1f       	adc	r25, r19
    1586:	2e e2       	ldi	r18, 0x2E	; 46
    1588:	30 e0       	ldi	r19, 0x00	; 0
    158a:	fc 01       	movw	r30, r24
    158c:	31 83       	std	Z+1, r19	; 0x01
    158e:	20 83       	st	Z, r18
					PrintGAVR("SYN");
    1590:	8c e1       	ldi	r24, 0x1C	; 28
    1592:	91 e0       	ldi	r25, 0x01	; 1
    1594:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
    1598:	80 e0       	ldi	r24, 0x00	; 0
    159a:	61 e0       	ldi	r22, 0x01	; 1
    159c:	41 e0       	ldi	r20, 0x01	; 1
    159e:	0e 94 c2 12 	call	0x2584	; 0x2584 <_Z13printTimeDatehhh>
				} else;	//end if-else (what we are doing).
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){
    15a2:	1f 82       	std	Y+7, r1	; 0x07
    15a4:	1e 82       	std	Y+6, r1	; 0x06
    15a6:	0e c0       	rjmp	.+28     	; 0x15c4 <_Z8sendGAVRv+0x368>
					recString[i]=NULL;
    15a8:	9e 01       	movw	r18, r28
    15aa:	2d 5c       	subi	r18, 0xCD	; 205
    15ac:	3f 4f       	sbci	r19, 0xFF	; 255
    15ae:	8e 81       	ldd	r24, Y+6	; 0x06
    15b0:	9f 81       	ldd	r25, Y+7	; 0x07
    15b2:	82 0f       	add	r24, r18
    15b4:	93 1f       	adc	r25, r19
    15b6:	fc 01       	movw	r30, r24
    15b8:	10 82       	st	Z, r1
					PrintGAVR("SYN");
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
				} else;	//end if-else (what we are doing).
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){
    15ba:	8e 81       	ldd	r24, Y+6	; 0x06
    15bc:	9f 81       	ldd	r25, Y+7	; 0x07
    15be:	01 96       	adiw	r24, 0x01	; 1
    15c0:	9f 83       	std	Y+7, r25	; 0x07
    15c2:	8e 83       	std	Y+6, r24	; 0x06
    15c4:	2e 81       	ldd	r18, Y+6	; 0x06
    15c6:	3f 81       	ldd	r19, Y+7	; 0x07
    15c8:	41 e0       	ldi	r20, 0x01	; 1
    15ca:	89 81       	ldd	r24, Y+1	; 0x01
    15cc:	9a 81       	ldd	r25, Y+2	; 0x02
    15ce:	28 17       	cp	r18, r24
    15d0:	39 07       	cpc	r19, r25
    15d2:	08 f0       	brcs	.+2      	; 0x15d6 <_Z8sendGAVRv+0x37a>
    15d4:	40 e0       	ldi	r20, 0x00	; 0
    15d6:	44 23       	and	r20, r20
    15d8:	39 f7       	brne	.-50     	; 0x15a8 <_Z8sendGAVRv+0x34c>
					recString[i]=NULL;
				}
				//Reset the carriage feature, string location and go back to the receiving state.
				noCarriage=fTrue;
    15da:	81 e0       	ldi	r24, 0x01	; 1
    15dc:	8a 87       	std	Y+10, r24	; 0x0a
				strLoc=0;
    15de:	1a 82       	std	Y+2, r1	; 0x02
    15e0:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    15e2:	81 e0       	ldi	r24, 0x01	; 1
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	90 93 d6 01 	sts	0x01D6, r25
    15ea:	80 93 d5 01 	sts	0x01D5, r24
				break;
    15ee:	42 c0       	rjmp	.+132    	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end case 3
			case 4:{
				//Successful communication with just flags
				PrintGAVR("SYNDONE.");	//end the communication
    15f0:	80 e2       	ldi	r24, 0x20	; 32
    15f2:	91 e0       	ldi	r25, 0x01	; 1
    15f4:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
				state=5;
    15f8:	85 e0       	ldi	r24, 0x05	; 5
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	90 93 d6 01 	sts	0x01D6, r25
    1600:	80 93 d5 01 	sts	0x01D5, r24
				break;				
    1604:	37 c0       	rjmp	.+110    	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end case 4	
			case 5:{
				//Successful communications overall
				flagSendingGAVR=fFalse;
    1606:	10 92 be 01 	sts	0x01BE, r1
				flagWaitingToSendGAVR=fFalse;
    160a:	10 92 c1 01 	sts	0x01C1, r1
				flagTimeout=fFalse;
    160e:	1b 82       	std	Y+3, r1	; 0x03
				state=0;
    1610:	10 92 d6 01 	sts	0x01D6, r1
    1614:	10 92 d5 01 	sts	0x01D5, r1
				break;
    1618:	2d c0       	rjmp	.+90     	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
    161a:	80 e9       	ldi	r24, 0x90	; 144
    161c:	91 e0       	ldi	r25, 0x01	; 1
    161e:	0e 94 bc 06 	call	0xd78	; 0xd78 <_ZN6myTime13checkValidityEv>
    1622:	89 87       	std	Y+9, r24	; 0x09
				if (dateOK){state=7;}
    1624:	89 85       	ldd	r24, Y+9	; 0x09
    1626:	88 23       	and	r24, r24
    1628:	39 f0       	breq	.+14     	; 0x1638 <_Z8sendGAVRv+0x3dc>
    162a:	87 e0       	ldi	r24, 0x07	; 7
    162c:	90 e0       	ldi	r25, 0x00	; 0
    162e:	90 93 d6 01 	sts	0x01D6, r25
    1632:	80 93 d5 01 	sts	0x01D5, r24
				else {state=5; flagInvalidDateTime=fTrue;}
				break;
    1636:	1e c0       	rjmp	.+60     	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
				if (dateOK){state=7;}
				else {state=5; flagInvalidDateTime=fTrue;}
    1638:	85 e0       	ldi	r24, 0x05	; 5
    163a:	90 e0       	ldi	r25, 0x00	; 0
    163c:	90 93 d6 01 	sts	0x01D6, r25
    1640:	80 93 d5 01 	sts	0x01D5, r24
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	80 93 c0 01 	sts	0x01C0, r24
				break;
    164a:	14 c0       	rjmp	.+40     	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end case 6
			case 7:{
				//Got the wrong ACK back, or invalid ACK. Wait for next cycle then resend. Keep all the flags the same
				flagWaitingToSendGAVR=fTrue;
    164c:	81 e0       	ldi	r24, 0x01	; 1
    164e:	80 93 c1 01 	sts	0x01C1, r24
				flagSendingGAVR=fFalse;
    1652:	10 92 be 01 	sts	0x01BE, r1
				flagTimeout=fFalse;
    1656:	1b 82       	std	Y+3, r1	; 0x03
				state=0;
    1658:	10 92 d6 01 	sts	0x01D6, r1
    165c:	10 92 d5 01 	sts	0x01D5, r1
				break;
    1660:	09 c0       	rjmp	.+18     	; 0x1674 <_Z8sendGAVRv+0x418>
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; flagTimeout=fFalse;break;}
    1662:	10 92 d6 01 	sts	0x01D6, r1
    1666:	10 92 d5 01 	sts	0x01D5, r1
    166a:	10 92 be 01 	sts	0x01BE, r1
    166e:	1a 86       	std	Y+10, r1	; 0x0a
    1670:	1b 82       	std	Y+3, r1	; 0x03
    1672:	00 00       	nop
	
	//Used for shutdown connection logic if there was a timeout in sending or receiving
	BOOL flagTimeout=fFalse;
	
	//Transmission protocol
	while (flagSendingGAVR && !flagTimeout){
    1674:	80 91 be 01 	lds	r24, 0x01BE
    1678:	88 23       	and	r24, r24
    167a:	29 f0       	breq	.+10     	; 0x1686 <_Z8sendGAVRv+0x42a>
    167c:	8b 81       	ldd	r24, Y+3	; 0x03
    167e:	88 23       	and	r24, r24
    1680:	11 f4       	brne	.+4      	; 0x1686 <_Z8sendGAVRv+0x42a>
    1682:	81 e0       	ldi	r24, 0x01	; 1
    1684:	01 c0       	rjmp	.+2      	; 0x1688 <_Z8sendGAVRv+0x42c>
    1686:	80 e0       	ldi	r24, 0x00	; 0
    1688:	88 23       	and	r24, r24
    168a:	09 f0       	breq	.+2      	; 0x168e <_Z8sendGAVRv+0x432>
    168c:	f8 cd       	rjmp	.-1040   	; 0x127e <_Z8sendGAVRv+0x22>
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; flagTimeout=fFalse;break;}
		}//end switch
	}//end while
	
	//If there was a timeout and the wiating flag has not been set yet, make sure waiting flag.
	if (noCarriage || flagTimeout){
    168e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1690:	88 23       	and	r24, r24
    1692:	19 f4       	brne	.+6      	; 0x169a <_Z8sendGAVRv+0x43e>
    1694:	8b 81       	ldd	r24, Y+3	; 0x03
    1696:	88 23       	and	r24, r24
    1698:	11 f0       	breq	.+4      	; 0x169e <_Z8sendGAVRv+0x442>
    169a:	81 e0       	ldi	r24, 0x01	; 1
    169c:	01 c0       	rjmp	.+2      	; 0x16a0 <_Z8sendGAVRv+0x444>
    169e:	80 e0       	ldi	r24, 0x00	; 0
    16a0:	88 23       	and	r24, r24
    16a2:	19 f0       	breq	.+6      	; 0x16aa <_Z8sendGAVRv+0x44e>
		flagWaitingToSendGAVR=fTrue;
    16a4:	81 e0       	ldi	r24, 0x01	; 1
    16a6:	80 93 c1 01 	sts	0x01C1, r24
	}
	
	//If we aren't waiting for the next round, don't reset the flags. If we are waiting, just reset the waiting flag->the UserCLock and GAVRClcok flags
	//will still be at the values they were before.
	if (!flagWaitingToSendGAVR){
    16aa:	80 91 c1 01 	lds	r24, 0x01C1
    16ae:	88 23       	and	r24, r24
    16b0:	29 f4       	brne	.+10     	; 0x16bc <_Z8sendGAVRv+0x460>
		flagUserClock=fFalse;
    16b2:	10 92 bf 01 	sts	0x01BF, r1
		flagUpdateGAVRClock=fFalse;	
    16b6:	10 92 bd 01 	sts	0x01BD, r1
    16ba:	02 c0       	rjmp	.+4      	; 0x16c0 <_Z8sendGAVRv+0x464>
	} else {flagWaitingToSendGAVR=fFalse;}
    16bc:	10 92 c1 01 	sts	0x01C1, r1
}//end function 	
    16c0:	c6 5a       	subi	r28, 0xA6	; 166
    16c2:	df 4f       	sbci	r29, 0xFF	; 255
    16c4:	0f b6       	in	r0, 0x3f	; 63
    16c6:	f8 94       	cli
    16c8:	de bf       	out	0x3e, r29	; 62
    16ca:	0f be       	out	0x3f, r0	; 63
    16cc:	cd bf       	out	0x3d, r28	; 61
    16ce:	df 91       	pop	r29
    16d0:	cf 91       	pop	r28
    16d2:	08 95       	ret

000016d4 <_Z11ReceiveBonev>:
	
/*************************************************************************************************************/
void ReceiveBone(){
    16d4:	cf 93       	push	r28
    16d6:	df 93       	push	r29
    16d8:	cd b7       	in	r28, 0x3d	; 61
    16da:	de b7       	in	r29, 0x3e	; 62
    16dc:	cb 55       	subi	r28, 0x5B	; 91
    16de:	d0 40       	sbci	r29, 0x00	; 0
    16e0:	0f b6       	in	r0, 0x3f	; 63
    16e2:	f8 94       	cli
    16e4:	de bf       	out	0x3e, r29	; 62
    16e6:	0f be       	out	0x3f, r0	; 63
    16e8:	cd bf       	out	0x3d, r28	; 61
	volatile static unsigned int state=0;
	char recChar, recString[40];
	volatile unsigned int strLoc=0;
    16ea:	1c 8a       	std	Y+20, r1	; 0x14
    16ec:	1b 8a       	std	Y+19, r1	; 0x13
	BOOL noCarriage=fTrue;
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	89 83       	std	Y+1, r24	; 0x01
	
	while (flagReceivingBone){
    16f2:	b9 c3       	rjmp	.+1906   	; 0x1e66 <_Z11ReceiveBonev+0x792>
			/* State 6: Graceful exit. Exit from a command like adc or temp.																*/
			/* State 7: Parse the input string for the time and date. Should be time(:)'/'date(,) where : and , are the delimiters. Term by */
			/*			'.'																													*/
			/********************************************************************************************************************************/
			
			switch(state){
    16f4:	80 91 d3 01 	lds	r24, 0x01D3
    16f8:	90 91 d4 01 	lds	r25, 0x01D4
    16fc:	83 30       	cpi	r24, 0x03	; 3
    16fe:	91 05       	cpc	r25, r1
    1700:	09 f4       	brne	.+2      	; 0x1704 <_Z11ReceiveBonev+0x30>
    1702:	76 c1       	rjmp	.+748    	; 0x19f0 <_Z11ReceiveBonev+0x31c>
    1704:	84 30       	cpi	r24, 0x04	; 4
    1706:	91 05       	cpc	r25, r1
    1708:	48 f4       	brcc	.+18     	; 0x171c <_Z11ReceiveBonev+0x48>
    170a:	81 30       	cpi	r24, 0x01	; 1
    170c:	91 05       	cpc	r25, r1
    170e:	09 f4       	brne	.+2      	; 0x1712 <_Z11ReceiveBonev+0x3e>
    1710:	8b c0       	rjmp	.+278    	; 0x1828 <_Z11ReceiveBonev+0x154>
    1712:	82 30       	cpi	r24, 0x02	; 2
    1714:	91 05       	cpc	r25, r1
    1716:	08 f0       	brcs	.+2      	; 0x171a <_Z11ReceiveBonev+0x46>
    1718:	95 c0       	rjmp	.+298    	; 0x1844 <_Z11ReceiveBonev+0x170>
    171a:	11 c0       	rjmp	.+34     	; 0x173e <_Z11ReceiveBonev+0x6a>
    171c:	85 30       	cpi	r24, 0x05	; 5
    171e:	91 05       	cpc	r25, r1
    1720:	09 f4       	brne	.+2      	; 0x1724 <_Z11ReceiveBonev+0x50>
    1722:	82 c1       	rjmp	.+772    	; 0x1a28 <_Z11ReceiveBonev+0x354>
    1724:	85 30       	cpi	r24, 0x05	; 5
    1726:	91 05       	cpc	r25, r1
    1728:	08 f4       	brcc	.+2      	; 0x172c <_Z11ReceiveBonev+0x58>
    172a:	73 c1       	rjmp	.+742    	; 0x1a12 <_Z11ReceiveBonev+0x33e>
    172c:	86 30       	cpi	r24, 0x06	; 6
    172e:	91 05       	cpc	r25, r1
    1730:	09 f4       	brne	.+2      	; 0x1734 <_Z11ReceiveBonev+0x60>
    1732:	85 c1       	rjmp	.+778    	; 0x1a3e <_Z11ReceiveBonev+0x36a>
    1734:	87 30       	cpi	r24, 0x07	; 7
    1736:	91 05       	cpc	r25, r1
    1738:	09 f4       	brne	.+2      	; 0x173c <_Z11ReceiveBonev+0x68>
    173a:	88 c1       	rjmp	.+784    	; 0x1a4c <_Z11ReceiveBonev+0x378>
    173c:	8d c3       	rjmp	.+1818   	; 0x1e58 <_Z11ReceiveBonev+0x784>
				case 0:{
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
    173e:	1c 8a       	std	Y+20, r1	; 0x14
    1740:	1b 8a       	std	Y+19, r1	; 0x13
					recChar = UDR0;
    1742:	86 ec       	ldi	r24, 0xC6	; 198
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	fc 01       	movw	r30, r24
    1748:	80 81       	ld	r24, Z
    174a:	8a 8b       	std	Y+18, r24	; 0x12
					if (recChar=='.'){
    174c:	8a 89       	ldd	r24, Y+18	; 0x12
    174e:	8e 32       	cpi	r24, 0x2E	; 46
    1750:	39 f4       	brne	.+14     	; 0x1760 <_Z11ReceiveBonev+0x8c>
						state=5;
    1752:	85 e0       	ldi	r24, 0x05	; 5
    1754:	90 e0       	ldi	r25, 0x00	; 0
    1756:	90 93 d4 01 	sts	0x01D4, r25
    175a:	80 93 d3 01 	sts	0x01D3, r24
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
    175e:	83 c3       	rjmp	.+1798   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
					recChar = UDR0;
					if (recChar=='.'){
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
    1760:	8b 89       	ldd	r24, Y+19	; 0x13
    1762:	9c 89       	ldd	r25, Y+20	; 0x14
    1764:	9e 01       	movw	r18, r28
    1766:	2c 5c       	subi	r18, 0xCC	; 204
    1768:	3f 4f       	sbci	r19, 0xFF	; 255
    176a:	28 0f       	add	r18, r24
    176c:	39 1f       	adc	r19, r25
    176e:	4a 89       	ldd	r20, Y+18	; 0x12
    1770:	f9 01       	movw	r30, r18
    1772:	40 83       	st	Z, r20
    1774:	01 96       	adiw	r24, 0x01	; 1
    1776:	9c 8b       	std	Y+20, r25	; 0x14
    1778:	8b 8b       	std	Y+19, r24	; 0x13
    177a:	81 e0       	ldi	r24, 0x01	; 1
    177c:	90 e0       	ldi	r25, 0x00	; 0
    177e:	90 93 d4 01 	sts	0x01D4, r25
    1782:	80 93 d3 01 	sts	0x01D3, r24
					break;				
    1786:	6f c3       	rjmp	.+1758   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while (!(UCSR0A & (1 << RXC0)) && flagReceivingBone);		//get the next character
    1788:	00 00       	nop
    178a:	80 ec       	ldi	r24, 0xC0	; 192
    178c:	90 e0       	ldi	r25, 0x00	; 0
    178e:	fc 01       	movw	r30, r24
    1790:	80 81       	ld	r24, Z
    1792:	88 23       	and	r24, r24
    1794:	34 f0       	brlt	.+12     	; 0x17a2 <_Z11ReceiveBonev+0xce>
    1796:	80 91 b9 01 	lds	r24, 0x01B9
    179a:	88 23       	and	r24, r24
    179c:	11 f0       	breq	.+4      	; 0x17a2 <_Z11ReceiveBonev+0xce>
    179e:	81 e0       	ldi	r24, 0x01	; 1
    17a0:	01 c0       	rjmp	.+2      	; 0x17a4 <_Z11ReceiveBonev+0xd0>
    17a2:	80 e0       	ldi	r24, 0x00	; 0
    17a4:	88 23       	and	r24, r24
    17a6:	89 f7       	brne	.-30     	; 0x178a <_Z11ReceiveBonev+0xb6>
						if (!flagReceivingBone){state=0; break;}					//if there was a timeout, break out and reset state
    17a8:	80 91 b9 01 	lds	r24, 0x01B9
    17ac:	88 23       	and	r24, r24
    17ae:	31 f4       	brne	.+12     	; 0x17bc <_Z11ReceiveBonev+0xe8>
    17b0:	10 92 d4 01 	sts	0x01D4, r1
    17b4:	10 92 d3 01 	sts	0x01D3, r1
    17b8:	00 00       	nop
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 19){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    17ba:	55 c3       	rjmp	.+1706   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						while (!(UCSR0A & (1 << RXC0)) && flagReceivingBone);		//get the next character
						if (!flagReceivingBone){state=0; break;}					//if there was a timeout, break out and reset state
						recChar=UDR0;
    17bc:	86 ec       	ldi	r24, 0xC6	; 198
    17be:	90 e0       	ldi	r25, 0x00	; 0
    17c0:	fc 01       	movw	r30, r24
    17c2:	80 81       	ld	r24, Z
    17c4:	8a 8b       	std	Y+18, r24	; 0x12
						recString[strLoc++]=recChar;
    17c6:	8b 89       	ldd	r24, Y+19	; 0x13
    17c8:	9c 89       	ldd	r25, Y+20	; 0x14
    17ca:	9e 01       	movw	r18, r28
    17cc:	2c 5c       	subi	r18, 0xCC	; 204
    17ce:	3f 4f       	sbci	r19, 0xFF	; 255
    17d0:	28 0f       	add	r18, r24
    17d2:	39 1f       	adc	r19, r25
    17d4:	4a 89       	ldd	r20, Y+18	; 0x12
    17d6:	f9 01       	movw	r30, r18
    17d8:	40 83       	st	Z, r20
    17da:	01 96       	adiw	r24, 0x01	; 1
    17dc:	9c 8b       	std	Y+20, r25	; 0x14
    17de:	8b 8b       	std	Y+19, r24	; 0x13
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    17e0:	8a 89       	ldd	r24, Y+18	; 0x12
    17e2:	8e 32       	cpi	r24, 0x2E	; 46
    17e4:	89 f4       	brne	.+34     	; 0x1808 <_Z11ReceiveBonev+0x134>
    17e6:	8b 89       	ldd	r24, Y+19	; 0x13
    17e8:	9c 89       	ldd	r25, Y+20	; 0x14
    17ea:	9e 01       	movw	r18, r28
    17ec:	2c 5c       	subi	r18, 0xCC	; 204
    17ee:	3f 4f       	sbci	r19, 0xFF	; 255
    17f0:	82 0f       	add	r24, r18
    17f2:	93 1f       	adc	r25, r19
    17f4:	fc 01       	movw	r30, r24
    17f6:	10 82       	st	Z, r1
    17f8:	19 82       	std	Y+1, r1	; 0x01
    17fa:	82 e0       	ldi	r24, 0x02	; 2
    17fc:	90 e0       	ldi	r25, 0x00	; 0
    17fe:	90 93 d4 01 	sts	0x01D4, r25
    1802:	80 93 d3 01 	sts	0x01D3, r24
    1806:	10 c0       	rjmp	.+32     	; 0x1828 <_Z11ReceiveBonev+0x154>
						else if (strLoc >= 19){state=5;noCarriage=fFalse;}
    1808:	8b 89       	ldd	r24, Y+19	; 0x13
    180a:	9c 89       	ldd	r25, Y+20	; 0x14
    180c:	21 e0       	ldi	r18, 0x01	; 1
    180e:	83 31       	cpi	r24, 0x13	; 19
    1810:	91 05       	cpc	r25, r1
    1812:	08 f4       	brcc	.+2      	; 0x1816 <_Z11ReceiveBonev+0x142>
    1814:	20 e0       	ldi	r18, 0x00	; 0
    1816:	22 23       	and	r18, r18
    1818:	39 f0       	breq	.+14     	; 0x1828 <_Z11ReceiveBonev+0x154>
    181a:	85 e0       	ldi	r24, 0x05	; 5
    181c:	90 e0       	ldi	r25, 0x00	; 0
    181e:	90 93 d4 01 	sts	0x01D4, r25
    1822:	80 93 d3 01 	sts	0x01D3, r24
    1826:	19 82       	std	Y+1, r1	; 0x01
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    1828:	89 81       	ldd	r24, Y+1	; 0x01
    182a:	88 23       	and	r24, r24
    182c:	31 f0       	breq	.+12     	; 0x183a <_Z11ReceiveBonev+0x166>
    182e:	80 91 b9 01 	lds	r24, 0x01B9
    1832:	88 23       	and	r24, r24
    1834:	11 f0       	breq	.+4      	; 0x183a <_Z11ReceiveBonev+0x166>
    1836:	81 e0       	ldi	r24, 0x01	; 1
    1838:	01 c0       	rjmp	.+2      	; 0x183c <_Z11ReceiveBonev+0x168>
    183a:	80 e0       	ldi	r24, 0x00	; 0
    183c:	88 23       	and	r24, r24
    183e:	09 f0       	breq	.+2      	; 0x1842 <_Z11ReceiveBonev+0x16e>
    1840:	a3 cf       	rjmp	.-186    	; 0x1788 <_Z11ReceiveBonev+0xb4>
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 19){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    1842:	11 c3       	rjmp	.+1570   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
    1844:	ce 01       	movw	r24, r28
    1846:	c4 96       	adiw	r24, 0x34	; 52
    1848:	29 e2       	ldi	r18, 0x29	; 41
    184a:	31 e0       	ldi	r19, 0x01	; 1
    184c:	b9 01       	movw	r22, r18
    184e:	45 e0       	ldi	r20, 0x05	; 5
    1850:	50 e0       	ldi	r21, 0x00	; 0
    1852:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    1856:	00 97       	sbiw	r24, 0x00	; 0
    1858:	61 f4       	brne	.+24     	; 0x1872 <_Z11ReceiveBonev+0x19e>
    185a:	81 e0       	ldi	r24, 0x01	; 1
    185c:	60 e0       	ldi	r22, 0x00	; 0
    185e:	41 e0       	ldi	r20, 0x01	; 1
    1860:	0e 94 c2 12 	call	0x2584	; 0x2584 <_Z13printTimeDatehhh>
    1864:	86 e0       	ldi	r24, 0x06	; 6
    1866:	90 e0       	ldi	r25, 0x00	; 0
    1868:	90 93 d4 01 	sts	0x01D4, r25
    186c:	80 93 d3 01 	sts	0x01D3, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1870:	fa c2       	rjmp	.+1524   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end while
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
    1872:	ce 01       	movw	r24, r28
    1874:	c4 96       	adiw	r24, 0x34	; 52
    1876:	2f e2       	ldi	r18, 0x2F	; 47
    1878:	31 e0       	ldi	r19, 0x01	; 1
    187a:	b9 01       	movw	r22, r18
    187c:	45 e0       	ldi	r20, 0x05	; 5
    187e:	50 e0       	ldi	r21, 0x00	; 0
    1880:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    1884:	00 97       	sbiw	r24, 0x00	; 0
    1886:	61 f4       	brne	.+24     	; 0x18a0 <_Z11ReceiveBonev+0x1cc>
    1888:	81 e0       	ldi	r24, 0x01	; 1
    188a:	61 e0       	ldi	r22, 0x01	; 1
    188c:	40 e0       	ldi	r20, 0x00	; 0
    188e:	0e 94 c2 12 	call	0x2584	; 0x2584 <_Z13printTimeDatehhh>
    1892:	86 e0       	ldi	r24, 0x06	; 6
    1894:	90 e0       	ldi	r25, 0x00	; 0
    1896:	90 93 d4 01 	sts	0x01D4, r25
    189a:	80 93 d3 01 	sts	0x01D3, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    189e:	e3 c2       	rjmp	.+1478   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
    18a0:	ce 01       	movw	r24, r28
    18a2:	c4 96       	adiw	r24, 0x34	; 52
    18a4:	25 e3       	ldi	r18, 0x35	; 53
    18a6:	31 e0       	ldi	r19, 0x01	; 1
    18a8:	b9 01       	movw	r22, r18
    18aa:	45 e0       	ldi	r20, 0x05	; 5
    18ac:	50 e0       	ldi	r21, 0x00	; 0
    18ae:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    18b2:	00 97       	sbiw	r24, 0x00	; 0
    18b4:	61 f4       	brne	.+24     	; 0x18ce <_Z11ReceiveBonev+0x1fa>
    18b6:	81 e0       	ldi	r24, 0x01	; 1
    18b8:	61 e0       	ldi	r22, 0x01	; 1
    18ba:	41 e0       	ldi	r20, 0x01	; 1
    18bc:	0e 94 c2 12 	call	0x2584	; 0x2584 <_Z13printTimeDatehhh>
    18c0:	86 e0       	ldi	r24, 0x06	; 6
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	90 93 d4 01 	sts	0x01D4, r25
    18c8:	80 93 d3 01 	sts	0x01D3, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    18cc:	cc c2       	rjmp	.+1432   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
    18ce:	ce 01       	movw	r24, r28
    18d0:	c4 96       	adiw	r24, 0x34	; 52
    18d2:	2b e3       	ldi	r18, 0x3B	; 59
    18d4:	31 e0       	ldi	r19, 0x01	; 1
    18d6:	b9 01       	movw	r22, r18
    18d8:	45 e0       	ldi	r20, 0x05	; 5
    18da:	50 e0       	ldi	r21, 0x00	; 0
    18dc:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    18e0:	00 97       	sbiw	r24, 0x00	; 0
    18e2:	79 f4       	brne	.+30     	; 0x1902 <_Z11ReceiveBonev+0x22e>
    18e4:	81 e0       	ldi	r24, 0x01	; 1
    18e6:	60 e0       	ldi	r22, 0x00	; 0
    18e8:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    18ec:	ce 01       	movw	r24, r28
    18ee:	c4 96       	adiw	r24, 0x34	; 52
    18f0:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    18f4:	86 e0       	ldi	r24, 0x06	; 6
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	90 93 d4 01 	sts	0x01D4, r25
    18fc:	80 93 d3 01 	sts	0x01D3, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1900:	b2 c2       	rjmp	.+1380   	; 0x1e66 <_Z11ReceiveBonev+0x792>
				case 2:{
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    1902:	ce 01       	movw	r24, r28
    1904:	c4 96       	adiw	r24, 0x34	; 52
    1906:	21 e4       	ldi	r18, 0x41	; 65
    1908:	31 e0       	ldi	r19, 0x01	; 1
    190a:	b9 01       	movw	r22, r18
    190c:	44 e0       	ldi	r20, 0x04	; 4
    190e:	50 e0       	ldi	r21, 0x00	; 0
    1910:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    1914:	00 97       	sbiw	r24, 0x00	; 0
    1916:	c1 f4       	brne	.+48     	; 0x1948 <_Z11ReceiveBonev+0x274>
    1918:	80 91 8c 01 	lds	r24, 0x018C
    191c:	90 91 8d 01 	lds	r25, 0x018D
    1920:	9e 01       	movw	r18, r28
    1922:	2b 5e       	subi	r18, 0xEB	; 235
    1924:	3f 4f       	sbci	r19, 0xFF	; 255
    1926:	b9 01       	movw	r22, r18
    1928:	4a e0       	ldi	r20, 0x0A	; 10
    192a:	50 e0       	ldi	r21, 0x00	; 0
    192c:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <utoa>
    1930:	1b 8e       	std	Y+27, r1	; 0x1b
    1932:	ce 01       	movw	r24, r28
    1934:	45 96       	adiw	r24, 0x15	; 21
    1936:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    193a:	86 e0       	ldi	r24, 0x06	; 6
    193c:	90 e0       	ldi	r25, 0x00	; 0
    193e:	90 93 d4 01 	sts	0x01D4, r25
    1942:	80 93 d3 01 	sts	0x01D3, r24
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    1946:	8f c2       	rjmp	.+1310   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					if (!strncmp(recString,"date.",5)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    1948:	ce 01       	movw	r24, r28
    194a:	c4 96       	adiw	r24, 0x34	; 52
    194c:	26 e4       	ldi	r18, 0x46	; 70
    194e:	31 e0       	ldi	r19, 0x01	; 1
    1950:	b9 01       	movw	r22, r18
    1952:	45 e0       	ldi	r20, 0x05	; 5
    1954:	50 e0       	ldi	r21, 0x00	; 0
    1956:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    195a:	00 97       	sbiw	r24, 0x00	; 0
    195c:	c1 f4       	brne	.+48     	; 0x198e <_Z11ReceiveBonev+0x2ba>
    195e:	80 91 8e 01 	lds	r24, 0x018E
    1962:	90 91 8f 01 	lds	r25, 0x018F
    1966:	9e 01       	movw	r18, r28
    1968:	24 5e       	subi	r18, 0xE4	; 228
    196a:	3f 4f       	sbci	r19, 0xFF	; 255
    196c:	b9 01       	movw	r22, r18
    196e:	4a e0       	ldi	r20, 0x0A	; 10
    1970:	50 e0       	ldi	r21, 0x00	; 0
    1972:	0e 94 e2 1b 	call	0x37c4	; 0x37c4 <utoa>
    1976:	1a a2       	lds	r17, 0x9a
    1978:	ce 01       	movw	r24, r28
    197a:	4c 96       	adiw	r24, 0x1c	; 28
    197c:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    1980:	86 e0       	ldi	r24, 0x06	; 6
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	90 93 d4 01 	sts	0x01D4, r25
    1988:	80 93 d3 01 	sts	0x01D3, r24
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    198c:	6c c2       	rjmp	.+1240   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					else if (!strncmp(recString,"time.",5)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"both.",5)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
    198e:	88 ad       	sts	0x68, r24
    1990:	91 e0       	ldi	r25, 0x01	; 1
    1992:	8a 33       	cpi	r24, 0x3A	; 58
    1994:	09 f0       	breq	.+2      	; 0x1998 <_Z11ReceiveBonev+0x2c4>
    1996:	90 e0       	ldi	r25, 0x00	; 0
    1998:	29 ad       	sts	0x69, r18
    199a:	81 e0       	ldi	r24, 0x01	; 1
    199c:	2a 33       	cpi	r18, 0x3A	; 58
    199e:	09 f0       	breq	.+2      	; 0x19a2 <_Z11ReceiveBonev+0x2ce>
    19a0:	80 e0       	ldi	r24, 0x00	; 0
    19a2:	89 27       	eor	r24, r25
    19a4:	88 23       	and	r24, r24
    19a6:	39 f0       	breq	.+14     	; 0x19b6 <_Z11ReceiveBonev+0x2e2>
						state=7;	
    19a8:	87 e0       	ldi	r24, 0x07	; 7
    19aa:	90 e0       	ldi	r25, 0x00	; 0
    19ac:	90 93 d4 01 	sts	0x01D4, r25
    19b0:	80 93 d3 01 	sts	0x01D3, r24
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
					break;
    19b4:	58 c2       	rjmp	.+1200   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					else if (!strncmp(recString,"save.",5)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
    19b6:	ce 01       	movw	r24, r28
    19b8:	c4 96       	adiw	r24, 0x34	; 52
    19ba:	2c e4       	ldi	r18, 0x4C	; 76
    19bc:	31 e0       	ldi	r19, 0x01	; 1
    19be:	b9 01       	movw	r22, r18
    19c0:	48 e0       	ldi	r20, 0x08	; 8
    19c2:	50 e0       	ldi	r21, 0x00	; 0
    19c4:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    19c8:	00 97       	sbiw	r24, 0x00	; 0
    19ca:	59 f4       	brne	.+22     	; 0x19e2 <_Z11ReceiveBonev+0x30e>
    19cc:	85 e5       	ldi	r24, 0x55	; 85
    19ce:	91 e0       	ldi	r25, 0x01	; 1
    19d0:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
    19d4:	86 e0       	ldi	r24, 0x06	; 6
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	90 93 d4 01 	sts	0x01D4, r25
    19dc:	80 93 d3 01 	sts	0x01D3, r24
					else {state=5;}						
					break;
    19e0:	42 c2       	rjmp	.+1156   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					else if (!strncmp(recString,"adc.",4)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"temp.",5)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[4] == ':') != (recString[5] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"SYNNONE.",8)){PrintBone("ACKNONE."); state=6;}	
					else {state=5;}						
    19e2:	85 e0       	ldi	r24, 0x05	; 5
    19e4:	90 e0       	ldi	r25, 0x00	; 0
    19e6:	90 93 d4 01 	sts	0x01D4, r25
    19ea:	80 93 d3 01 	sts	0x01D3, r24
					break;
    19ee:	3b c2       	rjmp	.+1142   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 2
				case 3:{
					//Successful receive state of time, change SYN to ACK, then print what we got.
					recString[0]='A';
    19f0:	81 e4       	ldi	r24, 0x41	; 65
    19f2:	8c ab       	sts	0x5c, r24
					recString[1]='C';
    19f4:	83 e4       	ldi	r24, 0x43	; 67
    19f6:	8d ab       	sts	0x5d, r24
					recString[2]='K';
    19f8:	8b e4       	ldi	r24, 0x4B	; 75
    19fa:	8e ab       	sts	0x5e, r24
					PrintBone(recString);
    19fc:	ce 01       	movw	r24, r28
    19fe:	c4 96       	adiw	r24, 0x34	; 52
    1a00:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					state=0;
    1a04:	10 92 d4 01 	sts	0x01D4, r1
    1a08:	10 92 d3 01 	sts	0x01D3, r1
					flagReceivingBone=fFalse;
    1a0c:	10 92 b9 01 	sts	0x01B9, r1
					break;
    1a10:	2a c2       	rjmp	.+1108   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 3
				case 4:{
					//Bad time string.
					PrintBone("ACKBAD.");
    1a12:	8d e0       	ldi	r24, 0x0D	; 13
    1a14:	91 e0       	ldi	r25, 0x01	; 1
    1a16:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1a1a:	10 92 b9 01 	sts	0x01B9, r1
					state=0;
    1a1e:	10 92 d4 01 	sts	0x01D4, r1
    1a22:	10 92 d3 01 	sts	0x01D3, r1
					break;
    1a26:	1f c2       	rjmp	.+1086   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 4
				case 5:{
					//Didn't get a good ack or there was an error.
					PrintBone("ACKERROR.");
    1a28:	8e e5       	ldi	r24, 0x5E	; 94
    1a2a:	91 e0       	ldi	r25, 0x01	; 1
    1a2c:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1a30:	10 92 b9 01 	sts	0x01B9, r1
					state=0;
    1a34:	10 92 d4 01 	sts	0x01D4, r1
    1a38:	10 92 d3 01 	sts	0x01D3, r1
					break;
    1a3c:	14 c2       	rjmp	.+1064   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 5
				case 6:{
					//Graceful exit.
					flagReceivingBone=fFalse;
    1a3e:	10 92 b9 01 	sts	0x01B9, r1
					state=0;
    1a42:	10 92 d4 01 	sts	0x01D4, r1
    1a46:	10 92 d3 01 	sts	0x01D3, r1
					break;
    1a4a:	0d c2       	rjmp	.+1050   	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 6
				case 7:{
					//Parse the string
					//Go through the string and parse for the time. Must go through the time to get the date.
					BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    1a4c:	1a 82       	std	Y+2, r1	; 0x02
    1a4e:	1b 82       	std	Y+3, r1	; 0x03
					int counter=0;
    1a50:	1d 82       	std	Y+5, r1	; 0x05
    1a52:	1c 82       	std	Y+4, r1	; 0x04
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    1a54:	1c a2       	lds	r17, 0x9c
    1a56:	1b a2       	lds	r17, 0x9b
    1a58:	1e a2       	lds	r17, 0x9e
    1a5a:	1d a2       	lds	r17, 0x9d
    1a5c:	18 a6       	lds	r17, 0xb8
    1a5e:	1f a2       	lds	r17, 0x9f
    1a60:	1a a6       	lds	r17, 0xba
    1a62:	19 a6       	lds	r17, 0xb9
    1a64:	1c a6       	lds	r17, 0xbc
    1a66:	1b a6       	lds	r17, 0xbb
    1a68:	1e a6       	lds	r17, 0xbe
    1a6a:	1d a6       	lds	r17, 0xbd
    1a6c:	1f 82       	std	Y+7, r1	; 0x07
    1a6e:	1e 82       	std	Y+6, r1	; 0x06
    1a70:	19 86       	std	Y+9, r1	; 0x09
    1a72:	18 86       	std	Y+8, r1	; 0x08
    1a74:	1b 86       	std	Y+11, r1	; 0x0b
    1a76:	1a 86       	std	Y+10, r1	; 0x0a
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    1a78:	73 c0       	rjmp	.+230    	; 0x1b60 <_Z11ReceiveBonev+0x48c>
						//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
						if (recString[counter]!=':' && hms<3){
    1a7a:	9e 01       	movw	r18, r28
    1a7c:	2c 5c       	subi	r18, 0xCC	; 204
    1a7e:	3f 4f       	sbci	r19, 0xFF	; 255
    1a80:	8c 81       	ldd	r24, Y+4	; 0x04
    1a82:	9d 81       	ldd	r25, Y+5	; 0x05
    1a84:	82 0f       	add	r24, r18
    1a86:	93 1f       	adc	r25, r19
    1a88:	fc 01       	movw	r30, r24
    1a8a:	80 81       	ld	r24, Z
    1a8c:	8a 33       	cpi	r24, 0x3A	; 58
    1a8e:	e9 f0       	breq	.+58     	; 0x1aca <_Z11ReceiveBonev+0x3f6>
    1a90:	88 85       	ldd	r24, Y+8	; 0x08
    1a92:	99 85       	ldd	r25, Y+9	; 0x09
    1a94:	83 30       	cpi	r24, 0x03	; 3
    1a96:	91 05       	cpc	r25, r1
    1a98:	c4 f4       	brge	.+48     	; 0x1aca <_Z11ReceiveBonev+0x3f6>
							tempStringNum[placement++]=recString[counter];
    1a9a:	9e 01       	movw	r18, r28
    1a9c:	2c 5c       	subi	r18, 0xCC	; 204
    1a9e:	3f 4f       	sbci	r19, 0xFF	; 255
    1aa0:	8c 81       	ldd	r24, Y+4	; 0x04
    1aa2:	9d 81       	ldd	r25, Y+5	; 0x05
    1aa4:	82 0f       	add	r24, r18
    1aa6:	93 1f       	adc	r25, r19
    1aa8:	fc 01       	movw	r30, r24
    1aaa:	40 81       	ld	r20, Z
    1aac:	9e 01       	movw	r18, r28
    1aae:	21 5d       	subi	r18, 0xD1	; 209
    1ab0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ab2:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ab4:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ab6:	82 0f       	add	r24, r18
    1ab8:	93 1f       	adc	r25, r19
    1aba:	fc 01       	movw	r30, r24
    1abc:	40 83       	st	Z, r20
    1abe:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ac0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ac2:	01 96       	adiw	r24, 0x01	; 1
    1ac4:	9b 87       	std	Y+11, r25	; 0x0b
    1ac6:	8a 87       	std	Y+10, r24	; 0x0a
    1ac8:	46 c0       	rjmp	.+140    	; 0x1b56 <_Z11ReceiveBonev+0x482>
						//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
						} else if (hms<2 && recString[counter] == ':') {
    1aca:	88 85       	ldd	r24, Y+8	; 0x08
    1acc:	99 85       	ldd	r25, Y+9	; 0x09
    1ace:	82 30       	cpi	r24, 0x02	; 2
    1ad0:	91 05       	cpc	r25, r1
    1ad2:	0c f0       	brlt	.+2      	; 0x1ad6 <_Z11ReceiveBonev+0x402>
    1ad4:	40 c0       	rjmp	.+128    	; 0x1b56 <_Z11ReceiveBonev+0x482>
    1ad6:	9e 01       	movw	r18, r28
    1ad8:	2c 5c       	subi	r18, 0xCC	; 204
    1ada:	3f 4f       	sbci	r19, 0xFF	; 255
    1adc:	8c 81       	ldd	r24, Y+4	; 0x04
    1ade:	9d 81       	ldd	r25, Y+5	; 0x05
    1ae0:	82 0f       	add	r24, r18
    1ae2:	93 1f       	adc	r25, r19
    1ae4:	fc 01       	movw	r30, r24
    1ae6:	80 81       	ld	r24, Z
    1ae8:	8a 33       	cpi	r24, 0x3A	; 58
    1aea:	a9 f5       	brne	.+106    	; 0x1b56 <_Z11ReceiveBonev+0x482>
							tempNum[hms++] = atoi(tempStringNum);
    1aec:	ce 01       	movw	r24, r28
    1aee:	8f 96       	adiw	r24, 0x2f	; 47
    1af0:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
    1af4:	9c 01       	movw	r18, r24
    1af6:	88 85       	ldd	r24, Y+8	; 0x08
    1af8:	99 85       	ldd	r25, Y+9	; 0x09
    1afa:	88 0f       	add	r24, r24
    1afc:	99 1f       	adc	r25, r25
    1afe:	ae 01       	movw	r20, r28
    1b00:	4f 5f       	subi	r20, 0xFF	; 255
    1b02:	5f 4f       	sbci	r21, 0xFF	; 255
    1b04:	84 0f       	add	r24, r20
    1b06:	95 1f       	adc	r25, r21
    1b08:	82 96       	adiw	r24, 0x22	; 34
    1b0a:	fc 01       	movw	r30, r24
    1b0c:	31 83       	std	Z+1, r19	; 0x01
    1b0e:	20 83       	st	Z, r18
    1b10:	88 85       	ldd	r24, Y+8	; 0x08
    1b12:	99 85       	ldd	r25, Y+9	; 0x09
    1b14:	01 96       	adiw	r24, 0x01	; 1
    1b16:	99 87       	std	Y+9, r25	; 0x09
    1b18:	88 87       	std	Y+8, r24	; 0x08
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1b1a:	1d 86       	std	Y+13, r1	; 0x0d
    1b1c:	1c 86       	std	Y+12, r1	; 0x0c
    1b1e:	0e c0       	rjmp	.+28     	; 0x1b3c <_Z11ReceiveBonev+0x468>
    1b20:	9e 01       	movw	r18, r28
    1b22:	21 5d       	subi	r18, 0xD1	; 209
    1b24:	3f 4f       	sbci	r19, 0xFF	; 255
    1b26:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b28:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b2a:	82 0f       	add	r24, r18
    1b2c:	93 1f       	adc	r25, r19
    1b2e:	fc 01       	movw	r30, r24
    1b30:	10 82       	st	Z, r1
    1b32:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b34:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b36:	01 96       	adiw	r24, 0x01	; 1
    1b38:	9d 87       	std	Y+13, r25	; 0x0d
    1b3a:	8c 87       	std	Y+12, r24	; 0x0c
    1b3c:	41 e0       	ldi	r20, 0x01	; 1
    1b3e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1b40:	3d 85       	ldd	r19, Y+13	; 0x0d
    1b42:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b44:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b46:	82 17       	cp	r24, r18
    1b48:	93 07       	cpc	r25, r19
    1b4a:	0c f4       	brge	.+2      	; 0x1b4e <_Z11ReceiveBonev+0x47a>
    1b4c:	40 e0       	ldi	r20, 0x00	; 0
    1b4e:	44 23       	and	r20, r20
    1b50:	39 f7       	brne	.-50     	; 0x1b20 <_Z11ReceiveBonev+0x44c>
							placement=0;												//reset placement
    1b52:	1b 86       	std	Y+11, r1	; 0x0b
    1b54:	1a 86       	std	Y+10, r1	; 0x0a
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
    1b56:	8c 81       	ldd	r24, Y+4	; 0x04
    1b58:	9d 81       	ldd	r25, Y+5	; 0x05
    1b5a:	01 96       	adiw	r24, 0x01	; 1
    1b5c:	9d 83       	std	Y+5, r25	; 0x05
    1b5e:	8c 83       	std	Y+4, r24	; 0x04
					int counter=0;
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    1b60:	9e 01       	movw	r18, r28
    1b62:	2c 5c       	subi	r18, 0xCC	; 204
    1b64:	3f 4f       	sbci	r19, 0xFF	; 255
    1b66:	8c 81       	ldd	r24, Y+4	; 0x04
    1b68:	9d 81       	ldd	r25, Y+5	; 0x05
    1b6a:	82 0f       	add	r24, r18
    1b6c:	93 1f       	adc	r25, r19
    1b6e:	fc 01       	movw	r30, r24
    1b70:	80 81       	ld	r24, Z
    1b72:	8f 32       	cpi	r24, 0x2F	; 47
    1b74:	69 f0       	breq	.+26     	; 0x1b90 <_Z11ReceiveBonev+0x4bc>
    1b76:	9e 01       	movw	r18, r28
    1b78:	2c 5c       	subi	r18, 0xCC	; 204
    1b7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1b7c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b7e:	9d 81       	ldd	r25, Y+5	; 0x05
    1b80:	82 0f       	add	r24, r18
    1b82:	93 1f       	adc	r25, r19
    1b84:	fc 01       	movw	r30, r24
    1b86:	80 81       	ld	r24, Z
    1b88:	88 23       	and	r24, r24
    1b8a:	11 f0       	breq	.+4      	; 0x1b90 <_Z11ReceiveBonev+0x4bc>
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	01 c0       	rjmp	.+2      	; 0x1b92 <_Z11ReceiveBonev+0x4be>
    1b90:	80 e0       	ldi	r24, 0x00	; 0
    1b92:	88 23       	and	r24, r24
    1b94:	09 f0       	breq	.+2      	; 0x1b98 <_Z11ReceiveBonev+0x4c4>
    1b96:	71 cf       	rjmp	.-286    	; 0x1a7a <_Z11ReceiveBonev+0x3a6>
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
					}//end while
					//Found a '/', assign tempNum otherwise exit with ACKBAD
					if (recString[counter] == '/'){
    1b98:	9e 01       	movw	r18, r28
    1b9a:	2c 5c       	subi	r18, 0xCC	; 204
    1b9c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b9e:	8c 81       	ldd	r24, Y+4	; 0x04
    1ba0:	9d 81       	ldd	r25, Y+5	; 0x05
    1ba2:	82 0f       	add	r24, r18
    1ba4:	93 1f       	adc	r25, r19
    1ba6:	fc 01       	movw	r30, r24
    1ba8:	80 81       	ld	r24, Z
    1baa:	8f 32       	cpi	r24, 0x2F	; 47
    1bac:	a9 f4       	brne	.+42     	; 0x1bd8 <_Z11ReceiveBonev+0x504>
						tempNum[hms] = atoi(tempStringNum);
    1bae:	ce 01       	movw	r24, r28
    1bb0:	8f 96       	adiw	r24, 0x2f	; 47
    1bb2:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
    1bb6:	9c 01       	movw	r18, r24
    1bb8:	88 85       	ldd	r24, Y+8	; 0x08
    1bba:	99 85       	ldd	r25, Y+9	; 0x09
    1bbc:	88 0f       	add	r24, r24
    1bbe:	99 1f       	adc	r25, r25
    1bc0:	ae 01       	movw	r20, r28
    1bc2:	4f 5f       	subi	r20, 0xFF	; 255
    1bc4:	5f 4f       	sbci	r21, 0xFF	; 255
    1bc6:	84 0f       	add	r24, r20
    1bc8:	95 1f       	adc	r25, r21
    1bca:	82 96       	adiw	r24, 0x22	; 34
    1bcc:	fc 01       	movw	r30, r24
    1bce:	31 83       	std	Z+1, r19	; 0x01
    1bd0:	20 83       	st	Z, r18
						successTime=fTrue;
    1bd2:	81 e0       	ldi	r24, 0x01	; 1
    1bd4:	8a 83       	std	Y+2, r24	; 0x02
    1bd6:	06 c0       	rjmp	.+12     	; 0x1be4 <_Z11ReceiveBonev+0x510>
					} else {
						state=4;
    1bd8:	84 e0       	ldi	r24, 0x04	; 4
    1bda:	90 e0       	ldi	r25, 0x00	; 0
    1bdc:	90 93 d4 01 	sts	0x01D4, r25
    1be0:	80 93 d3 01 	sts	0x01D3, r24
					}
					
					//If flag for Date is set, then parse the string and do something with it.
					//Now get the date. have to null the tempStringNum
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1be4:	1f 86       	std	Y+15, r1	; 0x0f
    1be6:	1e 86       	std	Y+14, r1	; 0x0e
    1be8:	0e c0       	rjmp	.+28     	; 0x1c06 <_Z11ReceiveBonev+0x532>
    1bea:	9e 01       	movw	r18, r28
    1bec:	21 5d       	subi	r18, 0xD1	; 209
    1bee:	3f 4f       	sbci	r19, 0xFF	; 255
    1bf0:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bf2:	9f 85       	ldd	r25, Y+15	; 0x0f
    1bf4:	82 0f       	add	r24, r18
    1bf6:	93 1f       	adc	r25, r19
    1bf8:	fc 01       	movw	r30, r24
    1bfa:	10 82       	st	Z, r1
    1bfc:	8e 85       	ldd	r24, Y+14	; 0x0e
    1bfe:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c00:	01 96       	adiw	r24, 0x01	; 1
    1c02:	9f 87       	std	Y+15, r25	; 0x0f
    1c04:	8e 87       	std	Y+14, r24	; 0x0e
    1c06:	41 e0       	ldi	r20, 0x01	; 1
    1c08:	2e 85       	ldd	r18, Y+14	; 0x0e
    1c0a:	3f 85       	ldd	r19, Y+15	; 0x0f
    1c0c:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c0e:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c10:	82 17       	cp	r24, r18
    1c12:	93 07       	cpc	r25, r19
    1c14:	0c f4       	brge	.+2      	; 0x1c18 <_Z11ReceiveBonev+0x544>
    1c16:	40 e0       	ldi	r20, 0x00	; 0
    1c18:	44 23       	and	r20, r20
    1c1a:	39 f7       	brne	.-50     	; 0x1bea <_Z11ReceiveBonev+0x516>
					placement=0;
    1c1c:	1b 86       	std	Y+11, r1	; 0x0b
    1c1e:	1a 86       	std	Y+10, r1	; 0x0a
					counter++;	//get past the '/'
    1c20:	8c 81       	ldd	r24, Y+4	; 0x04
    1c22:	9d 81       	ldd	r25, Y+5	; 0x05
    1c24:	01 96       	adiw	r24, 0x01	; 1
    1c26:	9d 83       	std	Y+5, r25	; 0x05
    1c28:	8c 83       	std	Y+4, r24	; 0x04
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1c2a:	73 c0       	rjmp	.+230    	; 0x1d12 <_Z11ReceiveBonev+0x63e>
						//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
						if  (recString[counter] != ',' && dmy < 3){
    1c2c:	9e 01       	movw	r18, r28
    1c2e:	2c 5c       	subi	r18, 0xCC	; 204
    1c30:	3f 4f       	sbci	r19, 0xFF	; 255
    1c32:	8c 81       	ldd	r24, Y+4	; 0x04
    1c34:	9d 81       	ldd	r25, Y+5	; 0x05
    1c36:	82 0f       	add	r24, r18
    1c38:	93 1f       	adc	r25, r19
    1c3a:	fc 01       	movw	r30, r24
    1c3c:	80 81       	ld	r24, Z
    1c3e:	8c 32       	cpi	r24, 0x2C	; 44
    1c40:	e9 f0       	breq	.+58     	; 0x1c7c <_Z11ReceiveBonev+0x5a8>
    1c42:	8e 81       	ldd	r24, Y+6	; 0x06
    1c44:	9f 81       	ldd	r25, Y+7	; 0x07
    1c46:	83 30       	cpi	r24, 0x03	; 3
    1c48:	91 05       	cpc	r25, r1
    1c4a:	c4 f4       	brge	.+48     	; 0x1c7c <_Z11ReceiveBonev+0x5a8>
							tempStringNum[placement++]=recString[counter];
    1c4c:	9e 01       	movw	r18, r28
    1c4e:	2c 5c       	subi	r18, 0xCC	; 204
    1c50:	3f 4f       	sbci	r19, 0xFF	; 255
    1c52:	8c 81       	ldd	r24, Y+4	; 0x04
    1c54:	9d 81       	ldd	r25, Y+5	; 0x05
    1c56:	82 0f       	add	r24, r18
    1c58:	93 1f       	adc	r25, r19
    1c5a:	fc 01       	movw	r30, r24
    1c5c:	40 81       	ld	r20, Z
    1c5e:	9e 01       	movw	r18, r28
    1c60:	21 5d       	subi	r18, 0xD1	; 209
    1c62:	3f 4f       	sbci	r19, 0xFF	; 255
    1c64:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c66:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c68:	82 0f       	add	r24, r18
    1c6a:	93 1f       	adc	r25, r19
    1c6c:	fc 01       	movw	r30, r24
    1c6e:	40 83       	st	Z, r20
    1c70:	8a 85       	ldd	r24, Y+10	; 0x0a
    1c72:	9b 85       	ldd	r25, Y+11	; 0x0b
    1c74:	01 96       	adiw	r24, 0x01	; 1
    1c76:	9b 87       	std	Y+11, r25	; 0x0b
    1c78:	8a 87       	std	Y+10, r24	; 0x0a
    1c7a:	46 c0       	rjmp	.+140    	; 0x1d08 <_Z11ReceiveBonev+0x634>
						//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
						} else if (dmy<2 && recString[counter]==','){
    1c7c:	8e 81       	ldd	r24, Y+6	; 0x06
    1c7e:	9f 81       	ldd	r25, Y+7	; 0x07
    1c80:	82 30       	cpi	r24, 0x02	; 2
    1c82:	91 05       	cpc	r25, r1
    1c84:	0c f0       	brlt	.+2      	; 0x1c88 <_Z11ReceiveBonev+0x5b4>
    1c86:	40 c0       	rjmp	.+128    	; 0x1d08 <_Z11ReceiveBonev+0x634>
    1c88:	9e 01       	movw	r18, r28
    1c8a:	2c 5c       	subi	r18, 0xCC	; 204
    1c8c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c8e:	8c 81       	ldd	r24, Y+4	; 0x04
    1c90:	9d 81       	ldd	r25, Y+5	; 0x05
    1c92:	82 0f       	add	r24, r18
    1c94:	93 1f       	adc	r25, r19
    1c96:	fc 01       	movw	r30, r24
    1c98:	80 81       	ld	r24, Z
    1c9a:	8c 32       	cpi	r24, 0x2C	; 44
    1c9c:	a9 f5       	brne	.+106    	; 0x1d08 <_Z11ReceiveBonev+0x634>
							tempNum1[dmy++] = atoi(tempStringNum);
    1c9e:	ce 01       	movw	r24, r28
    1ca0:	8f 96       	adiw	r24, 0x2f	; 47
    1ca2:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
    1ca6:	9c 01       	movw	r18, r24
    1ca8:	8e 81       	ldd	r24, Y+6	; 0x06
    1caa:	9f 81       	ldd	r25, Y+7	; 0x07
    1cac:	88 0f       	add	r24, r24
    1cae:	99 1f       	adc	r25, r25
    1cb0:	ae 01       	movw	r20, r28
    1cb2:	4f 5f       	subi	r20, 0xFF	; 255
    1cb4:	5f 4f       	sbci	r21, 0xFF	; 255
    1cb6:	84 0f       	add	r24, r20
    1cb8:	95 1f       	adc	r25, r21
    1cba:	88 96       	adiw	r24, 0x28	; 40
    1cbc:	fc 01       	movw	r30, r24
    1cbe:	31 83       	std	Z+1, r19	; 0x01
    1cc0:	20 83       	st	Z, r18
    1cc2:	8e 81       	ldd	r24, Y+6	; 0x06
    1cc4:	9f 81       	ldd	r25, Y+7	; 0x07
    1cc6:	01 96       	adiw	r24, 0x01	; 1
    1cc8:	9f 83       	std	Y+7, r25	; 0x07
    1cca:	8e 83       	std	Y+6, r24	; 0x06
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    1ccc:	19 8a       	std	Y+17, r1	; 0x11
    1cce:	18 8a       	std	Y+16, r1	; 0x10
    1cd0:	0e c0       	rjmp	.+28     	; 0x1cee <_Z11ReceiveBonev+0x61a>
    1cd2:	9e 01       	movw	r18, r28
    1cd4:	21 5d       	subi	r18, 0xD1	; 209
    1cd6:	3f 4f       	sbci	r19, 0xFF	; 255
    1cd8:	88 89       	ldd	r24, Y+16	; 0x10
    1cda:	99 89       	ldd	r25, Y+17	; 0x11
    1cdc:	82 0f       	add	r24, r18
    1cde:	93 1f       	adc	r25, r19
    1ce0:	fc 01       	movw	r30, r24
    1ce2:	10 82       	st	Z, r1
    1ce4:	88 89       	ldd	r24, Y+16	; 0x10
    1ce6:	99 89       	ldd	r25, Y+17	; 0x11
    1ce8:	01 96       	adiw	r24, 0x01	; 1
    1cea:	99 8b       	std	Y+17, r25	; 0x11
    1cec:	88 8b       	std	Y+16, r24	; 0x10
    1cee:	41 e0       	ldi	r20, 0x01	; 1
    1cf0:	28 89       	ldd	r18, Y+16	; 0x10
    1cf2:	39 89       	ldd	r19, Y+17	; 0x11
    1cf4:	8a 85       	ldd	r24, Y+10	; 0x0a
    1cf6:	9b 85       	ldd	r25, Y+11	; 0x0b
    1cf8:	82 17       	cp	r24, r18
    1cfa:	93 07       	cpc	r25, r19
    1cfc:	0c f4       	brge	.+2      	; 0x1d00 <_Z11ReceiveBonev+0x62c>
    1cfe:	40 e0       	ldi	r20, 0x00	; 0
    1d00:	44 23       	and	r20, r20
    1d02:	39 f7       	brne	.-50     	; 0x1cd2 <_Z11ReceiveBonev+0x5fe>
							placement=0;
    1d04:	1b 86       	std	Y+11, r1	; 0x0b
    1d06:	1a 86       	std	Y+10, r1	; 0x0a
						} else;
						counter++;							
    1d08:	8c 81       	ldd	r24, Y+4	; 0x04
    1d0a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d0c:	01 96       	adiw	r24, 0x01	; 1
    1d0e:	9d 83       	std	Y+5, r25	; 0x05
    1d10:	8c 83       	std	Y+4, r24	; 0x04
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
					placement=0;
					counter++;	//get past the '/'
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1d12:	9e 01       	movw	r18, r28
    1d14:	2c 5c       	subi	r18, 0xCC	; 204
    1d16:	3f 4f       	sbci	r19, 0xFF	; 255
    1d18:	8c 81       	ldd	r24, Y+4	; 0x04
    1d1a:	9d 81       	ldd	r25, Y+5	; 0x05
    1d1c:	82 0f       	add	r24, r18
    1d1e:	93 1f       	adc	r25, r19
    1d20:	fc 01       	movw	r30, r24
    1d22:	80 81       	ld	r24, Z
    1d24:	8e 32       	cpi	r24, 0x2E	; 46
    1d26:	a1 f0       	breq	.+40     	; 0x1d50 <_Z11ReceiveBonev+0x67c>
    1d28:	9e 01       	movw	r18, r28
    1d2a:	2c 5c       	subi	r18, 0xCC	; 204
    1d2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1d2e:	8c 81       	ldd	r24, Y+4	; 0x04
    1d30:	9d 81       	ldd	r25, Y+5	; 0x05
    1d32:	82 0f       	add	r24, r18
    1d34:	93 1f       	adc	r25, r19
    1d36:	fc 01       	movw	r30, r24
    1d38:	80 81       	ld	r24, Z
    1d3a:	88 23       	and	r24, r24
    1d3c:	49 f0       	breq	.+18     	; 0x1d50 <_Z11ReceiveBonev+0x67c>
    1d3e:	2c 81       	ldd	r18, Y+4	; 0x04
    1d40:	3d 81       	ldd	r19, Y+5	; 0x05
    1d42:	8b 89       	ldd	r24, Y+19	; 0x13
    1d44:	9c 89       	ldd	r25, Y+20	; 0x14
    1d46:	28 17       	cp	r18, r24
    1d48:	39 07       	cpc	r19, r25
    1d4a:	11 f0       	breq	.+4      	; 0x1d50 <_Z11ReceiveBonev+0x67c>
    1d4c:	81 e0       	ldi	r24, 0x01	; 1
    1d4e:	01 c0       	rjmp	.+2      	; 0x1d52 <_Z11ReceiveBonev+0x67e>
    1d50:	80 e0       	ldi	r24, 0x00	; 0
    1d52:	88 23       	and	r24, r24
    1d54:	09 f0       	breq	.+2      	; 0x1d58 <_Z11ReceiveBonev+0x684>
    1d56:	6a cf       	rjmp	.-300    	; 0x1c2c <_Z11ReceiveBonev+0x558>
						} else;
						counter++;							
					}//end while
					
					//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
					if (recString[counter] == '.'){
    1d58:	9e 01       	movw	r18, r28
    1d5a:	2c 5c       	subi	r18, 0xCC	; 204
    1d5c:	3f 4f       	sbci	r19, 0xFF	; 255
    1d5e:	8c 81       	ldd	r24, Y+4	; 0x04
    1d60:	9d 81       	ldd	r25, Y+5	; 0x05
    1d62:	82 0f       	add	r24, r18
    1d64:	93 1f       	adc	r25, r19
    1d66:	fc 01       	movw	r30, r24
    1d68:	80 81       	ld	r24, Z
    1d6a:	8e 32       	cpi	r24, 0x2E	; 46
    1d6c:	a9 f4       	brne	.+42     	; 0x1d98 <_Z11ReceiveBonev+0x6c4>
						tempNum1[dmy] = atoi(tempStringNum);
    1d6e:	ce 01       	movw	r24, r28
    1d70:	8f 96       	adiw	r24, 0x2f	; 47
    1d72:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
    1d76:	9c 01       	movw	r18, r24
    1d78:	8e 81       	ldd	r24, Y+6	; 0x06
    1d7a:	9f 81       	ldd	r25, Y+7	; 0x07
    1d7c:	88 0f       	add	r24, r24
    1d7e:	99 1f       	adc	r25, r25
    1d80:	ae 01       	movw	r20, r28
    1d82:	4f 5f       	subi	r20, 0xFF	; 255
    1d84:	5f 4f       	sbci	r21, 0xFF	; 255
    1d86:	84 0f       	add	r24, r20
    1d88:	95 1f       	adc	r25, r21
    1d8a:	88 96       	adiw	r24, 0x28	; 40
    1d8c:	fc 01       	movw	r30, r24
    1d8e:	31 83       	std	Z+1, r19	; 0x01
    1d90:	20 83       	st	Z, r18
						successDate=fTrue;
    1d92:	81 e0       	ldi	r24, 0x01	; 1
    1d94:	8b 83       	std	Y+3, r24	; 0x03
    1d96:	06 c0       	rjmp	.+12     	; 0x1da4 <_Z11ReceiveBonev+0x6d0>
					} else {//something in the string was wrong, ACKBAD and then exit
						state=4;
    1d98:	84 e0       	ldi	r24, 0x04	; 4
    1d9a:	90 e0       	ldi	r25, 0x00	; 0
    1d9c:	90 93 d4 01 	sts	0x01D4, r25
    1da0:	80 93 d3 01 	sts	0x01D3, r24
					}	
					
					//NOw set the time and date, then save it to EEPROM
					if (successDate && successTime){
    1da4:	8b 81       	ldd	r24, Y+3	; 0x03
    1da6:	88 23       	and	r24, r24
    1da8:	39 f1       	breq	.+78     	; 0x1df8 <_Z11ReceiveBonev+0x724>
    1daa:	8a 81       	ldd	r24, Y+2	; 0x02
    1dac:	88 23       	and	r24, r24
    1dae:	21 f1       	breq	.+72     	; 0x1df8 <_Z11ReceiveBonev+0x724>
						currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    1db0:	69 a5       	lds	r22, 0x69
    1db2:	7a a5       	lds	r23, 0x6a
    1db4:	4b a5       	lds	r20, 0x6b
    1db6:	5c a5       	lds	r21, 0x6c
    1db8:	2d a5       	lds	r18, 0x6d
    1dba:	3e a5       	lds	r19, 0x6e
    1dbc:	80 e9       	ldi	r24, 0x90	; 144
    1dbe:	91 e0       	ldi	r25, 0x01	; 1
    1dc0:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
						currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    1dc4:	6b a1       	lds	r22, 0x4b
    1dc6:	7c a1       	lds	r23, 0x4c
    1dc8:	4d a1       	lds	r20, 0x4d
    1dca:	5e a1       	lds	r21, 0x4e
    1dcc:	2f a1       	lds	r18, 0x4f
    1dce:	38 a5       	lds	r19, 0x68
    1dd0:	80 e9       	ldi	r24, 0x90	; 144
    1dd2:	91 e0       	ldi	r25, 0x01	; 1
    1dd4:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
						saveDateTime_eeprom(fTrue,fTrue);
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	61 e0       	ldi	r22, 0x01	; 1
    1ddc:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    1de0:	81 e0       	ldi	r24, 0x01	; 1
    1de2:	80 93 bd 01 	sts	0x01BD, r24
						//Make sure UserCLock flags are down
						flagUserClock=fFalse;
    1de6:	10 92 bf 01 	sts	0x01BF, r1
						state=3;	//Graceful exit
    1dea:	83 e0       	ldi	r24, 0x03	; 3
    1dec:	90 e0       	ldi	r25, 0x00	; 0
    1dee:	90 93 d4 01 	sts	0x01D4, r25
    1df2:	80 93 d3 01 	sts	0x01D3, r24
    1df6:	2b c0       	rjmp	.+86     	; 0x1e4e <_Z11ReceiveBonev+0x77a>
					} else if (!(successDate && successTime) && restart){
    1df8:	8b 81       	ldd	r24, Y+3	; 0x03
    1dfa:	88 23       	and	r24, r24
    1dfc:	19 f0       	breq	.+6      	; 0x1e04 <_Z11ReceiveBonev+0x730>
    1dfe:	8a 81       	ldd	r24, Y+2	; 0x02
    1e00:	88 23       	and	r24, r24
    1e02:	81 f4       	brne	.+32     	; 0x1e24 <_Z11ReceiveBonev+0x750>
    1e04:	80 91 c7 01 	lds	r24, 0x01C7
    1e08:	88 23       	and	r24, r24
    1e0a:	61 f0       	breq	.+24     	; 0x1e24 <_Z11ReceiveBonev+0x750>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    1e0c:	81 e0       	ldi	r24, 0x01	; 1
    1e0e:	80 93 bd 01 	sts	0x01BD, r24
						flagUserClock=fFalse;
    1e12:	10 92 bf 01 	sts	0x01BF, r1
						state=4;	//ACKBAD
    1e16:	84 e0       	ldi	r24, 0x04	; 4
    1e18:	90 e0       	ldi	r25, 0x00	; 0
    1e1a:	90 93 d4 01 	sts	0x01D4, r25
    1e1e:	80 93 d3 01 	sts	0x01D3, r24
    1e22:	15 c0       	rjmp	.+42     	; 0x1e4e <_Z11ReceiveBonev+0x77a>
					} else if (!(successDate && successTime) && flagFreshStart){
    1e24:	8b 81       	ldd	r24, Y+3	; 0x03
    1e26:	88 23       	and	r24, r24
    1e28:	19 f0       	breq	.+6      	; 0x1e30 <_Z11ReceiveBonev+0x75c>
    1e2a:	8a 81       	ldd	r24, Y+2	; 0x02
    1e2c:	88 23       	and	r24, r24
    1e2e:	79 f4       	brne	.+30     	; 0x1e4e <_Z11ReceiveBonev+0x77a>
    1e30:	80 91 c8 01 	lds	r24, 0x01C8
    1e34:	88 23       	and	r24, r24
    1e36:	59 f0       	breq	.+22     	; 0x1e4e <_Z11ReceiveBonev+0x77a>
						flagUserClock=fTrue;
    1e38:	81 e0       	ldi	r24, 0x01	; 1
    1e3a:	80 93 bf 01 	sts	0x01BF, r24
						flagUpdateGAVRClock=fFalse;
    1e3e:	10 92 bd 01 	sts	0x01BD, r1
						state=4;	//ACKBAD
    1e42:	84 e0       	ldi	r24, 0x04	; 4
    1e44:	90 e0       	ldi	r25, 0x00	; 0
    1e46:	90 93 d4 01 	sts	0x01D4, r25
    1e4a:	80 93 d3 01 	sts	0x01D3, r24
					} else;		
					
					//Lower restart flags. Should have parallel case in timer just in case this state doesn't happen.
					flagFreshStart=fFalse;
    1e4e:	10 92 c8 01 	sts	0x01C8, r1
					restart=fFalse;		
    1e52:	10 92 c7 01 	sts	0x01C7, r1
					break;
    1e56:	07 c0       	rjmp	.+14     	; 0x1e66 <_Z11ReceiveBonev+0x792>
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
    1e58:	10 92 b9 01 	sts	0x01B9, r1
    1e5c:	10 92 d4 01 	sts	0x01D4, r1
    1e60:	10 92 d3 01 	sts	0x01D3, r1
    1e64:	00 00       	nop
	volatile static unsigned int state=0;
	char recChar, recString[40];
	volatile unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	while (flagReceivingBone){
    1e66:	90 91 b9 01 	lds	r25, 0x01B9
    1e6a:	81 e0       	ldi	r24, 0x01	; 1
    1e6c:	99 23       	and	r25, r25
    1e6e:	09 f4       	brne	.+2      	; 0x1e72 <_Z11ReceiveBonev+0x79e>
    1e70:	80 e0       	ldi	r24, 0x00	; 0
    1e72:	88 23       	and	r24, r24
    1e74:	09 f0       	breq	.+2      	; 0x1e78 <_Z11ReceiveBonev+0x7a4>
    1e76:	3e cc       	rjmp	.-1924   	; 0x16f4 <_Z11ReceiveBonev+0x20>
					break;
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
			}//end switch
	}//end while(flagUARTbone)	
}//end ReceiveBone()
    1e78:	c5 5a       	subi	r28, 0xA5	; 165
    1e7a:	df 4f       	sbci	r29, 0xFF	; 255
    1e7c:	0f b6       	in	r0, 0x3f	; 63
    1e7e:	f8 94       	cli
    1e80:	de bf       	out	0x3e, r29	; 62
    1e82:	0f be       	out	0x3f, r0	; 63
    1e84:	cd bf       	out	0x3d, r28	; 61
    1e86:	df 91       	pop	r29
    1e88:	cf 91       	pop	r28
    1e8a:	08 95       	ret

00001e8c <_Z11ReceiveGAVRv>:

/*************************************************************************************************************/
void ReceiveGAVR(){
    1e8c:	cf 93       	push	r28
    1e8e:	df 93       	push	r29
    1e90:	cd b7       	in	r28, 0x3d	; 61
    1e92:	de b7       	in	r29, 0x3e	; 62
    1e94:	cd 54       	subi	r28, 0x4D	; 77
    1e96:	d0 40       	sbci	r29, 0x00	; 0
    1e98:	0f b6       	in	r0, 0x3f	; 63
    1e9a:	f8 94       	cli
    1e9c:	de bf       	out	0x3e, r29	; 62
    1e9e:	0f be       	out	0x3f, r0	; 63
    1ea0:	cd bf       	out	0x3d, r28	; 61
	volatile static unsigned int state=0;
	char recChar, recString[40];
	volatile unsigned int strLoc=0;
    1ea2:	1c 8a       	std	Y+20, r1	; 0x14
    1ea4:	1b 8a       	std	Y+19, r1	; 0x13
	BOOL noCarriage=fTrue;
    1ea6:	81 e0       	ldi	r24, 0x01	; 1
    1ea8:	89 83       	std	Y+1, r24	; 0x01
	
	//While Loop
	while (flagReceivingGAVR){
    1eaa:	59 c3       	rjmp	.+1714   	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
			/** State 5: Exit case. Lower "flagReceivingGAVR" which causes and exit.													   **/
			/** State 6: ACKERROR state. Send "ACKERROR", then exit through state 5.													   **/
			/** State 7: Successful acquire of time/date.																				   **/
			/** Default: Set state to 0, doesn't really matter though. Exit signalling timeout to sender.								   **/
			/********************************************************************************************************************************/			
			switch(state){
    1eac:	80 91 d1 01 	lds	r24, 0x01D1
    1eb0:	90 91 d2 01 	lds	r25, 0x01D2
    1eb4:	83 30       	cpi	r24, 0x03	; 3
    1eb6:	91 05       	cpc	r25, r1
    1eb8:	09 f4       	brne	.+2      	; 0x1ebc <_Z11ReceiveGAVRv+0x30>
    1eba:	cd c0       	rjmp	.+410    	; 0x2056 <_Z11ReceiveGAVRv+0x1ca>
    1ebc:	84 30       	cpi	r24, 0x04	; 4
    1ebe:	91 05       	cpc	r25, r1
    1ec0:	48 f4       	brcc	.+18     	; 0x1ed4 <_Z11ReceiveGAVRv+0x48>
    1ec2:	81 30       	cpi	r24, 0x01	; 1
    1ec4:	91 05       	cpc	r25, r1
    1ec6:	09 f4       	brne	.+2      	; 0x1eca <_Z11ReceiveGAVRv+0x3e>
    1ec8:	8b c0       	rjmp	.+278    	; 0x1fe0 <_Z11ReceiveGAVRv+0x154>
    1eca:	82 30       	cpi	r24, 0x02	; 2
    1ecc:	91 05       	cpc	r25, r1
    1ece:	08 f0       	brcs	.+2      	; 0x1ed2 <_Z11ReceiveGAVRv+0x46>
    1ed0:	95 c0       	rjmp	.+298    	; 0x1ffc <_Z11ReceiveGAVRv+0x170>
    1ed2:	11 c0       	rjmp	.+34     	; 0x1ef6 <_Z11ReceiveGAVRv+0x6a>
    1ed4:	85 30       	cpi	r24, 0x05	; 5
    1ed6:	91 05       	cpc	r25, r1
    1ed8:	09 f4       	brne	.+2      	; 0x1edc <_Z11ReceiveGAVRv+0x50>
    1eda:	15 c3       	rjmp	.+1578   	; 0x2506 <_Z11ReceiveGAVRv+0x67a>
    1edc:	85 30       	cpi	r24, 0x05	; 5
    1ede:	91 05       	cpc	r25, r1
    1ee0:	08 f4       	brcc	.+2      	; 0x1ee4 <_Z11ReceiveGAVRv+0x58>
    1ee2:	fa c2       	rjmp	.+1524   	; 0x24d8 <_Z11ReceiveGAVRv+0x64c>
    1ee4:	86 30       	cpi	r24, 0x06	; 6
    1ee6:	91 05       	cpc	r25, r1
    1ee8:	09 f4       	brne	.+2      	; 0x1eec <_Z11ReceiveGAVRv+0x60>
    1eea:	14 c3       	rjmp	.+1576   	; 0x2514 <_Z11ReceiveGAVRv+0x688>
    1eec:	87 30       	cpi	r24, 0x07	; 7
    1eee:	91 05       	cpc	r25, r1
    1ef0:	09 f4       	brne	.+2      	; 0x1ef4 <_Z11ReceiveGAVRv+0x68>
    1ef2:	1b c3       	rjmp	.+1590   	; 0x252a <_Z11ReceiveGAVRv+0x69e>
    1ef4:	2b c3       	rjmp	.+1622   	; 0x254c <_Z11ReceiveGAVRv+0x6c0>
				case 0:{
					//Beginning case
					strLoc=0;
    1ef6:	1c 8a       	std	Y+20, r1	; 0x14
    1ef8:	1b 8a       	std	Y+19, r1	; 0x13
					recChar = UDR1;
    1efa:	8e ec       	ldi	r24, 0xCE	; 206
    1efc:	90 e0       	ldi	r25, 0x00	; 0
    1efe:	fc 01       	movw	r30, r24
    1f00:	80 81       	ld	r24, Z
    1f02:	8a 8b       	std	Y+18, r24	; 0x12
					if (recChar=='.'){
    1f04:	8a 89       	ldd	r24, Y+18	; 0x12
    1f06:	8e 32       	cpi	r24, 0x2E	; 46
    1f08:	39 f4       	brne	.+14     	; 0x1f18 <_Z11ReceiveGAVRv+0x8c>
						state=6;															//Go to error state.
    1f0a:	86 e0       	ldi	r24, 0x06	; 6
    1f0c:	90 e0       	ldi	r25, 0x00	; 0
    1f0e:	90 93 d2 01 	sts	0x01D2, r25
    1f12:	80 93 d1 01 	sts	0x01D1, r24
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
    1f16:	23 c3       	rjmp	.+1606   	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
					//Beginning case
					strLoc=0;
					recChar = UDR1;
					if (recChar=='.'){
						state=6;															//Go to error state.
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
    1f18:	8b 89       	ldd	r24, Y+19	; 0x13
    1f1a:	9c 89       	ldd	r25, Y+20	; 0x14
    1f1c:	9e 01       	movw	r18, r28
    1f1e:	2a 5d       	subi	r18, 0xDA	; 218
    1f20:	3f 4f       	sbci	r19, 0xFF	; 255
    1f22:	28 0f       	add	r18, r24
    1f24:	39 1f       	adc	r19, r25
    1f26:	4a 89       	ldd	r20, Y+18	; 0x12
    1f28:	f9 01       	movw	r30, r18
    1f2a:	40 83       	st	Z, r20
    1f2c:	01 96       	adiw	r24, 0x01	; 1
    1f2e:	9c 8b       	std	Y+20, r25	; 0x14
    1f30:	8b 8b       	std	Y+19, r24	; 0x13
    1f32:	81 e0       	ldi	r24, 0x01	; 1
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	90 93 d2 01 	sts	0x01D2, r25
    1f3a:	80 93 d1 01 	sts	0x01D1, r24
					break;
    1f3e:	0f c3       	rjmp	.+1566   	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
    1f40:	00 00       	nop
    1f42:	88 ec       	ldi	r24, 0xC8	; 200
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	fc 01       	movw	r30, r24
    1f48:	80 81       	ld	r24, Z
    1f4a:	88 23       	and	r24, r24
    1f4c:	34 f0       	brlt	.+12     	; 0x1f5a <_Z11ReceiveGAVRv+0xce>
    1f4e:	80 91 bb 01 	lds	r24, 0x01BB
    1f52:	88 23       	and	r24, r24
    1f54:	11 f0       	breq	.+4      	; 0x1f5a <_Z11ReceiveGAVRv+0xce>
    1f56:	81 e0       	ldi	r24, 0x01	; 1
    1f58:	01 c0       	rjmp	.+2      	; 0x1f5c <_Z11ReceiveGAVRv+0xd0>
    1f5a:	80 e0       	ldi	r24, 0x00	; 0
    1f5c:	88 23       	and	r24, r24
    1f5e:	89 f7       	brne	.-30     	; 0x1f42 <_Z11ReceiveGAVRv+0xb6>
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
    1f60:	80 91 bb 01 	lds	r24, 0x01BB
    1f64:	88 23       	and	r24, r24
    1f66:	31 f4       	brne	.+12     	; 0x1f74 <_Z11ReceiveGAVRv+0xe8>
    1f68:	10 92 d2 01 	sts	0x01D2, r1
    1f6c:	10 92 d1 01 	sts	0x01D1, r1
    1f70:	00 00       	nop
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    1f72:	f5 c2       	rjmp	.+1514   	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
						recChar=UDR1;
    1f74:	8e ec       	ldi	r24, 0xCE	; 206
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	fc 01       	movw	r30, r24
    1f7a:	80 81       	ld	r24, Z
    1f7c:	8a 8b       	std	Y+18, r24	; 0x12
						recString[strLoc++]=recChar;										//'.' always included into recString
    1f7e:	8b 89       	ldd	r24, Y+19	; 0x13
    1f80:	9c 89       	ldd	r25, Y+20	; 0x14
    1f82:	9e 01       	movw	r18, r28
    1f84:	2a 5d       	subi	r18, 0xDA	; 218
    1f86:	3f 4f       	sbci	r19, 0xFF	; 255
    1f88:	28 0f       	add	r18, r24
    1f8a:	39 1f       	adc	r19, r25
    1f8c:	4a 89       	ldd	r20, Y+18	; 0x12
    1f8e:	f9 01       	movw	r30, r18
    1f90:	40 83       	st	Z, r20
    1f92:	01 96       	adiw	r24, 0x01	; 1
    1f94:	9c 8b       	std	Y+20, r25	; 0x14
    1f96:	8b 8b       	std	Y+19, r24	; 0x13
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1f98:	8a 89       	ldd	r24, Y+18	; 0x12
    1f9a:	8e 32       	cpi	r24, 0x2E	; 46
    1f9c:	89 f4       	brne	.+34     	; 0x1fc0 <_Z11ReceiveGAVRv+0x134>
    1f9e:	8b 89       	ldd	r24, Y+19	; 0x13
    1fa0:	9c 89       	ldd	r25, Y+20	; 0x14
    1fa2:	9e 01       	movw	r18, r28
    1fa4:	2a 5d       	subi	r18, 0xDA	; 218
    1fa6:	3f 4f       	sbci	r19, 0xFF	; 255
    1fa8:	82 0f       	add	r24, r18
    1faa:	93 1f       	adc	r25, r19
    1fac:	fc 01       	movw	r30, r24
    1fae:	10 82       	st	Z, r1
    1fb0:	19 82       	std	Y+1, r1	; 0x01
    1fb2:	82 e0       	ldi	r24, 0x02	; 2
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	90 93 d2 01 	sts	0x01D2, r25
    1fba:	80 93 d1 01 	sts	0x01D1, r24
    1fbe:	10 c0       	rjmp	.+32     	; 0x1fe0 <_Z11ReceiveGAVRv+0x154>
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
    1fc0:	8b 89       	ldd	r24, Y+19	; 0x13
    1fc2:	9c 89       	ldd	r25, Y+20	; 0x14
    1fc4:	21 e0       	ldi	r18, 0x01	; 1
    1fc6:	87 32       	cpi	r24, 0x27	; 39
    1fc8:	91 05       	cpc	r25, r1
    1fca:	08 f4       	brcc	.+2      	; 0x1fce <_Z11ReceiveGAVRv+0x142>
    1fcc:	20 e0       	ldi	r18, 0x00	; 0
    1fce:	22 23       	and	r18, r18
    1fd0:	39 f0       	breq	.+14     	; 0x1fe0 <_Z11ReceiveGAVRv+0x154>
    1fd2:	86 e0       	ldi	r24, 0x06	; 6
    1fd4:	90 e0       	ldi	r25, 0x00	; 0
    1fd6:	90 93 d2 01 	sts	0x01D2, r25
    1fda:	80 93 d1 01 	sts	0x01D1, r24
    1fde:	19 82       	std	Y+1, r1	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
    1fe0:	89 81       	ldd	r24, Y+1	; 0x01
    1fe2:	88 23       	and	r24, r24
    1fe4:	31 f0       	breq	.+12     	; 0x1ff2 <_Z11ReceiveGAVRv+0x166>
    1fe6:	80 91 bb 01 	lds	r24, 0x01BB
    1fea:	88 23       	and	r24, r24
    1fec:	11 f0       	breq	.+4      	; 0x1ff2 <_Z11ReceiveGAVRv+0x166>
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	01 c0       	rjmp	.+2      	; 0x1ff4 <_Z11ReceiveGAVRv+0x168>
    1ff2:	80 e0       	ldi	r24, 0x00	; 0
    1ff4:	88 23       	and	r24, r24
    1ff6:	09 f0       	breq	.+2      	; 0x1ffa <_Z11ReceiveGAVRv+0x16e>
    1ff8:	a3 cf       	rjmp	.-186    	; 0x1f40 <_Z11ReceiveGAVRv+0xb4>
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    1ffa:	b1 c2       	rjmp	.+1378   	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
    1ffc:	ce 01       	movw	r24, r28
    1ffe:	86 96       	adiw	r24, 0x26	; 38
    2000:	28 e6       	ldi	r18, 0x68	; 104
    2002:	31 e0       	ldi	r19, 0x01	; 1
    2004:	b9 01       	movw	r22, r18
    2006:	48 e0       	ldi	r20, 0x08	; 8
    2008:	50 e0       	ldi	r21, 0x00	; 0
    200a:	0e 94 ab 1b 	call	0x3756	; 0x3756 <strncmp>
    200e:	00 97       	sbiw	r24, 0x00	; 0
    2010:	39 f4       	brne	.+14     	; 0x2020 <_Z11ReceiveGAVRv+0x194>
    2012:	84 e0       	ldi	r24, 0x04	; 4
    2014:	90 e0       	ldi	r25, 0x00	; 0
    2016:	90 93 d2 01 	sts	0x01D2, r25
    201a:	80 93 d1 01 	sts	0x01D1, r24
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
					break;
    201e:	9f c2       	rjmp	.+1342   	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
					break;
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
    2020:	8a a5       	lds	r24, 0x6a
    2022:	91 e0       	ldi	r25, 0x01	; 1
    2024:	8a 33       	cpi	r24, 0x3A	; 58
    2026:	09 f0       	breq	.+2      	; 0x202a <_Z11ReceiveGAVRv+0x19e>
    2028:	90 e0       	ldi	r25, 0x00	; 0
    202a:	2b a5       	lds	r18, 0x6b
    202c:	81 e0       	ldi	r24, 0x01	; 1
    202e:	2a 33       	cpi	r18, 0x3A	; 58
    2030:	09 f0       	breq	.+2      	; 0x2034 <_Z11ReceiveGAVRv+0x1a8>
    2032:	80 e0       	ldi	r24, 0x00	; 0
    2034:	89 27       	eor	r24, r25
    2036:	88 23       	and	r24, r24
    2038:	39 f0       	breq	.+14     	; 0x2048 <_Z11ReceiveGAVRv+0x1bc>
    203a:	83 e0       	ldi	r24, 0x03	; 3
    203c:	90 e0       	ldi	r25, 0x00	; 0
    203e:	90 93 d2 01 	sts	0x01D2, r25
    2042:	80 93 d1 01 	sts	0x01D1, r24
					else {state=6;}
					break;
    2046:	8b c2       	rjmp	.+1302   	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"SYNNEED.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[4]==':') != (recString[5]==':')){state=3;}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
    2048:	86 e0       	ldi	r24, 0x06	; 6
    204a:	90 e0       	ldi	r25, 0x00	; 0
    204c:	90 93 d2 01 	sts	0x01D2, r25
    2050:	80 93 d1 01 	sts	0x01D1, r24
					break;
    2054:	84 c2       	rjmp	.+1288   	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				}//end case 2
				case 3:{
					//Parse for date/time case
					if (flagUserClock){
    2056:	80 91 bf 01 	lds	r24, 0x01BF
    205a:	88 23       	and	r24, r24
    205c:	09 f4       	brne	.+2      	; 0x2060 <_Z11ReceiveGAVRv+0x1d4>
    205e:	31 c2       	rjmp	.+1122   	; 0x24c2 <_Z11ReceiveGAVRv+0x636>
						//Go through the string and parse for the time. Must go through the time to get the date.
						BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    2060:	1a 82       	std	Y+2, r1	; 0x02
    2062:	1b 82       	std	Y+3, r1	; 0x03
						int counter=0;
    2064:	1d 82       	std	Y+5, r1	; 0x05
    2066:	1c 82       	std	Y+4, r1	; 0x04
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    2068:	1e 8a       	std	Y+22, r1	; 0x16
    206a:	1d 8a       	std	Y+21, r1	; 0x15
    206c:	18 8e       	std	Y+24, r1	; 0x18
    206e:	1f 8a       	std	Y+23, r1	; 0x17
    2070:	1a 8e       	std	Y+26, r1	; 0x1a
    2072:	19 8e       	std	Y+25, r1	; 0x19
    2074:	1c 8e       	std	Y+28, r1	; 0x1c
    2076:	1b 8e       	std	Y+27, r1	; 0x1b
    2078:	1e 8e       	std	Y+30, r1	; 0x1e
    207a:	1d 8e       	std	Y+29, r1	; 0x1d
    207c:	18 a2       	lds	r17, 0x98
    207e:	1f 8e       	std	Y+31, r1	; 0x1f
    2080:	1f 82       	std	Y+7, r1	; 0x07
    2082:	1e 82       	std	Y+6, r1	; 0x06
    2084:	19 86       	std	Y+9, r1	; 0x09
    2086:	18 86       	std	Y+8, r1	; 0x08
    2088:	1b 86       	std	Y+11, r1	; 0x0b
    208a:	1a 86       	std	Y+10, r1	; 0x0a
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    208c:	73 c0       	rjmp	.+230    	; 0x2174 <_Z11ReceiveGAVRv+0x2e8>
							//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
							if (recString[counter]!=':' && hms<3){
    208e:	9e 01       	movw	r18, r28
    2090:	2a 5d       	subi	r18, 0xDA	; 218
    2092:	3f 4f       	sbci	r19, 0xFF	; 255
    2094:	8c 81       	ldd	r24, Y+4	; 0x04
    2096:	9d 81       	ldd	r25, Y+5	; 0x05
    2098:	82 0f       	add	r24, r18
    209a:	93 1f       	adc	r25, r19
    209c:	fc 01       	movw	r30, r24
    209e:	80 81       	ld	r24, Z
    20a0:	8a 33       	cpi	r24, 0x3A	; 58
    20a2:	e9 f0       	breq	.+58     	; 0x20de <_Z11ReceiveGAVRv+0x252>
    20a4:	88 85       	ldd	r24, Y+8	; 0x08
    20a6:	99 85       	ldd	r25, Y+9	; 0x09
    20a8:	83 30       	cpi	r24, 0x03	; 3
    20aa:	91 05       	cpc	r25, r1
    20ac:	c4 f4       	brge	.+48     	; 0x20de <_Z11ReceiveGAVRv+0x252>
								tempStringNum[placement++]=recString[counter];
    20ae:	9e 01       	movw	r18, r28
    20b0:	2a 5d       	subi	r18, 0xDA	; 218
    20b2:	3f 4f       	sbci	r19, 0xFF	; 255
    20b4:	8c 81       	ldd	r24, Y+4	; 0x04
    20b6:	9d 81       	ldd	r25, Y+5	; 0x05
    20b8:	82 0f       	add	r24, r18
    20ba:	93 1f       	adc	r25, r19
    20bc:	fc 01       	movw	r30, r24
    20be:	40 81       	ld	r20, Z
    20c0:	9e 01       	movw	r18, r28
    20c2:	2f 5d       	subi	r18, 0xDF	; 223
    20c4:	3f 4f       	sbci	r19, 0xFF	; 255
    20c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    20c8:	9b 85       	ldd	r25, Y+11	; 0x0b
    20ca:	82 0f       	add	r24, r18
    20cc:	93 1f       	adc	r25, r19
    20ce:	fc 01       	movw	r30, r24
    20d0:	40 83       	st	Z, r20
    20d2:	8a 85       	ldd	r24, Y+10	; 0x0a
    20d4:	9b 85       	ldd	r25, Y+11	; 0x0b
    20d6:	01 96       	adiw	r24, 0x01	; 1
    20d8:	9b 87       	std	Y+11, r25	; 0x0b
    20da:	8a 87       	std	Y+10, r24	; 0x0a
    20dc:	46 c0       	rjmp	.+140    	; 0x216a <_Z11ReceiveGAVRv+0x2de>
							//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
							} else if (hms<2 && recString[counter] == ':') {
    20de:	88 85       	ldd	r24, Y+8	; 0x08
    20e0:	99 85       	ldd	r25, Y+9	; 0x09
    20e2:	82 30       	cpi	r24, 0x02	; 2
    20e4:	91 05       	cpc	r25, r1
    20e6:	0c f0       	brlt	.+2      	; 0x20ea <_Z11ReceiveGAVRv+0x25e>
    20e8:	40 c0       	rjmp	.+128    	; 0x216a <_Z11ReceiveGAVRv+0x2de>
    20ea:	9e 01       	movw	r18, r28
    20ec:	2a 5d       	subi	r18, 0xDA	; 218
    20ee:	3f 4f       	sbci	r19, 0xFF	; 255
    20f0:	8c 81       	ldd	r24, Y+4	; 0x04
    20f2:	9d 81       	ldd	r25, Y+5	; 0x05
    20f4:	82 0f       	add	r24, r18
    20f6:	93 1f       	adc	r25, r19
    20f8:	fc 01       	movw	r30, r24
    20fa:	80 81       	ld	r24, Z
    20fc:	8a 33       	cpi	r24, 0x3A	; 58
    20fe:	a9 f5       	brne	.+106    	; 0x216a <_Z11ReceiveGAVRv+0x2de>
								tempNum[hms++] = atoi(tempStringNum);
    2100:	ce 01       	movw	r24, r28
    2102:	81 96       	adiw	r24, 0x21	; 33
    2104:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
    2108:	9c 01       	movw	r18, r24
    210a:	88 85       	ldd	r24, Y+8	; 0x08
    210c:	99 85       	ldd	r25, Y+9	; 0x09
    210e:	88 0f       	add	r24, r24
    2110:	99 1f       	adc	r25, r25
    2112:	ae 01       	movw	r20, r28
    2114:	4f 5f       	subi	r20, 0xFF	; 255
    2116:	5f 4f       	sbci	r21, 0xFF	; 255
    2118:	84 0f       	add	r24, r20
    211a:	95 1f       	adc	r25, r21
    211c:	44 96       	adiw	r24, 0x14	; 20
    211e:	fc 01       	movw	r30, r24
    2120:	31 83       	std	Z+1, r19	; 0x01
    2122:	20 83       	st	Z, r18
    2124:	88 85       	ldd	r24, Y+8	; 0x08
    2126:	99 85       	ldd	r25, Y+9	; 0x09
    2128:	01 96       	adiw	r24, 0x01	; 1
    212a:	99 87       	std	Y+9, r25	; 0x09
    212c:	88 87       	std	Y+8, r24	; 0x08
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    212e:	1d 86       	std	Y+13, r1	; 0x0d
    2130:	1c 86       	std	Y+12, r1	; 0x0c
    2132:	0e c0       	rjmp	.+28     	; 0x2150 <_Z11ReceiveGAVRv+0x2c4>
    2134:	9e 01       	movw	r18, r28
    2136:	2f 5d       	subi	r18, 0xDF	; 223
    2138:	3f 4f       	sbci	r19, 0xFF	; 255
    213a:	8c 85       	ldd	r24, Y+12	; 0x0c
    213c:	9d 85       	ldd	r25, Y+13	; 0x0d
    213e:	82 0f       	add	r24, r18
    2140:	93 1f       	adc	r25, r19
    2142:	fc 01       	movw	r30, r24
    2144:	10 82       	st	Z, r1
    2146:	8c 85       	ldd	r24, Y+12	; 0x0c
    2148:	9d 85       	ldd	r25, Y+13	; 0x0d
    214a:	01 96       	adiw	r24, 0x01	; 1
    214c:	9d 87       	std	Y+13, r25	; 0x0d
    214e:	8c 87       	std	Y+12, r24	; 0x0c
    2150:	41 e0       	ldi	r20, 0x01	; 1
    2152:	2c 85       	ldd	r18, Y+12	; 0x0c
    2154:	3d 85       	ldd	r19, Y+13	; 0x0d
    2156:	8a 85       	ldd	r24, Y+10	; 0x0a
    2158:	9b 85       	ldd	r25, Y+11	; 0x0b
    215a:	82 17       	cp	r24, r18
    215c:	93 07       	cpc	r25, r19
    215e:	0c f4       	brge	.+2      	; 0x2162 <_Z11ReceiveGAVRv+0x2d6>
    2160:	40 e0       	ldi	r20, 0x00	; 0
    2162:	44 23       	and	r20, r20
    2164:	39 f7       	brne	.-50     	; 0x2134 <_Z11ReceiveGAVRv+0x2a8>
								placement=0;												//reset placement
    2166:	1b 86       	std	Y+11, r1	; 0x0b
    2168:	1a 86       	std	Y+10, r1	; 0x0a
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
    216a:	8c 81       	ldd	r24, Y+4	; 0x04
    216c:	9d 81       	ldd	r25, Y+5	; 0x05
    216e:	01 96       	adiw	r24, 0x01	; 1
    2170:	9d 83       	std	Y+5, r25	; 0x05
    2172:	8c 83       	std	Y+4, r24	; 0x04
						int counter=0;
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    2174:	9e 01       	movw	r18, r28
    2176:	2a 5d       	subi	r18, 0xDA	; 218
    2178:	3f 4f       	sbci	r19, 0xFF	; 255
    217a:	8c 81       	ldd	r24, Y+4	; 0x04
    217c:	9d 81       	ldd	r25, Y+5	; 0x05
    217e:	82 0f       	add	r24, r18
    2180:	93 1f       	adc	r25, r19
    2182:	fc 01       	movw	r30, r24
    2184:	80 81       	ld	r24, Z
    2186:	8f 32       	cpi	r24, 0x2F	; 47
    2188:	69 f0       	breq	.+26     	; 0x21a4 <_Z11ReceiveGAVRv+0x318>
    218a:	9e 01       	movw	r18, r28
    218c:	2a 5d       	subi	r18, 0xDA	; 218
    218e:	3f 4f       	sbci	r19, 0xFF	; 255
    2190:	8c 81       	ldd	r24, Y+4	; 0x04
    2192:	9d 81       	ldd	r25, Y+5	; 0x05
    2194:	82 0f       	add	r24, r18
    2196:	93 1f       	adc	r25, r19
    2198:	fc 01       	movw	r30, r24
    219a:	80 81       	ld	r24, Z
    219c:	88 23       	and	r24, r24
    219e:	11 f0       	breq	.+4      	; 0x21a4 <_Z11ReceiveGAVRv+0x318>
    21a0:	81 e0       	ldi	r24, 0x01	; 1
    21a2:	01 c0       	rjmp	.+2      	; 0x21a6 <_Z11ReceiveGAVRv+0x31a>
    21a4:	80 e0       	ldi	r24, 0x00	; 0
    21a6:	88 23       	and	r24, r24
    21a8:	09 f0       	breq	.+2      	; 0x21ac <_Z11ReceiveGAVRv+0x320>
    21aa:	71 cf       	rjmp	.-286    	; 0x208e <_Z11ReceiveGAVRv+0x202>
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
						}//end while
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
    21ac:	9e 01       	movw	r18, r28
    21ae:	2a 5d       	subi	r18, 0xDA	; 218
    21b0:	3f 4f       	sbci	r19, 0xFF	; 255
    21b2:	8c 81       	ldd	r24, Y+4	; 0x04
    21b4:	9d 81       	ldd	r25, Y+5	; 0x05
    21b6:	82 0f       	add	r24, r18
    21b8:	93 1f       	adc	r25, r19
    21ba:	fc 01       	movw	r30, r24
    21bc:	80 81       	ld	r24, Z
    21be:	8f 32       	cpi	r24, 0x2F	; 47
    21c0:	a9 f4       	brne	.+42     	; 0x21ec <_Z11ReceiveGAVRv+0x360>
							tempNum[hms] = atoi(tempStringNum);
    21c2:	ce 01       	movw	r24, r28
    21c4:	81 96       	adiw	r24, 0x21	; 33
    21c6:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
    21ca:	9c 01       	movw	r18, r24
    21cc:	88 85       	ldd	r24, Y+8	; 0x08
    21ce:	99 85       	ldd	r25, Y+9	; 0x09
    21d0:	88 0f       	add	r24, r24
    21d2:	99 1f       	adc	r25, r25
    21d4:	ae 01       	movw	r20, r28
    21d6:	4f 5f       	subi	r20, 0xFF	; 255
    21d8:	5f 4f       	sbci	r21, 0xFF	; 255
    21da:	84 0f       	add	r24, r20
    21dc:	95 1f       	adc	r25, r21
    21de:	44 96       	adiw	r24, 0x14	; 20
    21e0:	fc 01       	movw	r30, r24
    21e2:	31 83       	std	Z+1, r19	; 0x01
    21e4:	20 83       	st	Z, r18
							successTime=fTrue;
    21e6:	81 e0       	ldi	r24, 0x01	; 1
    21e8:	8a 83       	std	Y+2, r24	; 0x02
    21ea:	0a c0       	rjmp	.+20     	; 0x2200 <_Z11ReceiveGAVRv+0x374>
						} else {
							state=5;
    21ec:	85 e0       	ldi	r24, 0x05	; 5
    21ee:	90 e0       	ldi	r25, 0x00	; 0
    21f0:	90 93 d2 01 	sts	0x01D2, r25
    21f4:	80 93 d1 01 	sts	0x01D1, r24
							PrintGAVR("ACKBAD.");
    21f8:	8d e0       	ldi	r24, 0x0D	; 13
    21fa:	91 e0       	ldi	r25, 0x01	; 1
    21fc:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    2200:	1f 86       	std	Y+15, r1	; 0x0f
    2202:	1e 86       	std	Y+14, r1	; 0x0e
    2204:	0e c0       	rjmp	.+28     	; 0x2222 <_Z11ReceiveGAVRv+0x396>
    2206:	9e 01       	movw	r18, r28
    2208:	2f 5d       	subi	r18, 0xDF	; 223
    220a:	3f 4f       	sbci	r19, 0xFF	; 255
    220c:	8e 85       	ldd	r24, Y+14	; 0x0e
    220e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2210:	82 0f       	add	r24, r18
    2212:	93 1f       	adc	r25, r19
    2214:	fc 01       	movw	r30, r24
    2216:	10 82       	st	Z, r1
    2218:	8e 85       	ldd	r24, Y+14	; 0x0e
    221a:	9f 85       	ldd	r25, Y+15	; 0x0f
    221c:	01 96       	adiw	r24, 0x01	; 1
    221e:	9f 87       	std	Y+15, r25	; 0x0f
    2220:	8e 87       	std	Y+14, r24	; 0x0e
    2222:	41 e0       	ldi	r20, 0x01	; 1
    2224:	2e 85       	ldd	r18, Y+14	; 0x0e
    2226:	3f 85       	ldd	r19, Y+15	; 0x0f
    2228:	8a 85       	ldd	r24, Y+10	; 0x0a
    222a:	9b 85       	ldd	r25, Y+11	; 0x0b
    222c:	82 17       	cp	r24, r18
    222e:	93 07       	cpc	r25, r19
    2230:	0c f4       	brge	.+2      	; 0x2234 <_Z11ReceiveGAVRv+0x3a8>
    2232:	40 e0       	ldi	r20, 0x00	; 0
    2234:	44 23       	and	r20, r20
    2236:	39 f7       	brne	.-50     	; 0x2206 <_Z11ReceiveGAVRv+0x37a>
						placement=0;
    2238:	1b 86       	std	Y+11, r1	; 0x0b
    223a:	1a 86       	std	Y+10, r1	; 0x0a
						counter++;	//get past the '/'
    223c:	8c 81       	ldd	r24, Y+4	; 0x04
    223e:	9d 81       	ldd	r25, Y+5	; 0x05
    2240:	01 96       	adiw	r24, 0x01	; 1
    2242:	9d 83       	std	Y+5, r25	; 0x05
    2244:	8c 83       	std	Y+4, r24	; 0x04
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    2246:	73 c0       	rjmp	.+230    	; 0x232e <_Z11ReceiveGAVRv+0x4a2>
							//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
							if  (recString[counter] != ',' && dmy < 3){
    2248:	9e 01       	movw	r18, r28
    224a:	2a 5d       	subi	r18, 0xDA	; 218
    224c:	3f 4f       	sbci	r19, 0xFF	; 255
    224e:	8c 81       	ldd	r24, Y+4	; 0x04
    2250:	9d 81       	ldd	r25, Y+5	; 0x05
    2252:	82 0f       	add	r24, r18
    2254:	93 1f       	adc	r25, r19
    2256:	fc 01       	movw	r30, r24
    2258:	80 81       	ld	r24, Z
    225a:	8c 32       	cpi	r24, 0x2C	; 44
    225c:	e9 f0       	breq	.+58     	; 0x2298 <_Z11ReceiveGAVRv+0x40c>
    225e:	8e 81       	ldd	r24, Y+6	; 0x06
    2260:	9f 81       	ldd	r25, Y+7	; 0x07
    2262:	83 30       	cpi	r24, 0x03	; 3
    2264:	91 05       	cpc	r25, r1
    2266:	c4 f4       	brge	.+48     	; 0x2298 <_Z11ReceiveGAVRv+0x40c>
								tempStringNum[placement++]=recString[counter];
    2268:	9e 01       	movw	r18, r28
    226a:	2a 5d       	subi	r18, 0xDA	; 218
    226c:	3f 4f       	sbci	r19, 0xFF	; 255
    226e:	8c 81       	ldd	r24, Y+4	; 0x04
    2270:	9d 81       	ldd	r25, Y+5	; 0x05
    2272:	82 0f       	add	r24, r18
    2274:	93 1f       	adc	r25, r19
    2276:	fc 01       	movw	r30, r24
    2278:	40 81       	ld	r20, Z
    227a:	9e 01       	movw	r18, r28
    227c:	2f 5d       	subi	r18, 0xDF	; 223
    227e:	3f 4f       	sbci	r19, 0xFF	; 255
    2280:	8a 85       	ldd	r24, Y+10	; 0x0a
    2282:	9b 85       	ldd	r25, Y+11	; 0x0b
    2284:	82 0f       	add	r24, r18
    2286:	93 1f       	adc	r25, r19
    2288:	fc 01       	movw	r30, r24
    228a:	40 83       	st	Z, r20
    228c:	8a 85       	ldd	r24, Y+10	; 0x0a
    228e:	9b 85       	ldd	r25, Y+11	; 0x0b
    2290:	01 96       	adiw	r24, 0x01	; 1
    2292:	9b 87       	std	Y+11, r25	; 0x0b
    2294:	8a 87       	std	Y+10, r24	; 0x0a
    2296:	46 c0       	rjmp	.+140    	; 0x2324 <_Z11ReceiveGAVRv+0x498>
							//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
							} else if (dmy<2 && recString[counter]==','){
    2298:	8e 81       	ldd	r24, Y+6	; 0x06
    229a:	9f 81       	ldd	r25, Y+7	; 0x07
    229c:	82 30       	cpi	r24, 0x02	; 2
    229e:	91 05       	cpc	r25, r1
    22a0:	0c f0       	brlt	.+2      	; 0x22a4 <_Z11ReceiveGAVRv+0x418>
    22a2:	40 c0       	rjmp	.+128    	; 0x2324 <_Z11ReceiveGAVRv+0x498>
    22a4:	9e 01       	movw	r18, r28
    22a6:	2a 5d       	subi	r18, 0xDA	; 218
    22a8:	3f 4f       	sbci	r19, 0xFF	; 255
    22aa:	8c 81       	ldd	r24, Y+4	; 0x04
    22ac:	9d 81       	ldd	r25, Y+5	; 0x05
    22ae:	82 0f       	add	r24, r18
    22b0:	93 1f       	adc	r25, r19
    22b2:	fc 01       	movw	r30, r24
    22b4:	80 81       	ld	r24, Z
    22b6:	8c 32       	cpi	r24, 0x2C	; 44
    22b8:	a9 f5       	brne	.+106    	; 0x2324 <_Z11ReceiveGAVRv+0x498>
								tempNum1[dmy++] = atoi(tempStringNum);
    22ba:	ce 01       	movw	r24, r28
    22bc:	81 96       	adiw	r24, 0x21	; 33
    22be:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
    22c2:	9c 01       	movw	r18, r24
    22c4:	8e 81       	ldd	r24, Y+6	; 0x06
    22c6:	9f 81       	ldd	r25, Y+7	; 0x07
    22c8:	88 0f       	add	r24, r24
    22ca:	99 1f       	adc	r25, r25
    22cc:	ae 01       	movw	r20, r28
    22ce:	4f 5f       	subi	r20, 0xFF	; 255
    22d0:	5f 4f       	sbci	r21, 0xFF	; 255
    22d2:	84 0f       	add	r24, r20
    22d4:	95 1f       	adc	r25, r21
    22d6:	4a 96       	adiw	r24, 0x1a	; 26
    22d8:	fc 01       	movw	r30, r24
    22da:	31 83       	std	Z+1, r19	; 0x01
    22dc:	20 83       	st	Z, r18
    22de:	8e 81       	ldd	r24, Y+6	; 0x06
    22e0:	9f 81       	ldd	r25, Y+7	; 0x07
    22e2:	01 96       	adiw	r24, 0x01	; 1
    22e4:	9f 83       	std	Y+7, r25	; 0x07
    22e6:	8e 83       	std	Y+6, r24	; 0x06
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    22e8:	19 8a       	std	Y+17, r1	; 0x11
    22ea:	18 8a       	std	Y+16, r1	; 0x10
    22ec:	0e c0       	rjmp	.+28     	; 0x230a <_Z11ReceiveGAVRv+0x47e>
    22ee:	9e 01       	movw	r18, r28
    22f0:	2f 5d       	subi	r18, 0xDF	; 223
    22f2:	3f 4f       	sbci	r19, 0xFF	; 255
    22f4:	88 89       	ldd	r24, Y+16	; 0x10
    22f6:	99 89       	ldd	r25, Y+17	; 0x11
    22f8:	82 0f       	add	r24, r18
    22fa:	93 1f       	adc	r25, r19
    22fc:	fc 01       	movw	r30, r24
    22fe:	10 82       	st	Z, r1
    2300:	88 89       	ldd	r24, Y+16	; 0x10
    2302:	99 89       	ldd	r25, Y+17	; 0x11
    2304:	01 96       	adiw	r24, 0x01	; 1
    2306:	99 8b       	std	Y+17, r25	; 0x11
    2308:	88 8b       	std	Y+16, r24	; 0x10
    230a:	41 e0       	ldi	r20, 0x01	; 1
    230c:	28 89       	ldd	r18, Y+16	; 0x10
    230e:	39 89       	ldd	r19, Y+17	; 0x11
    2310:	8a 85       	ldd	r24, Y+10	; 0x0a
    2312:	9b 85       	ldd	r25, Y+11	; 0x0b
    2314:	82 17       	cp	r24, r18
    2316:	93 07       	cpc	r25, r19
    2318:	0c f4       	brge	.+2      	; 0x231c <_Z11ReceiveGAVRv+0x490>
    231a:	40 e0       	ldi	r20, 0x00	; 0
    231c:	44 23       	and	r20, r20
    231e:	39 f7       	brne	.-50     	; 0x22ee <_Z11ReceiveGAVRv+0x462>
								placement=0;
    2320:	1b 86       	std	Y+11, r1	; 0x0b
    2322:	1a 86       	std	Y+10, r1	; 0x0a
							} else;
							counter++;							
    2324:	8c 81       	ldd	r24, Y+4	; 0x04
    2326:	9d 81       	ldd	r25, Y+5	; 0x05
    2328:	01 96       	adiw	r24, 0x01	; 1
    232a:	9d 83       	std	Y+5, r25	; 0x05
    232c:	8c 83       	std	Y+4, r24	; 0x04
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
						placement=0;
						counter++;	//get past the '/'
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    232e:	9e 01       	movw	r18, r28
    2330:	2a 5d       	subi	r18, 0xDA	; 218
    2332:	3f 4f       	sbci	r19, 0xFF	; 255
    2334:	8c 81       	ldd	r24, Y+4	; 0x04
    2336:	9d 81       	ldd	r25, Y+5	; 0x05
    2338:	82 0f       	add	r24, r18
    233a:	93 1f       	adc	r25, r19
    233c:	fc 01       	movw	r30, r24
    233e:	80 81       	ld	r24, Z
    2340:	8e 32       	cpi	r24, 0x2E	; 46
    2342:	a1 f0       	breq	.+40     	; 0x236c <_Z11ReceiveGAVRv+0x4e0>
    2344:	9e 01       	movw	r18, r28
    2346:	2a 5d       	subi	r18, 0xDA	; 218
    2348:	3f 4f       	sbci	r19, 0xFF	; 255
    234a:	8c 81       	ldd	r24, Y+4	; 0x04
    234c:	9d 81       	ldd	r25, Y+5	; 0x05
    234e:	82 0f       	add	r24, r18
    2350:	93 1f       	adc	r25, r19
    2352:	fc 01       	movw	r30, r24
    2354:	80 81       	ld	r24, Z
    2356:	88 23       	and	r24, r24
    2358:	49 f0       	breq	.+18     	; 0x236c <_Z11ReceiveGAVRv+0x4e0>
    235a:	2c 81       	ldd	r18, Y+4	; 0x04
    235c:	3d 81       	ldd	r19, Y+5	; 0x05
    235e:	8b 89       	ldd	r24, Y+19	; 0x13
    2360:	9c 89       	ldd	r25, Y+20	; 0x14
    2362:	28 17       	cp	r18, r24
    2364:	39 07       	cpc	r19, r25
    2366:	11 f0       	breq	.+4      	; 0x236c <_Z11ReceiveGAVRv+0x4e0>
    2368:	81 e0       	ldi	r24, 0x01	; 1
    236a:	01 c0       	rjmp	.+2      	; 0x236e <_Z11ReceiveGAVRv+0x4e2>
    236c:	80 e0       	ldi	r24, 0x00	; 0
    236e:	88 23       	and	r24, r24
    2370:	09 f0       	breq	.+2      	; 0x2374 <_Z11ReceiveGAVRv+0x4e8>
    2372:	6a cf       	rjmp	.-300    	; 0x2248 <_Z11ReceiveGAVRv+0x3bc>
								placement=0;
							} else;
							counter++;							
						}//end while
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
    2374:	9e 01       	movw	r18, r28
    2376:	2a 5d       	subi	r18, 0xDA	; 218
    2378:	3f 4f       	sbci	r19, 0xFF	; 255
    237a:	8c 81       	ldd	r24, Y+4	; 0x04
    237c:	9d 81       	ldd	r25, Y+5	; 0x05
    237e:	82 0f       	add	r24, r18
    2380:	93 1f       	adc	r25, r19
    2382:	fc 01       	movw	r30, r24
    2384:	80 81       	ld	r24, Z
    2386:	8e 32       	cpi	r24, 0x2E	; 46
    2388:	a9 f4       	brne	.+42     	; 0x23b4 <_Z11ReceiveGAVRv+0x528>
							tempNum1[dmy] = atoi(tempStringNum);
    238a:	ce 01       	movw	r24, r28
    238c:	81 96       	adiw	r24, 0x21	; 33
    238e:	0e 94 72 1b 	call	0x36e4	; 0x36e4 <atoi>
    2392:	9c 01       	movw	r18, r24
    2394:	8e 81       	ldd	r24, Y+6	; 0x06
    2396:	9f 81       	ldd	r25, Y+7	; 0x07
    2398:	88 0f       	add	r24, r24
    239a:	99 1f       	adc	r25, r25
    239c:	ae 01       	movw	r20, r28
    239e:	4f 5f       	subi	r20, 0xFF	; 255
    23a0:	5f 4f       	sbci	r21, 0xFF	; 255
    23a2:	84 0f       	add	r24, r20
    23a4:	95 1f       	adc	r25, r21
    23a6:	4a 96       	adiw	r24, 0x1a	; 26
    23a8:	fc 01       	movw	r30, r24
    23aa:	31 83       	std	Z+1, r19	; 0x01
    23ac:	20 83       	st	Z, r18
							successDate=fTrue;
    23ae:	81 e0       	ldi	r24, 0x01	; 1
    23b0:	8b 83       	std	Y+3, r24	; 0x03
    23b2:	0a c0       	rjmp	.+20     	; 0x23c8 <_Z11ReceiveGAVRv+0x53c>
						} else {//something in the string was wrong, ACKBAD and then exit
							PrintGAVR("ACKBAD.");
    23b4:	8d e0       	ldi	r24, 0x0D	; 13
    23b6:	91 e0       	ldi	r25, 0x01	; 1
    23b8:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
							state=5;
    23bc:	85 e0       	ldi	r24, 0x05	; 5
    23be:	90 e0       	ldi	r25, 0x00	; 0
    23c0:	90 93 d2 01 	sts	0x01D2, r25
    23c4:	80 93 d1 01 	sts	0x01D1, r24
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0 && successTime){
    23c8:	8d 89       	ldd	r24, Y+21	; 0x15
    23ca:	9e 89       	ldd	r25, Y+22	; 0x16
    23cc:	47 96       	adiw	r24, 0x17	; 23
    23ce:	8f 32       	cpi	r24, 0x2F	; 47
    23d0:	91 05       	cpc	r25, r1
    23d2:	f0 f4       	brcc	.+60     	; 0x2410 <_Z11ReceiveGAVRv+0x584>
    23d4:	8f 89       	ldd	r24, Y+23	; 0x17
    23d6:	98 8d       	ldd	r25, Y+24	; 0x18
    23d8:	cb 96       	adiw	r24, 0x3b	; 59
    23da:	87 37       	cpi	r24, 0x77	; 119
    23dc:	91 05       	cpc	r25, r1
    23de:	c0 f4       	brcc	.+48     	; 0x2410 <_Z11ReceiveGAVRv+0x584>
    23e0:	89 8d       	ldd	r24, Y+25	; 0x19
    23e2:	9a 8d       	ldd	r25, Y+26	; 0x1a
    23e4:	cb 96       	adiw	r24, 0x3b	; 59
    23e6:	87 37       	cpi	r24, 0x77	; 119
    23e8:	91 05       	cpc	r25, r1
    23ea:	90 f4       	brcc	.+36     	; 0x2410 <_Z11ReceiveGAVRv+0x584>
    23ec:	8a 81       	ldd	r24, Y+2	; 0x02
    23ee:	88 23       	and	r24, r24
    23f0:	79 f0       	breq	.+30     	; 0x2410 <_Z11ReceiveGAVRv+0x584>
							currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    23f2:	6d 89       	ldd	r22, Y+21	; 0x15
    23f4:	7e 89       	ldd	r23, Y+22	; 0x16
    23f6:	4f 89       	ldd	r20, Y+23	; 0x17
    23f8:	58 8d       	ldd	r21, Y+24	; 0x18
    23fa:	29 8d       	ldd	r18, Y+25	; 0x19
    23fc:	3a 8d       	ldd	r19, Y+26	; 0x1a
    23fe:	80 e9       	ldi	r24, 0x90	; 144
    2400:	91 e0       	ldi	r25, 0x01	; 1
    2402:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
							saveDateTime_eeprom(fTrue,fFalse);
    2406:	81 e0       	ldi	r24, 0x01	; 1
    2408:	60 e0       	ldi	r22, 0x00	; 0
    240a:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    240e:	0a c0       	rjmp	.+20     	; 0x2424 <_Z11ReceiveGAVRv+0x598>
						} else {
							PrintGAVR("ACKBAD.");
    2410:	8d e0       	ldi	r24, 0x0D	; 13
    2412:	91 e0       	ldi	r25, 0x01	; 1
    2414:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
							state=5;
    2418:	85 e0       	ldi	r24, 0x05	; 5
    241a:	90 e0       	ldi	r25, 0x00	; 0
    241c:	90 93 d2 01 	sts	0x01D2, r25
    2420:	80 93 d1 01 	sts	0x01D1, r24
						}//end if-else time
						
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && successDate){
    2424:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2426:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2428:	0c 96       	adiw	r24, 0x0c	; 12
    242a:	89 31       	cpi	r24, 0x19	; 25
    242c:	91 05       	cpc	r25, r1
    242e:	10 f5       	brcc	.+68     	; 0x2474 <_Z11ReceiveGAVRv+0x5e8>
    2430:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2432:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2434:	4f 96       	adiw	r24, 0x1f	; 31
    2436:	8f 33       	cpi	r24, 0x3F	; 63
    2438:	91 05       	cpc	r25, r1
    243a:	e0 f4       	brcc	.+56     	; 0x2474 <_Z11ReceiveGAVRv+0x5e8>
    243c:	8f 8d       	ldd	r24, Y+31	; 0x1f
    243e:	98 a1       	lds	r25, 0x48
    2440:	f7 e0       	ldi	r31, 0x07	; 7
    2442:	80 3d       	cpi	r24, 0xD0	; 208
    2444:	9f 07       	cpc	r25, r31
    2446:	b4 f0       	brlt	.+44     	; 0x2474 <_Z11ReceiveGAVRv+0x5e8>
    2448:	8b 81       	ldd	r24, Y+3	; 0x03
    244a:	88 23       	and	r24, r24
    244c:	99 f0       	breq	.+38     	; 0x2474 <_Z11ReceiveGAVRv+0x5e8>
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
    244e:	6b 8d       	ldd	r22, Y+27	; 0x1b
    2450:	7c 8d       	ldd	r23, Y+28	; 0x1c
    2452:	4d 8d       	ldd	r20, Y+29	; 0x1d
    2454:	5e 8d       	ldd	r21, Y+30	; 0x1e
    2456:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2458:	38 a1       	lds	r19, 0x48
    245a:	80 e9       	ldi	r24, 0x90	; 144
    245c:	91 e0       	ldi	r25, 0x01	; 1
    245e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
							saveDateTime_eeprom(fFalse,fTrue);
    2462:	80 e0       	ldi	r24, 0x00	; 0
    2464:	61 e0       	ldi	r22, 0x01	; 1
    2466:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
							state=5;
							break;
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    246a:	80 91 bf 01 	lds	r24, 0x01BF
    246e:	88 23       	and	r24, r24
    2470:	61 f4       	brne	.+24     	; 0x248a <_Z11ReceiveGAVRv+0x5fe>
    2472:	1c c0       	rjmp	.+56     	; 0x24ac <_Z11ReceiveGAVRv+0x620>
						//Make sure the date is correct before setting it. If not, send ACKBAD. and exit.
						if (tempNum1[0]/13==0 && tempNum1[1]/32==0 && tempNum1[2]/2000>=1 && successDate){
							currentTime.setDate(tempNum1[0],tempNum1[1], tempNum1[2]);
							saveDateTime_eeprom(fFalse,fTrue);
						} else {
							PrintGAVR("ACKBAD.");
    2474:	8d e0       	ldi	r24, 0x0D	; 13
    2476:	91 e0       	ldi	r25, 0x01	; 1
    2478:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
							state=5;
    247c:	85 e0       	ldi	r24, 0x05	; 5
    247e:	90 e0       	ldi	r25, 0x00	; 0
    2480:	90 93 d2 01 	sts	0x01D2, r25
    2484:	80 93 d1 01 	sts	0x01D1, r24
							break;
    2488:	6a c0       	rjmp	.+212    	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
						}//end if-else date
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    248a:	8b 81       	ldd	r24, Y+3	; 0x03
    248c:	88 23       	and	r24, r24
    248e:	71 f0       	breq	.+28     	; 0x24ac <_Z11ReceiveGAVRv+0x620>
    2490:	8a 81       	ldd	r24, Y+2	; 0x02
    2492:	88 23       	and	r24, r24
    2494:	59 f0       	breq	.+22     	; 0x24ac <_Z11ReceiveGAVRv+0x620>
							flagUserClock=fFalse;
    2496:	10 92 bf 01 	sts	0x01BF, r1
							flagWaitingForReceiveGAVR=fFalse;
    249a:	10 92 bc 01 	sts	0x01BC, r1
							state=7;					//Respond with correct string ACK
    249e:	87 e0       	ldi	r24, 0x07	; 7
    24a0:	90 e0       	ldi	r25, 0x00	; 0
    24a2:	90 93 d2 01 	sts	0x01D2, r25
    24a6:	80 93 d1 01 	sts	0x01D1, r24
						PrintGAVR("ACKNO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    24aa:	59 c0       	rjmp	.+178    	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
						if (flagUserClock && successDate && successTime){
							flagUserClock=fFalse;
							flagWaitingForReceiveGAVR=fFalse;
							state=7;					//Respond with correct string ACK
						} else {
							PrintGAVR("ACKBAD.");
    24ac:	8d e0       	ldi	r24, 0x0D	; 13
    24ae:	91 e0       	ldi	r25, 0x01	; 1
    24b0:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
							state=5;
    24b4:	85 e0       	ldi	r24, 0x05	; 5
    24b6:	90 e0       	ldi	r25, 0x00	; 0
    24b8:	90 93 d2 01 	sts	0x01D2, r25
    24bc:	80 93 d1 01 	sts	0x01D1, r24
						PrintGAVR("ACKNO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    24c0:	4e c0       	rjmp	.+156    	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
						} else {
							PrintGAVR("ACKBAD.");
							state=5;
						}																										
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("ACKNO.");
    24c2:	81 e7       	ldi	r24, 0x71	; 113
    24c4:	91 e0       	ldi	r25, 0x01	; 1
    24c6:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
						state=5;
    24ca:	85 e0       	ldi	r24, 0x05	; 5
    24cc:	90 e0       	ldi	r25, 0x00	; 0
    24ce:	90 93 d2 01 	sts	0x01D2, r25
    24d2:	80 93 d1 01 	sts	0x01D1, r24
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    24d6:	43 c0       	rjmp	.+134    	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
					}//end case 3				
				case 4:{
					//Successful SYNNEED case.
					if (!flagUserClock){	//If we don't need the date or time, update with what we have.
    24d8:	80 91 bf 01 	lds	r24, 0x01BF
    24dc:	88 23       	and	r24, r24
    24de:	41 f4       	brne	.+16     	; 0x24f0 <_Z11ReceiveGAVRv+0x664>
						flagUpdateGAVRClock=fTrue;
    24e0:	81 e0       	ldi	r24, 0x01	; 1
    24e2:	80 93 bd 01 	sts	0x01BD, r24
						PrintGAVR("ACKNEED.");				//respond with correct ack
    24e6:	88 e7       	ldi	r24, 0x78	; 120
    24e8:	91 e0       	ldi	r25, 0x01	; 1
    24ea:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
    24ee:	04 c0       	rjmp	.+8      	; 0x24f8 <_Z11ReceiveGAVRv+0x66c>
					} else {
						PrintGAVR("ACKNO.");	//say we can't give you anything, ask the user.
    24f0:	81 e7       	ldi	r24, 0x71	; 113
    24f2:	91 e0       	ldi	r25, 0x01	; 1
    24f4:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
						//Should be expecting something from the GAVR with user date and time, this reminds the GAVR.
					} //end if-else
					state=5;
    24f8:	85 e0       	ldi	r24, 0x05	; 5
    24fa:	90 e0       	ldi	r25, 0x00	; 0
    24fc:	90 93 d2 01 	sts	0x01D2, r25
    2500:	80 93 d1 01 	sts	0x01D1, r24
					break;					
    2504:	2c c0       	rjmp	.+88     	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				}//end case 4
				case 5:{
					//Exit case
					flagReceivingGAVR=fFalse;
    2506:	10 92 bb 01 	sts	0x01BB, r1
					state=0;		//just in case
    250a:	10 92 d2 01 	sts	0x01D2, r1
    250e:	10 92 d1 01 	sts	0x01D1, r1
					break;
    2512:	25 c0       	rjmp	.+74     	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				}//end case 5
				case 6:{
					//Error in ACK case
					PrintGAVR("ACKERROR.");
    2514:	8e e5       	ldi	r24, 0x5E	; 94
    2516:	91 e0       	ldi	r25, 0x01	; 1
    2518:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
					state=5;
    251c:	85 e0       	ldi	r24, 0x05	; 5
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	90 93 d2 01 	sts	0x01D2, r25
    2524:	80 93 d1 01 	sts	0x01D1, r24
					break;
    2528:	1a c0       	rjmp	.+52     	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				}//end case 6
				case 7:{
					//Successful grab of date/time case
					recString[0]='A';
    252a:	81 e4       	ldi	r24, 0x41	; 65
    252c:	8e a3       	lds	r24, 0x5e
					recString[1]='C';
    252e:	83 e4       	ldi	r24, 0x43	; 67
    2530:	8f a3       	lds	r24, 0x5f
					recString[2]='K';
    2532:	8b e4       	ldi	r24, 0x4B	; 75
    2534:	88 a7       	lds	r24, 0x78
					PrintGAVR(recString);
    2536:	ce 01       	movw	r24, r28
    2538:	86 96       	adiw	r24, 0x26	; 38
    253a:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
					state=5;
    253e:	85 e0       	ldi	r24, 0x05	; 5
    2540:	90 e0       	ldi	r25, 0x00	; 0
    2542:	90 93 d2 01 	sts	0x01D2, r25
    2546:	80 93 d1 01 	sts	0x01D1, r24
					break;		
    254a:	09 c0       	rjmp	.+18     	; 0x255e <_Z11ReceiveGAVRv+0x6d2>
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
    254c:	10 92 d2 01 	sts	0x01D2, r1
    2550:	10 92 d1 01 	sts	0x01D1, r1
    2554:	1c 8a       	std	Y+20, r1	; 0x14
    2556:	1b 8a       	std	Y+19, r1	; 0x13
    2558:	10 92 bb 01 	sts	0x01BB, r1
    255c:	00 00       	nop
	char recChar, recString[40];
	volatile unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	//While Loop
	while (flagReceivingGAVR){
    255e:	90 91 bb 01 	lds	r25, 0x01BB
    2562:	81 e0       	ldi	r24, 0x01	; 1
    2564:	99 23       	and	r25, r25
    2566:	09 f4       	brne	.+2      	; 0x256a <_Z11ReceiveGAVRv+0x6de>
    2568:	80 e0       	ldi	r24, 0x00	; 0
    256a:	88 23       	and	r24, r24
    256c:	09 f0       	breq	.+2      	; 0x2570 <_Z11ReceiveGAVRv+0x6e4>
    256e:	9e cc       	rjmp	.-1732   	; 0x1eac <_Z11ReceiveGAVRv+0x20>
					break;		
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
			}//end switch	
		}//end while flagReceivingGAVR	
}
    2570:	c3 5b       	subi	r28, 0xB3	; 179
    2572:	df 4f       	sbci	r29, 0xFF	; 255
    2574:	0f b6       	in	r0, 0x3f	; 63
    2576:	f8 94       	cli
    2578:	de bf       	out	0x3e, r29	; 62
    257a:	0f be       	out	0x3f, r0	; 63
    257c:	cd bf       	out	0x3d, r28	; 61
    257e:	df 91       	pop	r29
    2580:	cf 91       	pop	r28
    2582:	08 95       	ret

00002584 <_Z13printTimeDatehhh>:
/*************************************************************************************************************/
//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    2584:	cf 93       	push	r28
    2586:	df 93       	push	r29
    2588:	cd b7       	in	r28, 0x3d	; 61
    258a:	de b7       	in	r29, 0x3e	; 62
    258c:	eb 97       	sbiw	r28, 0x3b	; 59
    258e:	0f b6       	in	r0, 0x3f	; 63
    2590:	f8 94       	cli
    2592:	de bf       	out	0x3e, r29	; 62
    2594:	0f be       	out	0x3f, r0	; 63
    2596:	cd bf       	out	0x3d, r28	; 61
    2598:	89 af       	sts	0x79, r24
    259a:	6a af       	sts	0x7a, r22
    259c:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    259e:	89 ad       	sts	0x69, r24
    25a0:	88 23       	and	r24, r24
    25a2:	49 f1       	breq	.+82     	; 0x25f6 <_Z13printTimeDatehhh+0x72>
		if (pTime){
    25a4:	8a ad       	sts	0x6a, r24
    25a6:	88 23       	and	r24, r24
    25a8:	89 f0       	breq	.+34     	; 0x25cc <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    25aa:	80 e9       	ldi	r24, 0x90	; 144
    25ac:	91 e0       	ldi	r25, 0x01	; 1
    25ae:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    25b2:	9c 01       	movw	r18, r24
    25b4:	ce 01       	movw	r24, r28
    25b6:	01 96       	adiw	r24, 0x01	; 1
    25b8:	b9 01       	movw	r22, r18
    25ba:	0e 94 a4 1b 	call	0x3748	; 0x3748 <strcpy>
			PrintBone(tempTime);
    25be:	ce 01       	movw	r24, r28
    25c0:	01 96       	adiw	r24, 0x01	; 1
    25c2:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
			PutUartChBone('/');
    25c6:	8f e2       	ldi	r24, 0x2F	; 47
    25c8:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z13PutUartChBonec>
		}
		if (pDate){
    25cc:	8b ad       	sts	0x6b, r24
    25ce:	88 23       	and	r24, r24
    25d0:	d1 f1       	breq	.+116    	; 0x2646 <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    25d2:	80 e9       	ldi	r24, 0x90	; 144
    25d4:	91 e0       	ldi	r25, 0x01	; 1
    25d6:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    25da:	9c 01       	movw	r18, r24
    25dc:	ce 01       	movw	r24, r28
    25de:	0c 96       	adiw	r24, 0x0c	; 12
    25e0:	b9 01       	movw	r22, r18
    25e2:	0e 94 a4 1b 	call	0x3748	; 0x3748 <strcpy>
			PrintBone(tempDate);
    25e6:	ce 01       	movw	r24, r28
    25e8:	0c 96       	adiw	r24, 0x0c	; 12
    25ea:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
			PutUartChGAVR('.');
    25ee:	8e e2       	ldi	r24, 0x2E	; 46
    25f0:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_Z13PutUartChGAVRc>
    25f4:	28 c0       	rjmp	.+80     	; 0x2646 <_Z13printTimeDatehhh+0xc2>
		}
	} else { //Printing to GAVR
		if (pTime){
    25f6:	8a ad       	sts	0x6a, r24
    25f8:	88 23       	and	r24, r24
    25fa:	89 f0       	breq	.+34     	; 0x261e <_Z13printTimeDatehhh+0x9a>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    25fc:	80 e9       	ldi	r24, 0x90	; 144
    25fe:	91 e0       	ldi	r25, 0x01	; 1
    2600:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    2604:	9c 01       	movw	r18, r24
    2606:	ce 01       	movw	r24, r28
    2608:	4d 96       	adiw	r24, 0x1d	; 29
    260a:	b9 01       	movw	r22, r18
    260c:	0e 94 a4 1b 	call	0x3748	; 0x3748 <strcpy>
			PrintGAVR(tempTime);
    2610:	ce 01       	movw	r24, r28
    2612:	4d 96       	adiw	r24, 0x1d	; 29
    2614:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    2618:	8f e2       	ldi	r24, 0x2F	; 47
    261a:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_Z13PutUartChGAVRc>
		}
		if (pDate){
    261e:	8b ad       	sts	0x6b, r24
    2620:	88 23       	and	r24, r24
    2622:	89 f0       	breq	.+34     	; 0x2646 <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    2624:	80 e9       	ldi	r24, 0x90	; 144
    2626:	91 e0       	ldi	r25, 0x01	; 1
    2628:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    262c:	9c 01       	movw	r18, r24
    262e:	ce 01       	movw	r24, r28
    2630:	88 96       	adiw	r24, 0x28	; 40
    2632:	b9 01       	movw	r22, r18
    2634:	0e 94 a4 1b 	call	0x3748	; 0x3748 <strcpy>
			PrintGAVR(tempDate);
    2638:	ce 01       	movw	r24, r28
    263a:	88 96       	adiw	r24, 0x28	; 40
    263c:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
			PutUartChGAVR('.');
    2640:	8e e2       	ldi	r24, 0x2E	; 46
    2642:	0e 94 e3 08 	call	0x11c6	; 0x11c6 <_Z13PutUartChGAVRc>
		}
	}
}
    2646:	eb 96       	adiw	r28, 0x3b	; 59
    2648:	0f b6       	in	r0, 0x3f	; 63
    264a:	f8 94       	cli
    264c:	de bf       	out	0x3e, r29	; 62
    264e:	0f be       	out	0x3f, r0	; 63
    2650:	cd bf       	out	0x3d, r28	; 61
    2652:	df 91       	pop	r29
    2654:	cf 91       	pop	r28
    2656:	08 95       	ret

00002658 <__vector_6>:
/****************************************************************************************************************/


/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
//PCINT_17: Getting information from the GAVR
ISR(PCINT2_vect){
    2658:	1f 92       	push	r1
    265a:	0f 92       	push	r0
    265c:	0f b6       	in	r0, 0x3f	; 63
    265e:	0f 92       	push	r0
    2660:	11 24       	eor	r1, r1
    2662:	2f 93       	push	r18
    2664:	3f 93       	push	r19
    2666:	4f 93       	push	r20
    2668:	5f 93       	push	r21
    266a:	6f 93       	push	r22
    266c:	7f 93       	push	r23
    266e:	8f 93       	push	r24
    2670:	9f 93       	push	r25
    2672:	af 93       	push	r26
    2674:	bf 93       	push	r27
    2676:	ef 93       	push	r30
    2678:	ff 93       	push	r31
    267a:	cf 93       	push	r28
    267c:	df 93       	push	r29
    267e:	cd b7       	in	r28, 0x3d	; 61
    2680:	de b7       	in	r29, 0x3e	; 62
	if ((PINC & (1 << PCINT17)) && !flagShutdown){
    2682:	86 e2       	ldi	r24, 0x26	; 38
    2684:	90 e0       	ldi	r25, 0x00	; 0
    2686:	fc 01       	movw	r30, r24
    2688:	80 81       	ld	r24, Z
    268a:	88 2f       	mov	r24, r24
    268c:	90 e0       	ldi	r25, 0x00	; 0
    268e:	82 70       	andi	r24, 0x02	; 2
    2690:	90 70       	andi	r25, 0x00	; 0
    2692:	00 97       	sbiw	r24, 0x00	; 0
    2694:	31 f0       	breq	.+12     	; 0x26a2 <__vector_6+0x4a>
    2696:	80 91 c4 01 	lds	r24, 0x01C4
    269a:	88 23       	and	r24, r24
    269c:	11 f4       	brne	.+4      	; 0x26a2 <__vector_6+0x4a>
    269e:	81 e0       	ldi	r24, 0x01	; 1
    26a0:	01 c0       	rjmp	.+2      	; 0x26a4 <__vector_6+0x4c>
    26a2:	80 e0       	ldi	r24, 0x00	; 0
    26a4:	88 23       	and	r24, r24
    26a6:	c9 f0       	breq	.+50     	; 0x26da <__vector_6+0x82>
		//Do work, correct interrupt
		UCSR1B |= (1 << RXCIE1);
    26a8:	89 ec       	ldi	r24, 0xC9	; 201
    26aa:	90 e0       	ldi	r25, 0x00	; 0
    26ac:	29 ec       	ldi	r18, 0xC9	; 201
    26ae:	30 e0       	ldi	r19, 0x00	; 0
    26b0:	f9 01       	movw	r30, r18
    26b2:	20 81       	ld	r18, Z
    26b4:	20 68       	ori	r18, 0x80	; 128
    26b6:	fc 01       	movw	r30, r24
    26b8:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;
    26ba:	10 92 b8 01 	sts	0x01B8, r1
		flagNormalMode=fFalse;
    26be:	10 92 ba 01 	sts	0x01BA, r1
		__killCommINT();
    26c2:	8d e3       	ldi	r24, 0x3D	; 61
    26c4:	90 e0       	ldi	r25, 0x00	; 0
    26c6:	fc 01       	movw	r30, r24
    26c8:	10 82       	st	Z, r1
    26ca:	8d e6       	ldi	r24, 0x6D	; 109
    26cc:	90 e0       	ldi	r25, 0x00	; 0
    26ce:	fc 01       	movw	r30, r24
    26d0:	10 82       	st	Z, r1
		//Acknowledge
		PrintGAVR("ACKG");
    26d2:	81 e8       	ldi	r24, 0x81	; 129
    26d4:	91 e0       	ldi	r25, 0x01	; 1
    26d6:	0e 94 01 09 	call	0x1202	; 0x1202 <_Z9PrintGAVRPc>
	}
}	
    26da:	df 91       	pop	r29
    26dc:	cf 91       	pop	r28
    26de:	ff 91       	pop	r31
    26e0:	ef 91       	pop	r30
    26e2:	bf 91       	pop	r27
    26e4:	af 91       	pop	r26
    26e6:	9f 91       	pop	r25
    26e8:	8f 91       	pop	r24
    26ea:	7f 91       	pop	r23
    26ec:	6f 91       	pop	r22
    26ee:	5f 91       	pop	r21
    26f0:	4f 91       	pop	r20
    26f2:	3f 91       	pop	r19
    26f4:	2f 91       	pop	r18
    26f6:	0f 90       	pop	r0
    26f8:	0f be       	out	0x3f, r0	; 63
    26fa:	0f 90       	pop	r0
    26fc:	1f 90       	pop	r1
    26fe:	18 95       	reti

00002700 <__vector_3>:

//INT2: Getting information from BeagleBone
ISR(INT2_vect){	//about to get time, get things ready
    2700:	1f 92       	push	r1
    2702:	0f 92       	push	r0
    2704:	0f b6       	in	r0, 0x3f	; 63
    2706:	0f 92       	push	r0
    2708:	11 24       	eor	r1, r1
    270a:	2f 93       	push	r18
    270c:	3f 93       	push	r19
    270e:	4f 93       	push	r20
    2710:	5f 93       	push	r21
    2712:	6f 93       	push	r22
    2714:	7f 93       	push	r23
    2716:	8f 93       	push	r24
    2718:	9f 93       	push	r25
    271a:	af 93       	push	r26
    271c:	bf 93       	push	r27
    271e:	ef 93       	push	r30
    2720:	ff 93       	push	r31
    2722:	cf 93       	push	r28
    2724:	df 93       	push	r29
    2726:	cd b7       	in	r28, 0x3d	; 61
    2728:	de b7       	in	r29, 0x3e	; 62
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    272a:	80 91 c4 01 	lds	r24, 0x01C4
    272e:	88 23       	and	r24, r24
    2730:	c9 f4       	brne	.+50     	; 0x2764 <__vector_3+0x64>
		UCSR0B |= (1 << RXCIE0);
    2732:	81 ec       	ldi	r24, 0xC1	; 193
    2734:	90 e0       	ldi	r25, 0x00	; 0
    2736:	21 ec       	ldi	r18, 0xC1	; 193
    2738:	30 e0       	ldi	r19, 0x00	; 0
    273a:	f9 01       	movw	r30, r18
    273c:	20 81       	ld	r18, Z
    273e:	20 68       	ori	r18, 0x80	; 128
    2740:	fc 01       	movw	r30, r24
    2742:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    2744:	10 92 b8 01 	sts	0x01B8, r1
		flagNormalMode=fFalse;
    2748:	10 92 ba 01 	sts	0x01BA, r1
		__killCommINT();
    274c:	8d e3       	ldi	r24, 0x3D	; 61
    274e:	90 e0       	ldi	r25, 0x00	; 0
    2750:	fc 01       	movw	r30, r24
    2752:	10 82       	st	Z, r1
    2754:	8d e6       	ldi	r24, 0x6D	; 109
    2756:	90 e0       	ldi	r25, 0x00	; 0
    2758:	fc 01       	movw	r30, r24
    275a:	10 82       	st	Z, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("ACKT");
    275c:	86 e8       	ldi	r24, 0x86	; 134
    275e:	91 e0       	ldi	r25, 0x01	; 1
    2760:	0e 94 b6 08 	call	0x116c	; 0x116c <_Z9PrintBonePc>
	}	
}
    2764:	df 91       	pop	r29
    2766:	cf 91       	pop	r28
    2768:	ff 91       	pop	r31
    276a:	ef 91       	pop	r30
    276c:	bf 91       	pop	r27
    276e:	af 91       	pop	r26
    2770:	9f 91       	pop	r25
    2772:	8f 91       	pop	r24
    2774:	7f 91       	pop	r23
    2776:	6f 91       	pop	r22
    2778:	5f 91       	pop	r21
    277a:	4f 91       	pop	r20
    277c:	3f 91       	pop	r19
    277e:	2f 91       	pop	r18
    2780:	0f 90       	pop	r0
    2782:	0f be       	out	0x3f, r0	; 63
    2784:	0f 90       	pop	r0
    2786:	1f 90       	pop	r1
    2788:	18 95       	reti

0000278a <__vector_11>:

//RTC Timer.
ISR(TIMER2_OVF_vect){
    278a:	1f 92       	push	r1
    278c:	0f 92       	push	r0
    278e:	0f b6       	in	r0, 0x3f	; 63
    2790:	0f 92       	push	r0
    2792:	11 24       	eor	r1, r1
    2794:	2f 93       	push	r18
    2796:	3f 93       	push	r19
    2798:	4f 93       	push	r20
    279a:	5f 93       	push	r21
    279c:	6f 93       	push	r22
    279e:	7f 93       	push	r23
    27a0:	8f 93       	push	r24
    27a2:	9f 93       	push	r25
    27a4:	af 93       	push	r26
    27a6:	bf 93       	push	r27
    27a8:	ef 93       	push	r30
    27aa:	ff 93       	push	r31
    27ac:	cf 93       	push	r28
    27ae:	df 93       	push	r29
    27b0:	cd b7       	in	r28, 0x3d	; 61
    27b2:	de b7       	in	r29, 0x3e	; 62
	volatile static int gavrSendTimeout=0, boneReceiveTimeout=0, gavrReceiveTimeout=0, startupTimeout=0;
	
	currentTime.addSeconds(1);
    27b4:	80 e9       	ldi	r24, 0x90	; 144
    27b6:	91 e0       	ldi	r25, 0x01	; 1
    27b8:	61 e0       	ldi	r22, 0x01	; 1
    27ba:	70 e0       	ldi	r23, 0x00	; 0
    27bc:	0e 94 72 06 	call	0xce4	; 0xce4 <_ZN6myTime10addSecondsEi>
	
	//GAVR Transmission Timeout
	if (flagSendingGAVR && gavrSendTimeout <=COMM_TIMEOUT_SEC){gavrSendTimeout++;}
    27c0:	80 91 be 01 	lds	r24, 0x01BE
    27c4:	88 23       	and	r24, r24
    27c6:	49 f0       	breq	.+18     	; 0x27da <__vector_11+0x50>
    27c8:	80 91 c9 01 	lds	r24, 0x01C9
    27cc:	90 91 ca 01 	lds	r25, 0x01CA
    27d0:	84 30       	cpi	r24, 0x04	; 4
    27d2:	91 05       	cpc	r25, r1
    27d4:	14 f4       	brge	.+4      	; 0x27da <__vector_11+0x50>
    27d6:	81 e0       	ldi	r24, 0x01	; 1
    27d8:	01 c0       	rjmp	.+2      	; 0x27dc <__vector_11+0x52>
    27da:	80 e0       	ldi	r24, 0x00	; 0
    27dc:	88 23       	and	r24, r24
    27de:	51 f0       	breq	.+20     	; 0x27f4 <__vector_11+0x6a>
    27e0:	80 91 c9 01 	lds	r24, 0x01C9
    27e4:	90 91 ca 01 	lds	r25, 0x01CA
    27e8:	01 96       	adiw	r24, 0x01	; 1
    27ea:	90 93 ca 01 	sts	0x01CA, r25
    27ee:	80 93 c9 01 	sts	0x01C9, r24
    27f2:	39 c0       	rjmp	.+114    	; 0x2866 <__vector_11+0xdc>
	else if (flagSendingGAVR && gavrSendTimeout > COMM_TIMEOUT_SEC){flagSendingGAVR=fFalse; gavrSendTimeout=0; __enableCommINT();}
    27f4:	80 91 be 01 	lds	r24, 0x01BE
    27f8:	88 23       	and	r24, r24
    27fa:	49 f0       	breq	.+18     	; 0x280e <__vector_11+0x84>
    27fc:	80 91 c9 01 	lds	r24, 0x01C9
    2800:	90 91 ca 01 	lds	r25, 0x01CA
    2804:	84 30       	cpi	r24, 0x04	; 4
    2806:	91 05       	cpc	r25, r1
    2808:	14 f0       	brlt	.+4      	; 0x280e <__vector_11+0x84>
    280a:	81 e0       	ldi	r24, 0x01	; 1
    280c:	01 c0       	rjmp	.+2      	; 0x2810 <__vector_11+0x86>
    280e:	80 e0       	ldi	r24, 0x00	; 0
    2810:	88 23       	and	r24, r24
    2812:	a9 f0       	breq	.+42     	; 0x283e <__vector_11+0xb4>
    2814:	10 92 be 01 	sts	0x01BE, r1
    2818:	10 92 ca 01 	sts	0x01CA, r1
    281c:	10 92 c9 01 	sts	0x01C9, r1
    2820:	8d e3       	ldi	r24, 0x3D	; 61
    2822:	90 e0       	ldi	r25, 0x00	; 0
    2824:	2d e3       	ldi	r18, 0x3D	; 61
    2826:	30 e0       	ldi	r19, 0x00	; 0
    2828:	f9 01       	movw	r30, r18
    282a:	20 81       	ld	r18, Z
    282c:	24 60       	ori	r18, 0x04	; 4
    282e:	fc 01       	movw	r30, r24
    2830:	20 83       	st	Z, r18
    2832:	8d e6       	ldi	r24, 0x6D	; 109
    2834:	90 e0       	ldi	r25, 0x00	; 0
    2836:	22 e0       	ldi	r18, 0x02	; 2
    2838:	fc 01       	movw	r30, r24
    283a:	20 83       	st	Z, r18
    283c:	14 c0       	rjmp	.+40     	; 0x2866 <__vector_11+0xdc>
	else if (!flagSendingGAVR && gavrSendTimeout > 0){gavrSendTimeout=0;}
    283e:	80 91 be 01 	lds	r24, 0x01BE
    2842:	88 23       	and	r24, r24
    2844:	49 f4       	brne	.+18     	; 0x2858 <__vector_11+0xce>
    2846:	80 91 c9 01 	lds	r24, 0x01C9
    284a:	90 91 ca 01 	lds	r25, 0x01CA
    284e:	18 16       	cp	r1, r24
    2850:	19 06       	cpc	r1, r25
    2852:	14 f4       	brge	.+4      	; 0x2858 <__vector_11+0xce>
    2854:	81 e0       	ldi	r24, 0x01	; 1
    2856:	01 c0       	rjmp	.+2      	; 0x285a <__vector_11+0xd0>
    2858:	80 e0       	ldi	r24, 0x00	; 0
    285a:	88 23       	and	r24, r24
    285c:	21 f0       	breq	.+8      	; 0x2866 <__vector_11+0xdc>
    285e:	10 92 ca 01 	sts	0x01CA, r1
    2862:	10 92 c9 01 	sts	0x01C9, r1
	else;
	
	//BeagleBone Reception Timeout
	if (flagReceivingBone && boneReceiveTimeout <=COMM_TIMEOUT_SEC){boneReceiveTimeout++;}
    2866:	80 91 b9 01 	lds	r24, 0x01B9
    286a:	88 23       	and	r24, r24
    286c:	49 f0       	breq	.+18     	; 0x2880 <__vector_11+0xf6>
    286e:	80 91 cb 01 	lds	r24, 0x01CB
    2872:	90 91 cc 01 	lds	r25, 0x01CC
    2876:	84 30       	cpi	r24, 0x04	; 4
    2878:	91 05       	cpc	r25, r1
    287a:	14 f4       	brge	.+4      	; 0x2880 <__vector_11+0xf6>
    287c:	81 e0       	ldi	r24, 0x01	; 1
    287e:	01 c0       	rjmp	.+2      	; 0x2882 <__vector_11+0xf8>
    2880:	80 e0       	ldi	r24, 0x00	; 0
    2882:	88 23       	and	r24, r24
    2884:	51 f0       	breq	.+20     	; 0x289a <__vector_11+0x110>
    2886:	80 91 cb 01 	lds	r24, 0x01CB
    288a:	90 91 cc 01 	lds	r25, 0x01CC
    288e:	01 96       	adiw	r24, 0x01	; 1
    2890:	90 93 cc 01 	sts	0x01CC, r25
    2894:	80 93 cb 01 	sts	0x01CB, r24
    2898:	39 c0       	rjmp	.+114    	; 0x290c <__vector_11+0x182>
	else if (flagReceivingBone && boneReceiveTimeout > COMM_TIMEOUT_SEC){flagReceivingBone=fFalse; boneReceiveTimeout=0; __enableCommINT();}
    289a:	80 91 b9 01 	lds	r24, 0x01B9
    289e:	88 23       	and	r24, r24
    28a0:	49 f0       	breq	.+18     	; 0x28b4 <__vector_11+0x12a>
    28a2:	80 91 cb 01 	lds	r24, 0x01CB
    28a6:	90 91 cc 01 	lds	r25, 0x01CC
    28aa:	84 30       	cpi	r24, 0x04	; 4
    28ac:	91 05       	cpc	r25, r1
    28ae:	14 f0       	brlt	.+4      	; 0x28b4 <__vector_11+0x12a>
    28b0:	81 e0       	ldi	r24, 0x01	; 1
    28b2:	01 c0       	rjmp	.+2      	; 0x28b6 <__vector_11+0x12c>
    28b4:	80 e0       	ldi	r24, 0x00	; 0
    28b6:	88 23       	and	r24, r24
    28b8:	a9 f0       	breq	.+42     	; 0x28e4 <__vector_11+0x15a>
    28ba:	10 92 b9 01 	sts	0x01B9, r1
    28be:	10 92 cc 01 	sts	0x01CC, r1
    28c2:	10 92 cb 01 	sts	0x01CB, r1
    28c6:	8d e3       	ldi	r24, 0x3D	; 61
    28c8:	90 e0       	ldi	r25, 0x00	; 0
    28ca:	2d e3       	ldi	r18, 0x3D	; 61
    28cc:	30 e0       	ldi	r19, 0x00	; 0
    28ce:	f9 01       	movw	r30, r18
    28d0:	20 81       	ld	r18, Z
    28d2:	24 60       	ori	r18, 0x04	; 4
    28d4:	fc 01       	movw	r30, r24
    28d6:	20 83       	st	Z, r18
    28d8:	8d e6       	ldi	r24, 0x6D	; 109
    28da:	90 e0       	ldi	r25, 0x00	; 0
    28dc:	22 e0       	ldi	r18, 0x02	; 2
    28de:	fc 01       	movw	r30, r24
    28e0:	20 83       	st	Z, r18
    28e2:	14 c0       	rjmp	.+40     	; 0x290c <__vector_11+0x182>
	else if (!flagReceivingBone && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    28e4:	80 91 b9 01 	lds	r24, 0x01B9
    28e8:	88 23       	and	r24, r24
    28ea:	49 f4       	brne	.+18     	; 0x28fe <__vector_11+0x174>
    28ec:	80 91 cb 01 	lds	r24, 0x01CB
    28f0:	90 91 cc 01 	lds	r25, 0x01CC
    28f4:	18 16       	cp	r1, r24
    28f6:	19 06       	cpc	r1, r25
    28f8:	14 f4       	brge	.+4      	; 0x28fe <__vector_11+0x174>
    28fa:	81 e0       	ldi	r24, 0x01	; 1
    28fc:	01 c0       	rjmp	.+2      	; 0x2900 <__vector_11+0x176>
    28fe:	80 e0       	ldi	r24, 0x00	; 0
    2900:	88 23       	and	r24, r24
    2902:	21 f0       	breq	.+8      	; 0x290c <__vector_11+0x182>
    2904:	10 92 cc 01 	sts	0x01CC, r1
    2908:	10 92 cb 01 	sts	0x01CB, r1
	else;
	
	//GAVR Reception Timeout
	if (flagReceivingGAVR && gavrReceiveTimeout <= COMM_TIMEOUT_SEC){gavrReceiveTimeout++;}
    290c:	80 91 bb 01 	lds	r24, 0x01BB
    2910:	88 23       	and	r24, r24
    2912:	49 f0       	breq	.+18     	; 0x2926 <__vector_11+0x19c>
    2914:	80 91 cd 01 	lds	r24, 0x01CD
    2918:	90 91 ce 01 	lds	r25, 0x01CE
    291c:	84 30       	cpi	r24, 0x04	; 4
    291e:	91 05       	cpc	r25, r1
    2920:	14 f4       	brge	.+4      	; 0x2926 <__vector_11+0x19c>
    2922:	81 e0       	ldi	r24, 0x01	; 1
    2924:	01 c0       	rjmp	.+2      	; 0x2928 <__vector_11+0x19e>
    2926:	80 e0       	ldi	r24, 0x00	; 0
    2928:	88 23       	and	r24, r24
    292a:	51 f0       	breq	.+20     	; 0x2940 <__vector_11+0x1b6>
    292c:	80 91 cd 01 	lds	r24, 0x01CD
    2930:	90 91 ce 01 	lds	r25, 0x01CE
    2934:	01 96       	adiw	r24, 0x01	; 1
    2936:	90 93 ce 01 	sts	0x01CE, r25
    293a:	80 93 cd 01 	sts	0x01CD, r24
    293e:	39 c0       	rjmp	.+114    	; 0x29b2 <__vector_11+0x228>
	else if (flagReceivingGAVR && gavrReceiveTimeout > COMM_TIMEOUT_SEC){flagReceivingGAVR=fFalse; boneReceiveTimeout=0; __enableCommINT();}
    2940:	80 91 bb 01 	lds	r24, 0x01BB
    2944:	88 23       	and	r24, r24
    2946:	49 f0       	breq	.+18     	; 0x295a <__vector_11+0x1d0>
    2948:	80 91 cd 01 	lds	r24, 0x01CD
    294c:	90 91 ce 01 	lds	r25, 0x01CE
    2950:	84 30       	cpi	r24, 0x04	; 4
    2952:	91 05       	cpc	r25, r1
    2954:	14 f0       	brlt	.+4      	; 0x295a <__vector_11+0x1d0>
    2956:	81 e0       	ldi	r24, 0x01	; 1
    2958:	01 c0       	rjmp	.+2      	; 0x295c <__vector_11+0x1d2>
    295a:	80 e0       	ldi	r24, 0x00	; 0
    295c:	88 23       	and	r24, r24
    295e:	a9 f0       	breq	.+42     	; 0x298a <__vector_11+0x200>
    2960:	10 92 bb 01 	sts	0x01BB, r1
    2964:	10 92 cc 01 	sts	0x01CC, r1
    2968:	10 92 cb 01 	sts	0x01CB, r1
    296c:	8d e3       	ldi	r24, 0x3D	; 61
    296e:	90 e0       	ldi	r25, 0x00	; 0
    2970:	2d e3       	ldi	r18, 0x3D	; 61
    2972:	30 e0       	ldi	r19, 0x00	; 0
    2974:	f9 01       	movw	r30, r18
    2976:	20 81       	ld	r18, Z
    2978:	24 60       	ori	r18, 0x04	; 4
    297a:	fc 01       	movw	r30, r24
    297c:	20 83       	st	Z, r18
    297e:	8d e6       	ldi	r24, 0x6D	; 109
    2980:	90 e0       	ldi	r25, 0x00	; 0
    2982:	22 e0       	ldi	r18, 0x02	; 2
    2984:	fc 01       	movw	r30, r24
    2986:	20 83       	st	Z, r18
    2988:	14 c0       	rjmp	.+40     	; 0x29b2 <__vector_11+0x228>
	else if (!flagReceivingGAVR && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    298a:	80 91 bb 01 	lds	r24, 0x01BB
    298e:	88 23       	and	r24, r24
    2990:	49 f4       	brne	.+18     	; 0x29a4 <__vector_11+0x21a>
    2992:	80 91 cb 01 	lds	r24, 0x01CB
    2996:	90 91 cc 01 	lds	r25, 0x01CC
    299a:	18 16       	cp	r1, r24
    299c:	19 06       	cpc	r1, r25
    299e:	14 f4       	brge	.+4      	; 0x29a4 <__vector_11+0x21a>
    29a0:	81 e0       	ldi	r24, 0x01	; 1
    29a2:	01 c0       	rjmp	.+2      	; 0x29a6 <__vector_11+0x21c>
    29a4:	80 e0       	ldi	r24, 0x00	; 0
    29a6:	88 23       	and	r24, r24
    29a8:	21 f0       	breq	.+8      	; 0x29b2 <__vector_11+0x228>
    29aa:	10 92 cc 01 	sts	0x01CC, r1
    29ae:	10 92 cb 01 	sts	0x01CB, r1
	else;

	//Startup Tiemout for sending clock to GAVR
	if ((flagFreshStart || restart) && startupTimeout <= STARTUP_TIMEOUT_SEC){startupTimeout++;}
    29b2:	80 91 c8 01 	lds	r24, 0x01C8
    29b6:	88 23       	and	r24, r24
    29b8:	21 f4       	brne	.+8      	; 0x29c2 <__vector_11+0x238>
    29ba:	80 91 c7 01 	lds	r24, 0x01C7
    29be:	88 23       	and	r24, r24
    29c0:	49 f0       	breq	.+18     	; 0x29d4 <__vector_11+0x24a>
    29c2:	80 91 cf 01 	lds	r24, 0x01CF
    29c6:	90 91 d0 01 	lds	r25, 0x01D0
    29ca:	89 32       	cpi	r24, 0x29	; 41
    29cc:	91 05       	cpc	r25, r1
    29ce:	14 f4       	brge	.+4      	; 0x29d4 <__vector_11+0x24a>
    29d0:	81 e0       	ldi	r24, 0x01	; 1
    29d2:	01 c0       	rjmp	.+2      	; 0x29d6 <__vector_11+0x24c>
    29d4:	80 e0       	ldi	r24, 0x00	; 0
    29d6:	88 23       	and	r24, r24
    29d8:	51 f0       	breq	.+20     	; 0x29ee <__vector_11+0x264>
    29da:	80 91 cf 01 	lds	r24, 0x01CF
    29de:	90 91 d0 01 	lds	r25, 0x01D0
    29e2:	01 96       	adiw	r24, 0x01	; 1
    29e4:	90 93 d0 01 	sts	0x01D0, r25
    29e8:	80 93 cf 01 	sts	0x01CF, r24
    29ec:	56 c0       	rjmp	.+172    	; 0x2a9a <__vector_11+0x310>
	else if ((flagFreshStart || restart) && startupTimeout > STARTUP_TIMEOUT_SEC){
    29ee:	80 91 c8 01 	lds	r24, 0x01C8
    29f2:	88 23       	and	r24, r24
    29f4:	21 f4       	brne	.+8      	; 0x29fe <__vector_11+0x274>
    29f6:	80 91 c7 01 	lds	r24, 0x01C7
    29fa:	88 23       	and	r24, r24
    29fc:	49 f0       	breq	.+18     	; 0x2a10 <__vector_11+0x286>
    29fe:	80 91 cf 01 	lds	r24, 0x01CF
    2a02:	90 91 d0 01 	lds	r25, 0x01D0
    2a06:	89 32       	cpi	r24, 0x29	; 41
    2a08:	91 05       	cpc	r25, r1
    2a0a:	14 f0       	brlt	.+4      	; 0x2a10 <__vector_11+0x286>
    2a0c:	81 e0       	ldi	r24, 0x01	; 1
    2a0e:	01 c0       	rjmp	.+2      	; 0x2a12 <__vector_11+0x288>
    2a10:	80 e0       	ldi	r24, 0x00	; 0
    2a12:	88 23       	and	r24, r24
    2a14:	51 f1       	breq	.+84     	; 0x2a6a <__vector_11+0x2e0>
		if (flagFreshStart){flagFreshStart=fFalse; flagUserClock=fTrue; flagUpdateGAVRClock=fFalse;}	//The GPS didn't send valid data, get user clock.
    2a16:	80 91 c8 01 	lds	r24, 0x01C8
    2a1a:	88 23       	and	r24, r24
    2a1c:	41 f0       	breq	.+16     	; 0x2a2e <__vector_11+0x2a4>
    2a1e:	10 92 c8 01 	sts	0x01C8, r1
    2a22:	81 e0       	ldi	r24, 0x01	; 1
    2a24:	80 93 bf 01 	sts	0x01BF, r24
    2a28:	10 92 bd 01 	sts	0x01BD, r1
    2a2c:	0b c0       	rjmp	.+22     	; 0x2a44 <__vector_11+0x2ba>
		else if (restart){restart=fFalse; flagUserClock=fFalse; flagUpdateGAVRClock=fTrue;}				//Gps didn't send valid data, we have valid data. This is redundant to the main
    2a2e:	80 91 c7 01 	lds	r24, 0x01C7
    2a32:	88 23       	and	r24, r24
    2a34:	39 f0       	breq	.+14     	; 0x2a44 <__vector_11+0x2ba>
    2a36:	10 92 c7 01 	sts	0x01C7, r1
    2a3a:	10 92 bf 01 	sts	0x01BF, r1
    2a3e:	81 e0       	ldi	r24, 0x01	; 1
    2a40:	80 93 bd 01 	sts	0x01BD, r24
		__enableCommINT();																				//--procedure that depends on "if (restart)"
    2a44:	8d e3       	ldi	r24, 0x3D	; 61
    2a46:	90 e0       	ldi	r25, 0x00	; 0
    2a48:	2d e3       	ldi	r18, 0x3D	; 61
    2a4a:	30 e0       	ldi	r19, 0x00	; 0
    2a4c:	f9 01       	movw	r30, r18
    2a4e:	20 81       	ld	r18, Z
    2a50:	24 60       	ori	r18, 0x04	; 4
    2a52:	fc 01       	movw	r30, r24
    2a54:	20 83       	st	Z, r18
    2a56:	8d e6       	ldi	r24, 0x6D	; 109
    2a58:	90 e0       	ldi	r25, 0x00	; 0
    2a5a:	22 e0       	ldi	r18, 0x02	; 2
    2a5c:	fc 01       	movw	r30, r24
    2a5e:	20 83       	st	Z, r18
		startupTimeout=0;
    2a60:	10 92 d0 01 	sts	0x01D0, r1
    2a64:	10 92 cf 01 	sts	0x01CF, r1
    2a68:	18 c0       	rjmp	.+48     	; 0x2a9a <__vector_11+0x310>
	} else if (!(flagFreshStart || restart) && startupTimeout > 0){startupTimeout=0;}
    2a6a:	80 91 c8 01 	lds	r24, 0x01C8
    2a6e:	88 23       	and	r24, r24
    2a70:	69 f4       	brne	.+26     	; 0x2a8c <__vector_11+0x302>
    2a72:	80 91 c7 01 	lds	r24, 0x01C7
    2a76:	88 23       	and	r24, r24
    2a78:	49 f4       	brne	.+18     	; 0x2a8c <__vector_11+0x302>
    2a7a:	80 91 cf 01 	lds	r24, 0x01CF
    2a7e:	90 91 d0 01 	lds	r25, 0x01D0
    2a82:	18 16       	cp	r1, r24
    2a84:	19 06       	cpc	r1, r25
    2a86:	14 f4       	brge	.+4      	; 0x2a8c <__vector_11+0x302>
    2a88:	81 e0       	ldi	r24, 0x01	; 1
    2a8a:	01 c0       	rjmp	.+2      	; 0x2a8e <__vector_11+0x304>
    2a8c:	80 e0       	ldi	r24, 0x00	; 0
    2a8e:	88 23       	and	r24, r24
    2a90:	21 f0       	breq	.+8      	; 0x2a9a <__vector_11+0x310>
    2a92:	10 92 d0 01 	sts	0x01D0, r1
    2a96:	10 92 cf 01 	sts	0x01CF, r1
	else;
}//End timer 2 overflow.
    2a9a:	df 91       	pop	r29
    2a9c:	cf 91       	pop	r28
    2a9e:	ff 91       	pop	r31
    2aa0:	ef 91       	pop	r30
    2aa2:	bf 91       	pop	r27
    2aa4:	af 91       	pop	r26
    2aa6:	9f 91       	pop	r25
    2aa8:	8f 91       	pop	r24
    2aaa:	7f 91       	pop	r23
    2aac:	6f 91       	pop	r22
    2aae:	5f 91       	pop	r21
    2ab0:	4f 91       	pop	r20
    2ab2:	3f 91       	pop	r19
    2ab4:	2f 91       	pop	r18
    2ab6:	0f 90       	pop	r0
    2ab8:	0f be       	out	0x3f, r0	; 63
    2aba:	0f 90       	pop	r0
    2abc:	1f 90       	pop	r1
    2abe:	18 95       	reti

00002ac0 <__vector_20>:

//UART Receive from BeagleBone
ISR(USART0_RX_vect){
    2ac0:	1f 92       	push	r1
    2ac2:	0f 92       	push	r0
    2ac4:	0f b6       	in	r0, 0x3f	; 63
    2ac6:	0f 92       	push	r0
    2ac8:	11 24       	eor	r1, r1
    2aca:	2f 93       	push	r18
    2acc:	3f 93       	push	r19
    2ace:	8f 93       	push	r24
    2ad0:	9f 93       	push	r25
    2ad2:	ef 93       	push	r30
    2ad4:	ff 93       	push	r31
    2ad6:	cf 93       	push	r28
    2ad8:	df 93       	push	r29
    2ada:	cd b7       	in	r28, 0x3d	; 61
    2adc:	de b7       	in	r29, 0x3e	; 62
	UCSR0B &= ~(1 << RXCIE0);
    2ade:	81 ec       	ldi	r24, 0xC1	; 193
    2ae0:	90 e0       	ldi	r25, 0x00	; 0
    2ae2:	21 ec       	ldi	r18, 0xC1	; 193
    2ae4:	30 e0       	ldi	r19, 0x00	; 0
    2ae6:	f9 01       	movw	r30, r18
    2ae8:	20 81       	ld	r18, Z
    2aea:	2f 77       	andi	r18, 0x7F	; 127
    2aec:	fc 01       	movw	r30, r24
    2aee:	20 83       	st	Z, r18
	__killCommINT();				//make sure all interrupts are disabled that could cripple protocol
    2af0:	8d e3       	ldi	r24, 0x3D	; 61
    2af2:	90 e0       	ldi	r25, 0x00	; 0
    2af4:	fc 01       	movw	r30, r24
    2af6:	10 82       	st	Z, r1
    2af8:	8d e6       	ldi	r24, 0x6D	; 109
    2afa:	90 e0       	ldi	r25, 0x00	; 0
    2afc:	fc 01       	movw	r30, r24
    2afe:	10 82       	st	Z, r1
	flagReceivingBone=fTrue;
    2b00:	81 e0       	ldi	r24, 0x01	; 1
    2b02:	80 93 b9 01 	sts	0x01B9, r24
}
    2b06:	df 91       	pop	r29
    2b08:	cf 91       	pop	r28
    2b0a:	ff 91       	pop	r31
    2b0c:	ef 91       	pop	r30
    2b0e:	9f 91       	pop	r25
    2b10:	8f 91       	pop	r24
    2b12:	3f 91       	pop	r19
    2b14:	2f 91       	pop	r18
    2b16:	0f 90       	pop	r0
    2b18:	0f be       	out	0x3f, r0	; 63
    2b1a:	0f 90       	pop	r0
    2b1c:	1f 90       	pop	r1
    2b1e:	18 95       	reti

00002b20 <__vector_28>:

ISR(USART1_RX_vect){
    2b20:	1f 92       	push	r1
    2b22:	0f 92       	push	r0
    2b24:	0f b6       	in	r0, 0x3f	; 63
    2b26:	0f 92       	push	r0
    2b28:	11 24       	eor	r1, r1
    2b2a:	2f 93       	push	r18
    2b2c:	3f 93       	push	r19
    2b2e:	8f 93       	push	r24
    2b30:	9f 93       	push	r25
    2b32:	ef 93       	push	r30
    2b34:	ff 93       	push	r31
    2b36:	cf 93       	push	r28
    2b38:	df 93       	push	r29
    2b3a:	cd b7       	in	r28, 0x3d	; 61
    2b3c:	de b7       	in	r29, 0x3e	; 62
	UCSR1B &= ~(1 <<RXCIE1);	//disable interrupt
    2b3e:	89 ec       	ldi	r24, 0xC9	; 201
    2b40:	90 e0       	ldi	r25, 0x00	; 0
    2b42:	29 ec       	ldi	r18, 0xC9	; 201
    2b44:	30 e0       	ldi	r19, 0x00	; 0
    2b46:	f9 01       	movw	r30, r18
    2b48:	20 81       	ld	r18, Z
    2b4a:	2f 77       	andi	r18, 0x7F	; 127
    2b4c:	fc 01       	movw	r30, r24
    2b4e:	20 83       	st	Z, r18
	__killCommINT();
    2b50:	8d e3       	ldi	r24, 0x3D	; 61
    2b52:	90 e0       	ldi	r25, 0x00	; 0
    2b54:	fc 01       	movw	r30, r24
    2b56:	10 82       	st	Z, r1
    2b58:	8d e6       	ldi	r24, 0x6D	; 109
    2b5a:	90 e0       	ldi	r25, 0x00	; 0
    2b5c:	fc 01       	movw	r30, r24
    2b5e:	10 82       	st	Z, r1
	flagReceivingGAVR=fTrue;
    2b60:	81 e0       	ldi	r24, 0x01	; 1
    2b62:	80 93 bb 01 	sts	0x01BB, r24
}
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	ff 91       	pop	r31
    2b6c:	ef 91       	pop	r30
    2b6e:	9f 91       	pop	r25
    2b70:	8f 91       	pop	r24
    2b72:	3f 91       	pop	r19
    2b74:	2f 91       	pop	r18
    2b76:	0f 90       	pop	r0
    2b78:	0f be       	out	0x3f, r0	; 63
    2b7a:	0f 90       	pop	r0
    2b7c:	1f 90       	pop	r1
    2b7e:	18 95       	reti

00002b80 <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    2b80:	cf 93       	push	r28
    2b82:	df 93       	push	r29
    2b84:	cd b7       	in	r28, 0x3d	; 61
    2b86:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    2b88:	0e 94 08 17 	call	0x2e10	; 0x2e10 <_Z10DeviceInitv>
	AppInit(MYUBRR);
    2b8c:	81 e8       	ldi	r24, 0x81	; 129
    2b8e:	90 e0       	ldi	r25, 0x00	; 0
    2b90:	0e 94 2f 17 	call	0x2e5e	; 0x2e5e <_Z7AppInitj>
	EnableRTCTimer();
    2b94:	0e 94 3c 18 	call	0x3078	; 0x3078 <_Z14EnableRTCTimerv>
	getDateTime_eeprom(fTrue,fTrue);
    2b98:	81 e0       	ldi	r24, 0x01	; 1
    2b9a:	61 e0       	ldi	r22, 0x01	; 1
    2b9c:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z18getDateTime_eepromhh>
	sei();
    2ba0:	78 94       	sei
	//Prep/make sure power/temp is good
	GetTemp();
    2ba2:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_Z7GetTempv>
	//flagGoodTemp=fTrue;
	TakeADC();
    2ba6:	0e 94 60 19 	call	0x32c0	; 0x32c0 <_Z7TakeADCv>
	if (flagGoodVolts && flagGoodTemp){				//Good to power on system
    2baa:	80 91 c6 01 	lds	r24, 0x01C6
    2bae:	88 23       	and	r24, r24
    2bb0:	e1 f0       	breq	.+56     	; 0x2bea <main+0x6a>
    2bb2:	80 91 c5 01 	lds	r24, 0x01C5
    2bb6:	88 23       	and	r24, r24
    2bb8:	c1 f0       	breq	.+48     	; 0x2bea <main+0x6a>
		__enableCommINT();
    2bba:	8d e3       	ldi	r24, 0x3D	; 61
    2bbc:	90 e0       	ldi	r25, 0x00	; 0
    2bbe:	2d e3       	ldi	r18, 0x3D	; 61
    2bc0:	30 e0       	ldi	r19, 0x00	; 0
    2bc2:	f9 01       	movw	r30, r18
    2bc4:	20 81       	ld	r18, Z
    2bc6:	24 60       	ori	r18, 0x04	; 4
    2bc8:	fc 01       	movw	r30, r24
    2bca:	20 83       	st	Z, r18
    2bcc:	8d e6       	ldi	r24, 0x6D	; 109
    2bce:	90 e0       	ldi	r25, 0x00	; 0
    2bd0:	22 e0       	ldi	r18, 0x02	; 2
    2bd2:	fc 01       	movw	r30, r24
    2bd4:	20 83       	st	Z, r18
		PowerUp(POWER_UP_INTERVAL);
    2bd6:	88 eb       	ldi	r24, 0xB8	; 184
    2bd8:	9b e0       	ldi	r25, 0x0B	; 11
    2bda:	0e 94 83 1a 	call	0x3506	; 0x3506 <_Z7PowerUpj>
		flagFreshStart=fTrue;
    2bde:	81 e0       	ldi	r24, 0x01	; 1
    2be0:	80 93 c8 01 	sts	0x01C8, r24
		flagShutdown=fFalse;
    2be4:	10 92 c4 01 	sts	0x01C4, r1
    2be8:	12 c0       	rjmp	.+36     	; 0x2c0e <main+0x8e>
	} else {										//Something isn't right, don't power on the system.
		__killCommINT();
    2bea:	8d e3       	ldi	r24, 0x3D	; 61
    2bec:	90 e0       	ldi	r25, 0x00	; 0
    2bee:	fc 01       	movw	r30, r24
    2bf0:	10 82       	st	Z, r1
    2bf2:	8d e6       	ldi	r24, 0x6D	; 109
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	fc 01       	movw	r30, r24
    2bf8:	10 82       	st	Z, r1
		flagNormalMode=fTrue;
    2bfa:	81 e0       	ldi	r24, 0x01	; 1
    2bfc:	80 93 ba 01 	sts	0x01BA, r24
		flagShutdown=fTrue;
    2c00:	81 e0       	ldi	r24, 0x01	; 1
    2c02:	80 93 c4 01 	sts	0x01C4, r24
		flagFreshStart=fFalse;
    2c06:	10 92 c8 01 	sts	0x01C8, r1
    2c0a:	01 c0       	rjmp	.+2      	; 0x2c0e <main+0x8e>
	}
		
	//main programming loop
	while(fTrue)
    2c0c:	00 00       	nop
	{				
		//If receiving UART string, go get rest of it.
		if (flagReceivingBone){
    2c0e:	80 91 b9 01 	lds	r24, 0x01B9
    2c12:	88 23       	and	r24, r24
    2c14:	d1 f0       	breq	.+52     	; 0x2c4a <main+0xca>
			ReceiveBone();
    2c16:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <_Z11ReceiveBonev>
			__enableCommINT();
    2c1a:	8d e3       	ldi	r24, 0x3D	; 61
    2c1c:	90 e0       	ldi	r25, 0x00	; 0
    2c1e:	2d e3       	ldi	r18, 0x3D	; 61
    2c20:	30 e0       	ldi	r19, 0x00	; 0
    2c22:	f9 01       	movw	r30, r18
    2c24:	20 81       	ld	r18, Z
    2c26:	24 60       	ori	r18, 0x04	; 4
    2c28:	fc 01       	movw	r30, r24
    2c2a:	20 83       	st	Z, r18
    2c2c:	8d e6       	ldi	r24, 0x6D	; 109
    2c2e:	90 e0       	ldi	r25, 0x00	; 0
    2c30:	22 e0       	ldi	r18, 0x02	; 2
    2c32:	fc 01       	movw	r30, r24
    2c34:	20 83       	st	Z, r18
			if (!flagReceivingGAVR){		//Just in case there was an interrupt IMMEDIATELY after the enabling of Communication interrupts
    2c36:	80 91 bb 01 	lds	r24, 0x01BB
    2c3a:	88 23       	and	r24, r24
    2c3c:	31 f4       	brne	.+12     	; 0x2c4a <main+0xca>
				flagGoToSleep=fTrue;
    2c3e:	81 e0       	ldi	r24, 0x01	; 1
    2c40:	80 93 b8 01 	sts	0x01B8, r24
				flagNormalMode=fTrue;
    2c44:	81 e0       	ldi	r24, 0x01	; 1
    2c46:	80 93 ba 01 	sts	0x01BA, r24
			}			
		}//end flag Receiving from Bone 
		
		//Receiving Data/Signals from GAVR
		if (flagReceivingGAVR){
    2c4a:	80 91 bb 01 	lds	r24, 0x01BB
    2c4e:	88 23       	and	r24, r24
    2c50:	d1 f0       	breq	.+52     	; 0x2c86 <main+0x106>
			ReceiveGAVR();
    2c52:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <_Z11ReceiveGAVRv>
			__enableCommINT();
    2c56:	8d e3       	ldi	r24, 0x3D	; 61
    2c58:	90 e0       	ldi	r25, 0x00	; 0
    2c5a:	2d e3       	ldi	r18, 0x3D	; 61
    2c5c:	30 e0       	ldi	r19, 0x00	; 0
    2c5e:	f9 01       	movw	r30, r18
    2c60:	20 81       	ld	r18, Z
    2c62:	24 60       	ori	r18, 0x04	; 4
    2c64:	fc 01       	movw	r30, r24
    2c66:	20 83       	st	Z, r18
    2c68:	8d e6       	ldi	r24, 0x6D	; 109
    2c6a:	90 e0       	ldi	r25, 0x00	; 0
    2c6c:	22 e0       	ldi	r18, 0x02	; 2
    2c6e:	fc 01       	movw	r30, r24
    2c70:	20 83       	st	Z, r18
			if (!flagReceivingBone){		//Just in case there was an interrupt IMMEDIATELY after the enabling of Communication interrupts
    2c72:	80 91 b9 01 	lds	r24, 0x01B9
    2c76:	88 23       	and	r24, r24
    2c78:	31 f4       	brne	.+12     	; 0x2c86 <main+0x106>
				flagGoToSleep=fTrue;
    2c7a:	81 e0       	ldi	r24, 0x01	; 1
    2c7c:	80 93 b8 01 	sts	0x01B8, r24
				flagNormalMode=fTrue;
    2c80:	81 e0       	ldi	r24, 0x01	; 1
    2c82:	80 93 ba 01 	sts	0x01BA, r24
			}			
		}//end flag Receiving from GAVR case
		
	
		//Communication with GAVR. Either updating the date/time on it or asking for date and time. The internal send machine deals with the flags.
		if ((flagUpdateGAVRClock  || flagUserClock) && !flagWaitingForReceiveGAVR){
    2c86:	80 91 bd 01 	lds	r24, 0x01BD
    2c8a:	88 23       	and	r24, r24
    2c8c:	21 f4       	brne	.+8      	; 0x2c96 <main+0x116>
    2c8e:	80 91 bf 01 	lds	r24, 0x01BF
    2c92:	88 23       	and	r24, r24
    2c94:	e1 f0       	breq	.+56     	; 0x2cce <main+0x14e>
    2c96:	80 91 bc 01 	lds	r24, 0x01BC
    2c9a:	88 23       	and	r24, r24
    2c9c:	c1 f4       	brne	.+48     	; 0x2cce <main+0x14e>
			__killCommINT();
    2c9e:	8d e3       	ldi	r24, 0x3D	; 61
    2ca0:	90 e0       	ldi	r25, 0x00	; 0
    2ca2:	fc 01       	movw	r30, r24
    2ca4:	10 82       	st	Z, r1
    2ca6:	8d e6       	ldi	r24, 0x6D	; 109
    2ca8:	90 e0       	ldi	r25, 0x00	; 0
    2caa:	fc 01       	movw	r30, r24
    2cac:	10 82       	st	Z, r1
			sendGAVR();
    2cae:	0e 94 2e 09 	call	0x125c	; 0x125c <_Z8sendGAVRv>
			__enableCommINT();
    2cb2:	8d e3       	ldi	r24, 0x3D	; 61
    2cb4:	90 e0       	ldi	r25, 0x00	; 0
    2cb6:	2d e3       	ldi	r18, 0x3D	; 61
    2cb8:	30 e0       	ldi	r19, 0x00	; 0
    2cba:	f9 01       	movw	r30, r18
    2cbc:	20 81       	ld	r18, Z
    2cbe:	24 60       	ori	r18, 0x04	; 4
    2cc0:	fc 01       	movw	r30, r24
    2cc2:	20 83       	st	Z, r18
    2cc4:	8d e6       	ldi	r24, 0x6D	; 109
    2cc6:	90 e0       	ldi	r25, 0x00	; 0
    2cc8:	22 e0       	ldi	r18, 0x02	; 2
    2cca:	fc 01       	movw	r30, r24
    2ccc:	20 83       	st	Z, r18
		}//end send to GAVR case

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    2cce:	80 91 ba 01 	lds	r24, 0x01BA
    2cd2:	88 23       	and	r24, r24
    2cd4:	49 f1       	breq	.+82     	; 0x2d28 <main+0x1a8>
			if (currentTime.getMinutes()%30 == 0){
    2cd6:	80 e9       	ldi	r24, 0x90	; 144
    2cd8:	91 e0       	ldi	r25, 0x01	; 1
    2cda:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    2cde:	9e e1       	ldi	r25, 0x1E	; 30
    2ce0:	69 2f       	mov	r22, r25
    2ce2:	0e 94 39 1b 	call	0x3672	; 0x3672 <__udivmodqi4>
    2ce6:	89 2f       	mov	r24, r25
    2ce8:	98 2f       	mov	r25, r24
    2cea:	81 e0       	ldi	r24, 0x01	; 1
    2cec:	99 23       	and	r25, r25
    2cee:	09 f0       	breq	.+2      	; 0x2cf2 <main+0x172>
    2cf0:	80 e0       	ldi	r24, 0x00	; 0
    2cf2:	88 23       	and	r24, r24
    2cf4:	c9 f0       	breq	.+50     	; 0x2d28 <main+0x1a8>
				if (currentTime.getHours()%12 == 0){
    2cf6:	80 e9       	ldi	r24, 0x90	; 144
    2cf8:	91 e0       	ldi	r25, 0x01	; 1
    2cfa:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    2cfe:	9c e0       	ldi	r25, 0x0C	; 12
    2d00:	69 2f       	mov	r22, r25
    2d02:	0e 94 39 1b 	call	0x3672	; 0x3672 <__udivmodqi4>
    2d06:	89 2f       	mov	r24, r25
    2d08:	98 2f       	mov	r25, r24
    2d0a:	81 e0       	ldi	r24, 0x01	; 1
    2d0c:	99 23       	and	r25, r25
    2d0e:	09 f0       	breq	.+2      	; 0x2d12 <main+0x192>
    2d10:	80 e0       	ldi	r24, 0x00	; 0
    2d12:	88 23       	and	r24, r24
    2d14:	29 f0       	breq	.+10     	; 0x2d20 <main+0x1a0>
					saveDateTime_eeprom(fTrue,fTrue);
    2d16:	81 e0       	ldi	r24, 0x01	; 1
    2d18:	61 e0       	ldi	r22, 0x01	; 1
    2d1a:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    2d1e:	04 c0       	rjmp	.+8      	; 0x2d28 <main+0x1a8>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    2d20:	81 e0       	ldi	r24, 0x01	; 1
    2d22:	60 e0       	ldi	r22, 0x00	; 0
    2d24:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}//end time capture/save
		
		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    2d28:	80 91 ba 01 	lds	r24, 0x01BA
    2d2c:	88 23       	and	r24, r24
    2d2e:	01 f1       	breq	.+64     	; 0x2d70 <main+0x1f0>
			TakeADC();
    2d30:	0e 94 60 19 	call	0x32c0	; 0x32c0 <_Z7TakeADCv>
			GetTemp();
    2d34:	0e 94 fd 19 	call	0x33fa	; 0x33fa <_Z7GetTempv>
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    2d38:	80 91 c6 01 	lds	r24, 0x01C6
    2d3c:	88 23       	and	r24, r24
    2d3e:	71 f0       	breq	.+28     	; 0x2d5c <main+0x1dc>
    2d40:	80 91 c5 01 	lds	r24, 0x01C5
    2d44:	88 23       	and	r24, r24
    2d46:	51 f0       	breq	.+20     	; 0x2d5c <main+0x1dc>
				if(flagShutdown){restart = fTrue;}
    2d48:	80 91 c4 01 	lds	r24, 0x01C4
    2d4c:	88 23       	and	r24, r24
    2d4e:	19 f0       	breq	.+6      	; 0x2d56 <main+0x1d6>
    2d50:	81 e0       	ldi	r24, 0x01	; 1
    2d52:	80 93 c7 01 	sts	0x01C7, r24
				flagShutdown = fFalse;
    2d56:	10 92 c4 01 	sts	0x01C4, r1
    2d5a:	0a c0       	rjmp	.+20     	; 0x2d70 <main+0x1f0>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (!flagShutdown){
    2d5c:	80 91 c4 01 	lds	r24, 0x01C4
    2d60:	88 23       	and	r24, r24
    2d62:	19 f4       	brne	.+6      	; 0x2d6a <main+0x1ea>
					flagNewShutdown = fTrue;
    2d64:	81 e0       	ldi	r24, 0x01	; 1
    2d66:	80 93 c3 01 	sts	0x01C3, r24
				}
				flagShutdown = fTrue;
    2d6a:	81 e0       	ldi	r24, 0x01	; 1
    2d6c:	80 93 c4 01 	sts	0x01C4, r24
			}
		}//end normal mode Check Analog Signals			
		
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    2d70:	80 91 c3 01 	lds	r24, 0x01C3
    2d74:	88 23       	and	r24, r24
    2d76:	b9 f0       	breq	.+46     	; 0x2da6 <main+0x226>
			//Make sure nothing messes with the routine that we care about
			__killCommINT();
    2d78:	8d e3       	ldi	r24, 0x3D	; 61
    2d7a:	90 e0       	ldi	r25, 0x00	; 0
    2d7c:	fc 01       	movw	r30, r24
    2d7e:	10 82       	st	Z, r1
    2d80:	8d e6       	ldi	r24, 0x6D	; 109
    2d82:	90 e0       	ldi	r25, 0x00	; 0
    2d84:	fc 01       	movw	r30, r24
    2d86:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    2d88:	81 e0       	ldi	r24, 0x01	; 1
    2d8a:	80 93 b8 01 	sts	0x01B8, r24
			flagReceivingBone = fFalse;
    2d8e:	10 92 b9 01 	sts	0x01B9, r1
			flagUserClock=fFalse;						//reset this so next boot is correct. Done in restart case as well for redundancy
    2d92:	10 92 bf 01 	sts	0x01BF, r1
			saveDateTime_eeprom(fTrue,fTrue);
    2d96:	81 e0       	ldi	r24, 0x01	; 1
    2d98:	61 e0       	ldi	r22, 0x01	; 1
    2d9a:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
			
			//Kill power--Alert comes in that function
			PowerDown();
    2d9e:	0e 94 c5 1a 	call	0x358a	; 0x358a <_Z9PowerDownv>
			flagNewShutdown = fFalse;
    2da2:	10 92 c3 01 	sts	0x01C3, r1
		}//end new shutdown
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    2da6:	80 91 c7 01 	lds	r24, 0x01C7
    2daa:	88 23       	and	r24, r24
    2dac:	b9 f0       	breq	.+46     	; 0x2ddc <main+0x25c>
			//Enable COmmunication protocols and then power up. Power up specifies the timing for it to happen
			__enableCommINT();	
    2dae:	8d e3       	ldi	r24, 0x3D	; 61
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	2d e3       	ldi	r18, 0x3D	; 61
    2db4:	30 e0       	ldi	r19, 0x00	; 0
    2db6:	f9 01       	movw	r30, r18
    2db8:	20 81       	ld	r18, Z
    2dba:	24 60       	ori	r18, 0x04	; 4
    2dbc:	fc 01       	movw	r30, r24
    2dbe:	20 83       	st	Z, r18
    2dc0:	8d e6       	ldi	r24, 0x6D	; 109
    2dc2:	90 e0       	ldi	r25, 0x00	; 0
    2dc4:	22 e0       	ldi	r18, 0x02	; 2
    2dc6:	fc 01       	movw	r30, r24
    2dc8:	20 83       	st	Z, r18
			PowerUp(POWER_UP_INTERVAL);
    2dca:	88 eb       	ldi	r24, 0xB8	; 184
    2dcc:	9b e0       	ldi	r25, 0x0B	; 11
    2dce:	0e 94 83 1a 	call	0x3506	; 0x3506 <_Z7PowerUpj>
			
			//Update the GAVRClock since it's a restart, we have the correct date and time. If BeagleBone sends GPS data, use that to back it up.
			flagUpdateGAVRClock=fTrue;
    2dd2:	81 e0       	ldi	r24, 0x01	; 1
    2dd4:	80 93 bd 01 	sts	0x01BD, r24
			flagUserClock=fFalse;		
    2dd8:	10 92 bf 01 	sts	0x01BF, r1
		}//end restart		
		
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep){GoToSleep(flagShutdown);}
    2ddc:	80 91 b8 01 	lds	r24, 0x01B8
    2de0:	88 23       	and	r24, r24
    2de2:	21 f0       	breq	.+8      	; 0x2dec <main+0x26c>
    2de4:	80 91 c4 01 	lds	r24, 0x01C4
    2de8:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <_Z9GoToSleeph>
		
		//Add logic for an invalid date and time somehow getting in here
		if (flagInvalidDateTime && !flagShutdown){
    2dec:	80 91 c0 01 	lds	r24, 0x01C0
    2df0:	88 23       	and	r24, r24
    2df2:	09 f4       	brne	.+2      	; 0x2df6 <main+0x276>
    2df4:	0b cf       	rjmp	.-490    	; 0x2c0c <main+0x8c>
    2df6:	80 91 c4 01 	lds	r24, 0x01C4
    2dfa:	88 23       	and	r24, r24
    2dfc:	09 f0       	breq	.+2      	; 0x2e00 <main+0x280>
    2dfe:	06 cf       	rjmp	.-500    	; 0x2c0c <main+0x8c>
			flagInvalidDateTime=fFalse;
    2e00:	10 92 c0 01 	sts	0x01C0, r1
			flagUserClock=fTrue;
    2e04:	81 e0       	ldi	r24, 0x01	; 1
    2e06:	80 93 bf 01 	sts	0x01BF, r24
			flagUpdateGAVRClock=fFalse;
    2e0a:	10 92 bd 01 	sts	0x01BD, r1
		flagShutdown=fTrue;
		flagFreshStart=fFalse;
	}
		
	//main programming loop
	while(fTrue)
    2e0e:	fe ce       	rjmp	.-516    	; 0x2c0c <main+0x8c>

00002e10 <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    2e10:	cf 93       	push	r28
    2e12:	df 93       	push	r29
    2e14:	cd b7       	in	r28, 0x3d	; 61
    2e16:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    2e18:	81 e2       	ldi	r24, 0x21	; 33
    2e1a:	90 e0       	ldi	r25, 0x00	; 0
    2e1c:	fc 01       	movw	r30, r24
    2e1e:	10 82       	st	Z, r1
	DDRB = 0;
    2e20:	84 e2       	ldi	r24, 0x24	; 36
    2e22:	90 e0       	ldi	r25, 0x00	; 0
    2e24:	fc 01       	movw	r30, r24
    2e26:	10 82       	st	Z, r1
	DDRC = 0;
    2e28:	87 e2       	ldi	r24, 0x27	; 39
    2e2a:	90 e0       	ldi	r25, 0x00	; 0
    2e2c:	fc 01       	movw	r30, r24
    2e2e:	10 82       	st	Z, r1
	DDRD = 0;
    2e30:	8a e2       	ldi	r24, 0x2A	; 42
    2e32:	90 e0       	ldi	r25, 0x00	; 0
    2e34:	fc 01       	movw	r30, r24
    2e36:	10 82       	st	Z, r1
	
	PORTA = 0;
    2e38:	82 e2       	ldi	r24, 0x22	; 34
    2e3a:	90 e0       	ldi	r25, 0x00	; 0
    2e3c:	fc 01       	movw	r30, r24
    2e3e:	10 82       	st	Z, r1
	PORTB = 0;
    2e40:	85 e2       	ldi	r24, 0x25	; 37
    2e42:	90 e0       	ldi	r25, 0x00	; 0
    2e44:	fc 01       	movw	r30, r24
    2e46:	10 82       	st	Z, r1
	PORTC = 0;
    2e48:	88 e2       	ldi	r24, 0x28	; 40
    2e4a:	90 e0       	ldi	r25, 0x00	; 0
    2e4c:	fc 01       	movw	r30, r24
    2e4e:	10 82       	st	Z, r1
	PORTD = 0;
    2e50:	8b e2       	ldi	r24, 0x2B	; 43
    2e52:	90 e0       	ldi	r25, 0x00	; 0
    2e54:	fc 01       	movw	r30, r24
    2e56:	10 82       	st	Z, r1
}
    2e58:	df 91       	pop	r29
    2e5a:	cf 91       	pop	r28
    2e5c:	08 95       	ret

00002e5e <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    2e5e:	cf 93       	push	r28
    2e60:	df 93       	push	r29
    2e62:	00 d0       	rcall	.+0      	; 0x2e64 <_Z7AppInitj+0x6>
    2e64:	cd b7       	in	r28, 0x3d	; 61
    2e66:	de b7       	in	r29, 0x3e	; 62
    2e68:	9a 83       	std	Y+2, r25	; 0x02
    2e6a:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    2e6c:	84 ec       	ldi	r24, 0xC4	; 196
    2e6e:	90 e0       	ldi	r25, 0x00	; 0
    2e70:	29 81       	ldd	r18, Y+1	; 0x01
    2e72:	fc 01       	movw	r30, r24
    2e74:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    2e76:	85 ec       	ldi	r24, 0xC5	; 197
    2e78:	90 e0       	ldi	r25, 0x00	; 0
    2e7a:	29 81       	ldd	r18, Y+1	; 0x01
    2e7c:	3a 81       	ldd	r19, Y+2	; 0x02
    2e7e:	23 2f       	mov	r18, r19
    2e80:	33 27       	eor	r19, r19
    2e82:	fc 01       	movw	r30, r24
    2e84:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    2e86:	81 ec       	ldi	r24, 0xC1	; 193
    2e88:	90 e0       	ldi	r25, 0x00	; 0
    2e8a:	28 e1       	ldi	r18, 0x18	; 24
    2e8c:	fc 01       	movw	r30, r24
    2e8e:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    2e90:	82 ec       	ldi	r24, 0xC2	; 194
    2e92:	90 e0       	ldi	r25, 0x00	; 0
    2e94:	26 e0       	ldi	r18, 0x06	; 6
    2e96:	fc 01       	movw	r30, r24
    2e98:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Set BAUD for UART1
	UBRR1L = ubrr;
    2e9a:	8c ec       	ldi	r24, 0xCC	; 204
    2e9c:	90 e0       	ldi	r25, 0x00	; 0
    2e9e:	29 81       	ldd	r18, Y+1	; 0x01
    2ea0:	fc 01       	movw	r30, r24
    2ea2:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);
    2ea4:	85 ec       	ldi	r24, 0xC5	; 197
    2ea6:	90 e0       	ldi	r25, 0x00	; 0
    2ea8:	29 81       	ldd	r18, Y+1	; 0x01
    2eaa:	3a 81       	ldd	r19, Y+2	; 0x02
    2eac:	23 2f       	mov	r18, r19
    2eae:	33 27       	eor	r19, r19
    2eb0:	fc 01       	movw	r30, r24
    2eb2:	20 83       	st	Z, r18
	//UCSR1A |= (1 << U2X1);
	
	//Enable UART_TX1 and UART_RX1
	UCSR1B = (1 << TXEN1)|(1 << RXEN1);
    2eb4:	89 ec       	ldi	r24, 0xC9	; 201
    2eb6:	90 e0       	ldi	r25, 0x00	; 0
    2eb8:	28 e1       	ldi	r18, 0x18	; 24
    2eba:	fc 01       	movw	r30, r24
    2ebc:	20 83       	st	Z, r18
	UCSR1C = (1 << UCSZ11)|(1 << UCSZ10);
    2ebe:	8a ec       	ldi	r24, 0xCA	; 202
    2ec0:	90 e0       	ldi	r25, 0x00	; 0
    2ec2:	26 e0       	ldi	r18, 0x06	; 6
    2ec4:	fc 01       	movw	r30, r24
    2ec6:	20 83       	st	Z, r18
	//UCSR1B |= (1 << RXCIE1);
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM2)|(1 << PRTIM0)|(1 << PRUSART1)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    2ec8:	84 e6       	ldi	r24, 0x64	; 100
    2eca:	90 e0       	ldi	r25, 0x00	; 0
    2ecc:	24 e6       	ldi	r18, 0x64	; 100
    2ece:	30 e0       	ldi	r19, 0x00	; 0
    2ed0:	f9 01       	movw	r30, r18
    2ed2:	20 81       	ld	r18, Z
    2ed4:	2d 6f       	ori	r18, 0xFD	; 253
    2ed6:	fc 01       	movw	r30, r24
    2ed8:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    2eda:	8a e2       	ldi	r24, 0x2A	; 42
    2edc:	90 e0       	ldi	r25, 0x00	; 0
    2ede:	2a e2       	ldi	r18, 0x2A	; 42
    2ee0:	30 e0       	ldi	r19, 0x00	; 0
    2ee2:	f9 01       	movw	r30, r18
    2ee4:	20 81       	ld	r18, Z
    2ee6:	20 68       	ori	r18, 0x80	; 128
    2ee8:	fc 01       	movw	r30, r24
    2eea:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    2eec:	87 e2       	ldi	r24, 0x27	; 39
    2eee:	90 e0       	ldi	r25, 0x00	; 0
    2ef0:	27 e2       	ldi	r18, 0x27	; 39
    2ef2:	30 e0       	ldi	r19, 0x00	; 0
    2ef4:	f9 01       	movw	r30, r18
    2ef6:	20 81       	ld	r18, Z
    2ef8:	24 60       	ori	r18, 0x04	; 4
    2efa:	fc 01       	movw	r30, r24
    2efc:	20 83       	st	Z, r18
	prtSLEEPled &= ~(1 << bnSLEEPled);	//turn off initially
    2efe:	8b e2       	ldi	r24, 0x2B	; 43
    2f00:	90 e0       	ldi	r25, 0x00	; 0
    2f02:	2b e2       	ldi	r18, 0x2B	; 43
    2f04:	30 e0       	ldi	r19, 0x00	; 0
    2f06:	f9 01       	movw	r30, r18
    2f08:	20 81       	ld	r18, Z
    2f0a:	2f 77       	andi	r18, 0x7F	; 127
    2f0c:	fc 01       	movw	r30, r24
    2f0e:	20 83       	st	Z, r18
	prtSTATUSled |= (1 << bnSTATUSled);	//turn on initially
    2f10:	88 e2       	ldi	r24, 0x28	; 40
    2f12:	90 e0       	ldi	r25, 0x00	; 0
    2f14:	28 e2       	ldi	r18, 0x28	; 40
    2f16:	30 e0       	ldi	r19, 0x00	; 0
    2f18:	f9 01       	movw	r30, r18
    2f1a:	20 81       	ld	r18, Z
    2f1c:	24 60       	ori	r18, 0x04	; 4
    2f1e:	fc 01       	movw	r30, r24
    2f20:	20 83       	st	Z, r18
	
	//Enable BB and GAVR alert pins...outputs, no pull by default.
	ddrBONEINT |= (1 << bnBBint);
    2f22:	81 e2       	ldi	r24, 0x21	; 33
    2f24:	90 e0       	ldi	r25, 0x00	; 0
    2f26:	21 e2       	ldi	r18, 0x21	; 33
    2f28:	30 e0       	ldi	r19, 0x00	; 0
    2f2a:	f9 01       	movw	r30, r18
    2f2c:	20 81       	ld	r18, Z
    2f2e:	24 60       	ori	r18, 0x04	; 4
    2f30:	fc 01       	movw	r30, r24
    2f32:	20 83       	st	Z, r18
	ddrGAVRINT |= (1 << bnGAVRint);
    2f34:	84 e2       	ldi	r24, 0x24	; 36
    2f36:	90 e0       	ldi	r25, 0x00	; 0
    2f38:	24 e2       	ldi	r18, 0x24	; 36
    2f3a:	30 e0       	ldi	r19, 0x00	; 0
    2f3c:	f9 01       	movw	r30, r18
    2f3e:	20 81       	ld	r18, Z
    2f40:	28 60       	ori	r18, 0x08	; 8
    2f42:	fc 01       	movw	r30, r24
    2f44:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrGAVRINT |= (1 << bnGAVRINT);
    2f46:	84 e2       	ldi	r24, 0x24	; 36
    2f48:	90 e0       	ldi	r25, 0x00	; 0
    2f4a:	24 e2       	ldi	r18, 0x24	; 36
    2f4c:	30 e0       	ldi	r19, 0x00	; 0
    2f4e:	f9 01       	movw	r30, r18
    2f50:	20 81       	ld	r18, Z
    2f52:	28 60       	ori	r18, 0x08	; 8
    2f54:	fc 01       	movw	r30, r24
    2f56:	20 83       	st	Z, r18
	prtGAVRINT &=  ~(1 << bnGAVRINT);	//set low at first
    2f58:	85 e2       	ldi	r24, 0x25	; 37
    2f5a:	90 e0       	ldi	r25, 0x00	; 0
    2f5c:	25 e2       	ldi	r18, 0x25	; 37
    2f5e:	30 e0       	ldi	r19, 0x00	; 0
    2f60:	f9 01       	movw	r30, r18
    2f62:	20 81       	ld	r18, Z
    2f64:	27 7f       	andi	r18, 0xF7	; 247
    2f66:	fc 01       	movw	r30, r24
    2f68:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen)|(1 << bnBBen);
    2f6a:	81 e2       	ldi	r24, 0x21	; 33
    2f6c:	90 e0       	ldi	r25, 0x00	; 0
    2f6e:	21 e2       	ldi	r18, 0x21	; 33
    2f70:	30 e0       	ldi	r19, 0x00	; 0
    2f72:	f9 01       	movw	r30, r18
    2f74:	20 81       	ld	r18, Z
    2f76:	20 6f       	ori	r18, 0xF0	; 240
    2f78:	fc 01       	movw	r30, r24
    2f7a:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    2f7c:	84 e2       	ldi	r24, 0x24	; 36
    2f7e:	90 e0       	ldi	r25, 0x00	; 0
    2f80:	24 e2       	ldi	r18, 0x24	; 36
    2f82:	30 e0       	ldi	r19, 0x00	; 0
    2f84:	f9 01       	movw	r30, r18
    2f86:	20 81       	ld	r18, Z
    2f88:	21 60       	ori	r18, 0x01	; 1
    2f8a:	fc 01       	movw	r30, r24
    2f8c:	20 83       	st	Z, r18
	ddrMAINen |= (1 << bnMAINen);
    2f8e:	87 e2       	ldi	r24, 0x27	; 39
    2f90:	90 e0       	ldi	r25, 0x00	; 0
    2f92:	27 e2       	ldi	r18, 0x27	; 39
    2f94:	30 e0       	ldi	r19, 0x00	; 0
    2f96:	f9 01       	movw	r30, r18
    2f98:	20 81       	ld	r18, Z
    2f9a:	21 60       	ori	r18, 0x01	; 1
    2f9c:	fc 01       	movw	r30, r24
    2f9e:	20 83       	st	Z, r18
	PowerDown();
    2fa0:	0e 94 c5 1a 	call	0x358a	; 0x358a <_Z9PowerDownv>
	__killTemp();
    2fa4:	85 e2       	ldi	r24, 0x25	; 37
    2fa6:	90 e0       	ldi	r25, 0x00	; 0
    2fa8:	25 e2       	ldi	r18, 0x25	; 37
    2faa:	30 e0       	ldi	r19, 0x00	; 0
    2fac:	f9 01       	movw	r30, r18
    2fae:	20 81       	ld	r18, Z
    2fb0:	2e 7f       	andi	r18, 0xFE	; 254
    2fb2:	fc 01       	movw	r30, r24
    2fb4:	20 83       	st	Z, r18

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    2fb6:	89 e6       	ldi	r24, 0x69	; 105
    2fb8:	90 e0       	ldi	r25, 0x00	; 0
    2fba:	20 e3       	ldi	r18, 0x30	; 48
    2fbc:	fc 01       	movw	r30, r24
    2fbe:	20 83       	st	Z, r18
	EIMSK = (1 << INT2);						//enable INT2 global interrupt
    2fc0:	8d e3       	ldi	r24, 0x3D	; 61
    2fc2:	90 e0       	ldi	r25, 0x00	; 0
    2fc4:	24 e0       	ldi	r18, 0x04	; 4
    2fc6:	fc 01       	movw	r30, r24
    2fc8:	20 83       	st	Z, r18
	
	//Enable PCINT17
	PCMSK1 |= (1 << PCINT17);
    2fca:	8c e6       	ldi	r24, 0x6C	; 108
    2fcc:	90 e0       	ldi	r25, 0x00	; 0
    2fce:	2c e6       	ldi	r18, 0x6C	; 108
    2fd0:	30 e0       	ldi	r19, 0x00	; 0
    2fd2:	f9 01       	movw	r30, r18
    2fd4:	20 81       	ld	r18, Z
    2fd6:	22 60       	ori	r18, 0x02	; 2
    2fd8:	fc 01       	movw	r30, r24
    2fda:	20 83       	st	Z, r18
	PCICR |= (1 << PCIE0);
    2fdc:	88 e6       	ldi	r24, 0x68	; 104
    2fde:	90 e0       	ldi	r25, 0x00	; 0
    2fe0:	28 e6       	ldi	r18, 0x68	; 104
    2fe2:	30 e0       	ldi	r19, 0x00	; 0
    2fe4:	f9 01       	movw	r30, r18
    2fe6:	20 81       	ld	r18, Z
    2fe8:	21 60       	ori	r18, 0x01	; 1
    2fea:	fc 01       	movw	r30, r24
    2fec:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    2fee:	84 e2       	ldi	r24, 0x24	; 36
    2ff0:	90 e0       	ldi	r25, 0x00	; 0
    2ff2:	24 e2       	ldi	r18, 0x24	; 36
    2ff4:	30 e0       	ldi	r19, 0x00	; 0
    2ff6:	f9 01       	movw	r30, r18
    2ff8:	20 81       	ld	r18, Z
    2ffa:	20 6b       	ori	r18, 0xB0	; 176
    2ffc:	fc 01       	movw	r30, r24
    2ffe:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    3000:	84 e2       	ldi	r24, 0x24	; 36
    3002:	90 e0       	ldi	r25, 0x00	; 0
    3004:	24 e2       	ldi	r18, 0x24	; 36
    3006:	30 e0       	ldi	r19, 0x00	; 0
    3008:	f9 01       	movw	r30, r18
    300a:	20 81       	ld	r18, Z
    300c:	2f 7b       	andi	r18, 0xBF	; 191
    300e:	fc 01       	movw	r30, r24
    3010:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    3012:	85 e2       	ldi	r24, 0x25	; 37
    3014:	90 e0       	ldi	r25, 0x00	; 0
    3016:	25 e2       	ldi	r18, 0x25	; 37
    3018:	30 e0       	ldi	r19, 0x00	; 0
    301a:	f9 01       	movw	r30, r18
    301c:	20 81       	ld	r18, Z
    301e:	20 69       	ori	r18, 0x90	; 144
    3020:	fc 01       	movw	r30, r24
    3022:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    3024:	85 e2       	ldi	r24, 0x25	; 37
    3026:	90 e0       	ldi	r25, 0x00	; 0
    3028:	25 e2       	ldi	r18, 0x25	; 37
    302a:	30 e0       	ldi	r19, 0x00	; 0
    302c:	f9 01       	movw	r30, r18
    302e:	20 81       	ld	r18, Z
    3030:	2f 7d       	andi	r18, 0xDF	; 223
    3032:	fc 01       	movw	r30, r24
    3034:	20 83       	st	Z, r18
	
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    3036:	81 e0       	ldi	r24, 0x01	; 1
    3038:	80 93 b8 01 	sts	0x01B8, r24
	flagReceivingBone = fFalse;
    303c:	10 92 b9 01 	sts	0x01B9, r1
	flagNormalMode=fTrue;
    3040:	81 e0       	ldi	r24, 0x01	; 1
    3042:	80 93 ba 01 	sts	0x01BA, r24

	flagUpdateGAVRClock=fFalse;	
    3046:	10 92 bd 01 	sts	0x01BD, r1
	flagSendingGAVR=fFalse;
    304a:	10 92 be 01 	sts	0x01BE, r1
	flagUserClock=fFalse;
    304e:	10 92 bf 01 	sts	0x01BF, r1
	flagInvalidDateTime=fFalse;
    3052:	10 92 c0 01 	sts	0x01C0, r1
	flagWaitingToSendGAVR=fFalse;
    3056:	10 92 c1 01 	sts	0x01C1, r1
	flagGPSTime=fFalse;
    305a:	10 92 c2 01 	sts	0x01C2, r1
	
	restart=fFalse;
    305e:	10 92 c7 01 	sts	0x01C7, r1
	flagNewShutdown=fFalse;	
    3062:	10 92 c3 01 	sts	0x01C3, r1
	//flagShutdown=fFalse;		//Initialized in startup procedure in beginning of "main"
	flagGoodVolts=fFalse;
    3066:	10 92 c6 01 	sts	0x01C6, r1
	flagGoodTemp=fFalse;
    306a:	10 92 c5 01 	sts	0x01C5, r1
	//flagFreshStart=fTrue;		//Initialized in startup procedure in beginning of "main"
}
    306e:	0f 90       	pop	r0
    3070:	0f 90       	pop	r0
    3072:	df 91       	pop	r29
    3074:	cf 91       	pop	r28
    3076:	08 95       	ret

00003078 <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    3078:	cf 93       	push	r28
    307a:	df 93       	push	r29
    307c:	cd b7       	in	r28, 0x3d	; 61
    307e:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    3080:	84 e6       	ldi	r24, 0x64	; 100
    3082:	90 e0       	ldi	r25, 0x00	; 0
    3084:	24 e6       	ldi	r18, 0x64	; 100
    3086:	30 e0       	ldi	r19, 0x00	; 0
    3088:	f9 01       	movw	r30, r18
    308a:	20 81       	ld	r18, Z
    308c:	2f 7b       	andi	r18, 0xBF	; 191
    308e:	fc 01       	movw	r30, r24
    3090:	20 83       	st	Z, r18
	Wait_ms(1);	//give it time to power on
    3092:	81 e0       	ldi	r24, 0x01	; 1
    3094:	90 e0       	ldi	r25, 0x00	; 0
    3096:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    309a:	86 eb       	ldi	r24, 0xB6	; 182
    309c:	90 e0       	ldi	r25, 0x00	; 0
    309e:	26 eb       	ldi	r18, 0xB6	; 182
    30a0:	30 e0       	ldi	r19, 0x00	; 0
    30a2:	f9 01       	movw	r30, r18
    30a4:	20 81       	ld	r18, Z
    30a6:	20 62       	ori	r18, 0x20	; 32
    30a8:	fc 01       	movw	r30, r24
    30aa:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    30ac:	81 eb       	ldi	r24, 0xB1	; 177
    30ae:	90 e0       	ldi	r25, 0x00	; 0
    30b0:	21 eb       	ldi	r18, 0xB1	; 177
    30b2:	30 e0       	ldi	r19, 0x00	; 0
    30b4:	f9 01       	movw	r30, r18
    30b6:	20 81       	ld	r18, Z
    30b8:	25 60       	ori	r18, 0x05	; 5
    30ba:	fc 01       	movw	r30, r24
    30bc:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    30be:	86 eb       	ldi	r24, 0xB6	; 182
    30c0:	90 e0       	ldi	r25, 0x00	; 0
    30c2:	fc 01       	movw	r30, r24
    30c4:	80 81       	ld	r24, Z
    30c6:	88 2f       	mov	r24, r24
    30c8:	90 e0       	ldi	r25, 0x00	; 0
    30ca:	81 71       	andi	r24, 0x11	; 17
    30cc:	90 70       	andi	r25, 0x00	; 0
    30ce:	21 e0       	ldi	r18, 0x01	; 1
    30d0:	00 97       	sbiw	r24, 0x00	; 0
    30d2:	09 f4       	brne	.+2      	; 0x30d6 <_Z14EnableRTCTimerv+0x5e>
    30d4:	20 e0       	ldi	r18, 0x00	; 0
    30d6:	22 23       	and	r18, r18
    30d8:	91 f7       	brne	.-28     	; 0x30be <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    30da:	87 e3       	ldi	r24, 0x37	; 55
    30dc:	90 e0       	ldi	r25, 0x00	; 0
    30de:	21 e0       	ldi	r18, 0x01	; 1
    30e0:	fc 01       	movw	r30, r24
    30e2:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    30e4:	80 e7       	ldi	r24, 0x70	; 112
    30e6:	90 e0       	ldi	r25, 0x00	; 0
    30e8:	21 e0       	ldi	r18, 0x01	; 1
    30ea:	fc 01       	movw	r30, r24
    30ec:	20 83       	st	Z, r18
	
	//Away we go
}
    30ee:	df 91       	pop	r29
    30f0:	cf 91       	pop	r28
    30f2:	08 95       	ret

000030f4 <_Z7Wait_msi>:
/*************************************************************************************************************/
void Wait_ms(volatile int delay)
{
    30f4:	cf 93       	push	r28
    30f6:	df 93       	push	r29
    30f8:	00 d0       	rcall	.+0      	; 0x30fa <_Z7Wait_msi+0x6>
    30fa:	00 d0       	rcall	.+0      	; 0x30fc <_Z7Wait_msi+0x8>
    30fc:	cd b7       	in	r28, 0x3d	; 61
    30fe:	de b7       	in	r29, 0x3e	; 62
    3100:	9c 83       	std	Y+4, r25	; 0x04
    3102:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    3104:	18 c0       	rjmp	.+48     	; 0x3136 <_Z7Wait_msi+0x42>
		for(i = 0; i < 800; i++){
    3106:	1a 82       	std	Y+2, r1	; 0x02
    3108:	19 82       	std	Y+1, r1	; 0x01
    310a:	06 c0       	rjmp	.+12     	; 0x3118 <_Z7Wait_msi+0x24>
			asm volatile("nop");
    310c:	00 00       	nop
void Wait_ms(volatile int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 800; i++){
    310e:	89 81       	ldd	r24, Y+1	; 0x01
    3110:	9a 81       	ldd	r25, Y+2	; 0x02
    3112:	01 96       	adiw	r24, 0x01	; 1
    3114:	9a 83       	std	Y+2, r25	; 0x02
    3116:	89 83       	std	Y+1, r24	; 0x01
    3118:	89 81       	ldd	r24, Y+1	; 0x01
    311a:	9a 81       	ldd	r25, Y+2	; 0x02
    311c:	21 e0       	ldi	r18, 0x01	; 1
    311e:	33 e0       	ldi	r19, 0x03	; 3
    3120:	80 32       	cpi	r24, 0x20	; 32
    3122:	93 07       	cpc	r25, r19
    3124:	0c f0       	brlt	.+2      	; 0x3128 <_Z7Wait_msi+0x34>
    3126:	20 e0       	ldi	r18, 0x00	; 0
    3128:	22 23       	and	r18, r18
    312a:	81 f7       	brne	.-32     	; 0x310c <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    312c:	8b 81       	ldd	r24, Y+3	; 0x03
    312e:	9c 81       	ldd	r25, Y+4	; 0x04
    3130:	01 97       	sbiw	r24, 0x01	; 1
    3132:	9c 83       	std	Y+4, r25	; 0x04
    3134:	8b 83       	std	Y+3, r24	; 0x03
/*************************************************************************************************************/
void Wait_ms(volatile int delay)
{
	volatile int i;

	while(delay > 0){
    3136:	8b 81       	ldd	r24, Y+3	; 0x03
    3138:	9c 81       	ldd	r25, Y+4	; 0x04
    313a:	21 e0       	ldi	r18, 0x01	; 1
    313c:	18 16       	cp	r1, r24
    313e:	19 06       	cpc	r1, r25
    3140:	0c f0       	brlt	.+2      	; 0x3144 <_Z7Wait_msi+0x50>
    3142:	20 e0       	ldi	r18, 0x00	; 0
    3144:	22 23       	and	r18, r18
    3146:	f9 f6       	brne	.-66     	; 0x3106 <_Z7Wait_msi+0x12>
		for(i = 0; i < 800; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    3148:	0f 90       	pop	r0
    314a:	0f 90       	pop	r0
    314c:	0f 90       	pop	r0
    314e:	0f 90       	pop	r0
    3150:	df 91       	pop	r29
    3152:	cf 91       	pop	r28
    3154:	08 95       	ret

00003156 <_Z8Wait_seci>:
/*************************************************************************************************************/
void Wait_sec(volatile int sec){
    3156:	cf 93       	push	r28
    3158:	df 93       	push	r29
    315a:	00 d0       	rcall	.+0      	; 0x315c <_Z8Wait_seci+0x6>
    315c:	00 d0       	rcall	.+0      	; 0x315e <_Z8Wait_seci+0x8>
    315e:	00 d0       	rcall	.+0      	; 0x3160 <_Z8Wait_seci+0xa>
    3160:	cd b7       	in	r28, 0x3d	; 61
    3162:	de b7       	in	r29, 0x3e	; 62
    3164:	9e 83       	std	Y+6, r25	; 0x06
    3166:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    3168:	80 e9       	ldi	r24, 0x90	; 144
    316a:	91 e0       	ldi	r25, 0x01	; 1
    316c:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    3170:	88 2f       	mov	r24, r24
    3172:	90 e0       	ldi	r25, 0x00	; 0
    3174:	9a 83       	std	Y+2, r25	; 0x02
    3176:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    3178:	29 81       	ldd	r18, Y+1	; 0x01
    317a:	3a 81       	ldd	r19, Y+2	; 0x02
    317c:	8d 81       	ldd	r24, Y+5	; 0x05
    317e:	9e 81       	ldd	r25, Y+6	; 0x06
    3180:	82 0f       	add	r24, r18
    3182:	93 1f       	adc	r25, r19
    3184:	2c e3       	ldi	r18, 0x3C	; 60
    3186:	30 e0       	ldi	r19, 0x00	; 0
    3188:	b9 01       	movw	r22, r18
    318a:	0e 94 45 1b 	call	0x368a	; 0x368a <__divmodhi4>
    318e:	9c 83       	std	Y+4, r25	; 0x04
    3190:	8b 83       	std	Y+3, r24	; 0x03
	while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    3192:	01 c0       	rjmp	.+2      	; 0x3196 <_Z8Wait_seci+0x40>
    3194:	00 00       	nop
    3196:	80 e9       	ldi	r24, 0x90	; 144
    3198:	91 e0       	ldi	r25, 0x01	; 1
    319a:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    319e:	28 2f       	mov	r18, r24
    31a0:	30 e0       	ldi	r19, 0x00	; 0
    31a2:	8b 81       	ldd	r24, Y+3	; 0x03
    31a4:	9c 81       	ldd	r25, Y+4	; 0x04
    31a6:	41 e0       	ldi	r20, 0x01	; 1
    31a8:	28 17       	cp	r18, r24
    31aa:	39 07       	cpc	r19, r25
    31ac:	09 f4       	brne	.+2      	; 0x31b0 <_Z8Wait_seci+0x5a>
    31ae:	40 e0       	ldi	r20, 0x00	; 0
    31b0:	44 23       	and	r20, r20
    31b2:	81 f7       	brne	.-32     	; 0x3194 <_Z8Wait_seci+0x3e>
}
    31b4:	26 96       	adiw	r28, 0x06	; 6
    31b6:	0f b6       	in	r0, 0x3f	; 63
    31b8:	f8 94       	cli
    31ba:	de bf       	out	0x3e, r29	; 62
    31bc:	0f be       	out	0x3f, r0	; 63
    31be:	cd bf       	out	0x3d, r28	; 61
    31c0:	df 91       	pop	r29
    31c2:	cf 91       	pop	r28
    31c4:	08 95       	ret

000031c6 <_Z9GoToSleeph>:

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    31c6:	cf 93       	push	r28
    31c8:	df 93       	push	r29
    31ca:	00 d0       	rcall	.+0      	; 0x31cc <_Z9GoToSleeph+0x6>
    31cc:	00 d0       	rcall	.+0      	; 0x31ce <_Z9GoToSleeph+0x8>
    31ce:	0f 92       	push	r0
    31d0:	cd b7       	in	r28, 0x3d	; 61
    31d2:	de b7       	in	r29, 0x3e	; 62
    31d4:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    31d6:	78 94       	sei
		volatile int sleepTime, sleepTicks = 0;
    31d8:	1c 82       	std	Y+4, r1	; 0x04
    31da:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong == fTrue){
    31dc:	8d 81       	ldd	r24, Y+5	; 0x05
    31de:	81 30       	cpi	r24, 0x01	; 1
    31e0:	49 f4       	brne	.+18     	; 0x31f4 <_Z9GoToSleeph+0x2e>
			sleepTime = SLEEP_TICKS_LOWV;
    31e2:	8c e0       	ldi	r24, 0x0C	; 12
    31e4:	90 e0       	ldi	r25, 0x00	; 0
    31e6:	9a 83       	std	Y+2, r25	; 0x02
    31e8:	89 83       	std	Y+1, r24	; 0x01
			EIMSK = 0;						//no int2
    31ea:	8d e3       	ldi	r24, 0x3D	; 61
    31ec:	90 e0       	ldi	r25, 0x00	; 0
    31ee:	fc 01       	movw	r30, r24
    31f0:	10 82       	st	Z, r1
    31f2:	0d c0       	rjmp	.+26     	; 0x320e <_Z9GoToSleeph+0x48>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    31f4:	8a e0       	ldi	r24, 0x0A	; 10
    31f6:	90 e0       	ldi	r25, 0x00	; 0
    31f8:	9a 83       	std	Y+2, r25	; 0x02
    31fa:	89 83       	std	Y+1, r24	; 0x01
			EIMSK |= (1 << INT2);			//int2 is allowed.
    31fc:	8d e3       	ldi	r24, 0x3D	; 61
    31fe:	90 e0       	ldi	r25, 0x00	; 0
    3200:	2d e3       	ldi	r18, 0x3D	; 61
    3202:	30 e0       	ldi	r19, 0x00	; 0
    3204:	f9 01       	movw	r30, r18
    3206:	20 81       	ld	r18, Z
    3208:	24 60       	ori	r18, 0x04	; 4
    320a:	fc 01       	movw	r30, r24
    320c:	20 83       	st	Z, r18
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    320e:	88 e2       	ldi	r24, 0x28	; 40
    3210:	90 e0       	ldi	r25, 0x00	; 0
    3212:	28 e2       	ldi	r18, 0x28	; 40
    3214:	30 e0       	ldi	r19, 0x00	; 0
    3216:	f9 01       	movw	r30, r18
    3218:	20 81       	ld	r18, Z
    321a:	2b 7f       	andi	r18, 0xFB	; 251
    321c:	fc 01       	movw	r30, r24
    321e:	20 83       	st	Z, r18
		prtSLEEPled |= (1 << bnSLEEPled);
    3220:	8b e2       	ldi	r24, 0x2B	; 43
    3222:	90 e0       	ldi	r25, 0x00	; 0
    3224:	2b e2       	ldi	r18, 0x2B	; 43
    3226:	30 e0       	ldi	r19, 0x00	; 0
    3228:	f9 01       	movw	r30, r18
    322a:	20 81       	ld	r18, Z
    322c:	20 68       	ori	r18, 0x80	; 128
    322e:	fc 01       	movw	r30, r24
    3230:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    3232:	83 e5       	ldi	r24, 0x53	; 83
    3234:	90 e0       	ldi	r25, 0x00	; 0
    3236:	26 e0       	ldi	r18, 0x06	; 6
    3238:	fc 01       	movw	r30, r24
    323a:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    323c:	83 e5       	ldi	r24, 0x53	; 83
    323e:	90 e0       	ldi	r25, 0x00	; 0
    3240:	23 e5       	ldi	r18, 0x53	; 83
    3242:	30 e0       	ldi	r19, 0x00	; 0
    3244:	f9 01       	movw	r30, r18
    3246:	20 81       	ld	r18, Z
    3248:	21 60       	ori	r18, 0x01	; 1
    324a:	fc 01       	movw	r30, r24
    324c:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    324e:	81 e0       	ldi	r24, 0x01	; 1
    3250:	90 e0       	ldi	r25, 0x00	; 0
    3252:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3256:	06 c0       	rjmp	.+12     	; 0x3264 <_Z9GoToSleeph+0x9e>
			asm volatile("SLEEP");
    3258:	88 95       	sleep
			sleepTicks++;
    325a:	8b 81       	ldd	r24, Y+3	; 0x03
    325c:	9c 81       	ldd	r25, Y+4	; 0x04
    325e:	01 96       	adiw	r24, 0x01	; 1
    3260:	9c 83       	std	Y+4, r25	; 0x04
    3262:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3264:	2b 81       	ldd	r18, Y+3	; 0x03
    3266:	3c 81       	ldd	r19, Y+4	; 0x04
    3268:	89 81       	ldd	r24, Y+1	; 0x01
    326a:	9a 81       	ldd	r25, Y+2	; 0x02
    326c:	28 17       	cp	r18, r24
    326e:	39 07       	cpc	r19, r25
    3270:	34 f4       	brge	.+12     	; 0x327e <_Z9GoToSleeph+0xb8>
    3272:	80 91 b8 01 	lds	r24, 0x01B8
    3276:	88 23       	and	r24, r24
    3278:	11 f0       	breq	.+4      	; 0x327e <_Z9GoToSleeph+0xb8>
    327a:	81 e0       	ldi	r24, 0x01	; 1
    327c:	01 c0       	rjmp	.+2      	; 0x3280 <_Z9GoToSleeph+0xba>
    327e:	80 e0       	ldi	r24, 0x00	; 0
    3280:	88 23       	and	r24, r24
    3282:	51 f7       	brne	.-44     	; 0x3258 <_Z9GoToSleeph+0x92>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(10);
    3284:	8a e0       	ldi	r24, 0x0A	; 10
    3286:	90 e0       	ldi	r25, 0x00	; 0
    3288:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSLEEPled &= ~(1 << bnSLEEPled);
    328c:	8b e2       	ldi	r24, 0x2B	; 43
    328e:	90 e0       	ldi	r25, 0x00	; 0
    3290:	2b e2       	ldi	r18, 0x2B	; 43
    3292:	30 e0       	ldi	r19, 0x00	; 0
    3294:	f9 01       	movw	r30, r18
    3296:	20 81       	ld	r18, Z
    3298:	2f 77       	andi	r18, 0x7F	; 127
    329a:	fc 01       	movw	r30, r24
    329c:	20 83       	st	Z, r18
		prtSTATUSled |= (1 << bnSTATUSled);
    329e:	88 e2       	ldi	r24, 0x28	; 40
    32a0:	90 e0       	ldi	r25, 0x00	; 0
    32a2:	28 e2       	ldi	r18, 0x28	; 40
    32a4:	30 e0       	ldi	r19, 0x00	; 0
    32a6:	f9 01       	movw	r30, r18
    32a8:	20 81       	ld	r18, Z
    32aa:	24 60       	ori	r18, 0x04	; 4
    32ac:	fc 01       	movw	r30, r24
    32ae:	20 83       	st	Z, r18
}
    32b0:	0f 90       	pop	r0
    32b2:	0f 90       	pop	r0
    32b4:	0f 90       	pop	r0
    32b6:	0f 90       	pop	r0
    32b8:	0f 90       	pop	r0
    32ba:	df 91       	pop	r29
    32bc:	cf 91       	pop	r28
    32be:	08 95       	ret

000032c0 <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    32c0:	cf 93       	push	r28
    32c2:	df 93       	push	r29
    32c4:	00 d0       	rcall	.+0      	; 0x32c6 <_Z7TakeADCv+0x6>
    32c6:	00 d0       	rcall	.+0      	; 0x32c8 <_Z7TakeADCv+0x8>
    32c8:	cd b7       	in	r28, 0x3d	; 61
    32ca:	de b7       	in	r29, 0x3e	; 62
	WORD adcReading = 0;
    32cc:	1c 82       	std	Y+4, r1	; 0x04
    32ce:	1b 82       	std	Y+3, r1	; 0x03
	
	cli();
    32d0:	f8 94       	cli
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    32d2:	84 e6       	ldi	r24, 0x64	; 100
    32d4:	90 e0       	ldi	r25, 0x00	; 0
    32d6:	24 e6       	ldi	r18, 0x64	; 100
    32d8:	30 e0       	ldi	r19, 0x00	; 0
    32da:	f9 01       	movw	r30, r18
    32dc:	20 81       	ld	r18, Z
    32de:	2e 7f       	andi	r18, 0xFE	; 254
    32e0:	fc 01       	movw	r30, r24
    32e2:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    32e4:	8c e7       	ldi	r24, 0x7C	; 124
    32e6:	90 e0       	ldi	r25, 0x00	; 0
    32e8:	2c e7       	ldi	r18, 0x7C	; 124
    32ea:	30 e0       	ldi	r19, 0x00	; 0
    32ec:	f9 01       	movw	r30, r18
    32ee:	20 81       	ld	r18, Z
    32f0:	20 68       	ori	r18, 0x80	; 128
    32f2:	fc 01       	movw	r30, r24
    32f4:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    32f6:	8a e7       	ldi	r24, 0x7A	; 122
    32f8:	90 e0       	ldi	r25, 0x00	; 0
    32fa:	2a e7       	ldi	r18, 0x7A	; 122
    32fc:	30 e0       	ldi	r19, 0x00	; 0
    32fe:	f9 01       	movw	r30, r18
    3300:	20 81       	ld	r18, Z
    3302:	24 68       	ori	r18, 0x84	; 132
    3304:	fc 01       	movw	r30, r24
    3306:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    3308:	8e e7       	ldi	r24, 0x7E	; 126
    330a:	90 e0       	ldi	r25, 0x00	; 0
    330c:	2e ef       	ldi	r18, 0xFE	; 254
    330e:	fc 01       	movw	r30, r24
    3310:	20 83       	st	Z, r18
	Wait_ms(5);									//Tim for registers to setup
    3312:	85 e0       	ldi	r24, 0x05	; 5
    3314:	90 e0       	ldi	r25, 0x00	; 0
    3316:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_Z7Wait_msi>
	
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    331a:	1a 82       	std	Y+2, r1	; 0x02
    331c:	19 82       	std	Y+1, r1	; 0x01
    331e:	1c c0       	rjmp	.+56     	; 0x3358 <_Z7TakeADCv+0x98>
    3320:	8a e7       	ldi	r24, 0x7A	; 122
    3322:	90 e0       	ldi	r25, 0x00	; 0
    3324:	2a e7       	ldi	r18, 0x7A	; 122
    3326:	30 e0       	ldi	r19, 0x00	; 0
    3328:	f9 01       	movw	r30, r18
    332a:	20 81       	ld	r18, Z
    332c:	20 64       	ori	r18, 0x40	; 64
    332e:	fc 01       	movw	r30, r24
    3330:	20 83       	st	Z, r18
    3332:	8a e7       	ldi	r24, 0x7A	; 122
    3334:	90 e0       	ldi	r25, 0x00	; 0
    3336:	fc 01       	movw	r30, r24
    3338:	80 81       	ld	r24, Z
    333a:	88 2f       	mov	r24, r24
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	80 74       	andi	r24, 0x40	; 64
    3340:	90 70       	andi	r25, 0x00	; 0
    3342:	21 e0       	ldi	r18, 0x01	; 1
    3344:	00 97       	sbiw	r24, 0x00	; 0
    3346:	09 f4       	brne	.+2      	; 0x334a <_Z7TakeADCv+0x8a>
    3348:	20 e0       	ldi	r18, 0x00	; 0
    334a:	22 23       	and	r18, r18
    334c:	91 f7       	brne	.-28     	; 0x3332 <_Z7TakeADCv+0x72>
    334e:	89 81       	ldd	r24, Y+1	; 0x01
    3350:	9a 81       	ldd	r25, Y+2	; 0x02
    3352:	01 96       	adiw	r24, 0x01	; 1
    3354:	9a 83       	std	Y+2, r25	; 0x02
    3356:	89 83       	std	Y+1, r24	; 0x01
    3358:	21 e0       	ldi	r18, 0x01	; 1
    335a:	89 81       	ldd	r24, Y+1	; 0x01
    335c:	9a 81       	ldd	r25, Y+2	; 0x02
    335e:	82 30       	cpi	r24, 0x02	; 2
    3360:	91 05       	cpc	r25, r1
    3362:	0c f0       	brlt	.+2      	; 0x3366 <_Z7TakeADCv+0xa6>
    3364:	20 e0       	ldi	r18, 0x00	; 0
    3366:	22 23       	and	r18, r18
    3368:	d9 f6       	brne	.-74     	; 0x3320 <_Z7TakeADCv+0x60>
	
	//Put conversion into buffer
	adcReading = ADCL;
    336a:	88 e7       	ldi	r24, 0x78	; 120
    336c:	90 e0       	ldi	r25, 0x00	; 0
    336e:	fc 01       	movw	r30, r24
    3370:	80 81       	ld	r24, Z
    3372:	88 2f       	mov	r24, r24
    3374:	90 e0       	ldi	r25, 0x00	; 0
    3376:	9c 83       	std	Y+4, r25	; 0x04
    3378:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    337a:	89 e7       	ldi	r24, 0x79	; 121
    337c:	90 e0       	ldi	r25, 0x00	; 0
    337e:	fc 01       	movw	r30, r24
    3380:	80 81       	ld	r24, Z
    3382:	88 2f       	mov	r24, r24
    3384:	90 e0       	ldi	r25, 0x00	; 0
    3386:	98 2f       	mov	r25, r24
    3388:	88 27       	eor	r24, r24
    338a:	2b 81       	ldd	r18, Y+3	; 0x03
    338c:	3c 81       	ldd	r19, Y+4	; 0x04
    338e:	82 2b       	or	r24, r18
    3390:	93 2b       	or	r25, r19
    3392:	9c 83       	std	Y+4, r25	; 0x04
    3394:	8b 83       	std	Y+3, r24	; 0x03
		
	//Assign global reading and set flag
	globalADC=adcReading;
    3396:	8b 81       	ldd	r24, Y+3	; 0x03
    3398:	9c 81       	ldd	r25, Y+4	; 0x04
    339a:	90 93 8d 01 	sts	0x018D, r25
    339e:	80 93 8c 01 	sts	0x018C, r24
	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    33a2:	21 e0       	ldi	r18, 0x01	; 1
    33a4:	8b 81       	ldd	r24, Y+3	; 0x03
    33a6:	9c 81       	ldd	r25, Y+4	; 0x04
    33a8:	f3 e0       	ldi	r31, 0x03	; 3
    33aa:	82 37       	cpi	r24, 0x72	; 114
    33ac:	9f 07       	cpc	r25, r31
    33ae:	08 f4       	brcc	.+2      	; 0x33b2 <_Z7TakeADCv+0xf2>
    33b0:	20 e0       	ldi	r18, 0x00	; 0
    33b2:	20 93 c6 01 	sts	0x01C6, r18
		
	//Re-enable interrupts
	sei();
    33b6:	78 94       	sei
	
	//Disable ADC hardware/registers
	ADCSRA = 0;
    33b8:	8a e7       	ldi	r24, 0x7A	; 122
    33ba:	90 e0       	ldi	r25, 0x00	; 0
    33bc:	fc 01       	movw	r30, r24
    33be:	10 82       	st	Z, r1
	ADMUX = 0;
    33c0:	8c e7       	ldi	r24, 0x7C	; 124
    33c2:	90 e0       	ldi	r25, 0x00	; 0
    33c4:	fc 01       	movw	r30, r24
    33c6:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    33c8:	8e e7       	ldi	r24, 0x7E	; 126
    33ca:	90 e0       	ldi	r25, 0x00	; 0
    33cc:	2e e7       	ldi	r18, 0x7E	; 126
    33ce:	30 e0       	ldi	r19, 0x00	; 0
    33d0:	f9 01       	movw	r30, r18
    33d2:	20 81       	ld	r18, Z
    33d4:	21 60       	ori	r18, 0x01	; 1
    33d6:	fc 01       	movw	r30, r24
    33d8:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    33da:	84 e6       	ldi	r24, 0x64	; 100
    33dc:	90 e0       	ldi	r25, 0x00	; 0
    33de:	24 e6       	ldi	r18, 0x64	; 100
    33e0:	30 e0       	ldi	r19, 0x00	; 0
    33e2:	f9 01       	movw	r30, r18
    33e4:	20 81       	ld	r18, Z
    33e6:	21 60       	ori	r18, 0x01	; 1
    33e8:	fc 01       	movw	r30, r24
    33ea:	20 83       	st	Z, r18
}
    33ec:	0f 90       	pop	r0
    33ee:	0f 90       	pop	r0
    33f0:	0f 90       	pop	r0
    33f2:	0f 90       	pop	r0
    33f4:	df 91       	pop	r29
    33f6:	cf 91       	pop	r28
    33f8:	08 95       	ret

000033fa <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    33fa:	cf 93       	push	r28
    33fc:	df 93       	push	r29
    33fe:	00 d0       	rcall	.+0      	; 0x3400 <_Z7GetTempv+0x6>
    3400:	cd b7       	in	r28, 0x3d	; 61
    3402:	de b7       	in	r29, 0x3e	; 62
	WORD rawTemp = 0;
    3404:	1a 82       	std	Y+2, r1	; 0x02
    3406:	19 82       	std	Y+1, r1	; 0x01
	
	//Power on temp monitor, let it settle
	prtTEMPen |= (1 << bnTEMPen);
    3408:	85 e2       	ldi	r24, 0x25	; 37
    340a:	90 e0       	ldi	r25, 0x00	; 0
    340c:	25 e2       	ldi	r18, 0x25	; 37
    340e:	30 e0       	ldi	r19, 0x00	; 0
    3410:	f9 01       	movw	r30, r18
    3412:	20 81       	ld	r18, Z
    3414:	21 60       	ori	r18, 0x01	; 1
    3416:	fc 01       	movw	r30, r24
    3418:	20 83       	st	Z, r18
	PRR0 &= ~(1 << PRSPI);	
    341a:	84 e6       	ldi	r24, 0x64	; 100
    341c:	90 e0       	ldi	r25, 0x00	; 0
    341e:	24 e6       	ldi	r18, 0x64	; 100
    3420:	30 e0       	ldi	r19, 0x00	; 0
    3422:	f9 01       	movw	r30, r18
    3424:	20 81       	ld	r18, Z
    3426:	2b 7f       	andi	r18, 0xFB	; 251
    3428:	fc 01       	movw	r30, r24
    342a:	20 83       	st	Z, r18
	SPCR |= (1 << MSTR)|(1 << SPE)|(1 << SPR0);			//enables SPI, master, fck/64
    342c:	8c e4       	ldi	r24, 0x4C	; 76
    342e:	90 e0       	ldi	r25, 0x00	; 0
    3430:	2c e4       	ldi	r18, 0x4C	; 76
    3432:	30 e0       	ldi	r19, 0x00	; 0
    3434:	f9 01       	movw	r30, r18
    3436:	20 81       	ld	r18, Z
    3438:	21 65       	ori	r18, 0x51	; 81
    343a:	fc 01       	movw	r30, r24
    343c:	20 83       	st	Z, r18
	Wait_sec(500);
    343e:	84 ef       	ldi	r24, 0xF4	; 244
    3440:	91 e0       	ldi	r25, 0x01	; 1
    3442:	0e 94 ab 18 	call	0x3156	; 0x3156 <_Z8Wait_seci>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    3446:	85 e2       	ldi	r24, 0x25	; 37
    3448:	90 e0       	ldi	r25, 0x00	; 0
    344a:	25 e2       	ldi	r18, 0x25	; 37
    344c:	30 e0       	ldi	r19, 0x00	; 0
    344e:	f9 01       	movw	r30, r18
    3450:	20 81       	ld	r18, Z
    3452:	2f 76       	andi	r18, 0x6F	; 111
    3454:	fc 01       	movw	r30, r24
    3456:	20 83       	st	Z, r18
	
	cli();
    3458:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR = 0x00;
    345a:	8e e4       	ldi	r24, 0x4E	; 78
    345c:	90 e0       	ldi	r25, 0x00	; 0
    345e:	fc 01       	movw	r30, r24
    3460:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR & (1 << SPIF)));
    3462:	00 00       	nop
    3464:	8d e4       	ldi	r24, 0x4D	; 77
    3466:	90 e0       	ldi	r25, 0x00	; 0
    3468:	fc 01       	movw	r30, r24
    346a:	80 81       	ld	r24, Z
    346c:	80 95       	com	r24
    346e:	88 1f       	adc	r24, r24
    3470:	88 27       	eor	r24, r24
    3472:	88 1f       	adc	r24, r24
    3474:	88 23       	and	r24, r24
    3476:	b1 f7       	brne	.-20     	; 0x3464 <_Z7GetTempv+0x6a>
	rawTemp = (SPDR0 << 8);
    3478:	1a 82       	std	Y+2, r1	; 0x02
    347a:	19 82       	std	Y+1, r1	; 0x01
	SPDR = 0x00;
    347c:	8e e4       	ldi	r24, 0x4E	; 78
    347e:	90 e0       	ldi	r25, 0x00	; 0
    3480:	fc 01       	movw	r30, r24
    3482:	10 82       	st	Z, r1
	while (!(SPSR & (1 << SPIF)));
    3484:	00 00       	nop
    3486:	8d e4       	ldi	r24, 0x4D	; 77
    3488:	90 e0       	ldi	r25, 0x00	; 0
    348a:	fc 01       	movw	r30, r24
    348c:	80 81       	ld	r24, Z
    348e:	80 95       	com	r24
    3490:	88 1f       	adc	r24, r24
    3492:	88 27       	eor	r24, r24
    3494:	88 1f       	adc	r24, r24
    3496:	88 23       	and	r24, r24
    3498:	b1 f7       	brne	.-20     	; 0x3486 <_Z7GetTempv+0x8c>
	rawTemp |= SPDR0;
	
	//Set flag to correct value, update global value
	flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
    349a:	89 81       	ldd	r24, Y+1	; 0x01
    349c:	9a 81       	ldd	r25, Y+2	; 0x02
    349e:	f2 e3       	ldi	r31, 0x32	; 50
    34a0:	84 36       	cpi	r24, 0x64	; 100
    34a2:	9f 07       	cpc	r25, r31
    34a4:	10 f4       	brcc	.+4      	; 0x34aa <_Z7GetTempv+0xb0>
    34a6:	81 e0       	ldi	r24, 0x01	; 1
    34a8:	01 c0       	rjmp	.+2      	; 0x34ac <_Z7GetTempv+0xb2>
    34aa:	80 e0       	ldi	r24, 0x00	; 0
    34ac:	80 93 c5 01 	sts	0x01C5, r24
	globalTemp=rawTemp;
    34b0:	89 81       	ldd	r24, Y+1	; 0x01
    34b2:	9a 81       	ldd	r25, Y+2	; 0x02
    34b4:	90 93 8f 01 	sts	0x018F, r25
    34b8:	80 93 8e 01 	sts	0x018E, r24
	
	//re enable interrupts
	sei();
    34bc:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    34be:	85 e2       	ldi	r24, 0x25	; 37
    34c0:	90 e0       	ldi	r25, 0x00	; 0
    34c2:	25 e2       	ldi	r18, 0x25	; 37
    34c4:	30 e0       	ldi	r19, 0x00	; 0
    34c6:	f9 01       	movw	r30, r18
    34c8:	20 81       	ld	r18, Z
    34ca:	20 69       	ori	r18, 0x90	; 144
    34cc:	fc 01       	movw	r30, r24
    34ce:	20 83       	st	Z, r18
	SPCR=0x00;	
    34d0:	8c e4       	ldi	r24, 0x4C	; 76
    34d2:	90 e0       	ldi	r25, 0x00	; 0
    34d4:	fc 01       	movw	r30, r24
    34d6:	10 82       	st	Z, r1
	prtTEMPen &= ~(1 << bnTEMPen);
    34d8:	85 e2       	ldi	r24, 0x25	; 37
    34da:	90 e0       	ldi	r25, 0x00	; 0
    34dc:	25 e2       	ldi	r18, 0x25	; 37
    34de:	30 e0       	ldi	r19, 0x00	; 0
    34e0:	f9 01       	movw	r30, r18
    34e2:	20 81       	ld	r18, Z
    34e4:	2e 7f       	andi	r18, 0xFE	; 254
    34e6:	fc 01       	movw	r30, r24
    34e8:	20 83       	st	Z, r18
	PRR0 |= (1 << PRSPI);
    34ea:	84 e6       	ldi	r24, 0x64	; 100
    34ec:	90 e0       	ldi	r25, 0x00	; 0
    34ee:	24 e6       	ldi	r18, 0x64	; 100
    34f0:	30 e0       	ldi	r19, 0x00	; 0
    34f2:	f9 01       	movw	r30, r18
    34f4:	20 81       	ld	r18, Z
    34f6:	24 60       	ori	r18, 0x04	; 4
    34f8:	fc 01       	movw	r30, r24
    34fa:	20 83       	st	Z, r18
}
    34fc:	0f 90       	pop	r0
    34fe:	0f 90       	pop	r0
    3500:	df 91       	pop	r29
    3502:	cf 91       	pop	r28
    3504:	08 95       	ret

00003506 <_Z7PowerUpj>:
/*************************************************************************************************************/
void PowerUp(WORD interval){
    3506:	cf 93       	push	r28
    3508:	df 93       	push	r29
    350a:	00 d0       	rcall	.+0      	; 0x350c <_Z7PowerUpj+0x6>
    350c:	cd b7       	in	r28, 0x3d	; 61
    350e:	de b7       	in	r29, 0x3e	; 62
    3510:	9a 83       	std	Y+2, r25	; 0x02
    3512:	89 83       	std	Y+1, r24	; 0x01
	cli();
    3514:	f8 94       	cli
	
	//First power on main regulator
	__enableMain();
    3516:	88 e2       	ldi	r24, 0x28	; 40
    3518:	90 e0       	ldi	r25, 0x00	; 0
    351a:	28 e2       	ldi	r18, 0x28	; 40
    351c:	30 e0       	ldi	r19, 0x00	; 0
    351e:	f9 01       	movw	r30, r18
    3520:	20 81       	ld	r18, Z
    3522:	21 60       	ori	r18, 0x01	; 1
    3524:	fc 01       	movw	r30, r24
    3526:	20 83       	st	Z, r18
	Wait_ms(interval);
    3528:	89 81       	ldd	r24, Y+1	; 0x01
    352a:	9a 81       	ldd	r25, Y+2	; 0x02
    352c:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_Z7Wait_msi>
	
	//Power on BeagleBone next, takes longer time.
	__enableBeagleBone();
    3530:	82 e2       	ldi	r24, 0x22	; 34
    3532:	90 e0       	ldi	r25, 0x00	; 0
    3534:	22 e2       	ldi	r18, 0x22	; 34
    3536:	30 e0       	ldi	r19, 0x00	; 0
    3538:	f9 01       	movw	r30, r18
    353a:	20 81       	ld	r18, Z
    353c:	20 61       	ori	r18, 0x10	; 16
    353e:	fc 01       	movw	r30, r24
    3540:	20 83       	st	Z, r18
	Wait_ms(interval);
    3542:	89 81       	ldd	r24, Y+1	; 0x01
    3544:	9a 81       	ldd	r25, Y+2	; 0x02
    3546:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_Z7Wait_msi>
	//while (!(pinBBio & (1 << bnW0B9)));	//Wait for GPIO line to go high
	
	//Power on GAVR and Enable GPS
	__enableGPSandGAVR();
    354a:	82 e2       	ldi	r24, 0x22	; 34
    354c:	90 e0       	ldi	r25, 0x00	; 0
    354e:	22 e2       	ldi	r18, 0x22	; 34
    3550:	30 e0       	ldi	r19, 0x00	; 0
    3552:	f9 01       	movw	r30, r18
    3554:	20 81       	ld	r18, Z
    3556:	20 6c       	ori	r18, 0xC0	; 192
    3558:	fc 01       	movw	r30, r24
    355a:	20 83       	st	Z, r18
	Wait_ms(interval);
    355c:	89 81       	ldd	r24, Y+1	; 0x01
    355e:	9a 81       	ldd	r25, Y+2	; 0x02
    3560:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_Z7Wait_msi>
	//while (!(pinGAVRio & (1 << bnW3G0)));	//Wait for GPIO line to go high signifying correct boot
	
	//Power on LCD
	__enableLCD();
    3564:	82 e2       	ldi	r24, 0x22	; 34
    3566:	90 e0       	ldi	r25, 0x00	; 0
    3568:	22 e2       	ldi	r18, 0x22	; 34
    356a:	30 e0       	ldi	r19, 0x00	; 0
    356c:	f9 01       	movw	r30, r18
    356e:	20 81       	ld	r18, Z
    3570:	20 62       	ori	r18, 0x20	; 32
    3572:	fc 01       	movw	r30, r24
    3574:	20 83       	st	Z, r18
	Wait_ms(interval);
    3576:	89 81       	ldd	r24, Y+1	; 0x01
    3578:	9a 81       	ldd	r25, Y+2	; 0x02
    357a:	0e 94 7a 18 	call	0x30f4	; 0x30f4 <_Z7Wait_msi>
	sei();
    357e:	78 94       	sei
	
}
    3580:	0f 90       	pop	r0
    3582:	0f 90       	pop	r0
    3584:	df 91       	pop	r29
    3586:	cf 91       	pop	r28
    3588:	08 95       	ret

0000358a <_Z9PowerDownv>:
/*************************************************************************************************************/
void PowerDown(){
    358a:	cf 93       	push	r28
    358c:	df 93       	push	r29
    358e:	cd b7       	in	r28, 0x3d	; 61
    3590:	de b7       	in	r29, 0x3e	; 62
	cli();
    3592:	f8 94       	cli
	//Signify interrupts, wait 6 seconds for all processing to stop.
	prtInterrupts |= (1 << bnBBint)|(1 << bnGAVRint);
    3594:	82 e2       	ldi	r24, 0x22	; 34
    3596:	90 e0       	ldi	r25, 0x00	; 0
    3598:	22 e2       	ldi	r18, 0x22	; 34
    359a:	30 e0       	ldi	r19, 0x00	; 0
    359c:	f9 01       	movw	r30, r18
    359e:	20 81       	ld	r18, Z
    35a0:	2c 60       	ori	r18, 0x0C	; 12
    35a2:	fc 01       	movw	r30, r24
    35a4:	20 83       	st	Z, r18
	Wait_sec(6);
    35a6:	86 e0       	ldi	r24, 0x06	; 6
    35a8:	90 e0       	ldi	r25, 0x00	; 0
    35aa:	0e 94 ab 18 	call	0x3156	; 0x3156 <_Z8Wait_seci>
	prtInterrupts &= ~((1 << bnBBint)|(1 << bnGAVRint));
    35ae:	82 e2       	ldi	r24, 0x22	; 34
    35b0:	90 e0       	ldi	r25, 0x00	; 0
    35b2:	22 e2       	ldi	r18, 0x22	; 34
    35b4:	30 e0       	ldi	r19, 0x00	; 0
    35b6:	f9 01       	movw	r30, r18
    35b8:	20 81       	ld	r18, Z
    35ba:	23 7f       	andi	r18, 0xF3	; 243
    35bc:	fc 01       	movw	r30, r24
    35be:	20 83       	st	Z, r18
	__killLCD();
    35c0:	82 e2       	ldi	r24, 0x22	; 34
    35c2:	90 e0       	ldi	r25, 0x00	; 0
    35c4:	22 e2       	ldi	r18, 0x22	; 34
    35c6:	30 e0       	ldi	r19, 0x00	; 0
    35c8:	f9 01       	movw	r30, r18
    35ca:	20 81       	ld	r18, Z
    35cc:	2f 7d       	andi	r18, 0xDF	; 223
    35ce:	fc 01       	movw	r30, r24
    35d0:	20 83       	st	Z, r18
	__killGPSandGAVR();
    35d2:	82 e2       	ldi	r24, 0x22	; 34
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	22 e2       	ldi	r18, 0x22	; 34
    35d8:	30 e0       	ldi	r19, 0x00	; 0
    35da:	f9 01       	movw	r30, r18
    35dc:	20 81       	ld	r18, Z
    35de:	2f 73       	andi	r18, 0x3F	; 63
    35e0:	fc 01       	movw	r30, r24
    35e2:	20 83       	st	Z, r18
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
    35e4:	86 e0       	ldi	r24, 0x06	; 6
    35e6:	90 e0       	ldi	r25, 0x00	; 0
    35e8:	0e 94 ab 18 	call	0x3156	; 0x3156 <_Z8Wait_seci>
	__killBeagleBone();
    35ec:	82 e2       	ldi	r24, 0x22	; 34
    35ee:	90 e0       	ldi	r25, 0x00	; 0
    35f0:	22 e2       	ldi	r18, 0x22	; 34
    35f2:	30 e0       	ldi	r19, 0x00	; 0
    35f4:	f9 01       	movw	r30, r18
    35f6:	20 81       	ld	r18, Z
    35f8:	2f 7e       	andi	r18, 0xEF	; 239
    35fa:	fc 01       	movw	r30, r24
    35fc:	20 83       	st	Z, r18
	__killMain();
    35fe:	88 e2       	ldi	r24, 0x28	; 40
    3600:	90 e0       	ldi	r25, 0x00	; 0
    3602:	28 e2       	ldi	r18, 0x28	; 40
    3604:	30 e0       	ldi	r19, 0x00	; 0
    3606:	f9 01       	movw	r30, r18
    3608:	20 81       	ld	r18, Z
    360a:	2e 7f       	andi	r18, 0xFE	; 254
    360c:	fc 01       	movw	r30, r24
    360e:	20 83       	st	Z, r18
	sei();
    3610:	78 94       	sei
}
    3612:	df 91       	pop	r29
    3614:	cf 91       	pop	r28
    3616:	08 95       	ret

00003618 <_Z41__static_initialization_and_destruction_0ii>:
    3618:	cf 93       	push	r28
    361a:	df 93       	push	r29
    361c:	00 d0       	rcall	.+0      	; 0x361e <_Z41__static_initialization_and_destruction_0ii+0x6>
    361e:	00 d0       	rcall	.+0      	; 0x3620 <_Z41__static_initialization_and_destruction_0ii+0x8>
    3620:	cd b7       	in	r28, 0x3d	; 61
    3622:	de b7       	in	r29, 0x3e	; 62
    3624:	9a 83       	std	Y+2, r25	; 0x02
    3626:	89 83       	std	Y+1, r24	; 0x01
    3628:	7c 83       	std	Y+4, r23	; 0x04
    362a:	6b 83       	std	Y+3, r22	; 0x03
    362c:	89 81       	ldd	r24, Y+1	; 0x01
    362e:	9a 81       	ldd	r25, Y+2	; 0x02
    3630:	81 30       	cpi	r24, 0x01	; 1
    3632:	91 05       	cpc	r25, r1
    3634:	51 f4       	brne	.+20     	; 0x364a <_Z41__static_initialization_and_destruction_0ii+0x32>
    3636:	8b 81       	ldd	r24, Y+3	; 0x03
    3638:	9c 81       	ldd	r25, Y+4	; 0x04
    363a:	2f ef       	ldi	r18, 0xFF	; 255
    363c:	8f 3f       	cpi	r24, 0xFF	; 255
    363e:	92 07       	cpc	r25, r18
    3640:	21 f4       	brne	.+8      	; 0x364a <_Z41__static_initialization_and_destruction_0ii+0x32>

/*********************************************GLOBAL VARIABLES***************************************************/
/****************************************************************************************************************/
WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    3642:	80 e9       	ldi	r24, 0x90	; 144
    3644:	91 e0       	ldi	r25, 0x01	; 1
    3646:	0e 94 10 04 	call	0x820	; 0x820 <_ZN6myTimeC1Ev>
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
	__killBeagleBone();
	__killMain();
	sei();
}
    364a:	0f 90       	pop	r0
    364c:	0f 90       	pop	r0
    364e:	0f 90       	pop	r0
    3650:	0f 90       	pop	r0
    3652:	df 91       	pop	r29
    3654:	cf 91       	pop	r28
    3656:	08 95       	ret

00003658 <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    3658:	cf 93       	push	r28
    365a:	df 93       	push	r29
    365c:	cd b7       	in	r28, 0x3d	; 61
    365e:	de b7       	in	r29, 0x3e	; 62
    3660:	81 e0       	ldi	r24, 0x01	; 1
    3662:	90 e0       	ldi	r25, 0x00	; 0
    3664:	6f ef       	ldi	r22, 0xFF	; 255
    3666:	7f ef       	ldi	r23, 0xFF	; 255
    3668:	0e 94 0c 1b 	call	0x3618	; 0x3618 <_Z41__static_initialization_and_destruction_0ii>
    366c:	df 91       	pop	r29
    366e:	cf 91       	pop	r28
    3670:	08 95       	ret

00003672 <__udivmodqi4>:
    3672:	99 1b       	sub	r25, r25
    3674:	79 e0       	ldi	r23, 0x09	; 9
    3676:	04 c0       	rjmp	.+8      	; 0x3680 <__udivmodqi4_ep>

00003678 <__udivmodqi4_loop>:
    3678:	99 1f       	adc	r25, r25
    367a:	96 17       	cp	r25, r22
    367c:	08 f0       	brcs	.+2      	; 0x3680 <__udivmodqi4_ep>
    367e:	96 1b       	sub	r25, r22

00003680 <__udivmodqi4_ep>:
    3680:	88 1f       	adc	r24, r24
    3682:	7a 95       	dec	r23
    3684:	c9 f7       	brne	.-14     	; 0x3678 <__udivmodqi4_loop>
    3686:	80 95       	com	r24
    3688:	08 95       	ret

0000368a <__divmodhi4>:
    368a:	97 fb       	bst	r25, 7
    368c:	09 2e       	mov	r0, r25
    368e:	07 26       	eor	r0, r23
    3690:	0a d0       	rcall	.+20     	; 0x36a6 <__divmodhi4_neg1>
    3692:	77 fd       	sbrc	r23, 7
    3694:	04 d0       	rcall	.+8      	; 0x369e <__divmodhi4_neg2>
    3696:	0c d0       	rcall	.+24     	; 0x36b0 <__udivmodhi4>
    3698:	06 d0       	rcall	.+12     	; 0x36a6 <__divmodhi4_neg1>
    369a:	00 20       	and	r0, r0
    369c:	1a f4       	brpl	.+6      	; 0x36a4 <__divmodhi4_exit>

0000369e <__divmodhi4_neg2>:
    369e:	70 95       	com	r23
    36a0:	61 95       	neg	r22
    36a2:	7f 4f       	sbci	r23, 0xFF	; 255

000036a4 <__divmodhi4_exit>:
    36a4:	08 95       	ret

000036a6 <__divmodhi4_neg1>:
    36a6:	f6 f7       	brtc	.-4      	; 0x36a4 <__divmodhi4_exit>
    36a8:	90 95       	com	r25
    36aa:	81 95       	neg	r24
    36ac:	9f 4f       	sbci	r25, 0xFF	; 255
    36ae:	08 95       	ret

000036b0 <__udivmodhi4>:
    36b0:	aa 1b       	sub	r26, r26
    36b2:	bb 1b       	sub	r27, r27
    36b4:	51 e1       	ldi	r21, 0x11	; 17
    36b6:	07 c0       	rjmp	.+14     	; 0x36c6 <__udivmodhi4_ep>

000036b8 <__udivmodhi4_loop>:
    36b8:	aa 1f       	adc	r26, r26
    36ba:	bb 1f       	adc	r27, r27
    36bc:	a6 17       	cp	r26, r22
    36be:	b7 07       	cpc	r27, r23
    36c0:	10 f0       	brcs	.+4      	; 0x36c6 <__udivmodhi4_ep>
    36c2:	a6 1b       	sub	r26, r22
    36c4:	b7 0b       	sbc	r27, r23

000036c6 <__udivmodhi4_ep>:
    36c6:	88 1f       	adc	r24, r24
    36c8:	99 1f       	adc	r25, r25
    36ca:	5a 95       	dec	r21
    36cc:	a9 f7       	brne	.-22     	; 0x36b8 <__udivmodhi4_loop>
    36ce:	80 95       	com	r24
    36d0:	90 95       	com	r25
    36d2:	bc 01       	movw	r22, r24
    36d4:	cd 01       	movw	r24, r26
    36d6:	08 95       	ret

000036d8 <__tablejump2__>:
    36d8:	ee 0f       	add	r30, r30
    36da:	ff 1f       	adc	r31, r31

000036dc <__tablejump__>:
    36dc:	05 90       	lpm	r0, Z+
    36de:	f4 91       	lpm	r31, Z
    36e0:	e0 2d       	mov	r30, r0
    36e2:	09 94       	ijmp

000036e4 <atoi>:
    36e4:	fc 01       	movw	r30, r24
    36e6:	88 27       	eor	r24, r24
    36e8:	99 27       	eor	r25, r25
    36ea:	e8 94       	clt
    36ec:	21 91       	ld	r18, Z+
    36ee:	20 32       	cpi	r18, 0x20	; 32
    36f0:	e9 f3       	breq	.-6      	; 0x36ec <atoi+0x8>
    36f2:	29 30       	cpi	r18, 0x09	; 9
    36f4:	10 f0       	brcs	.+4      	; 0x36fa <atoi+0x16>
    36f6:	2e 30       	cpi	r18, 0x0E	; 14
    36f8:	c8 f3       	brcs	.-14     	; 0x36ec <atoi+0x8>
    36fa:	2b 32       	cpi	r18, 0x2B	; 43
    36fc:	41 f0       	breq	.+16     	; 0x370e <atoi+0x2a>
    36fe:	2d 32       	cpi	r18, 0x2D	; 45
    3700:	39 f4       	brne	.+14     	; 0x3710 <atoi+0x2c>
    3702:	68 94       	set
    3704:	04 c0       	rjmp	.+8      	; 0x370e <atoi+0x2a>
    3706:	0e 94 da 1b 	call	0x37b4	; 0x37b4 <__mulhi_const_10>
    370a:	82 0f       	add	r24, r18
    370c:	91 1d       	adc	r25, r1
    370e:	21 91       	ld	r18, Z+
    3710:	20 53       	subi	r18, 0x30	; 48
    3712:	2a 30       	cpi	r18, 0x0A	; 10
    3714:	c0 f3       	brcs	.-16     	; 0x3706 <atoi+0x22>
    3716:	1e f4       	brtc	.+6      	; 0x371e <atoi+0x3a>
    3718:	90 95       	com	r25
    371a:	81 95       	neg	r24
    371c:	9f 4f       	sbci	r25, 0xFF	; 255
    371e:	08 95       	ret

00003720 <strcat>:
    3720:	fb 01       	movw	r30, r22
    3722:	dc 01       	movw	r26, r24
    3724:	0d 90       	ld	r0, X+
    3726:	00 20       	and	r0, r0
    3728:	e9 f7       	brne	.-6      	; 0x3724 <strcat+0x4>
    372a:	11 97       	sbiw	r26, 0x01	; 1
    372c:	01 90       	ld	r0, Z+
    372e:	0d 92       	st	X+, r0
    3730:	00 20       	and	r0, r0
    3732:	e1 f7       	brne	.-8      	; 0x372c <strcat+0xc>
    3734:	08 95       	ret

00003736 <strcmp>:
    3736:	fb 01       	movw	r30, r22
    3738:	dc 01       	movw	r26, r24
    373a:	8d 91       	ld	r24, X+
    373c:	01 90       	ld	r0, Z+
    373e:	80 19       	sub	r24, r0
    3740:	01 10       	cpse	r0, r1
    3742:	d9 f3       	breq	.-10     	; 0x373a <strcmp+0x4>
    3744:	99 0b       	sbc	r25, r25
    3746:	08 95       	ret

00003748 <strcpy>:
    3748:	fb 01       	movw	r30, r22
    374a:	dc 01       	movw	r26, r24
    374c:	01 90       	ld	r0, Z+
    374e:	0d 92       	st	X+, r0
    3750:	00 20       	and	r0, r0
    3752:	e1 f7       	brne	.-8      	; 0x374c <strcpy+0x4>
    3754:	08 95       	ret

00003756 <strncmp>:
    3756:	fb 01       	movw	r30, r22
    3758:	dc 01       	movw	r26, r24
    375a:	41 50       	subi	r20, 0x01	; 1
    375c:	50 40       	sbci	r21, 0x00	; 0
    375e:	30 f0       	brcs	.+12     	; 0x376c <strncmp+0x16>
    3760:	8d 91       	ld	r24, X+
    3762:	01 90       	ld	r0, Z+
    3764:	80 19       	sub	r24, r0
    3766:	19 f4       	brne	.+6      	; 0x376e <strncmp+0x18>
    3768:	00 20       	and	r0, r0
    376a:	b9 f7       	brne	.-18     	; 0x375a <strncmp+0x4>
    376c:	88 1b       	sub	r24, r24
    376e:	99 0b       	sbc	r25, r25
    3770:	08 95       	ret

00003772 <itoa>:
    3772:	fb 01       	movw	r30, r22
    3774:	9f 01       	movw	r18, r30
    3776:	e8 94       	clt
    3778:	42 30       	cpi	r20, 0x02	; 2
    377a:	c4 f0       	brlt	.+48     	; 0x37ac <itoa+0x3a>
    377c:	45 32       	cpi	r20, 0x25	; 37
    377e:	b4 f4       	brge	.+44     	; 0x37ac <itoa+0x3a>
    3780:	4a 30       	cpi	r20, 0x0A	; 10
    3782:	29 f4       	brne	.+10     	; 0x378e <itoa+0x1c>
    3784:	97 fb       	bst	r25, 7
    3786:	1e f4       	brtc	.+6      	; 0x378e <itoa+0x1c>
    3788:	90 95       	com	r25
    378a:	81 95       	neg	r24
    378c:	9f 4f       	sbci	r25, 0xFF	; 255
    378e:	64 2f       	mov	r22, r20
    3790:	77 27       	eor	r23, r23
    3792:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__udivmodhi4>
    3796:	80 5d       	subi	r24, 0xD0	; 208
    3798:	8a 33       	cpi	r24, 0x3A	; 58
    379a:	0c f0       	brlt	.+2      	; 0x379e <itoa+0x2c>
    379c:	89 5d       	subi	r24, 0xD9	; 217
    379e:	81 93       	st	Z+, r24
    37a0:	cb 01       	movw	r24, r22
    37a2:	00 97       	sbiw	r24, 0x00	; 0
    37a4:	a1 f7       	brne	.-24     	; 0x378e <itoa+0x1c>
    37a6:	16 f4       	brtc	.+4      	; 0x37ac <itoa+0x3a>
    37a8:	5d e2       	ldi	r21, 0x2D	; 45
    37aa:	51 93       	st	Z+, r21
    37ac:	10 82       	st	Z, r1
    37ae:	c9 01       	movw	r24, r18
    37b0:	0c 94 19 1c 	jmp	0x3832	; 0x3832 <strrev>

000037b4 <__mulhi_const_10>:
    37b4:	7a e0       	ldi	r23, 0x0A	; 10
    37b6:	97 9f       	mul	r25, r23
    37b8:	90 2d       	mov	r25, r0
    37ba:	87 9f       	mul	r24, r23
    37bc:	80 2d       	mov	r24, r0
    37be:	91 0d       	add	r25, r1
    37c0:	11 24       	eor	r1, r1
    37c2:	08 95       	ret

000037c4 <utoa>:
    37c4:	fb 01       	movw	r30, r22
    37c6:	9f 01       	movw	r18, r30
    37c8:	42 30       	cpi	r20, 0x02	; 2
    37ca:	74 f0       	brlt	.+28     	; 0x37e8 <utoa+0x24>
    37cc:	45 32       	cpi	r20, 0x25	; 37
    37ce:	64 f4       	brge	.+24     	; 0x37e8 <utoa+0x24>
    37d0:	64 2f       	mov	r22, r20
    37d2:	77 27       	eor	r23, r23
    37d4:	0e 94 58 1b 	call	0x36b0	; 0x36b0 <__udivmodhi4>
    37d8:	80 5d       	subi	r24, 0xD0	; 208
    37da:	8a 33       	cpi	r24, 0x3A	; 58
    37dc:	0c f0       	brlt	.+2      	; 0x37e0 <utoa+0x1c>
    37de:	89 5d       	subi	r24, 0xD9	; 217
    37e0:	81 93       	st	Z+, r24
    37e2:	cb 01       	movw	r24, r22
    37e4:	00 97       	sbiw	r24, 0x00	; 0
    37e6:	a1 f7       	brne	.-24     	; 0x37d0 <utoa+0xc>
    37e8:	10 82       	st	Z, r1
    37ea:	c9 01       	movw	r24, r18
    37ec:	0c 94 19 1c 	jmp	0x3832	; 0x3832 <strrev>

000037f0 <__eerd_byte_m644pa>:
    37f0:	f9 99       	sbic	0x1f, 1	; 31
    37f2:	fe cf       	rjmp	.-4      	; 0x37f0 <__eerd_byte_m644pa>
    37f4:	92 bd       	out	0x22, r25	; 34
    37f6:	81 bd       	out	0x21, r24	; 33
    37f8:	f8 9a       	sbi	0x1f, 0	; 31
    37fa:	99 27       	eor	r25, r25
    37fc:	80 b5       	in	r24, 0x20	; 32
    37fe:	08 95       	ret

00003800 <__eerd_word_m644pa>:
    3800:	a8 e1       	ldi	r26, 0x18	; 24
    3802:	b0 e0       	ldi	r27, 0x00	; 0
    3804:	42 e0       	ldi	r20, 0x02	; 2
    3806:	50 e0       	ldi	r21, 0x00	; 0
    3808:	0c 94 2b 1c 	jmp	0x3856	; 0x3856 <__eerd_blraw_m644pa>

0000380c <__eewr_byte_m644pa>:
    380c:	26 2f       	mov	r18, r22

0000380e <__eewr_r18_m644pa>:
    380e:	f9 99       	sbic	0x1f, 1	; 31
    3810:	fe cf       	rjmp	.-4      	; 0x380e <__eewr_r18_m644pa>
    3812:	1f ba       	out	0x1f, r1	; 31
    3814:	92 bd       	out	0x22, r25	; 34
    3816:	81 bd       	out	0x21, r24	; 33
    3818:	20 bd       	out	0x20, r18	; 32
    381a:	0f b6       	in	r0, 0x3f	; 63
    381c:	f8 94       	cli
    381e:	fa 9a       	sbi	0x1f, 2	; 31
    3820:	f9 9a       	sbi	0x1f, 1	; 31
    3822:	0f be       	out	0x3f, r0	; 63
    3824:	01 96       	adiw	r24, 0x01	; 1
    3826:	08 95       	ret

00003828 <__eewr_word_m644pa>:
    3828:	0e 94 06 1c 	call	0x380c	; 0x380c <__eewr_byte_m644pa>
    382c:	27 2f       	mov	r18, r23
    382e:	0c 94 07 1c 	jmp	0x380e	; 0x380e <__eewr_r18_m644pa>

00003832 <strrev>:
    3832:	dc 01       	movw	r26, r24
    3834:	fc 01       	movw	r30, r24
    3836:	67 2f       	mov	r22, r23
    3838:	71 91       	ld	r23, Z+
    383a:	77 23       	and	r23, r23
    383c:	e1 f7       	brne	.-8      	; 0x3836 <strrev+0x4>
    383e:	32 97       	sbiw	r30, 0x02	; 2
    3840:	04 c0       	rjmp	.+8      	; 0x384a <strrev+0x18>
    3842:	7c 91       	ld	r23, X
    3844:	6d 93       	st	X+, r22
    3846:	70 83       	st	Z, r23
    3848:	62 91       	ld	r22, -Z
    384a:	ae 17       	cp	r26, r30
    384c:	bf 07       	cpc	r27, r31
    384e:	c8 f3       	brcs	.-14     	; 0x3842 <strrev+0x10>
    3850:	08 95       	ret

00003852 <__eerd_block_m644pa>:
    3852:	dc 01       	movw	r26, r24
    3854:	cb 01       	movw	r24, r22

00003856 <__eerd_blraw_m644pa>:
    3856:	fc 01       	movw	r30, r24
    3858:	f9 99       	sbic	0x1f, 1	; 31
    385a:	fe cf       	rjmp	.-4      	; 0x3858 <__eerd_blraw_m644pa+0x2>
    385c:	06 c0       	rjmp	.+12     	; 0x386a <__eerd_blraw_m644pa+0x14>
    385e:	f2 bd       	out	0x22, r31	; 34
    3860:	e1 bd       	out	0x21, r30	; 33
    3862:	f8 9a       	sbi	0x1f, 0	; 31
    3864:	31 96       	adiw	r30, 0x01	; 1
    3866:	00 b4       	in	r0, 0x20	; 32
    3868:	0d 92       	st	X+, r0
    386a:	41 50       	subi	r20, 0x01	; 1
    386c:	50 40       	sbci	r21, 0x00	; 0
    386e:	b8 f7       	brcc	.-18     	; 0x385e <__eerd_blraw_m644pa+0x8>
    3870:	08 95       	ret

00003872 <_exit>:
    3872:	f8 94       	cli

00003874 <__stop_program>:
    3874:	ff cf       	rjmp	.-2      	; 0x3874 <__stop_program>
