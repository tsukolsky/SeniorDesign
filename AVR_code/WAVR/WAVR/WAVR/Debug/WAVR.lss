
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d0  00800100  00003baa  00003c5e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003baa  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000049  008001d0  008001d0  00003d2e  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  00003d2e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000011f4  00000000  00000000  00003d38  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000005eb  00000000  00000000  00004f2c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  00005518  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000022fb  00000000  00000000  00005638  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000393  00000000  00000000  00007933  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000fd4  00000000  00000000  00007cc6  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008f0  00000000  00000000  00008c9c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b51  00000000  00000000  0000958c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000012f8  00000000  00000000  0000a0dd  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000030  00000000  00000000  0000b3d5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 73 14 	jmp	0x28e6	; 0x28e6 <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 17 14 	jmp	0x282e	; 0x282e <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 3c 15 	jmp	0x2a78	; 0x2a78 <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 c6 14 	jmp	0x298c	; 0x298c <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 f9 14 	jmp	0x29f2	; 0x29f2 <__vector_28>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	c6 1c       	adc	r12, r6

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d0 e1       	ldi	r29, 0x10	; 16
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	ea ea       	ldi	r30, 0xAA	; 170
      92:	fb e3       	ldi	r31, 0x3B	; 59
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	a0 3d       	cpi	r26, 0xD0	; 208
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	12 e0       	ldi	r17, 0x02	; 2
      a2:	a0 ed       	ldi	r26, 0xD0	; 208
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	a9 31       	cpi	r26, 0x19	; 25
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 08 1d 	call	0x3a10	; 0x3a10 <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 0a 17 	call	0x2e14	; 0x2e14 <main>
      ca:	0c 94 d3 1d 	jmp	0x3ba6	; 0x3ba6 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate17checkValidityDateEv>:

BOOL myDate::checkValidityDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	00 d0       	rcall	.+0      	; 0x60a <_ZN6myDate17checkValidityDateEv+0x6>
     60a:	0f 92       	push	r0
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	9b 83       	std	Y+3, r25	; 0x03
     612:	8a 83       	std	Y+2, r24	; 0x02
	BOOL checkYear=fFalse;
     614:	19 82       	std	Y+1, r1	; 0x01
	if (month/13==0){
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	9b 81       	ldd	r25, Y+3	; 0x03
     61a:	fc 01       	movw	r30, r24
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	0c 96       	adiw	r24, 0x0c	; 12
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	89 31       	cpi	r24, 0x19	; 25
     626:	91 05       	cpc	r25, r1
     628:	08 f0       	brcs	.+2      	; 0x62c <_ZN6myDate17checkValidityDateEv+0x28>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	22 23       	and	r18, r18
     62e:	09 f4       	brne	.+2      	; 0x632 <_ZN6myDate17checkValidityDateEv+0x2e>
     630:	66 c0       	rjmp	.+204    	; 0x6fe <_ZN6myDate17checkValidityDateEv+0xfa>
			if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	89 30       	cpi	r24, 0x09	; 9
     63e:	91 05       	cpc	r25, r1
     640:	81 f0       	breq	.+32     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     642:	8a 81       	ldd	r24, Y+2	; 0x02
     644:	9b 81       	ldd	r25, Y+3	; 0x03
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
     64a:	91 81       	ldd	r25, Z+1	; 0x01
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	91 05       	cpc	r25, r1
     650:	41 f0       	breq	.+16     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	9b 81       	ldd	r25, Y+3	; 0x03
     656:	fc 01       	movw	r30, r24
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	86 30       	cpi	r24, 0x06	; 6
     65e:	91 05       	cpc	r25, r1
     660:	59 f4       	brne	.+22     	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	4e 96       	adiw	r24, 0x1e	; 30
     66e:	8d 33       	cpi	r24, 0x3D	; 61
     670:	91 05       	cpc	r25, r1
     672:	10 f4       	brcc	.+4      	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	01 c0       	rjmp	.+2      	; 0x67a <_ZN6myDate17checkValidityDateEv+0x76>
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	88 23       	and	r24, r24
     67c:	19 f0       	breq	.+6      	; 0x684 <_ZN6myDate17checkValidityDateEv+0x80>
				checkYear=fTrue;
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	89 83       	std	Y+1, r24	; 0x01
     682:	28 c0       	rjmp	.+80     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else if (month == 2 && day/29 == 0){
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	fc 01       	movw	r30, r24
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	91 05       	cpc	r25, r1
     692:	59 f4       	brne	.+22     	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     694:	8a 81       	ldd	r24, Y+2	; 0x02
     696:	9b 81       	ldd	r25, Y+3	; 0x03
     698:	fc 01       	movw	r30, r24
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	4c 96       	adiw	r24, 0x1c	; 28
     6a0:	89 33       	cpi	r24, 0x39	; 57
     6a2:	91 05       	cpc	r25, r1
     6a4:	10 f4       	brcc	.+4      	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_ZN6myDate17checkValidityDateEv+0xa8>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	88 23       	and	r24, r24
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_ZN6myDate17checkValidityDateEv+0xb2>
				checkYear=fTrue;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	89 83       	std	Y+1, r24	; 0x01
     6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else{
				if (day/32 == 0){
     6b6:	8a 81       	ldd	r24, Y+2	; 0x02
     6b8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ba:	fc 01       	movw	r30, r24
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	4f 96       	adiw	r24, 0x1f	; 31
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	8f 33       	cpi	r24, 0x3F	; 63
     6c6:	91 05       	cpc	r25, r1
     6c8:	08 f0       	brcs	.+2      	; 0x6cc <_ZN6myDate17checkValidityDateEv+0xc8>
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	22 23       	and	r18, r18
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
					checkYear=fTrue;
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
			
			//Check year
			if (checkYear && year>=2013){return fTrue;}
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	88 23       	and	r24, r24
     6d8:	59 f0       	breq	.+22     	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	84 81       	ldd	r24, Z+4	; 0x04
     6e2:	95 81       	ldd	r25, Z+5	; 0x05
     6e4:	f7 e0       	ldi	r31, 0x07	; 7
     6e6:	8d 3d       	cpi	r24, 0xDD	; 221
     6e8:	9f 07       	cpc	r25, r31
     6ea:	14 f0       	brlt	.+4      	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <_ZN6myDate17checkValidityDateEv+0xee>
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	88 23       	and	r24, r24
     6f4:	11 f0       	breq	.+4      	; 0x6fa <_ZN6myDate17checkValidityDateEv+0xf6>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	03 c0       	rjmp	.+6      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
			else {return fFalse;}
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
	} else {return fFalse;}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	cd b7       	in	r28, 0x3d	; 61
     712:	de b7       	in	r29, 0x3e	; 62
     714:	2d 97       	sbiw	r28, 0x0d	; 13
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	9d 87       	std	Y+13, r25	; 0x0d
     722:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     724:	8c 85       	ldd	r24, Y+12	; 0x0c
     726:	9d 85       	ldd	r25, Y+13	; 0x0d
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	91 81       	ldd	r25, Z+1	; 0x01
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <itoa>
	itoa(day,dayString,10);
     73e:	8c 85       	ldd	r24, Y+12	; 0x0c
     740:	9d 85       	ldd	r25, Y+13	; 0x0d
     742:	fc 01       	movw	r30, r24
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9e 01       	movw	r18, r28
     74a:	2c 5f       	subi	r18, 0xFC	; 252
     74c:	3f 4f       	sbci	r19, 0xFF	; 255
     74e:	b9 01       	movw	r22, r18
     750:	4a e0       	ldi	r20, 0x0A	; 10
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <itoa>
	itoa(year,yearString,10);
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	fc 01       	movw	r30, r24
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9e 01       	movw	r18, r28
     764:	29 5f       	subi	r18, 0xF9	; 249
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	4a e0       	ldi	r20, 0x0A	; 10
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <itoa>
	strcpy(dateString,monthString);
     772:	8c 85       	ldd	r24, Y+12	; 0x0c
     774:	9d 85       	ldd	r25, Y+13	; 0x0d
     776:	06 96       	adiw	r24, 0x06	; 6
     778:	9e 01       	movw	r18, r28
     77a:	2f 5f       	subi	r18, 0xFF	; 255
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <strcpy>
	strcat(dateString,",");
     784:	8c 85       	ldd	r24, Y+12	; 0x0c
     786:	9d 85       	ldd	r25, Y+13	; 0x0d
     788:	9c 01       	movw	r18, r24
     78a:	2a 5f       	subi	r18, 0xFA	; 250
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	c9 01       	movw	r24, r18
     790:	ac 01       	movw	r20, r24
     792:	fa 01       	movw	r30, r20
     794:	01 90       	ld	r0, Z+
     796:	00 20       	and	r0, r0
     798:	e9 f7       	brne	.-6      	; 0x794 <_ZN6myDate7getDateEv+0x88>
     79a:	cf 01       	movw	r24, r30
     79c:	01 97       	sbiw	r24, 0x01	; 1
     79e:	84 1b       	sub	r24, r20
     7a0:	95 0b       	sbc	r25, r21
     7a2:	82 0f       	add	r24, r18
     7a4:	93 1f       	adc	r25, r19
     7a6:	2c e2       	ldi	r18, 0x2C	; 44
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	fc 01       	movw	r30, r24
     7ac:	31 83       	std	Z+1, r19	; 0x01
     7ae:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     7b0:	8c 85       	ldd	r24, Y+12	; 0x0c
     7b2:	9d 85       	ldd	r25, Y+13	; 0x0d
     7b4:	06 96       	adiw	r24, 0x06	; 6
     7b6:	9e 01       	movw	r18, r28
     7b8:	2c 5f       	subi	r18, 0xFC	; 252
     7ba:	3f 4f       	sbci	r19, 0xFF	; 255
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <strcat>
	strcat(dateString,",");
     7c2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7c4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7c6:	9c 01       	movw	r18, r24
     7c8:	2a 5f       	subi	r18, 0xFA	; 250
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	c9 01       	movw	r24, r18
     7ce:	ac 01       	movw	r20, r24
     7d0:	fa 01       	movw	r30, r20
     7d2:	01 90       	ld	r0, Z+
     7d4:	00 20       	and	r0, r0
     7d6:	e9 f7       	brne	.-6      	; 0x7d2 <_ZN6myDate7getDateEv+0xc6>
     7d8:	cf 01       	movw	r24, r30
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	84 1b       	sub	r24, r20
     7de:	95 0b       	sbc	r25, r21
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	2c e2       	ldi	r18, 0x2C	; 44
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	fc 01       	movw	r30, r24
     7ea:	31 83       	std	Z+1, r19	; 0x01
     7ec:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     7ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     7f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f2:	06 96       	adiw	r24, 0x06	; 6
     7f4:	9e 01       	movw	r18, r28
     7f6:	29 5f       	subi	r18, 0xF9	; 249
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <strcat>
	dateString[16] = '\0';
     800:	8c 85       	ldd	r24, Y+12	; 0x0c
     802:	9d 85       	ldd	r25, Y+13	; 0x0d
     804:	fc 01       	movw	r30, r24
     806:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     808:	8c 85       	ldd	r24, Y+12	; 0x0c
     80a:	9d 85       	ldd	r25, Y+13	; 0x0d
     80c:	06 96       	adiw	r24, 0x06	; 6
     80e:	2d 96       	adiw	r28, 0x0d	; 13
     810:	0f b6       	in	r0, 0x3f	; 63
     812:	f8 94       	cli
     814:	de bf       	out	0x3e, r29	; 62
     816:	0f be       	out	0x3f, r0	; 63
     818:	cd bf       	out	0x3d, r28	; 61
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	08 95       	ret

00000820 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	00 d0       	rcall	.+0      	; 0x826 <_ZN6myTimeC1Ev+0x6>
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	9a 83       	std	Y+2, r25	; 0x02
     82c:	89 83       	std	Y+1, r24	; 0x01
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     836:	89 81       	ldd	r24, Y+1	; 0x01
     838:	9a 81       	ldd	r25, Y+2	; 0x02
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	40 e0       	ldi	r20, 0x00	; 0
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	08 95       	ret

00000854 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	28 97       	sbiw	r28, 0x08	; 8
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 83       	std	Y+2, r25	; 0x02
     86a:	89 83       	std	Y+1, r24	; 0x01
     86c:	7c 83       	std	Y+4, r23	; 0x04
     86e:	6b 83       	std	Y+3, r22	; 0x03
     870:	5e 83       	std	Y+6, r21	; 0x06
     872:	4d 83       	std	Y+5, r20	; 0x05
     874:	38 87       	std	Y+8, r19	; 0x08
     876:	2f 83       	std	Y+7, r18	; 0x07
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	9a 81       	ldd	r25, Y+2	; 0x02
     87c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	9a 81       	ldd	r25, Y+2	; 0x02
     884:	6b 81       	ldd	r22, Y+3	; 0x03
     886:	7c 81       	ldd	r23, Y+4	; 0x04
     888:	4d 81       	ldd	r20, Y+5	; 0x05
     88a:	5e 81       	ldd	r21, Y+6	; 0x06
     88c:	2f 81       	ldd	r18, Y+7	; 0x07
     88e:	38 85       	ldd	r19, Y+8	; 0x08
     890:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     894:	28 96       	adiw	r28, 0x08	; 8
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	de bf       	out	0x3e, r29	; 62
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	cd bf       	out	0x3d, r28	; 61
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	08 95       	ret

000008a6 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     8a6:	cf 92       	push	r12
     8a8:	df 92       	push	r13
     8aa:	ef 92       	push	r14
     8ac:	ff 92       	push	r15
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
     8ba:	2e 97       	sbiw	r28, 0x0e	; 14
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	f8 94       	cli
     8c0:	de bf       	out	0x3e, r29	; 62
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	cd bf       	out	0x3d, r28	; 61
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01
     8ca:	7c 83       	std	Y+4, r23	; 0x04
     8cc:	6b 83       	std	Y+3, r22	; 0x03
     8ce:	5e 83       	std	Y+6, r21	; 0x06
     8d0:	4d 83       	std	Y+5, r20	; 0x05
     8d2:	38 87       	std	Y+8, r19	; 0x08
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	1a 87       	std	Y+10, r17	; 0x0a
     8d8:	09 87       	std	Y+9, r16	; 0x09
     8da:	fc 86       	std	Y+12, r15	; 0x0c
     8dc:	eb 86       	std	Y+11, r14	; 0x0b
     8de:	de 86       	std	Y+14, r13	; 0x0e
     8e0:	cd 86       	std	Y+13, r12	; 0x0d
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	69 85       	ldd	r22, Y+9	; 0x09
     8e8:	7a 85       	ldd	r23, Y+10	; 0x0a
     8ea:	4b 85       	ldd	r20, Y+11	; 0x0b
     8ec:	5c 85       	ldd	r21, Y+12	; 0x0c
     8ee:	2d 85       	ldd	r18, Y+13	; 0x0d
     8f0:	3e 85       	ldd	r19, Y+14	; 0x0e
     8f2:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	9a 81       	ldd	r25, Y+2	; 0x02
     8fa:	6b 81       	ldd	r22, Y+3	; 0x03
     8fc:	7c 81       	ldd	r23, Y+4	; 0x04
     8fe:	4d 81       	ldd	r20, Y+5	; 0x05
     900:	5e 81       	ldd	r21, Y+6	; 0x06
     902:	2f 81       	ldd	r18, Y+7	; 0x07
     904:	38 85       	ldd	r19, Y+8	; 0x08
     906:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     90a:	2e 96       	adiw	r28, 0x0e	; 14
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	de bf       	out	0x3e, r29	; 62
     912:	0f be       	out	0x3f, r0	; 63
     914:	cd bf       	out	0x3d, r28	; 61
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	08 95       	ret

00000928 <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	00 d0       	rcall	.+0      	; 0x92e <_ZN6myTime10getSecondsEv+0x6>
     92e:	cd b7       	in	r28, 0x3d	; 61
     930:	de b7       	in	r29, 0x3e	; 62
     932:	9a 83       	std	Y+2, r25	; 0x02
     934:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     936:	89 81       	ldd	r24, Y+1	; 0x01
     938:	9a 81       	ldd	r25, Y+2	; 0x02
     93a:	fc 01       	movw	r30, r24
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	00 d0       	rcall	.+0      	; 0x950 <_ZN6myTime10getMinutesEv+0x6>
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	9a 83       	std	Y+2, r25	; 0x02
     956:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	9a 81       	ldd	r25, Y+2	; 0x02
     95c:	fc 01       	movw	r30, r24
     95e:	81 8d       	ldd	r24, Z+25	; 0x19
     960:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	00 d0       	rcall	.+0      	; 0x972 <_ZN6myTime8getHoursEv+0x6>
     972:	cd b7       	in	r28, 0x3d	; 61
     974:	de b7       	in	r29, 0x3e	; 62
     976:	9a 83       	std	Y+2, r25	; 0x02
     978:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	87 89       	ldd	r24, Z+23	; 0x17
     982:	90 8d       	ldd	r25, Z+24	; 0x18
}
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
     996:	a2 97       	sbiw	r28, 0x22	; 34
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	f8 94       	cli
     99c:	de bf       	out	0x3e, r29	; 62
     99e:	0f be       	out	0x3f, r0	; 63
     9a0:	cd bf       	out	0x3d, r28	; 61
     9a2:	98 a3       	lds	r25, 0x58
     9a4:	8f 8f       	std	Y+31, r24	; 0x1f
     9a6:	7a a3       	lds	r23, 0x5a
     9a8:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     9aa:	ce 01       	movw	r24, r28
     9ac:	0b 96       	adiw	r24, 0x0b	; 11
     9ae:	29 a1       	lds	r18, 0x49
     9b0:	3a a1       	lds	r19, 0x4a
     9b2:	b9 01       	movw	r22, r18
     9b4:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <strcpy>
	for (int j=0; j<3; j++){
     9b8:	1a 82       	std	Y+2, r1	; 0x02
     9ba:	19 82       	std	Y+1, r1	; 0x01
     9bc:	43 c0       	rjmp	.+134    	; 0xa44 <_ZN6myTime7setTimeEPc+0xb6>
		for (int i=0; i<2; i++){
     9be:	1c 82       	std	Y+4, r1	; 0x04
     9c0:	1b 82       	std	Y+3, r1	; 0x03
     9c2:	20 c0       	rjmp	.+64     	; 0xa04 <_ZN6myTime7setTimeEPc+0x76>
				tempString[i]=currentString[i+j*3];
     9c4:	29 81       	ldd	r18, Y+1	; 0x01
     9c6:	3a 81       	ldd	r19, Y+2	; 0x02
     9c8:	c9 01       	movw	r24, r18
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	28 0f       	add	r18, r24
     9d0:	39 1f       	adc	r19, r25
     9d2:	8b 81       	ldd	r24, Y+3	; 0x03
     9d4:	9c 81       	ldd	r25, Y+4	; 0x04
     9d6:	82 0f       	add	r24, r18
     9d8:	93 1f       	adc	r25, r19
     9da:	9e 01       	movw	r18, r28
     9dc:	25 5f       	subi	r18, 0xF5	; 245
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	fc 01       	movw	r30, r24
     9e6:	40 81       	ld	r20, Z
     9e8:	9e 01       	movw	r18, r28
     9ea:	2b 5e       	subi	r18, 0xEB	; 235
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	8b 81       	ldd	r24, Y+3	; 0x03
     9f0:	9c 81       	ldd	r25, Y+4	; 0x04
     9f2:	82 0f       	add	r24, r18
     9f4:	93 1f       	adc	r25, r19
     9f6:	fc 01       	movw	r30, r24
     9f8:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
     9fc:	9c 81       	ldd	r25, Y+4	; 0x04
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	9c 83       	std	Y+4, r25	; 0x04
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	21 e0       	ldi	r18, 0x01	; 1
     a06:	8b 81       	ldd	r24, Y+3	; 0x03
     a08:	9c 81       	ldd	r25, Y+4	; 0x04
     a0a:	82 30       	cpi	r24, 0x02	; 2
     a0c:	91 05       	cpc	r25, r1
     a0e:	0c f0       	brlt	.+2      	; 0xa12 <_ZN6myTime7setTimeEPc+0x84>
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	22 23       	and	r18, r18
     a14:	b9 f6       	brne	.-82     	; 0x9c4 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     a16:	ce 01       	movw	r24, r28
     a18:	45 96       	adiw	r24, 0x15	; 21
     a1a:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
     a1e:	9c 01       	movw	r18, r24
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	ae 01       	movw	r20, r28
     a2a:	4f 5f       	subi	r20, 0xFF	; 255
     a2c:	5f 4f       	sbci	r21, 0xFF	; 255
     a2e:	84 0f       	add	r24, r20
     a30:	95 1f       	adc	r25, r21
     a32:	04 96       	adiw	r24, 0x04	; 4
     a34:	fc 01       	movw	r30, r24
     a36:	31 83       	std	Z+1, r19	; 0x01
     a38:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	9a 81       	ldd	r25, Y+2	; 0x02
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	9a 83       	std	Y+2, r25	; 0x02
     a42:	89 83       	std	Y+1, r24	; 0x01
     a44:	21 e0       	ldi	r18, 0x01	; 1
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	9a 81       	ldd	r25, Y+2	; 0x02
     a4a:	83 30       	cpi	r24, 0x03	; 3
     a4c:	91 05       	cpc	r25, r1
     a4e:	0c f0       	brlt	.+2      	; 0xa52 <_ZN6myTime7setTimeEPc+0xc4>
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	22 23       	and	r18, r18
     a54:	09 f0       	breq	.+2      	; 0xa58 <_ZN6myTime7setTimeEPc+0xca>
     a56:	b3 cf       	rjmp	.-154    	; 0x9be <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	9e 81       	ldd	r25, Y+6	; 0x06
     a5c:	47 96       	adiw	r24, 0x17	; 23
     a5e:	8f 32       	cpi	r24, 0x2F	; 47
     a60:	91 05       	cpc	r25, r1
     a62:	c0 f4       	brcc	.+48     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a64:	8f 81       	ldd	r24, Y+7	; 0x07
     a66:	98 85       	ldd	r25, Y+8	; 0x08
     a68:	cb 96       	adiw	r24, 0x3b	; 59
     a6a:	87 37       	cpi	r24, 0x77	; 119
     a6c:	91 05       	cpc	r25, r1
     a6e:	90 f4       	brcc	.+36     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a70:	89 85       	ldd	r24, Y+9	; 0x09
     a72:	9a 85       	ldd	r25, Y+10	; 0x0a
     a74:	cb 96       	adiw	r24, 0x3b	; 59
     a76:	87 37       	cpi	r24, 0x77	; 119
     a78:	91 05       	cpc	r25, r1
     a7a:	60 f4       	brcc	.+24     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     a7c:	6d 81       	ldd	r22, Y+5	; 0x05
     a7e:	7e 81       	ldd	r23, Y+6	; 0x06
     a80:	4f 81       	ldd	r20, Y+7	; 0x07
     a82:	58 85       	ldd	r21, Y+8	; 0x08
     a84:	29 85       	ldd	r18, Y+9	; 0x09
     a86:	3a 85       	ldd	r19, Y+10	; 0x0a
     a88:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a8a:	98 a1       	lds	r25, 0x48
     a8c:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
		return fTrue;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	01 c0       	rjmp	.+2      	; 0xa96 <_ZN6myTime7setTimeEPc+0x108>
	} 
	return fFalse;
     a94:	80 e0       	ldi	r24, 0x00	; 0
}
     a96:	a2 96       	adiw	r28, 0x22	; 34
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	cd bf       	out	0x3d, r28	; 61
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	cd b7       	in	r28, 0x3d	; 61
     aae:	de b7       	in	r29, 0x3e	; 62
     ab0:	28 97       	sbiw	r28, 0x08	; 8
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	9a 83       	std	Y+2, r25	; 0x02
     abe:	89 83       	std	Y+1, r24	; 0x01
     ac0:	7c 83       	std	Y+4, r23	; 0x04
     ac2:	6b 83       	std	Y+3, r22	; 0x03
     ac4:	5e 83       	std	Y+6, r21	; 0x06
     ac6:	4d 83       	std	Y+5, r20	; 0x05
     ac8:	38 87       	std	Y+8, r19	; 0x08
     aca:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
     ad0:	2b 81       	ldd	r18, Y+3	; 0x03
     ad2:	3c 81       	ldd	r19, Y+4	; 0x04
     ad4:	b9 01       	movw	r22, r18
     ad6:	0e 94 84 05 	call	0xb08	; 0xb08 <_ZN6myTime7setHourEi>
	setMinute(minute);
     ada:	89 81       	ldd	r24, Y+1	; 0x01
     adc:	9a 81       	ldd	r25, Y+2	; 0x02
     ade:	2d 81       	ldd	r18, Y+5	; 0x05
     ae0:	3e 81       	ldd	r19, Y+6	; 0x06
     ae2:	b9 01       	movw	r22, r18
     ae4:	0e 94 a2 05 	call	0xb44	; 0xb44 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     ae8:	89 81       	ldd	r24, Y+1	; 0x01
     aea:	9a 81       	ldd	r25, Y+2	; 0x02
     aec:	2f 81       	ldd	r18, Y+7	; 0x07
     aee:	38 85       	ldd	r19, Y+8	; 0x08
     af0:	b9 01       	movw	r22, r18
     af2:	0e 94 c0 05 	call	0xb80	; 0xb80 <_ZN6myTime9setSecondEi>
}
     af6:	28 96       	adiw	r28, 0x08	; 8
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	de bf       	out	0x3e, r29	; 62
     afe:	0f be       	out	0x3f, r0	; 63
     b00:	cd bf       	out	0x3d, r28	; 61
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     b08:	cf 93       	push	r28
     b0a:	df 93       	push	r29
     b0c:	00 d0       	rcall	.+0      	; 0xb0e <_ZN6myTime7setHourEi+0x6>
     b0e:	00 d0       	rcall	.+0      	; 0xb10 <_ZN6myTime7setHourEi+0x8>
     b10:	cd b7       	in	r28, 0x3d	; 61
     b12:	de b7       	in	r29, 0x3e	; 62
     b14:	9a 83       	std	Y+2, r25	; 0x02
     b16:	89 83       	std	Y+1, r24	; 0x01
     b18:	7c 83       	std	Y+4, r23	; 0x04
     b1a:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     b1c:	8b 81       	ldd	r24, Y+3	; 0x03
     b1e:	9c 81       	ldd	r25, Y+4	; 0x04
     b20:	47 96       	adiw	r24, 0x17	; 23
     b22:	8f 32       	cpi	r24, 0x2F	; 47
     b24:	91 05       	cpc	r25, r1
     b26:	38 f4       	brcc	.+14     	; 0xb36 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     b28:	89 81       	ldd	r24, Y+1	; 0x01
     b2a:	9a 81       	ldd	r25, Y+2	; 0x02
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	3c 81       	ldd	r19, Y+4	; 0x04
     b30:	fc 01       	movw	r30, r24
     b32:	30 8f       	std	Z+24, r19	; 0x18
     b34:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	0f 90       	pop	r0
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <_ZN6myTime9setMinuteEi+0x6>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <_ZN6myTime9setMinuteEi+0x8>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01
     b54:	7c 83       	std	Y+4, r23	; 0x04
     b56:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	cb 96       	adiw	r24, 0x3b	; 59
     b5e:	87 37       	cpi	r24, 0x77	; 119
     b60:	91 05       	cpc	r25, r1
     b62:	38 f4       	brcc	.+14     	; 0xb72 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	2b 81       	ldd	r18, Y+3	; 0x03
     b6a:	3c 81       	ldd	r19, Y+4	; 0x04
     b6c:	fc 01       	movw	r30, r24
     b6e:	32 8f       	std	Z+26, r19	; 0x1a
     b70:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     b72:	0f 90       	pop	r0
     b74:	0f 90       	pop	r0
     b76:	0f 90       	pop	r0
     b78:	0f 90       	pop	r0
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	00 d0       	rcall	.+0      	; 0xb86 <_ZN6myTime9setSecondEi+0x6>
     b86:	00 d0       	rcall	.+0      	; 0xb88 <_ZN6myTime9setSecondEi+0x8>
     b88:	cd b7       	in	r28, 0x3d	; 61
     b8a:	de b7       	in	r29, 0x3e	; 62
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
     b90:	7c 83       	std	Y+4, r23	; 0x04
     b92:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	cb 96       	adiw	r24, 0x3b	; 59
     b9a:	87 37       	cpi	r24, 0x77	; 119
     b9c:	91 05       	cpc	r25, r1
     b9e:	38 f4       	brcc	.+14     	; 0xbae <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	9a 81       	ldd	r25, Y+2	; 0x02
     ba4:	2b 81       	ldd	r18, Y+3	; 0x03
     ba6:	3c 81       	ldd	r19, Y+4	; 0x04
     ba8:	fc 01       	movw	r30, r24
     baa:	34 8f       	std	Z+28, r19	; 0x1c
     bac:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	28 97       	sbiw	r28, 0x08	; 8
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	de bf       	out	0x3e, r29	; 62
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	cd bf       	out	0x3d, r28	; 61
     bd0:	9e 83       	std	Y+6, r25	; 0x06
     bd2:	8d 83       	std	Y+5, r24	; 0x05
     bd4:	78 87       	std	Y+8, r23	; 0x08
     bd6:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     bd8:	8d 81       	ldd	r24, Y+5	; 0x05
     bda:	9e 81       	ldd	r25, Y+6	; 0x06
     bdc:	fc 01       	movw	r30, r24
     bde:	27 89       	ldd	r18, Z+23	; 0x17
     be0:	30 8d       	ldd	r19, Z+24	; 0x18
     be2:	8f 81       	ldd	r24, Y+7	; 0x07
     be4:	98 85       	ldd	r25, Y+8	; 0x08
     be6:	82 0f       	add	r24, r18
     be8:	93 1f       	adc	r25, r19
     bea:	9a 83       	std	Y+2, r25	; 0x02
     bec:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	9a 81       	ldd	r25, Y+2	; 0x02
     bf2:	28 e1       	ldi	r18, 0x18	; 24
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	b9 01       	movw	r22, r18
     bf8:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     bfc:	9c 01       	movw	r18, r24
     bfe:	8d 81       	ldd	r24, Y+5	; 0x05
     c00:	9e 81       	ldd	r25, Y+6	; 0x06
     c02:	fc 01       	movw	r30, r24
     c04:	30 8f       	std	Z+24, r19	; 0x18
     c06:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a 81       	ldd	r25, Y+2	; 0x02
     c0c:	21 e0       	ldi	r18, 0x01	; 1
     c0e:	88 31       	cpi	r24, 0x18	; 24
     c10:	91 05       	cpc	r25, r1
     c12:	0c f4       	brge	.+2      	; 0xc16 <_ZN6myTime8addHoursEi+0x5a>
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	22 23       	and	r18, r18
     c18:	91 f0       	breq	.+36     	; 0xc3e <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	28 e1       	ldi	r18, 0x18	; 24
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	b9 01       	movw	r22, r18
     c24:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     c28:	9b 01       	movw	r18, r22
     c2a:	c9 01       	movw	r24, r18
     c2c:	9c 83       	std	Y+4, r25	; 0x04
     c2e:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     c30:	8d 81       	ldd	r24, Y+5	; 0x05
     c32:	9e 81       	ldd	r25, Y+6	; 0x06
     c34:	2b 81       	ldd	r18, Y+3	; 0x03
     c36:	3c 81       	ldd	r19, Y+4	; 0x04
     c38:	b9 01       	movw	r22, r18
     c3a:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     c3e:	28 96       	adiw	r28, 0x08	; 8
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	08 95       	ret

00000c50 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
     c58:	28 97       	sbiw	r28, 0x08	; 8
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	9e 83       	std	Y+6, r25	; 0x06
     c66:	8d 83       	std	Y+5, r24	; 0x05
     c68:	78 87       	std	Y+8, r23	; 0x08
     c6a:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     c6c:	8d 81       	ldd	r24, Y+5	; 0x05
     c6e:	9e 81       	ldd	r25, Y+6	; 0x06
     c70:	fc 01       	movw	r30, r24
     c72:	21 8d       	ldd	r18, Z+25	; 0x19
     c74:	32 8d       	ldd	r19, Z+26	; 0x1a
     c76:	8f 81       	ldd	r24, Y+7	; 0x07
     c78:	98 85       	ldd	r25, Y+8	; 0x08
     c7a:	82 0f       	add	r24, r18
     c7c:	93 1f       	adc	r25, r19
     c7e:	9a 83       	std	Y+2, r25	; 0x02
     c80:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	9a 81       	ldd	r25, Y+2	; 0x02
     c86:	2c e3       	ldi	r18, 0x3C	; 60
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	b9 01       	movw	r22, r18
     c8c:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     c90:	9c 01       	movw	r18, r24
     c92:	8d 81       	ldd	r24, Y+5	; 0x05
     c94:	9e 81       	ldd	r25, Y+6	; 0x06
     c96:	fc 01       	movw	r30, r24
     c98:	32 8f       	std	Z+26, r19	; 0x1a
     c9a:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ca0:	21 e0       	ldi	r18, 0x01	; 1
     ca2:	8c 33       	cpi	r24, 0x3C	; 60
     ca4:	91 05       	cpc	r25, r1
     ca6:	0c f4       	brge	.+2      	; 0xcaa <_ZN6myTime10addMinutesEi+0x5a>
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	22 23       	and	r18, r18
     cac:	91 f0       	breq	.+36     	; 0xcd2 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	2c e3       	ldi	r18, 0x3C	; 60
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	b9 01       	movw	r22, r18
     cb8:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     cbc:	9b 01       	movw	r18, r22
     cbe:	c9 01       	movw	r24, r18
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     cc4:	2b 81       	ldd	r18, Y+3	; 0x03
     cc6:	3c 81       	ldd	r19, Y+4	; 0x04
     cc8:	8d 81       	ldd	r24, Y+5	; 0x05
     cca:	9e 81       	ldd	r25, Y+6	; 0x06
     ccc:	b9 01       	movw	r22, r18
     cce:	0e 94 de 05 	call	0xbbc	; 0xbbc <_ZN6myTime8addHoursEi>
	}
}
     cd2:	28 96       	adiw	r28, 0x08	; 8
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	cd b7       	in	r28, 0x3d	; 61
     cea:	de b7       	in	r29, 0x3e	; 62
     cec:	28 97       	sbiw	r28, 0x08	; 8
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	de bf       	out	0x3e, r29	; 62
     cf4:	0f be       	out	0x3f, r0	; 63
     cf6:	cd bf       	out	0x3d, r28	; 61
     cf8:	9e 83       	std	Y+6, r25	; 0x06
     cfa:	8d 83       	std	Y+5, r24	; 0x05
     cfc:	78 87       	std	Y+8, r23	; 0x08
     cfe:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	9e 81       	ldd	r25, Y+6	; 0x06
     d04:	fc 01       	movw	r30, r24
     d06:	23 8d       	ldd	r18, Z+27	; 0x1b
     d08:	34 8d       	ldd	r19, Z+28	; 0x1c
     d0a:	8f 81       	ldd	r24, Y+7	; 0x07
     d0c:	98 85       	ldd	r25, Y+8	; 0x08
     d0e:	82 0f       	add	r24, r18
     d10:	93 1f       	adc	r25, r19
     d12:	9a 83       	std	Y+2, r25	; 0x02
     d14:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     d16:	89 81       	ldd	r24, Y+1	; 0x01
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	2c e3       	ldi	r18, 0x3C	; 60
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	b9 01       	movw	r22, r18
     d20:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     d24:	9c 01       	movw	r18, r24
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	fc 01       	movw	r30, r24
     d2c:	34 8f       	std	Z+28, r19	; 0x1c
     d2e:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	9a 81       	ldd	r25, Y+2	; 0x02
     d34:	21 e0       	ldi	r18, 0x01	; 1
     d36:	8c 33       	cpi	r24, 0x3C	; 60
     d38:	91 05       	cpc	r25, r1
     d3a:	0c f4       	brge	.+2      	; 0xd3e <_ZN6myTime10addSecondsEi+0x5a>
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	22 23       	and	r18, r18
     d40:	91 f0       	breq	.+36     	; 0xd66 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     d42:	89 81       	ldd	r24, Y+1	; 0x01
     d44:	9a 81       	ldd	r25, Y+2	; 0x02
     d46:	2c e3       	ldi	r18, 0x3C	; 60
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	b9 01       	movw	r22, r18
     d4c:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
     d50:	9b 01       	movw	r18, r22
     d52:	c9 01       	movw	r24, r18
     d54:	9c 83       	std	Y+4, r25	; 0x04
     d56:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     d58:	2b 81       	ldd	r18, Y+3	; 0x03
     d5a:	3c 81       	ldd	r19, Y+4	; 0x04
     d5c:	8d 81       	ldd	r24, Y+5	; 0x05
     d5e:	9e 81       	ldd	r25, Y+6	; 0x06
     d60:	b9 01       	movw	r22, r18
     d62:	0e 94 28 06 	call	0xc50	; 0xc50 <_ZN6myTime10addMinutesEi>
	}
}
     d66:	28 96       	adiw	r28, 0x08	; 8
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	08 95       	ret

00000d78 <_ZN6myTime13checkValidityEv>:

BOOL myTime::checkValidity(){
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	00 d0       	rcall	.+0      	; 0xd7e <_ZN6myTime13checkValidityEv+0x6>
     d7e:	0f 92       	push	r0
     d80:	cd b7       	in	r28, 0x3d	; 61
     d82:	de b7       	in	r29, 0x3e	; 62
     d84:	9b 83       	std	Y+3, r25	; 0x03
     d86:	8a 83       	std	Y+2, r24	; 0x02
	BOOL stillValid=fTrue;
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	89 83       	std	Y+1, r24	; 0x01
	if (second/60==0 && minute/60==0 && hour/24==0){
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	fc 01       	movw	r30, r24
     d92:	83 8d       	ldd	r24, Z+27	; 0x1b
     d94:	94 8d       	ldd	r25, Z+28	; 0x1c
     d96:	cb 96       	adiw	r24, 0x3b	; 59
     d98:	87 37       	cpi	r24, 0x77	; 119
     d9a:	91 05       	cpc	r25, r1
     d9c:	a0 f4       	brcc	.+40     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	fc 01       	movw	r30, r24
     da4:	81 8d       	ldd	r24, Z+25	; 0x19
     da6:	92 8d       	ldd	r25, Z+26	; 0x1a
     da8:	cb 96       	adiw	r24, 0x3b	; 59
     daa:	87 37       	cpi	r24, 0x77	; 119
     dac:	91 05       	cpc	r25, r1
     dae:	58 f4       	brcc	.+22     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	9b 81       	ldd	r25, Y+3	; 0x03
     db4:	fc 01       	movw	r30, r24
     db6:	87 89       	ldd	r24, Z+23	; 0x17
     db8:	90 8d       	ldd	r25, Z+24	; 0x18
     dba:	47 96       	adiw	r24, 0x17	; 23
     dbc:	8f 32       	cpi	r24, 0x2F	; 47
     dbe:	91 05       	cpc	r25, r1
     dc0:	10 f4       	brcc	.+4      	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <_ZN6myTime13checkValidityEv+0x50>
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	88 23       	and	r24, r24
     dca:	69 f0       	breq	.+26     	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
		if (checkValidityDate()){return fTrue;}
     dcc:	8a 81       	ldd	r24, Y+2	; 0x02
     dce:	9b 81       	ldd	r25, Y+3	; 0x03
     dd0:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate17checkValidityDateEv>
     dd4:	98 2f       	mov	r25, r24
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	99 23       	and	r25, r25
     dda:	09 f4       	brne	.+2      	; 0xdde <_ZN6myTime13checkValidityEv+0x66>
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	88 23       	and	r24, r24
     de0:	11 f0       	breq	.+4      	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	01 c0       	rjmp	.+2      	; 0xde8 <_ZN6myTime13checkValidityEv+0x70>
	}
	return fFalse;
     de6:	80 e0       	ldi	r24, 0x00	; 0
}
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	cd b7       	in	r28, 0x3d	; 61
     dfa:	de b7       	in	r29, 0x3e	; 62
     dfc:	2b 97       	sbiw	r28, 0x0b	; 11
     dfe:	0f b6       	in	r0, 0x3f	; 63
     e00:	f8 94       	cli
     e02:	de bf       	out	0x3e, r29	; 62
     e04:	0f be       	out	0x3f, r0	; 63
     e06:	cd bf       	out	0x3d, r28	; 61
     e08:	9b 87       	std	Y+11, r25	; 0x0b
     e0a:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e10:	fc 01       	movw	r30, r24
     e12:	87 89       	ldd	r24, Z+23	; 0x17
     e14:	90 8d       	ldd	r25, Z+24	; 0x18
     e16:	9e 01       	movw	r18, r28
     e18:	2f 5f       	subi	r18, 0xFF	; 255
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	b9 01       	movw	r22, r18
     e1e:	4a e0       	ldi	r20, 0x0A	; 10
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <itoa>
	itoa(minute,minuteString,10);
     e26:	8a 85       	ldd	r24, Y+10	; 0x0a
     e28:	9b 85       	ldd	r25, Y+11	; 0x0b
     e2a:	fc 01       	movw	r30, r24
     e2c:	81 8d       	ldd	r24, Z+25	; 0x19
     e2e:	92 8d       	ldd	r25, Z+26	; 0x1a
     e30:	9e 01       	movw	r18, r28
     e32:	2c 5f       	subi	r18, 0xFC	; 252
     e34:	3f 4f       	sbci	r19, 0xFF	; 255
     e36:	b9 01       	movw	r22, r18
     e38:	4a e0       	ldi	r20, 0x0A	; 10
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <itoa>
	itoa(second,secondString,10);
     e40:	8a 85       	ldd	r24, Y+10	; 0x0a
     e42:	9b 85       	ldd	r25, Y+11	; 0x0b
     e44:	fc 01       	movw	r30, r24
     e46:	83 8d       	ldd	r24, Z+27	; 0x1b
     e48:	94 8d       	ldd	r25, Z+28	; 0x1c
     e4a:	9e 01       	movw	r18, r28
     e4c:	29 5f       	subi	r18, 0xF9	; 249
     e4e:	3f 4f       	sbci	r19, 0xFF	; 255
     e50:	b9 01       	movw	r22, r18
     e52:	4a e0       	ldi	r20, 0x0A	; 10
     e54:	50 e0       	ldi	r21, 0x00	; 0
     e56:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <itoa>
	strcpy(timeString,hourString);
     e5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e5e:	4d 96       	adiw	r24, 0x1d	; 29
     e60:	9e 01       	movw	r18, r28
     e62:	2f 5f       	subi	r18, 0xFF	; 255
     e64:	3f 4f       	sbci	r19, 0xFF	; 255
     e66:	b9 01       	movw	r22, r18
     e68:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <strcpy>
	strcat(timeString,":");
     e6c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e6e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e70:	9c 01       	movw	r18, r24
     e72:	23 5e       	subi	r18, 0xE3	; 227
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	c9 01       	movw	r24, r18
     e78:	ac 01       	movw	r20, r24
     e7a:	fa 01       	movw	r30, r20
     e7c:	01 90       	ld	r0, Z+
     e7e:	00 20       	and	r0, r0
     e80:	e9 f7       	brne	.-6      	; 0xe7c <_ZN6myTime7getTimeEv+0x88>
     e82:	cf 01       	movw	r24, r30
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	84 1b       	sub	r24, r20
     e88:	95 0b       	sbc	r25, r21
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	2a e3       	ldi	r18, 0x3A	; 58
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	fc 01       	movw	r30, r24
     e94:	31 83       	std	Z+1, r19	; 0x01
     e96:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     e98:	8a 85       	ldd	r24, Y+10	; 0x0a
     e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9c:	4d 96       	adiw	r24, 0x1d	; 29
     e9e:	9e 01       	movw	r18, r28
     ea0:	2c 5f       	subi	r18, 0xFC	; 252
     ea2:	3f 4f       	sbci	r19, 0xFF	; 255
     ea4:	b9 01       	movw	r22, r18
     ea6:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <strcat>
	strcat(timeString,":");
     eaa:	8a 85       	ldd	r24, Y+10	; 0x0a
     eac:	9b 85       	ldd	r25, Y+11	; 0x0b
     eae:	9c 01       	movw	r18, r24
     eb0:	23 5e       	subi	r18, 0xE3	; 227
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	c9 01       	movw	r24, r18
     eb6:	ac 01       	movw	r20, r24
     eb8:	fa 01       	movw	r30, r20
     eba:	01 90       	ld	r0, Z+
     ebc:	00 20       	and	r0, r0
     ebe:	e9 f7       	brne	.-6      	; 0xeba <_ZN6myTime7getTimeEv+0xc6>
     ec0:	cf 01       	movw	r24, r30
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	84 1b       	sub	r24, r20
     ec6:	95 0b       	sbc	r25, r21
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	2a e3       	ldi	r18, 0x3A	; 58
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	fc 01       	movw	r30, r24
     ed2:	31 83       	std	Z+1, r19	; 0x01
     ed4:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
     eda:	4d 96       	adiw	r24, 0x1d	; 29
     edc:	9e 01       	movw	r18, r28
     ede:	29 5f       	subi	r18, 0xF9	; 249
     ee0:	3f 4f       	sbci	r19, 0xFF	; 255
     ee2:	b9 01       	movw	r22, r18
     ee4:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <strcat>
	timeString[11] = '\0';
     ee8:	8a 85       	ldd	r24, Y+10	; 0x0a
     eea:	9b 85       	ldd	r25, Y+11	; 0x0b
     eec:	fc 01       	movw	r30, r24
     eee:	10 a6       	lds	r17, 0xb0
	return timeString;
     ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ef4:	4d 96       	adiw	r24, 0x1d	; 29
     ef6:	2b 96       	adiw	r28, 0x0b	; 11
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 31;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	2f 97       	sbiw	r28, 0x0f	; 15
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	8e 87       	std	Y+14, r24	; 0x0e
     f1e:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     f20:	f8 94       	cli
	if (gTime){
     f22:	8e 85       	ldd	r24, Y+14	; 0x0e
     f24:	88 23       	and	r24, r24
     f26:	09 f4       	brne	.+2      	; 0xf2a <_Z18getDateTime_eepromhh+0x22>
     f28:	4b c0       	rjmp	.+150    	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     f2a:	1a 82       	std	Y+2, r1	; 0x02
     f2c:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     f32:	2c c0       	rjmp	.+88     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <__eerd_byte_m644pa>
     f3c:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <__eerd_byte_m644pa>
     f46:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <__eerd_byte_m644pa>
     f50:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     f52:	8f 81       	ldd	r24, Y+7	; 0x07
     f54:	8c 33       	cpi	r24, 0x3C	; 60
     f56:	a8 f4       	brcc	.+42     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f58:	88 85       	ldd	r24, Y+8	; 0x08
     f5a:	8c 33       	cpi	r24, 0x3C	; 60
     f5c:	90 f4       	brcc	.+36     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f5e:	89 85       	ldd	r24, Y+9	; 0x09
     f60:	88 31       	cpi	r24, 0x18	; 24
     f62:	78 f4       	brcc	.+30     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	68 2f       	mov	r22, r24
     f68:	70 e0       	ldi	r23, 0x00	; 0
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	48 2f       	mov	r20, r24
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	8f 81       	ldd	r24, Y+7	; 0x07
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	84 ed       	ldi	r24, 0xD4	; 212
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
     f7e:	1b 82       	std	Y+3, r1	; 0x03
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	9a 81       	ldd	r25, Y+2	; 0x02
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     f8c:	8b 81       	ldd	r24, Y+3	; 0x03
     f8e:	88 23       	and	r24, r24
     f90:	39 f0       	breq	.+14     	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	9a 81       	ldd	r25, Y+2	; 0x02
     f96:	83 30       	cpi	r24, 0x03	; 3
     f98:	91 05       	cpc	r25, r1
     f9a:	14 f4       	brge	.+4      	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <_Z18getDateTime_eepromhh+0x9a>
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	88 23       	and	r24, r24
     fa4:	39 f6       	brne	.-114    	; 0xf34 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     fa6:	8b 81       	ldd	r24, Y+3	; 0x03
     fa8:	88 23       	and	r24, r24
     faa:	51 f0       	breq	.+20     	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
     fac:	84 ed       	ldi	r24, 0xD4	; 212
     fae:	91 e0       	ldi	r25, 0x01	; 1
     fb0:	61 e0       	ldi	r22, 0x01	; 1
     fb2:	70 e0       	ldi	r23, 0x00	; 0
     fb4:	41 e0       	ldi	r20, 0x01	; 1
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	21 e0       	ldi	r18, 0x01	; 1
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
     fc2:	88 23       	and	r24, r24
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <_Z18getDateTime_eepromhh+0xc0>
     fc6:	4e c0       	rjmp	.+156    	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     fc8:	1d 82       	std	Y+5, r1	; 0x05
     fca:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     fcc:	81 e0       	ldi	r24, 0x01	; 1
     fce:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     fd0:	2f c0       	rjmp	.+94     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     fd2:	84 e0       	ldi	r24, 0x04	; 4
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <__eerd_byte_m644pa>
     fda:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 92 1d 	call	0x3b24	; 0x3b24 <__eerd_byte_m644pa>
     fe4:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     fe6:	85 e0       	ldi	r24, 0x05	; 5
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <__eerd_word_m644pa>
     fee:	9d 87       	std	Y+13, r25	; 0x0d
     ff0:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     ff2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff4:	8f 31       	cpi	r24, 0x1F	; 31
     ff6:	b8 f4       	brcc	.+46     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ff8:	8b 85       	ldd	r24, Y+11	; 0x0b
     ffa:	8d 30       	cpi	r24, 0x0D	; 13
     ffc:	a0 f4       	brcc	.+40     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ffe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1000:	9d 85       	ldd	r25, Y+13	; 0x0d
    1002:	27 e2       	ldi	r18, 0x27	; 39
    1004:	80 31       	cpi	r24, 0x10	; 16
    1006:	92 07       	cpc	r25, r18
    1008:	70 f4       	brcc	.+28     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
    100a:	8b 85       	ldd	r24, Y+11	; 0x0b
    100c:	68 2f       	mov	r22, r24
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	8a 85       	ldd	r24, Y+10	; 0x0a
    1012:	48 2f       	mov	r20, r24
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	2c 85       	ldd	r18, Y+12	; 0x0c
    1018:	3d 85       	ldd	r19, Y+13	; 0x0d
    101a:	84 ed       	ldi	r24, 0xD4	; 212
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
    1022:	1e 82       	std	Y+6, r1	; 0x06
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
    1026:	8c 81       	ldd	r24, Y+4	; 0x04
    1028:	9d 81       	ldd	r25, Y+5	; 0x05
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	9d 83       	std	Y+5, r25	; 0x05
    102e:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
    1030:	8e 81       	ldd	r24, Y+6	; 0x06
    1032:	88 23       	and	r24, r24
    1034:	39 f0       	breq	.+14     	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	9d 81       	ldd	r25, Y+5	; 0x05
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	91 05       	cpc	r25, r1
    103e:	14 f4       	brge	.+4      	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <_Z18getDateTime_eepromhh+0x13e>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	88 23       	and	r24, r24
    1048:	21 f6       	brne	.-120    	; 0xfd2 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	88 23       	and	r24, r24
    104e:	51 f0       	breq	.+20     	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
    1050:	84 ed       	ldi	r24, 0xD4	; 212
    1052:	91 e0       	ldi	r25, 0x01	; 1
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	70 e0       	ldi	r23, 0x00	; 0
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	21 ed       	ldi	r18, 0xD1	; 209
    105e:	37 e0       	ldi	r19, 0x07	; 7
    1060:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
    1064:	78 94       	sei
}
    1066:	2f 96       	adiw	r28, 0x0f	; 15
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	29 97       	sbiw	r28, 0x09	; 9
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	88 87       	std	Y+8, r24	; 0x08
    108e:	69 87       	std	Y+9, r22	; 0x09
	cli();
    1090:	f8 94       	cli
	if (sTime){
    1092:	88 85       	ldd	r24, Y+8	; 0x08
    1094:	88 23       	and	r24, r24
    1096:	f1 f0       	breq	.+60     	; 0x10d4 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
    1098:	84 ed       	ldi	r24, 0xD4	; 212
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    10a0:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
    10a2:	84 ed       	ldi	r24, 0xD4	; 212
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    10aa:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
    10ac:	84 ed       	ldi	r24, 0xD4	; 212
    10ae:	91 e0       	ldi	r25, 0x01	; 1
    10b0:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    10b4:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	6b 81       	ldd	r22, Y+3	; 0x03
    10bc:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeMinute,tempMin);
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	6a 81       	ldd	r22, Y+2	; 0x02
    10c6:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeHour,tempHour);
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	69 81       	ldd	r22, Y+1	; 0x01
    10d0:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <__eewr_byte_m644pa>
	}
	if (sDate){
    10d4:	89 85       	ldd	r24, Y+9	; 0x09
    10d6:	88 23       	and	r24, r24
    10d8:	09 f1       	breq	.+66     	; 0x111c <__stack+0x1d>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
    10da:	84 ed       	ldi	r24, 0xD4	; 212
    10dc:	91 e0       	ldi	r25, 0x01	; 1
    10de:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
    10e2:	9d 83       	std	Y+5, r25	; 0x05
    10e4:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
    10e6:	84 ed       	ldi	r24, 0xD4	; 212
    10e8:	91 e0       	ldi	r25, 0x01	; 1
    10ea:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
    10ee:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
    10f0:	84 ed       	ldi	r24, 0xD4	; 212
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
    10f8:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
    10fa:	85 e0       	ldi	r24, 0x05	; 5
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1100:	3d 81       	ldd	r19, Y+5	; 0x05
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 ae 1d 	call	0x3b5c	; 0x3b5c <__eewr_word_m644pa>
		eeprom_write_byte(&eeMonth,tempMonth);
    1108:	83 e0       	ldi	r24, 0x03	; 3
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	6e 81       	ldd	r22, Y+6	; 0x06
    110e:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <__eewr_byte_m644pa>
		eeprom_write_byte(&eeDay,tempDay);
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	6f 81       	ldd	r22, Y+7	; 0x07
    1118:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <__eewr_byte_m644pa>
	}
	sei();
    111c:	78 94       	sei
}
    111e:	29 96       	adiw	r28, 0x09	; 9
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	cd bf       	out	0x3d, r28	; 61
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	08 95       	ret

00001130 <_Z8Wait_seci>:
extern WORD globalADC, globalTemp;
extern myTime currentTime;


/************************************************************************************************************/
void Wait_sec(int sec){
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	00 d0       	rcall	.+0      	; 0x1136 <_Z8Wait_seci+0x6>
    1136:	00 d0       	rcall	.+0      	; 0x1138 <_Z8Wait_seci+0x8>
    1138:	00 d0       	rcall	.+0      	; 0x113a <_Z8Wait_seci+0xa>
    113a:	cd b7       	in	r28, 0x3d	; 61
    113c:	de b7       	in	r29, 0x3e	; 62
    113e:	9e 83       	std	Y+6, r25	; 0x06
    1140:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    1142:	84 ed       	ldi	r24, 0xD4	; 212
    1144:	91 e0       	ldi	r25, 0x01	; 1
    1146:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    114a:	88 2f       	mov	r24, r24
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	9a 83       	std	Y+2, r25	; 0x02
    1150:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    1152:	29 81       	ldd	r18, Y+1	; 0x01
    1154:	3a 81       	ldd	r19, Y+2	; 0x02
    1156:	8d 81       	ldd	r24, Y+5	; 0x05
    1158:	9e 81       	ldd	r25, Y+6	; 0x06
    115a:	82 0f       	add	r24, r18
    115c:	93 1f       	adc	r25, r19
    115e:	2c e3       	ldi	r18, 0x3C	; 60
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	b9 01       	movw	r22, r18
    1164:	0e 94 df 1c 	call	0x39be	; 0x39be <__divmodhi4>
    1168:	9c 83       	std	Y+4, r25	; 0x04
    116a:	8b 83       	std	Y+3, r24	; 0x03
while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    116c:	01 c0       	rjmp	.+2      	; 0x1170 <_Z8Wait_seci+0x40>
    116e:	00 00       	nop
    1170:	84 ed       	ldi	r24, 0xD4	; 212
    1172:	91 e0       	ldi	r25, 0x01	; 1
    1174:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    1178:	28 2f       	mov	r18, r24
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	8b 81       	ldd	r24, Y+3	; 0x03
    117e:	9c 81       	ldd	r25, Y+4	; 0x04
    1180:	41 e0       	ldi	r20, 0x01	; 1
    1182:	28 17       	cp	r18, r24
    1184:	39 07       	cpc	r19, r25
    1186:	09 f4       	brne	.+2      	; 0x118a <_Z8Wait_seci+0x5a>
    1188:	40 e0       	ldi	r20, 0x00	; 0
    118a:	44 23       	and	r20, r20
    118c:	81 f7       	brne	.-32     	; 0x116e <_Z8Wait_seci+0x3e>
}
    118e:	26 96       	adiw	r28, 0x06	; 6
    1190:	0f b6       	in	r0, 0x3f	; 63
    1192:	f8 94       	cli
    1194:	de bf       	out	0x3e, r29	; 62
    1196:	0f be       	out	0x3f, r0	; 63
    1198:	cd bf       	out	0x3d, r28	; 61
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	08 95       	ret

000011a0 <_Z7Wait_msi>:
/************************************************************************************************************/
void Wait_ms(int delay)
{
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	00 d0       	rcall	.+0      	; 0x11a6 <_Z7Wait_msi+0x6>
    11a6:	00 d0       	rcall	.+0      	; 0x11a8 <_Z7Wait_msi+0x8>
    11a8:	cd b7       	in	r28, 0x3d	; 61
    11aa:	de b7       	in	r29, 0x3e	; 62
    11ac:	9c 83       	std	Y+4, r25	; 0x04
    11ae:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    11b0:	17 c0       	rjmp	.+46     	; 0x11e0 <_Z7Wait_msi+0x40>
		for(i = 0; i < 200; i++){
    11b2:	1a 82       	std	Y+2, r1	; 0x02
    11b4:	19 82       	std	Y+1, r1	; 0x01
    11b6:	06 c0       	rjmp	.+12     	; 0x11c4 <_Z7Wait_msi+0x24>
			asm volatile("nop");
    11b8:	00 00       	nop
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 200; i++){
    11ba:	89 81       	ldd	r24, Y+1	; 0x01
    11bc:	9a 81       	ldd	r25, Y+2	; 0x02
    11be:	01 96       	adiw	r24, 0x01	; 1
    11c0:	9a 83       	std	Y+2, r25	; 0x02
    11c2:	89 83       	std	Y+1, r24	; 0x01
    11c4:	89 81       	ldd	r24, Y+1	; 0x01
    11c6:	9a 81       	ldd	r25, Y+2	; 0x02
    11c8:	21 e0       	ldi	r18, 0x01	; 1
    11ca:	88 3c       	cpi	r24, 0xC8	; 200
    11cc:	91 05       	cpc	r25, r1
    11ce:	0c f0       	brlt	.+2      	; 0x11d2 <_Z7Wait_msi+0x32>
    11d0:	20 e0       	ldi	r18, 0x00	; 0
    11d2:	22 23       	and	r18, r18
    11d4:	89 f7       	brne	.-30     	; 0x11b8 <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    11d6:	8b 81       	ldd	r24, Y+3	; 0x03
    11d8:	9c 81       	ldd	r25, Y+4	; 0x04
    11da:	01 97       	sbiw	r24, 0x01	; 1
    11dc:	9c 83       	std	Y+4, r25	; 0x04
    11de:	8b 83       	std	Y+3, r24	; 0x03
/************************************************************************************************************/
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
    11e0:	21 e0       	ldi	r18, 0x01	; 1
    11e2:	8b 81       	ldd	r24, Y+3	; 0x03
    11e4:	9c 81       	ldd	r25, Y+4	; 0x04
    11e6:	18 16       	cp	r1, r24
    11e8:	19 06       	cpc	r1, r25
    11ea:	0c f0       	brlt	.+2      	; 0x11ee <_Z7Wait_msi+0x4e>
    11ec:	20 e0       	ldi	r18, 0x00	; 0
    11ee:	22 23       	and	r18, r18
    11f0:	01 f7       	brne	.-64     	; 0x11b2 <_Z7Wait_msi+0x12>
		for(i = 0; i < 200; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	0f 90       	pop	r0
    11f8:	0f 90       	pop	r0
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
    11fe:	08 95       	ret

00001200 <_Z17SendInterruptGAVRv>:
/************************************************************************************************************/
void SendInterruptGAVR(){
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	00 d0       	rcall	.+0      	; 0x1206 <_Z17SendInterruptGAVRv+0x6>
    1206:	cd b7       	in	r28, 0x3d	; 61
    1208:	de b7       	in	r29, 0x3e	; 62
	//Raise interrupts to GAVR for three ish clock cycles.
	prtGAVRINT |= (1 << bnGAVRINT);
    120a:	85 e2       	ldi	r24, 0x25	; 37
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	25 e2       	ldi	r18, 0x25	; 37
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	f9 01       	movw	r30, r18
    1214:	20 81       	ld	r18, Z
    1216:	28 60       	ori	r18, 0x08	; 8
    1218:	fc 01       	movw	r30, r24
    121a:	20 83       	st	Z, r18
for (int i=0; i<2; i++){asm ("nop");}
    121c:	1a 82       	std	Y+2, r1	; 0x02
    121e:	19 82       	std	Y+1, r1	; 0x01
    1220:	06 c0       	rjmp	.+12     	; 0x122e <_Z17SendInterruptGAVRv+0x2e>
    1222:	00 00       	nop
    1224:	89 81       	ldd	r24, Y+1	; 0x01
    1226:	9a 81       	ldd	r25, Y+2	; 0x02
    1228:	01 96       	adiw	r24, 0x01	; 1
    122a:	9a 83       	std	Y+2, r25	; 0x02
    122c:	89 83       	std	Y+1, r24	; 0x01
    122e:	21 e0       	ldi	r18, 0x01	; 1
    1230:	89 81       	ldd	r24, Y+1	; 0x01
    1232:	9a 81       	ldd	r25, Y+2	; 0x02
    1234:	82 30       	cpi	r24, 0x02	; 2
    1236:	91 05       	cpc	r25, r1
    1238:	0c f0       	brlt	.+2      	; 0x123c <_Z17SendInterruptGAVRv+0x3c>
    123a:	20 e0       	ldi	r18, 0x00	; 0
    123c:	22 23       	and	r18, r18
    123e:	89 f7       	brne	.-30     	; 0x1222 <_Z17SendInterruptGAVRv+0x22>
prtGAVRINT &= ~(1 << bnGAVRINT);
    1240:	85 e2       	ldi	r24, 0x25	; 37
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	25 e2       	ldi	r18, 0x25	; 37
    1246:	30 e0       	ldi	r19, 0x00	; 0
    1248:	f9 01       	movw	r30, r18
    124a:	20 81       	ld	r18, Z
    124c:	27 7f       	andi	r18, 0xF7	; 247
    124e:	fc 01       	movw	r30, r24
    1250:	20 83       	st	Z, r18
Wait_sec(1);
    1252:	81 e0       	ldi	r24, 0x01	; 1
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
}
    125a:	0f 90       	pop	r0
    125c:	0f 90       	pop	r0
    125e:	df 91       	pop	r29
    1260:	cf 91       	pop	r28
    1262:	08 95       	ret

00001264 <_Z13PutUartChBonec>:

/**************************************************************************************************************/
void PutUartChBone(char ch){
    1264:	cf 93       	push	r28
    1266:	df 93       	push	r29
    1268:	0f 92       	push	r0
    126a:	cd b7       	in	r28, 0x3d	; 61
    126c:	de b7       	in	r29, 0x3e	; 62
    126e:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
    1270:	00 00       	nop
    1272:	80 ec       	ldi	r24, 0xC0	; 192
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	fc 01       	movw	r30, r24
    1278:	80 81       	ld	r24, Z
    127a:	88 2f       	mov	r24, r24
    127c:	90 e0       	ldi	r25, 0x00	; 0
    127e:	80 72       	andi	r24, 0x20	; 32
    1280:	90 70       	andi	r25, 0x00	; 0
    1282:	21 e0       	ldi	r18, 0x01	; 1
    1284:	00 97       	sbiw	r24, 0x00	; 0
    1286:	09 f0       	breq	.+2      	; 0x128a <_Z13PutUartChBonec+0x26>
    1288:	20 e0       	ldi	r18, 0x00	; 0
    128a:	22 23       	and	r18, r18
    128c:	91 f7       	brne	.-28     	; 0x1272 <_Z13PutUartChBonec+0xe>
	UDR0=ch;
    128e:	86 ec       	ldi	r24, 0xC6	; 198
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	29 81       	ldd	r18, Y+1	; 0x01
    1294:	fc 01       	movw	r30, r24
    1296:	20 83       	st	Z, r18
}
    1298:	0f 90       	pop	r0
    129a:	df 91       	pop	r29
    129c:	cf 91       	pop	r28
    129e:	08 95       	ret

000012a0 <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
    12a0:	cf 93       	push	r28
    12a2:	df 93       	push	r29
    12a4:	00 d0       	rcall	.+0      	; 0x12a6 <_Z9PrintBonePc+0x6>
    12a6:	0f 92       	push	r0
    12a8:	cd b7       	in	r28, 0x3d	; 61
    12aa:	de b7       	in	r29, 0x3e	; 62
    12ac:	9b 83       	std	Y+3, r25	; 0x03
    12ae:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    12b0:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    12b2:	0e c0       	rjmp	.+28     	; 0x12d0 <_Z9PrintBonePc+0x30>
		PutUartChBone(string[i++]);
    12b4:	89 81       	ldd	r24, Y+1	; 0x01
    12b6:	88 2f       	mov	r24, r24
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	2a 81       	ldd	r18, Y+2	; 0x02
    12bc:	3b 81       	ldd	r19, Y+3	; 0x03
    12be:	82 0f       	add	r24, r18
    12c0:	93 1f       	adc	r25, r19
    12c2:	fc 01       	movw	r30, r24
    12c4:	80 81       	ld	r24, Z
    12c6:	99 81       	ldd	r25, Y+1	; 0x01
    12c8:	9f 5f       	subi	r25, 0xFF	; 255
    12ca:	99 83       	std	Y+1, r25	; 0x01
    12cc:	0e 94 32 09 	call	0x1264	; 0x1264 <_Z13PutUartChBonec>
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    12d0:	89 81       	ldd	r24, Y+1	; 0x01
    12d2:	88 2f       	mov	r24, r24
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	2a 81       	ldd	r18, Y+2	; 0x02
    12d8:	3b 81       	ldd	r19, Y+3	; 0x03
    12da:	82 0f       	add	r24, r18
    12dc:	93 1f       	adc	r25, r19
    12de:	fc 01       	movw	r30, r24
    12e0:	90 81       	ld	r25, Z
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	99 23       	and	r25, r25
    12e6:	09 f4       	brne	.+2      	; 0x12ea <_Z9PrintBonePc+0x4a>
    12e8:	80 e0       	ldi	r24, 0x00	; 0
    12ea:	88 23       	and	r24, r24
    12ec:	19 f7       	brne	.-58     	; 0x12b4 <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i++]);
	}
}
    12ee:	0f 90       	pop	r0
    12f0:	0f 90       	pop	r0
    12f2:	0f 90       	pop	r0
    12f4:	df 91       	pop	r29
    12f6:	cf 91       	pop	r28
    12f8:	08 95       	ret

000012fa <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    12fa:	cf 93       	push	r28
    12fc:	df 93       	push	r29
    12fe:	0f 92       	push	r0
    1300:	cd b7       	in	r28, 0x3d	; 61
    1302:	de b7       	in	r29, 0x3e	; 62
    1304:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    1306:	00 00       	nop
    1308:	88 ec       	ldi	r24, 0xC8	; 200
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	fc 01       	movw	r30, r24
    130e:	80 81       	ld	r24, Z
    1310:	88 2f       	mov	r24, r24
    1312:	90 e0       	ldi	r25, 0x00	; 0
    1314:	80 72       	andi	r24, 0x20	; 32
    1316:	90 70       	andi	r25, 0x00	; 0
    1318:	21 e0       	ldi	r18, 0x01	; 1
    131a:	00 97       	sbiw	r24, 0x00	; 0
    131c:	09 f0       	breq	.+2      	; 0x1320 <_Z13PutUartChGAVRc+0x26>
    131e:	20 e0       	ldi	r18, 0x00	; 0
    1320:	22 23       	and	r18, r18
    1322:	91 f7       	brne	.-28     	; 0x1308 <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    1324:	8e ec       	ldi	r24, 0xCE	; 206
    1326:	90 e0       	ldi	r25, 0x00	; 0
    1328:	29 81       	ldd	r18, Y+1	; 0x01
    132a:	fc 01       	movw	r30, r24
    132c:	20 83       	st	Z, r18
}
    132e:	0f 90       	pop	r0
    1330:	df 91       	pop	r29
    1332:	cf 91       	pop	r28
    1334:	08 95       	ret

00001336 <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    1336:	cf 93       	push	r28
    1338:	df 93       	push	r29
    133a:	00 d0       	rcall	.+0      	; 0x133c <_Z9PrintGAVRPc+0x6>
    133c:	0f 92       	push	r0
    133e:	cd b7       	in	r28, 0x3d	; 61
    1340:	de b7       	in	r29, 0x3e	; 62
    1342:	9b 83       	std	Y+3, r25	; 0x03
    1344:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    1346:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    1348:	12 c0       	rjmp	.+36     	; 0x136e <_Z9PrintGAVRPc+0x38>
		Wait_ms(350);
    134a:	8e e5       	ldi	r24, 0x5E	; 94
    134c:	91 e0       	ldi	r25, 0x01	; 1
    134e:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		PutUartChGAVR(string[i++]);
    1352:	89 81       	ldd	r24, Y+1	; 0x01
    1354:	88 2f       	mov	r24, r24
    1356:	90 e0       	ldi	r25, 0x00	; 0
    1358:	2a 81       	ldd	r18, Y+2	; 0x02
    135a:	3b 81       	ldd	r19, Y+3	; 0x03
    135c:	82 0f       	add	r24, r18
    135e:	93 1f       	adc	r25, r19
    1360:	fc 01       	movw	r30, r24
    1362:	80 81       	ld	r24, Z
    1364:	99 81       	ldd	r25, Y+1	; 0x01
    1366:	9f 5f       	subi	r25, 0xFF	; 255
    1368:	99 83       	std	Y+1, r25	; 0x01
    136a:	0e 94 7d 09 	call	0x12fa	; 0x12fa <_Z13PutUartChGAVRc>
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    136e:	89 81       	ldd	r24, Y+1	; 0x01
    1370:	88 2f       	mov	r24, r24
    1372:	90 e0       	ldi	r25, 0x00	; 0
    1374:	2a 81       	ldd	r18, Y+2	; 0x02
    1376:	3b 81       	ldd	r19, Y+3	; 0x03
    1378:	82 0f       	add	r24, r18
    137a:	93 1f       	adc	r25, r19
    137c:	fc 01       	movw	r30, r24
    137e:	90 81       	ld	r25, Z
    1380:	81 e0       	ldi	r24, 0x01	; 1
    1382:	99 23       	and	r25, r25
    1384:	09 f4       	brne	.+2      	; 0x1388 <_Z9PrintGAVRPc+0x52>
    1386:	80 e0       	ldi	r24, 0x00	; 0
    1388:	88 23       	and	r24, r24
    138a:	f9 f6       	brne	.-66     	; 0x134a <_Z9PrintGAVRPc+0x14>
		Wait_ms(350);
		PutUartChGAVR(string[i++]);
	}
}
    138c:	0f 90       	pop	r0
    138e:	0f 90       	pop	r0
    1390:	0f 90       	pop	r0
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	08 95       	ret

00001398 <_Z8sendGAVRv>:
/*************************************************************************************************************/
void sendGAVR(){
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
    139c:	cd b7       	in	r28, 0x3d	; 61
    139e:	de b7       	in	r29, 0x3e	; 62
    13a0:	cb 55       	subi	r28, 0x5B	; 91
    13a2:	d0 40       	sbci	r29, 0x00	; 0
    13a4:	0f b6       	in	r0, 0x3f	; 63
    13a6:	f8 94       	cli
    13a8:	de bf       	out	0x3e, r29	; 62
    13aa:	0f be       	out	0x3f, r0	; 63
    13ac:	cd bf       	out	0x3d, r28	; 61
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	8b 87       	std	Y+11, r24	; 0x0b
	char recChar, recString[40], sentString[40];
	unsigned int strLoc=0;
    13b2:	1a 82       	std	Y+2, r1	; 0x02
    13b4:	19 82       	std	Y+1, r1	; 0x01
	
	//Set sending flag
	flagSendingGAVR=fTrue;
    13b6:	81 e0       	ldi	r24, 0x01	; 1
    13b8:	80 93 04 02 	sts	0x0204, r24
	
	//Transmission protocol
	while (flagSendingGAVR){
    13bc:	14 c2       	rjmp	.+1064   	; 0x17e6 <_Z8sendGAVRv+0x44e>
		/* State 5: Successful transmission and reception. Kill sending flag, reset state, exit.					 */
		/* State 6: ACKBAD received, check to see if we have an invalid date/time in our clock or it was just noisy  */
		/*			and had error in transmission/reception. If valid, go to waiting state. Else exit and set flag.	 */
		/* State 7: Got the wrong ack for something, set a flag to let the WAVR do its thing then try again.		 */
		/*************************************************************************************************************/
		switch (state){
    13be:	80 91 17 02 	lds	r24, 0x0217
    13c2:	90 91 18 02 	lds	r25, 0x0218
    13c6:	83 30       	cpi	r24, 0x03	; 3
    13c8:	91 05       	cpc	r25, r1
    13ca:	09 f4       	brne	.+2      	; 0x13ce <_Z8sendGAVRv+0x36>
    13cc:	f1 c0       	rjmp	.+482    	; 0x15b0 <_Z8sendGAVRv+0x218>
    13ce:	84 30       	cpi	r24, 0x04	; 4
    13d0:	91 05       	cpc	r25, r1
    13d2:	40 f4       	brcc	.+16     	; 0x13e4 <_Z8sendGAVRv+0x4c>
    13d4:	81 30       	cpi	r24, 0x01	; 1
    13d6:	91 05       	cpc	r25, r1
    13d8:	d9 f0       	breq	.+54     	; 0x1410 <_Z8sendGAVRv+0x78>
    13da:	82 30       	cpi	r24, 0x02	; 2
    13dc:	91 05       	cpc	r25, r1
    13de:	08 f0       	brcs	.+2      	; 0x13e2 <_Z8sendGAVRv+0x4a>
    13e0:	89 c0       	rjmp	.+274    	; 0x14f4 <_Z8sendGAVRv+0x15c>
    13e2:	0d c0       	rjmp	.+26     	; 0x13fe <_Z8sendGAVRv+0x66>
    13e4:	86 30       	cpi	r24, 0x06	; 6
    13e6:	91 05       	cpc	r25, r1
    13e8:	09 f4       	brne	.+2      	; 0x13ec <_Z8sendGAVRv+0x54>
    13ea:	b5 c1       	rjmp	.+874    	; 0x1756 <_Z8sendGAVRv+0x3be>
    13ec:	87 30       	cpi	r24, 0x07	; 7
    13ee:	91 05       	cpc	r25, r1
    13f0:	09 f4       	brne	.+2      	; 0x13f4 <_Z8sendGAVRv+0x5c>
    13f2:	ca c1       	rjmp	.+916    	; 0x1788 <_Z8sendGAVRv+0x3f0>
    13f4:	85 30       	cpi	r24, 0x05	; 5
    13f6:	91 05       	cpc	r25, r1
    13f8:	09 f4       	brne	.+2      	; 0x13fc <_Z8sendGAVRv+0x64>
    13fa:	84 c1       	rjmp	.+776    	; 0x1704 <_Z8sendGAVRv+0x36c>
    13fc:	ec c1       	rjmp	.+984    	; 0x17d6 <_Z8sendGAVRv+0x43e>
			case 0: {
				SendInterruptGAVR();
    13fe:	0e 94 00 09 	call	0x1200	; 0x1200 <_Z17SendInterruptGAVRv>
				state=1;
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	90 93 18 02 	sts	0x0218, r25
    140a:	80 93 17 02 	sts	0x0217, r24
				break;
    140e:	eb c1       	rjmp	.+982    	; 0x17e6 <_Z8sendGAVRv+0x44e>
			}//end case 0
			case 1: {
				Wait_ms(300);		//Wait for connection to set and something to come in.			
    1410:	8c e2       	ldi	r24, 0x2C	; 44
    1412:	91 e0       	ldi	r25, 0x01	; 1
    1414:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    1418:	5f c0       	rjmp	.+190    	; 0x14d8 <_Z8sendGAVRv+0x140>
					Wait_ms(100);				//wait for the register to start to load.
    141a:	84 e6       	ldi	r24, 0x64	; 100
    141c:	90 e0       	ldi	r25, 0x00	; 0
    141e:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					PrintBone("WaitingW...");
    1422:	80 e0       	ldi	r24, 0x00	; 0
    1424:	91 e0       	ldi	r25, 0x01	; 1
    1426:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
    142a:	00 00       	nop
    142c:	88 ec       	ldi	r24, 0xC8	; 200
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	fc 01       	movw	r30, r24
    1432:	80 81       	ld	r24, Z
    1434:	88 23       	and	r24, r24
    1436:	34 f0       	brlt	.+12     	; 0x1444 <_Z8sendGAVRv+0xac>
    1438:	80 91 04 02 	lds	r24, 0x0204
    143c:	88 23       	and	r24, r24
    143e:	11 f0       	breq	.+4      	; 0x1444 <_Z8sendGAVRv+0xac>
    1440:	81 e0       	ldi	r24, 0x01	; 1
    1442:	01 c0       	rjmp	.+2      	; 0x1446 <_Z8sendGAVRv+0xae>
    1444:	80 e0       	ldi	r24, 0x00	; 0
    1446:	88 23       	and	r24, r24
    1448:	89 f7       	brne	.-30     	; 0x142c <_Z8sendGAVRv+0x94>
					if (!flagSendingGAVR){state=7; break;}		//if timeout is why we broke, just exit
    144a:	80 91 04 02 	lds	r24, 0x0204
    144e:	88 23       	and	r24, r24
    1450:	41 f4       	brne	.+16     	; 0x1462 <_Z8sendGAVRv+0xca>
    1452:	87 e0       	ldi	r24, 0x07	; 7
    1454:	90 e0       	ldi	r25, 0x00	; 0
    1456:	90 93 18 02 	sts	0x0218, r25
    145a:	80 93 17 02 	sts	0x0217, r24
    145e:	00 00       	nop
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    1460:	c2 c1       	rjmp	.+900    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				while (noCarriage && flagSendingGAVR){
					Wait_ms(100);				//wait for the register to start to load.
					PrintBone("WaitingW...");
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
					if (!flagSendingGAVR){state=7; break;}		//if timeout is why we broke, just exit
					recChar=UDR1;
    1462:	8e ec       	ldi	r24, 0xCE	; 206
    1464:	90 e0       	ldi	r25, 0x00	; 0
    1466:	fc 01       	movw	r30, r24
    1468:	80 81       	ld	r24, Z
    146a:	89 87       	std	Y+9, r24	; 0x09
					recString[strLoc++]=recChar;
    146c:	9e 01       	movw	r18, r28
    146e:	2c 5c       	subi	r18, 0xCC	; 204
    1470:	3f 4f       	sbci	r19, 0xFF	; 255
    1472:	89 81       	ldd	r24, Y+1	; 0x01
    1474:	9a 81       	ldd	r25, Y+2	; 0x02
    1476:	82 0f       	add	r24, r18
    1478:	93 1f       	adc	r25, r19
    147a:	29 85       	ldd	r18, Y+9	; 0x09
    147c:	fc 01       	movw	r30, r24
    147e:	20 83       	st	Z, r18
    1480:	89 81       	ldd	r24, Y+1	; 0x01
    1482:	9a 81       	ldd	r25, Y+2	; 0x02
    1484:	01 96       	adiw	r24, 0x01	; 1
    1486:	9a 83       	std	Y+2, r25	; 0x02
    1488:	89 83       	std	Y+1, r24	; 0x01
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
    148a:	89 85       	ldd	r24, Y+9	; 0x09
    148c:	8e 32       	cpi	r24, 0x2E	; 46
    148e:	b1 f4       	brne	.+44     	; 0x14bc <_Z8sendGAVRv+0x124>
    1490:	9e 01       	movw	r18, r28
    1492:	2c 5c       	subi	r18, 0xCC	; 204
    1494:	3f 4f       	sbci	r19, 0xFF	; 255
    1496:	89 81       	ldd	r24, Y+1	; 0x01
    1498:	9a 81       	ldd	r25, Y+2	; 0x02
    149a:	82 0f       	add	r24, r18
    149c:	93 1f       	adc	r25, r19
    149e:	fc 01       	movw	r30, r24
    14a0:	10 82       	st	Z, r1
    14a2:	89 81       	ldd	r24, Y+1	; 0x01
    14a4:	9a 81       	ldd	r25, Y+2	; 0x02
    14a6:	01 96       	adiw	r24, 0x01	; 1
    14a8:	9a 83       	std	Y+2, r25	; 0x02
    14aa:	89 83       	std	Y+1, r24	; 0x01
    14ac:	82 e0       	ldi	r24, 0x02	; 2
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	90 93 18 02 	sts	0x0218, r25
    14b4:	80 93 17 02 	sts	0x0217, r24
    14b8:	1b 86       	std	Y+11, r1	; 0x0b
    14ba:	0e c0       	rjmp	.+28     	; 0x14d8 <_Z8sendGAVRv+0x140>
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
    14bc:	89 81       	ldd	r24, Y+1	; 0x01
    14be:	9a 81       	ldd	r25, Y+2	; 0x02
    14c0:	87 32       	cpi	r24, 0x27	; 39
    14c2:	91 05       	cpc	r25, r1
    14c4:	48 f0       	brcs	.+18     	; 0x14d8 <_Z8sendGAVRv+0x140>
    14c6:	1a 82       	std	Y+2, r1	; 0x02
    14c8:	19 82       	std	Y+1, r1	; 0x01
    14ca:	1b 86       	std	Y+11, r1	; 0x0b
    14cc:	87 e0       	ldi	r24, 0x07	; 7
    14ce:	90 e0       	ldi	r25, 0x00	; 0
    14d0:	90 93 18 02 	sts	0x0218, r25
    14d4:	80 93 17 02 	sts	0x0217, r24
				break;
			}//end case 0
			case 1: {
				Wait_ms(300);		//Wait for connection to set and something to come in.			
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    14d8:	8b 85       	ldd	r24, Y+11	; 0x0b
    14da:	88 23       	and	r24, r24
    14dc:	31 f0       	breq	.+12     	; 0x14ea <_Z8sendGAVRv+0x152>
    14de:	80 91 04 02 	lds	r24, 0x0204
    14e2:	88 23       	and	r24, r24
    14e4:	11 f0       	breq	.+4      	; 0x14ea <_Z8sendGAVRv+0x152>
    14e6:	81 e0       	ldi	r24, 0x01	; 1
    14e8:	01 c0       	rjmp	.+2      	; 0x14ec <_Z8sendGAVRv+0x154>
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	88 23       	and	r24, r24
    14ee:	09 f0       	breq	.+2      	; 0x14f2 <_Z8sendGAVRv+0x15a>
    14f0:	94 cf       	rjmp	.-216    	; 0x141a <_Z8sendGAVRv+0x82>
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    14f2:	79 c1       	rjmp	.+754    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
    14f4:	ce 01       	movw	r24, r28
    14f6:	c4 96       	adiw	r24, 0x34	; 52
    14f8:	2c e0       	ldi	r18, 0x0C	; 12
    14fa:	31 e0       	ldi	r19, 0x01	; 1
    14fc:	b9 01       	movw	r22, r18
    14fe:	42 e0       	ldi	r20, 0x02	; 2
    1500:	50 e0       	ldi	r21, 0x00	; 0
    1502:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    1506:	00 97       	sbiw	r24, 0x00	; 0
    1508:	39 f4       	brne	.+14     	; 0x1518 <_Z8sendGAVRv+0x180>
    150a:	83 e0       	ldi	r24, 0x03	; 3
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	90 93 18 02 	sts	0x0218, r25
    1512:	80 93 17 02 	sts	0x0217, r24
				else if (!strncmp(recString,"G.",2)){state=5;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    1516:	67 c1       	rjmp	.+718    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5;}	//get
    1518:	ce 01       	movw	r24, r28
    151a:	c4 96       	adiw	r24, 0x34	; 52
    151c:	2f e0       	ldi	r18, 0x0F	; 15
    151e:	31 e0       	ldi	r19, 0x01	; 1
    1520:	b9 01       	movw	r22, r18
    1522:	42 e0       	ldi	r20, 0x02	; 2
    1524:	50 e0       	ldi	r21, 0x00	; 0
    1526:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    152a:	00 97       	sbiw	r24, 0x00	; 0
    152c:	39 f4       	brne	.+14     	; 0x153c <_Z8sendGAVRv+0x1a4>
    152e:	85 e0       	ldi	r24, 0x05	; 5
    1530:	90 e0       	ldi	r25, 0x00	; 0
    1532:	90 93 18 02 	sts	0x0218, r25
    1536:	80 93 17 02 	sts	0x0217, r24
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    153a:	55 c1       	rjmp	.+682    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
    153c:	ce 01       	movw	r24, r28
    153e:	c4 96       	adiw	r24, 0x34	; 52
    1540:	22 e1       	ldi	r18, 0x12	; 18
    1542:	31 e0       	ldi	r19, 0x01	; 1
    1544:	b9 01       	movw	r22, r18
    1546:	42 e0       	ldi	r20, 0x02	; 2
    1548:	50 e0       	ldi	r21, 0x00	; 0
    154a:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    154e:	00 97       	sbiw	r24, 0x00	; 0
    1550:	39 f4       	brne	.+14     	; 0x1560 <_Z8sendGAVRv+0x1c8>
    1552:	86 e0       	ldi	r24, 0x06	; 6
    1554:	90 e0       	ldi	r25, 0x00	; 0
    1556:	90 93 18 02 	sts	0x0218, r25
    155a:	80 93 17 02 	sts	0x0217, r24
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    155e:	43 c1       	rjmp	.+646    	; 0x17e6 <_Z8sendGAVRv+0x44e>
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
    1560:	80 91 03 02 	lds	r24, 0x0203
    1564:	88 23       	and	r24, r24
    1566:	a9 f0       	breq	.+42     	; 0x1592 <_Z8sendGAVRv+0x1fa>
    1568:	ce 01       	movw	r24, r28
    156a:	c4 96       	adiw	r24, 0x34	; 52
    156c:	9e 01       	movw	r18, r28
    156e:	24 5f       	subi	r18, 0xF4	; 244
    1570:	3f 4f       	sbci	r19, 0xFF	; 255
    1572:	b9 01       	movw	r22, r18
    1574:	0e 94 35 1d 	call	0x3a6a	; 0x3a6a <strcmp>
    1578:	00 97       	sbiw	r24, 0x00	; 0
    157a:	59 f4       	brne	.+22     	; 0x1592 <_Z8sendGAVRv+0x1fa>
    157c:	85 e1       	ldi	r24, 0x15	; 21
    157e:	91 e0       	ldi	r25, 0x01	; 1
    1580:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    1584:	85 e0       	ldi	r24, 0x05	; 5
    1586:	90 e0       	ldi	r25, 0x00	; 0
    1588:	90 93 18 02 	sts	0x0218, r25
    158c:	80 93 17 02 	sts	0x0217, r24
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    1590:	2a c1       	rjmp	.+596    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
    1592:	83 e2       	ldi	r24, 0x23	; 35
    1594:	91 e0       	ldi	r25, 0x01	; 1
    1596:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    159a:	ce 01       	movw	r24, r28
    159c:	c4 96       	adiw	r24, 0x34	; 52
    159e:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    15a2:	87 e0       	ldi	r24, 0x07	; 7
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	90 93 18 02 	sts	0x0218, r25
    15aa:	80 93 17 02 	sts	0x0217, r24
				break;
    15ae:	1b c1       	rjmp	.+566    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				}//end case 2
			case 3:{
				Wait_ms(100);
    15b0:	84 e6       	ldi	r24, 0x64	; 100
    15b2:	90 e0       	ldi	r25, 0x00	; 0
    15b4:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
				if (flagUserClock && !flagUpdateGAVRClock){
    15b8:	80 91 05 02 	lds	r24, 0x0205
    15bc:	88 23       	and	r24, r24
    15be:	81 f0       	breq	.+32     	; 0x15e0 <_Z8sendGAVRv+0x248>
    15c0:	80 91 03 02 	lds	r24, 0x0203
    15c4:	88 23       	and	r24, r24
    15c6:	61 f4       	brne	.+24     	; 0x15e0 <_Z8sendGAVRv+0x248>
					PrintBone("GetTime.");
    15c8:	8e e2       	ldi	r24, 0x2E	; 46
    15ca:	91 e0       	ldi	r25, 0x01	; 1
    15cc:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					PrintGAVR("G.");
    15d0:	8f e0       	ldi	r24, 0x0F	; 15
    15d2:	91 e0       	ldi	r25, 0x01	; 1
    15d4:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
					flagWaitingForReceiveGAVR=fTrue;				
    15d8:	81 e0       	ldi	r24, 0x01	; 1
    15da:	80 93 00 02 	sts	0x0200, r24
    15de:	6b c0       	rjmp	.+214    	; 0x16b6 <_Z8sendGAVRv+0x31e>
				//If we are updating the gavr, send the time and date together regardless. preface with SYN
				} else if (flagUpdateGAVRClock && !flagUserClock){
    15e0:	80 91 03 02 	lds	r24, 0x0203
    15e4:	88 23       	and	r24, r24
    15e6:	09 f4       	brne	.+2      	; 0x15ea <_Z8sendGAVRv+0x252>
    15e8:	5b c0       	rjmp	.+182    	; 0x16a0 <_Z8sendGAVRv+0x308>
    15ea:	80 91 05 02 	lds	r24, 0x0205
    15ee:	88 23       	and	r24, r24
    15f0:	09 f0       	breq	.+2      	; 0x15f4 <_Z8sendGAVRv+0x25c>
    15f2:	56 c0       	rjmp	.+172    	; 0x16a0 <_Z8sendGAVRv+0x308>
					PrintBone("Sending time.");
    15f4:	87 e3       	ldi	r24, 0x37	; 55
    15f6:	91 e0       	ldi	r25, 0x01	; 1
    15f8:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					strcpy(sentString,"A");			//this is a syn, not ack to save logic in GAVR code. Can change if we want.
    15fc:	ce 01       	movw	r24, r28
    15fe:	0c 96       	adiw	r24, 0x0c	; 12
    1600:	21 e4       	ldi	r18, 0x41	; 65
    1602:	30 e0       	ldi	r19, 0x00	; 0
    1604:	fc 01       	movw	r30, r24
    1606:	31 83       	std	Z+1, r19	; 0x01
    1608:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getTime());
    160a:	84 ed       	ldi	r24, 0xD4	; 212
    160c:	91 e0       	ldi	r25, 0x01	; 1
    160e:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    1612:	9c 01       	movw	r18, r24
    1614:	ce 01       	movw	r24, r28
    1616:	0c 96       	adiw	r24, 0x0c	; 12
    1618:	b9 01       	movw	r22, r18
    161a:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <strcat>
					strcat(sentString,"/");	//add delimiter.
    161e:	ce 01       	movw	r24, r28
    1620:	0c 96       	adiw	r24, 0x0c	; 12
    1622:	9c 01       	movw	r18, r24
    1624:	f9 01       	movw	r30, r18
    1626:	01 90       	ld	r0, Z+
    1628:	00 20       	and	r0, r0
    162a:	e9 f7       	brne	.-6      	; 0x1626 <_Z8sendGAVRv+0x28e>
    162c:	cf 01       	movw	r24, r30
    162e:	01 97       	sbiw	r24, 0x01	; 1
    1630:	82 1b       	sub	r24, r18
    1632:	93 0b       	sbc	r25, r19
    1634:	9e 01       	movw	r18, r28
    1636:	24 5f       	subi	r18, 0xF4	; 244
    1638:	3f 4f       	sbci	r19, 0xFF	; 255
    163a:	82 0f       	add	r24, r18
    163c:	93 1f       	adc	r25, r19
    163e:	2f e2       	ldi	r18, 0x2F	; 47
    1640:	30 e0       	ldi	r19, 0x00	; 0
    1642:	fc 01       	movw	r30, r24
    1644:	31 83       	std	Z+1, r19	; 0x01
    1646:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getDate());
    1648:	84 ed       	ldi	r24, 0xD4	; 212
    164a:	91 e0       	ldi	r25, 0x01	; 1
    164c:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    1650:	9c 01       	movw	r18, r24
    1652:	ce 01       	movw	r24, r28
    1654:	0c 96       	adiw	r24, 0x0c	; 12
    1656:	b9 01       	movw	r22, r18
    1658:	0e 94 2a 1d 	call	0x3a54	; 0x3a54 <strcat>
					strcat(sentString,".\0");
    165c:	ce 01       	movw	r24, r28
    165e:	0c 96       	adiw	r24, 0x0c	; 12
    1660:	9c 01       	movw	r18, r24
    1662:	f9 01       	movw	r30, r18
    1664:	01 90       	ld	r0, Z+
    1666:	00 20       	and	r0, r0
    1668:	e9 f7       	brne	.-6      	; 0x1664 <_Z8sendGAVRv+0x2cc>
    166a:	cf 01       	movw	r24, r30
    166c:	01 97       	sbiw	r24, 0x01	; 1
    166e:	82 1b       	sub	r24, r18
    1670:	93 0b       	sbc	r25, r19
    1672:	9e 01       	movw	r18, r28
    1674:	24 5f       	subi	r18, 0xF4	; 244
    1676:	3f 4f       	sbci	r19, 0xFF	; 255
    1678:	82 0f       	add	r24, r18
    167a:	93 1f       	adc	r25, r19
    167c:	2e e2       	ldi	r18, 0x2E	; 46
    167e:	30 e0       	ldi	r19, 0x00	; 0
    1680:	fc 01       	movw	r30, r24
    1682:	31 83       	std	Z+1, r19	; 0x01
    1684:	20 83       	st	Z, r18
					PutUartChGAVR('S');
    1686:	83 e5       	ldi	r24, 0x53	; 83
    1688:	0e 94 7d 09 	call	0x12fa	; 0x12fa <_Z13PutUartChGAVRc>
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
    168c:	80 e0       	ldi	r24, 0x00	; 0
    168e:	61 e0       	ldi	r22, 0x01	; 1
    1690:	41 e0       	ldi	r20, 0x01	; 1
    1692:	0e 94 ad 13 	call	0x275a	; 0x275a <_Z13printTimeDatehhh>
					Wait_ms(500);
    1696:	84 ef       	ldi	r24, 0xF4	; 244
    1698:	91 e0       	ldi	r25, 0x01	; 1
    169a:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
    169e:	0b c0       	rjmp	.+22     	; 0x16b6 <_Z8sendGAVRv+0x31e>
				} else {PrintBone("noflags.");state=7; break;}	//end if-else (what we are doing).
    16a0:	85 e4       	ldi	r24, 0x45	; 69
    16a2:	91 e0       	ldi	r25, 0x01	; 1
    16a4:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    16a8:	87 e0       	ldi	r24, 0x07	; 7
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	90 93 18 02 	sts	0x0218, r25
    16b0:	80 93 17 02 	sts	0x0217, r24
    16b4:	98 c0       	rjmp	.+304    	; 0x17e6 <_Z8sendGAVRv+0x44e>
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    16b6:	1c 82       	std	Y+4, r1	; 0x04
    16b8:	1b 82       	std	Y+3, r1	; 0x03
    16ba:	0e c0       	rjmp	.+28     	; 0x16d8 <_Z8sendGAVRv+0x340>
    16bc:	9e 01       	movw	r18, r28
    16be:	2c 5c       	subi	r18, 0xCC	; 204
    16c0:	3f 4f       	sbci	r19, 0xFF	; 255
    16c2:	8b 81       	ldd	r24, Y+3	; 0x03
    16c4:	9c 81       	ldd	r25, Y+4	; 0x04
    16c6:	82 0f       	add	r24, r18
    16c8:	93 1f       	adc	r25, r19
    16ca:	fc 01       	movw	r30, r24
    16cc:	10 82       	st	Z, r1
    16ce:	8b 81       	ldd	r24, Y+3	; 0x03
    16d0:	9c 81       	ldd	r25, Y+4	; 0x04
    16d2:	01 96       	adiw	r24, 0x01	; 1
    16d4:	9c 83       	std	Y+4, r25	; 0x04
    16d6:	8b 83       	std	Y+3, r24	; 0x03
    16d8:	2b 81       	ldd	r18, Y+3	; 0x03
    16da:	3c 81       	ldd	r19, Y+4	; 0x04
    16dc:	41 e0       	ldi	r20, 0x01	; 1
    16de:	89 81       	ldd	r24, Y+1	; 0x01
    16e0:	9a 81       	ldd	r25, Y+2	; 0x02
    16e2:	28 17       	cp	r18, r24
    16e4:	39 07       	cpc	r19, r25
    16e6:	08 f0       	brcs	.+2      	; 0x16ea <_Z8sendGAVRv+0x352>
    16e8:	40 e0       	ldi	r20, 0x00	; 0
    16ea:	44 23       	and	r20, r20
    16ec:	39 f7       	brne	.-50     	; 0x16bc <_Z8sendGAVRv+0x324>
					
				//Reset the carriage feature, string location and go back to the receiving state.
				noCarriage=fTrue;
    16ee:	81 e0       	ldi	r24, 0x01	; 1
    16f0:	8b 87       	std	Y+11, r24	; 0x0b
				strLoc=0;
    16f2:	1a 82       	std	Y+2, r1	; 0x02
    16f4:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	90 93 18 02 	sts	0x0218, r25
    16fe:	80 93 17 02 	sts	0x0217, r24
				break;
    1702:	71 c0       	rjmp	.+226    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				}//end case 3
			case 5:{
				//Successful communications overall
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1704:	1e 82       	std	Y+6, r1	; 0x06
    1706:	1d 82       	std	Y+5, r1	; 0x05
    1708:	0e c0       	rjmp	.+28     	; 0x1726 <_Z8sendGAVRv+0x38e>
    170a:	9e 01       	movw	r18, r28
    170c:	2c 5c       	subi	r18, 0xCC	; 204
    170e:	3f 4f       	sbci	r19, 0xFF	; 255
    1710:	8d 81       	ldd	r24, Y+5	; 0x05
    1712:	9e 81       	ldd	r25, Y+6	; 0x06
    1714:	82 0f       	add	r24, r18
    1716:	93 1f       	adc	r25, r19
    1718:	fc 01       	movw	r30, r24
    171a:	10 82       	st	Z, r1
    171c:	8d 81       	ldd	r24, Y+5	; 0x05
    171e:	9e 81       	ldd	r25, Y+6	; 0x06
    1720:	01 96       	adiw	r24, 0x01	; 1
    1722:	9e 83       	std	Y+6, r25	; 0x06
    1724:	8d 83       	std	Y+5, r24	; 0x05
    1726:	2d 81       	ldd	r18, Y+5	; 0x05
    1728:	3e 81       	ldd	r19, Y+6	; 0x06
    172a:	41 e0       	ldi	r20, 0x01	; 1
    172c:	89 81       	ldd	r24, Y+1	; 0x01
    172e:	9a 81       	ldd	r25, Y+2	; 0x02
    1730:	28 17       	cp	r18, r24
    1732:	39 07       	cpc	r19, r25
    1734:	08 f0       	brcs	.+2      	; 0x1738 <_Z8sendGAVRv+0x3a0>
    1736:	40 e0       	ldi	r20, 0x00	; 0
    1738:	44 23       	and	r20, r20
    173a:	39 f7       	brne	.-50     	; 0x170a <_Z8sendGAVRv+0x372>
				PrintBone("Success.");
    173c:	8e e4       	ldi	r24, 0x4E	; 78
    173e:	91 e0       	ldi	r25, 0x01	; 1
    1740:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
				flagSendingGAVR=fFalse;
    1744:	10 92 04 02 	sts	0x0204, r1
				flagUpdateGAVRClock=fFalse;
    1748:	10 92 03 02 	sts	0x0203, r1
				state=0;
    174c:	10 92 18 02 	sts	0x0218, r1
    1750:	10 92 17 02 	sts	0x0217, r1
				break;
    1754:	48 c0       	rjmp	.+144    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
    1756:	84 ed       	ldi	r24, 0xD4	; 212
    1758:	91 e0       	ldi	r25, 0x01	; 1
    175a:	0e 94 bc 06 	call	0xd78	; 0xd78 <_ZN6myTime13checkValidityEv>
    175e:	8a 87       	std	Y+10, r24	; 0x0a
				if (dateOK){state=7;}
    1760:	8a 85       	ldd	r24, Y+10	; 0x0a
    1762:	88 23       	and	r24, r24
    1764:	39 f0       	breq	.+14     	; 0x1774 <_Z8sendGAVRv+0x3dc>
    1766:	87 e0       	ldi	r24, 0x07	; 7
    1768:	90 e0       	ldi	r25, 0x00	; 0
    176a:	90 93 18 02 	sts	0x0218, r25
    176e:	80 93 17 02 	sts	0x0217, r24
				else {state=7; flagInvalidDateTime=fTrue;}
				break;
    1772:	39 c0       	rjmp	.+114    	; 0x17e6 <_Z8sendGAVRv+0x44e>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
				if (dateOK){state=7;}
				else {state=7; flagInvalidDateTime=fTrue;}
    1774:	87 e0       	ldi	r24, 0x07	; 7
    1776:	90 e0       	ldi	r25, 0x00	; 0
    1778:	90 93 18 02 	sts	0x0218, r25
    177c:	80 93 17 02 	sts	0x0217, r24
    1780:	81 e0       	ldi	r24, 0x01	; 1
    1782:	80 93 06 02 	sts	0x0206, r24
				break;
    1786:	2f c0       	rjmp	.+94     	; 0x17e6 <_Z8sendGAVRv+0x44e>
				}//end case 6
			case 7:{
				//Got the wrong ACK back, or invalid ACK. Wait for next cycle then resend. Keep all the flags the same
				PrintBone("ErrorS.");
    1788:	87 e5       	ldi	r24, 0x57	; 87
    178a:	91 e0       	ldi	r25, 0x01	; 1
    178c:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
				flagSendingGAVR=fFalse;
    1790:	10 92 04 02 	sts	0x0204, r1
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1794:	18 86       	std	Y+8, r1	; 0x08
    1796:	1f 82       	std	Y+7, r1	; 0x07
    1798:	0e c0       	rjmp	.+28     	; 0x17b6 <_Z8sendGAVRv+0x41e>
    179a:	9e 01       	movw	r18, r28
    179c:	2c 5c       	subi	r18, 0xCC	; 204
    179e:	3f 4f       	sbci	r19, 0xFF	; 255
    17a0:	8f 81       	ldd	r24, Y+7	; 0x07
    17a2:	98 85       	ldd	r25, Y+8	; 0x08
    17a4:	82 0f       	add	r24, r18
    17a6:	93 1f       	adc	r25, r19
    17a8:	fc 01       	movw	r30, r24
    17aa:	10 82       	st	Z, r1
    17ac:	8f 81       	ldd	r24, Y+7	; 0x07
    17ae:	98 85       	ldd	r25, Y+8	; 0x08
    17b0:	01 96       	adiw	r24, 0x01	; 1
    17b2:	98 87       	std	Y+8, r25	; 0x08
    17b4:	8f 83       	std	Y+7, r24	; 0x07
    17b6:	2f 81       	ldd	r18, Y+7	; 0x07
    17b8:	38 85       	ldd	r19, Y+8	; 0x08
    17ba:	41 e0       	ldi	r20, 0x01	; 1
    17bc:	89 81       	ldd	r24, Y+1	; 0x01
    17be:	9a 81       	ldd	r25, Y+2	; 0x02
    17c0:	28 17       	cp	r18, r24
    17c2:	39 07       	cpc	r19, r25
    17c4:	08 f0       	brcs	.+2      	; 0x17c8 <_Z8sendGAVRv+0x430>
    17c6:	40 e0       	ldi	r20, 0x00	; 0
    17c8:	44 23       	and	r20, r20
    17ca:	39 f7       	brne	.-50     	; 0x179a <_Z8sendGAVRv+0x402>
				state=0;
    17cc:	10 92 18 02 	sts	0x0218, r1
    17d0:	10 92 17 02 	sts	0x0217, r1
				break;
    17d4:	08 c0       	rjmp	.+16     	; 0x17e6 <_Z8sendGAVRv+0x44e>
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; break;}
    17d6:	10 92 18 02 	sts	0x0218, r1
    17da:	10 92 17 02 	sts	0x0217, r1
    17de:	10 92 04 02 	sts	0x0204, r1
    17e2:	1b 86       	std	Y+11, r1	; 0x0b
    17e4:	00 00       	nop
	
	//Set sending flag
	flagSendingGAVR=fTrue;
	
	//Transmission protocol
	while (flagSendingGAVR){
    17e6:	90 91 04 02 	lds	r25, 0x0204
    17ea:	81 e0       	ldi	r24, 0x01	; 1
    17ec:	99 23       	and	r25, r25
    17ee:	09 f4       	brne	.+2      	; 0x17f2 <_Z8sendGAVRv+0x45a>
    17f0:	80 e0       	ldi	r24, 0x00	; 0
    17f2:	88 23       	and	r24, r24
    17f4:	09 f0       	breq	.+2      	; 0x17f8 <_Z8sendGAVRv+0x460>
    17f6:	e3 cd       	rjmp	.-1082   	; 0x13be <_Z8sendGAVRv+0x26>
				break;
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; break;}
		}//end switch
	}//end while
}//end function 	
    17f8:	c5 5a       	subi	r28, 0xA5	; 165
    17fa:	df 4f       	sbci	r29, 0xFF	; 255
    17fc:	0f b6       	in	r0, 0x3f	; 63
    17fe:	f8 94       	cli
    1800:	de bf       	out	0x3e, r29	; 62
    1802:	0f be       	out	0x3f, r0	; 63
    1804:	cd bf       	out	0x3d, r28	; 61
    1806:	df 91       	pop	r29
    1808:	cf 91       	pop	r28
    180a:	08 95       	ret

0000180c <_Z11ReceiveBonev>:
	
/*************************************************************************************************************/
void ReceiveBone(){
    180c:	cf 93       	push	r28
    180e:	df 93       	push	r29
    1810:	cd b7       	in	r28, 0x3d	; 61
    1812:	de b7       	in	r29, 0x3e	; 62
    1814:	c5 56       	subi	r28, 0x65	; 101
    1816:	d0 40       	sbci	r29, 0x00	; 0
    1818:	0f b6       	in	r0, 0x3f	; 63
    181a:	f8 94       	cli
    181c:	de bf       	out	0x3e, r29	; 62
    181e:	0f be       	out	0x3f, r0	; 63
    1820:	cd bf       	out	0x3d, r28	; 61
	unsigned int state=0;
    1822:	1a 82       	std	Y+2, r1	; 0x02
    1824:	19 82       	std	Y+1, r1	; 0x01
	char recChar, recString[40];
	unsigned int strLoc=0;
    1826:	1c 82       	std	Y+4, r1	; 0x04
    1828:	1b 82       	std	Y+3, r1	; 0x03
	BOOL noCarriage=fTrue;
    182a:	81 e0       	ldi	r24, 0x01	; 1
    182c:	8d 83       	std	Y+5, r24	; 0x05
	sei();
    182e:	78 94       	sei
	while (flagReceivingBone){
    1830:	0b c4       	rjmp	.+2070   	; 0x2048 <_Z11ReceiveBonev+0x83c>
			/* State 6: Graceful exit. Exit from a command like adc or temp.																*/
			/* State 7: Parse the input string for the time and date. Should be time(:)'/'date(,) where : and , are the delimiters. Term by */
			/*			'.'																													*/
			/********************************************************************************************************************************/
			
			switch(state){
    1832:	89 81       	ldd	r24, Y+1	; 0x01
    1834:	9a 81       	ldd	r25, Y+2	; 0x02
    1836:	83 30       	cpi	r24, 0x03	; 3
    1838:	91 05       	cpc	r25, r1
    183a:	09 f4       	brne	.+2      	; 0x183e <_Z11ReceiveBonev+0x32>
    183c:	68 c1       	rjmp	.+720    	; 0x1b0e <_Z11ReceiveBonev+0x302>
    183e:	84 30       	cpi	r24, 0x04	; 4
    1840:	91 05       	cpc	r25, r1
    1842:	48 f4       	brcc	.+18     	; 0x1856 <_Z11ReceiveBonev+0x4a>
    1844:	81 30       	cpi	r24, 0x01	; 1
    1846:	91 05       	cpc	r25, r1
    1848:	09 f4       	brne	.+2      	; 0x184c <_Z11ReceiveBonev+0x40>
    184a:	87 c0       	rjmp	.+270    	; 0x195a <_Z11ReceiveBonev+0x14e>
    184c:	82 30       	cpi	r24, 0x02	; 2
    184e:	91 05       	cpc	r25, r1
    1850:	08 f0       	brcs	.+2      	; 0x1854 <_Z11ReceiveBonev+0x48>
    1852:	91 c0       	rjmp	.+290    	; 0x1976 <_Z11ReceiveBonev+0x16a>
    1854:	11 c0       	rjmp	.+34     	; 0x1878 <_Z11ReceiveBonev+0x6c>
    1856:	85 30       	cpi	r24, 0x05	; 5
    1858:	91 05       	cpc	r25, r1
    185a:	09 f4       	brne	.+2      	; 0x185e <_Z11ReceiveBonev+0x52>
    185c:	a4 c1       	rjmp	.+840    	; 0x1ba6 <_Z11ReceiveBonev+0x39a>
    185e:	85 30       	cpi	r24, 0x05	; 5
    1860:	91 05       	cpc	r25, r1
    1862:	08 f4       	brcc	.+2      	; 0x1866 <_Z11ReceiveBonev+0x5a>
    1864:	7b c1       	rjmp	.+758    	; 0x1b5c <_Z11ReceiveBonev+0x350>
    1866:	86 30       	cpi	r24, 0x06	; 6
    1868:	91 05       	cpc	r25, r1
    186a:	09 f4       	brne	.+2      	; 0x186e <_Z11ReceiveBonev+0x62>
    186c:	c5 c1       	rjmp	.+906    	; 0x1bf8 <_Z11ReceiveBonev+0x3ec>
    186e:	87 30       	cpi	r24, 0x07	; 7
    1870:	91 05       	cpc	r25, r1
    1872:	09 f4       	brne	.+2      	; 0x1876 <_Z11ReceiveBonev+0x6a>
    1874:	e2 c1       	rjmp	.+964    	; 0x1c3a <_Z11ReceiveBonev+0x42e>
    1876:	e3 c3       	rjmp	.+1990   	; 0x203e <_Z11ReceiveBonev+0x832>
				case 0:{
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
    1878:	1c 82       	std	Y+4, r1	; 0x04
    187a:	1b 82       	std	Y+3, r1	; 0x03
					recChar = UDR0;
    187c:	86 ec       	ldi	r24, 0xC6	; 198
    187e:	90 e0       	ldi	r25, 0x00	; 0
    1880:	fc 01       	movw	r30, r24
    1882:	80 81       	ld	r24, Z
    1884:	8e 8f       	std	Y+30, r24	; 0x1e
					if (recChar=='.'){
    1886:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1888:	8e 32       	cpi	r24, 0x2E	; 46
    188a:	29 f4       	brne	.+10     	; 0x1896 <_Z11ReceiveBonev+0x8a>
						state=5;
    188c:	85 e0       	ldi	r24, 0x05	; 5
    188e:	90 e0       	ldi	r25, 0x00	; 0
    1890:	9a 83       	std	Y+2, r25	; 0x02
    1892:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
    1894:	d9 c3       	rjmp	.+1970   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
					recChar = UDR0;
					if (recChar=='.'){
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
    1896:	9e 01       	movw	r18, r28
    1898:	22 5c       	subi	r18, 0xC2	; 194
    189a:	3f 4f       	sbci	r19, 0xFF	; 255
    189c:	8b 81       	ldd	r24, Y+3	; 0x03
    189e:	9c 81       	ldd	r25, Y+4	; 0x04
    18a0:	82 0f       	add	r24, r18
    18a2:	93 1f       	adc	r25, r19
    18a4:	2e 8d       	ldd	r18, Y+30	; 0x1e
    18a6:	fc 01       	movw	r30, r24
    18a8:	20 83       	st	Z, r18
    18aa:	8b 81       	ldd	r24, Y+3	; 0x03
    18ac:	9c 81       	ldd	r25, Y+4	; 0x04
    18ae:	01 96       	adiw	r24, 0x01	; 1
    18b0:	9c 83       	std	Y+4, r25	; 0x04
    18b2:	8b 83       	std	Y+3, r24	; 0x03
    18b4:	81 e0       	ldi	r24, 0x01	; 1
    18b6:	90 e0       	ldi	r25, 0x00	; 0
    18b8:	9a 83       	std	Y+2, r25	; 0x02
    18ba:	89 83       	std	Y+1, r24	; 0x01
					break;				
    18bc:	c5 c3       	rjmp	.+1930   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						Wait_ms(50);
    18be:	82 e3       	ldi	r24, 0x32	; 50
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
						while ((!(UCSR0A & (1 << RXC0))) && flagReceivingBone);		//get the next character
    18c6:	00 00       	nop
    18c8:	80 ec       	ldi	r24, 0xC0	; 192
    18ca:	90 e0       	ldi	r25, 0x00	; 0
    18cc:	fc 01       	movw	r30, r24
    18ce:	80 81       	ld	r24, Z
    18d0:	88 23       	and	r24, r24
    18d2:	34 f0       	brlt	.+12     	; 0x18e0 <_Z11ReceiveBonev+0xd4>
    18d4:	80 91 fd 01 	lds	r24, 0x01FD
    18d8:	88 23       	and	r24, r24
    18da:	11 f0       	breq	.+4      	; 0x18e0 <_Z11ReceiveBonev+0xd4>
    18dc:	81 e0       	ldi	r24, 0x01	; 1
    18de:	01 c0       	rjmp	.+2      	; 0x18e2 <_Z11ReceiveBonev+0xd6>
    18e0:	80 e0       	ldi	r24, 0x00	; 0
    18e2:	88 23       	and	r24, r24
    18e4:	89 f7       	brne	.-30     	; 0x18c8 <_Z11ReceiveBonev+0xbc>
						if (!flagReceivingBone){state=6;break;}					//if there was a timeout, break out and reset state
    18e6:	80 91 fd 01 	lds	r24, 0x01FD
    18ea:	88 23       	and	r24, r24
    18ec:	31 f4       	brne	.+12     	; 0x18fa <_Z11ReceiveBonev+0xee>
    18ee:	86 e0       	ldi	r24, 0x06	; 6
    18f0:	90 e0       	ldi	r25, 0x00	; 0
    18f2:	9a 83       	std	Y+2, r25	; 0x02
    18f4:	89 83       	std	Y+1, r24	; 0x01
    18f6:	00 00       	nop
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    18f8:	a7 c3       	rjmp	.+1870   	; 0x2048 <_Z11ReceiveBonev+0x83c>
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						Wait_ms(50);
						while ((!(UCSR0A & (1 << RXC0))) && flagReceivingBone);		//get the next character
						if (!flagReceivingBone){state=6;break;}					//if there was a timeout, break out and reset state
						recChar=UDR0;
    18fa:	86 ec       	ldi	r24, 0xC6	; 198
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	fc 01       	movw	r30, r24
    1900:	80 81       	ld	r24, Z
    1902:	8e 8f       	std	Y+30, r24	; 0x1e
						recString[strLoc++]=recChar;
    1904:	9e 01       	movw	r18, r28
    1906:	22 5c       	subi	r18, 0xC2	; 194
    1908:	3f 4f       	sbci	r19, 0xFF	; 255
    190a:	8b 81       	ldd	r24, Y+3	; 0x03
    190c:	9c 81       	ldd	r25, Y+4	; 0x04
    190e:	82 0f       	add	r24, r18
    1910:	93 1f       	adc	r25, r19
    1912:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1914:	fc 01       	movw	r30, r24
    1916:	20 83       	st	Z, r18
    1918:	8b 81       	ldd	r24, Y+3	; 0x03
    191a:	9c 81       	ldd	r25, Y+4	; 0x04
    191c:	01 96       	adiw	r24, 0x01	; 1
    191e:	9c 83       	std	Y+4, r25	; 0x04
    1920:	8b 83       	std	Y+3, r24	; 0x03
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1922:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1924:	8e 32       	cpi	r24, 0x2E	; 46
    1926:	79 f4       	brne	.+30     	; 0x1946 <_Z11ReceiveBonev+0x13a>
    1928:	9e 01       	movw	r18, r28
    192a:	22 5c       	subi	r18, 0xC2	; 194
    192c:	3f 4f       	sbci	r19, 0xFF	; 255
    192e:	8b 81       	ldd	r24, Y+3	; 0x03
    1930:	9c 81       	ldd	r25, Y+4	; 0x04
    1932:	82 0f       	add	r24, r18
    1934:	93 1f       	adc	r25, r19
    1936:	fc 01       	movw	r30, r24
    1938:	10 82       	st	Z, r1
    193a:	1d 82       	std	Y+5, r1	; 0x05
    193c:	82 e0       	ldi	r24, 0x02	; 2
    193e:	90 e0       	ldi	r25, 0x00	; 0
    1940:	9a 83       	std	Y+2, r25	; 0x02
    1942:	89 83       	std	Y+1, r24	; 0x01
    1944:	0a c0       	rjmp	.+20     	; 0x195a <_Z11ReceiveBonev+0x14e>
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
    1946:	8b 81       	ldd	r24, Y+3	; 0x03
    1948:	9c 81       	ldd	r25, Y+4	; 0x04
    194a:	87 32       	cpi	r24, 0x27	; 39
    194c:	91 05       	cpc	r25, r1
    194e:	28 f0       	brcs	.+10     	; 0x195a <_Z11ReceiveBonev+0x14e>
    1950:	85 e0       	ldi	r24, 0x05	; 5
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	9a 83       	std	Y+2, r25	; 0x02
    1956:	89 83       	std	Y+1, r24	; 0x01
    1958:	1d 82       	std	Y+5, r1	; 0x05
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    195a:	8d 81       	ldd	r24, Y+5	; 0x05
    195c:	88 23       	and	r24, r24
    195e:	31 f0       	breq	.+12     	; 0x196c <_Z11ReceiveBonev+0x160>
    1960:	80 91 fd 01 	lds	r24, 0x01FD
    1964:	88 23       	and	r24, r24
    1966:	11 f0       	breq	.+4      	; 0x196c <_Z11ReceiveBonev+0x160>
    1968:	81 e0       	ldi	r24, 0x01	; 1
    196a:	01 c0       	rjmp	.+2      	; 0x196e <_Z11ReceiveBonev+0x162>
    196c:	80 e0       	ldi	r24, 0x00	; 0
    196e:	88 23       	and	r24, r24
    1970:	09 f0       	breq	.+2      	; 0x1974 <_Z11ReceiveBonev+0x168>
    1972:	a5 cf       	rjmp	.-182    	; 0x18be <_Z11ReceiveBonev+0xb2>
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    1974:	69 c3       	rjmp	.+1746   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
    1976:	ce 01       	movw	r24, r28
    1978:	ce 96       	adiw	r24, 0x3e	; 62
    197a:	2f e5       	ldi	r18, 0x5F	; 95
    197c:	31 e0       	ldi	r19, 0x01	; 1
    197e:	b9 01       	movw	r22, r18
    1980:	42 e0       	ldi	r20, 0x02	; 2
    1982:	50 e0       	ldi	r21, 0x00	; 0
    1984:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    1988:	00 97       	sbiw	r24, 0x00	; 0
    198a:	51 f4       	brne	.+20     	; 0x19a0 <_Z11ReceiveBonev+0x194>
    198c:	81 e0       	ldi	r24, 0x01	; 1
    198e:	60 e0       	ldi	r22, 0x00	; 0
    1990:	41 e0       	ldi	r20, 0x01	; 1
    1992:	0e 94 ad 13 	call	0x275a	; 0x275a <_Z13printTimeDatehhh>
    1996:	86 e0       	ldi	r24, 0x06	; 6
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	9a 83       	std	Y+2, r25	; 0x02
    199c:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    199e:	54 c3       	rjmp	.+1704   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end while
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
    19a0:	ce 01       	movw	r24, r28
    19a2:	ce 96       	adiw	r24, 0x3e	; 62
    19a4:	22 e6       	ldi	r18, 0x62	; 98
    19a6:	31 e0       	ldi	r19, 0x01	; 1
    19a8:	b9 01       	movw	r22, r18
    19aa:	42 e0       	ldi	r20, 0x02	; 2
    19ac:	50 e0       	ldi	r21, 0x00	; 0
    19ae:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    19b2:	00 97       	sbiw	r24, 0x00	; 0
    19b4:	51 f4       	brne	.+20     	; 0x19ca <_Z11ReceiveBonev+0x1be>
    19b6:	81 e0       	ldi	r24, 0x01	; 1
    19b8:	61 e0       	ldi	r22, 0x01	; 1
    19ba:	40 e0       	ldi	r20, 0x00	; 0
    19bc:	0e 94 ad 13 	call	0x275a	; 0x275a <_Z13printTimeDatehhh>
    19c0:	86 e0       	ldi	r24, 0x06	; 6
    19c2:	90 e0       	ldi	r25, 0x00	; 0
    19c4:	9a 83       	std	Y+2, r25	; 0x02
    19c6:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    19c8:	3f c3       	rjmp	.+1662   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
    19ca:	ce 01       	movw	r24, r28
    19cc:	ce 96       	adiw	r24, 0x3e	; 62
    19ce:	25 e6       	ldi	r18, 0x65	; 101
    19d0:	31 e0       	ldi	r19, 0x01	; 1
    19d2:	b9 01       	movw	r22, r18
    19d4:	42 e0       	ldi	r20, 0x02	; 2
    19d6:	50 e0       	ldi	r21, 0x00	; 0
    19d8:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    19dc:	00 97       	sbiw	r24, 0x00	; 0
    19de:	51 f4       	brne	.+20     	; 0x19f4 <_Z11ReceiveBonev+0x1e8>
    19e0:	81 e0       	ldi	r24, 0x01	; 1
    19e2:	61 e0       	ldi	r22, 0x01	; 1
    19e4:	41 e0       	ldi	r20, 0x01	; 1
    19e6:	0e 94 ad 13 	call	0x275a	; 0x275a <_Z13printTimeDatehhh>
    19ea:	86 e0       	ldi	r24, 0x06	; 6
    19ec:	90 e0       	ldi	r25, 0x00	; 0
    19ee:	9a 83       	std	Y+2, r25	; 0x02
    19f0:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    19f2:	2a c3       	rjmp	.+1620   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
    19f4:	ce 01       	movw	r24, r28
    19f6:	ce 96       	adiw	r24, 0x3e	; 62
    19f8:	28 e6       	ldi	r18, 0x68	; 104
    19fa:	31 e0       	ldi	r19, 0x01	; 1
    19fc:	b9 01       	movw	r22, r18
    19fe:	42 e0       	ldi	r20, 0x02	; 2
    1a00:	50 e0       	ldi	r21, 0x00	; 0
    1a02:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    1a06:	00 97       	sbiw	r24, 0x00	; 0
    1a08:	69 f4       	brne	.+26     	; 0x1a24 <_Z11ReceiveBonev+0x218>
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	60 e0       	ldi	r22, 0x00	; 0
    1a0e:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    1a12:	ce 01       	movw	r24, r28
    1a14:	ce 96       	adiw	r24, 0x3e	; 62
    1a16:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    1a1a:	86 e0       	ldi	r24, 0x06	; 6
    1a1c:	90 e0       	ldi	r25, 0x00	; 0
    1a1e:	9a 83       	std	Y+2, r25	; 0x02
    1a20:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    1a22:	12 c3       	rjmp	.+1572   	; 0x2048 <_Z11ReceiveBonev+0x83c>
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    1a24:	ce 01       	movw	r24, r28
    1a26:	ce 96       	adiw	r24, 0x3e	; 62
    1a28:	2b e6       	ldi	r18, 0x6B	; 107
    1a2a:	31 e0       	ldi	r19, 0x01	; 1
    1a2c:	b9 01       	movw	r22, r18
    1a2e:	42 e0       	ldi	r20, 0x02	; 2
    1a30:	50 e0       	ldi	r21, 0x00	; 0
    1a32:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    1a36:	00 97       	sbiw	r24, 0x00	; 0
    1a38:	b1 f4       	brne	.+44     	; 0x1a66 <_Z11ReceiveBonev+0x25a>
    1a3a:	80 91 d0 01 	lds	r24, 0x01D0
    1a3e:	90 91 d1 01 	lds	r25, 0x01D1
    1a42:	9e 01       	movw	r18, r28
    1a44:	21 5e       	subi	r18, 0xE1	; 225
    1a46:	3f 4f       	sbci	r19, 0xFF	; 255
    1a48:	b9 01       	movw	r22, r18
    1a4a:	4a e0       	ldi	r20, 0x0A	; 10
    1a4c:	50 e0       	ldi	r21, 0x00	; 0
    1a4e:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <utoa>
    1a52:	1d a2       	lds	r17, 0x9d
    1a54:	ce 01       	movw	r24, r28
    1a56:	4f 96       	adiw	r24, 0x1f	; 31
    1a58:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    1a5c:	86 e0       	ldi	r24, 0x06	; 6
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	9a 83       	std	Y+2, r25	; 0x02
    1a62:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    1a64:	f1 c2       	rjmp	.+1506   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    1a66:	ce 01       	movw	r24, r28
    1a68:	ce 96       	adiw	r24, 0x3e	; 62
    1a6a:	2e e6       	ldi	r18, 0x6E	; 110
    1a6c:	31 e0       	ldi	r19, 0x01	; 1
    1a6e:	b9 01       	movw	r22, r18
    1a70:	43 e0       	ldi	r20, 0x03	; 3
    1a72:	50 e0       	ldi	r21, 0x00	; 0
    1a74:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    1a78:	00 97       	sbiw	r24, 0x00	; 0
    1a7a:	b1 f4       	brne	.+44     	; 0x1aa8 <_Z11ReceiveBonev+0x29c>
    1a7c:	80 91 d2 01 	lds	r24, 0x01D2
    1a80:	90 91 d3 01 	lds	r25, 0x01D3
    1a84:	9e 01       	movw	r18, r28
    1a86:	2a 5d       	subi	r18, 0xDA	; 218
    1a88:	3f 4f       	sbci	r19, 0xFF	; 255
    1a8a:	b9 01       	movw	r22, r18
    1a8c:	4a e0       	ldi	r20, 0x0A	; 10
    1a8e:	50 e0       	ldi	r21, 0x00	; 0
    1a90:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <utoa>
    1a94:	1c a6       	lds	r17, 0xbc
    1a96:	ce 01       	movw	r24, r28
    1a98:	86 96       	adiw	r24, 0x26	; 38
    1a9a:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    1a9e:	86 e0       	ldi	r24, 0x06	; 6
    1aa0:	90 e0       	ldi	r25, 0x00	; 0
    1aa2:	9a 83       	std	Y+2, r25	; 0x02
    1aa4:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    1aa6:	d0 c2       	rjmp	.+1440   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
    1aa8:	ce 01       	movw	r24, r28
    1aaa:	80 5c       	subi	r24, 0xC0	; 192
    1aac:	9f 4f       	sbci	r25, 0xFF	; 255
    1aae:	fc 01       	movw	r30, r24
    1ab0:	80 81       	ld	r24, Z
    1ab2:	21 e0       	ldi	r18, 0x01	; 1
    1ab4:	8a 33       	cpi	r24, 0x3A	; 58
    1ab6:	09 f0       	breq	.+2      	; 0x1aba <_Z11ReceiveBonev+0x2ae>
    1ab8:	20 e0       	ldi	r18, 0x00	; 0
    1aba:	ce 01       	movw	r24, r28
    1abc:	8f 5b       	subi	r24, 0xBF	; 191
    1abe:	9f 4f       	sbci	r25, 0xFF	; 255
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	90 81       	ld	r25, Z
    1ac4:	81 e0       	ldi	r24, 0x01	; 1
    1ac6:	9a 33       	cpi	r25, 0x3A	; 58
    1ac8:	09 f0       	breq	.+2      	; 0x1acc <_Z11ReceiveBonev+0x2c0>
    1aca:	80 e0       	ldi	r24, 0x00	; 0
    1acc:	82 27       	eor	r24, r18
    1ace:	88 23       	and	r24, r24
    1ad0:	29 f0       	breq	.+10     	; 0x1adc <_Z11ReceiveBonev+0x2d0>
						state=7;	
    1ad2:	87 e0       	ldi	r24, 0x07	; 7
    1ad4:	90 e0       	ldi	r25, 0x00	; 0
    1ad6:	9a 83       	std	Y+2, r25	; 0x02
    1ad8:	89 83       	std	Y+1, r24	; 0x01
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    1ada:	b6 c2       	rjmp	.+1388   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
    1adc:	ce 01       	movw	r24, r28
    1ade:	ce 96       	adiw	r24, 0x3e	; 62
    1ae0:	22 e7       	ldi	r18, 0x72	; 114
    1ae2:	31 e0       	ldi	r19, 0x01	; 1
    1ae4:	b9 01       	movw	r22, r18
    1ae6:	42 e0       	ldi	r20, 0x02	; 2
    1ae8:	50 e0       	ldi	r21, 0x00	; 0
    1aea:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    1aee:	00 97       	sbiw	r24, 0x00	; 0
    1af0:	49 f4       	brne	.+18     	; 0x1b04 <_Z11ReceiveBonev+0x2f8>
    1af2:	82 e7       	ldi	r24, 0x72	; 114
    1af4:	91 e0       	ldi	r25, 0x01	; 1
    1af6:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    1afa:	86 e0       	ldi	r24, 0x06	; 6
    1afc:	90 e0       	ldi	r25, 0x00	; 0
    1afe:	9a 83       	std	Y+2, r25	; 0x02
    1b00:	89 83       	std	Y+1, r24	; 0x01
					else {state=5;}						
					break;
    1b02:	a2 c2       	rjmp	.+1348   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 73
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
    1b04:	85 e0       	ldi	r24, 0x05	; 5
    1b06:	90 e0       	ldi	r25, 0x00	; 0
    1b08:	9a 83       	std	Y+2, r25	; 0x02
    1b0a:	89 83       	std	Y+1, r24	; 0x01
					break;
    1b0c:	9d c2       	rjmp	.+1338   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 2
				case 3:{
					//Successful receive state of time, change SYN to ACK, then print what we got.
					recString[0]='A';
    1b0e:	81 e4       	ldi	r24, 0x41	; 65
    1b10:	8e af       	sts	0x7e, r24
					PrintBone(recString);
    1b12:	ce 01       	movw	r24, r28
    1b14:	ce 96       	adiw	r24, 0x3e	; 62
    1b16:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					state=0;
    1b1a:	1a 82       	std	Y+2, r1	; 0x02
    1b1c:	19 82       	std	Y+1, r1	; 0x01
					flagReceivingBone=fFalse;
    1b1e:	10 92 fd 01 	sts	0x01FD, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1b22:	1f 82       	std	Y+7, r1	; 0x07
    1b24:	1e 82       	std	Y+6, r1	; 0x06
    1b26:	0e c0       	rjmp	.+28     	; 0x1b44 <_Z11ReceiveBonev+0x338>
    1b28:	9e 01       	movw	r18, r28
    1b2a:	22 5c       	subi	r18, 0xC2	; 194
    1b2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b2e:	8e 81       	ldd	r24, Y+6	; 0x06
    1b30:	9f 81       	ldd	r25, Y+7	; 0x07
    1b32:	82 0f       	add	r24, r18
    1b34:	93 1f       	adc	r25, r19
    1b36:	fc 01       	movw	r30, r24
    1b38:	10 82       	st	Z, r1
    1b3a:	8e 81       	ldd	r24, Y+6	; 0x06
    1b3c:	9f 81       	ldd	r25, Y+7	; 0x07
    1b3e:	01 96       	adiw	r24, 0x01	; 1
    1b40:	9f 83       	std	Y+7, r25	; 0x07
    1b42:	8e 83       	std	Y+6, r24	; 0x06
    1b44:	2e 81       	ldd	r18, Y+6	; 0x06
    1b46:	3f 81       	ldd	r19, Y+7	; 0x07
    1b48:	41 e0       	ldi	r20, 0x01	; 1
    1b4a:	8b 81       	ldd	r24, Y+3	; 0x03
    1b4c:	9c 81       	ldd	r25, Y+4	; 0x04
    1b4e:	28 17       	cp	r18, r24
    1b50:	39 07       	cpc	r19, r25
    1b52:	08 f0       	brcs	.+2      	; 0x1b56 <_Z11ReceiveBonev+0x34a>
    1b54:	40 e0       	ldi	r20, 0x00	; 0
    1b56:	44 23       	and	r20, r20
    1b58:	39 f7       	brne	.-50     	; 0x1b28 <_Z11ReceiveBonev+0x31c>
					break;
    1b5a:	76 c2       	rjmp	.+1260   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 3
				case 4:{
					//Bad time string.
					PrintBone("B.");
    1b5c:	82 e1       	ldi	r24, 0x12	; 18
    1b5e:	91 e0       	ldi	r25, 0x01	; 1
    1b60:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1b64:	10 92 fd 01 	sts	0x01FD, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1b68:	19 86       	std	Y+9, r1	; 0x09
    1b6a:	18 86       	std	Y+8, r1	; 0x08
    1b6c:	0e c0       	rjmp	.+28     	; 0x1b8a <_Z11ReceiveBonev+0x37e>
    1b6e:	9e 01       	movw	r18, r28
    1b70:	22 5c       	subi	r18, 0xC2	; 194
    1b72:	3f 4f       	sbci	r19, 0xFF	; 255
    1b74:	88 85       	ldd	r24, Y+8	; 0x08
    1b76:	99 85       	ldd	r25, Y+9	; 0x09
    1b78:	82 0f       	add	r24, r18
    1b7a:	93 1f       	adc	r25, r19
    1b7c:	fc 01       	movw	r30, r24
    1b7e:	10 82       	st	Z, r1
    1b80:	88 85       	ldd	r24, Y+8	; 0x08
    1b82:	99 85       	ldd	r25, Y+9	; 0x09
    1b84:	01 96       	adiw	r24, 0x01	; 1
    1b86:	99 87       	std	Y+9, r25	; 0x09
    1b88:	88 87       	std	Y+8, r24	; 0x08
    1b8a:	28 85       	ldd	r18, Y+8	; 0x08
    1b8c:	39 85       	ldd	r19, Y+9	; 0x09
    1b8e:	41 e0       	ldi	r20, 0x01	; 1
    1b90:	8b 81       	ldd	r24, Y+3	; 0x03
    1b92:	9c 81       	ldd	r25, Y+4	; 0x04
    1b94:	28 17       	cp	r18, r24
    1b96:	39 07       	cpc	r19, r25
    1b98:	08 f0       	brcs	.+2      	; 0x1b9c <_Z11ReceiveBonev+0x390>
    1b9a:	40 e0       	ldi	r20, 0x00	; 0
    1b9c:	44 23       	and	r20, r20
    1b9e:	39 f7       	brne	.-50     	; 0x1b6e <_Z11ReceiveBonev+0x362>
					state=0;
    1ba0:	1a 82       	std	Y+2, r1	; 0x02
    1ba2:	19 82       	std	Y+1, r1	; 0x01
					break;
    1ba4:	51 c2       	rjmp	.+1186   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 4
				case 5:{
					//Didn't get a good ack or there was an error.
					PrintBone("E.");
    1ba6:	85 e7       	ldi	r24, 0x75	; 117
    1ba8:	91 e0       	ldi	r25, 0x01	; 1
    1baa:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					PrintBone(recString);
    1bae:	ce 01       	movw	r24, r28
    1bb0:	ce 96       	adiw	r24, 0x3e	; 62
    1bb2:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    1bb6:	10 92 fd 01 	sts	0x01FD, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1bba:	1b 86       	std	Y+11, r1	; 0x0b
    1bbc:	1a 86       	std	Y+10, r1	; 0x0a
    1bbe:	0e c0       	rjmp	.+28     	; 0x1bdc <_Z11ReceiveBonev+0x3d0>
    1bc0:	9e 01       	movw	r18, r28
    1bc2:	22 5c       	subi	r18, 0xC2	; 194
    1bc4:	3f 4f       	sbci	r19, 0xFF	; 255
    1bc6:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bc8:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bca:	82 0f       	add	r24, r18
    1bcc:	93 1f       	adc	r25, r19
    1bce:	fc 01       	movw	r30, r24
    1bd0:	10 82       	st	Z, r1
    1bd2:	8a 85       	ldd	r24, Y+10	; 0x0a
    1bd4:	9b 85       	ldd	r25, Y+11	; 0x0b
    1bd6:	01 96       	adiw	r24, 0x01	; 1
    1bd8:	9b 87       	std	Y+11, r25	; 0x0b
    1bda:	8a 87       	std	Y+10, r24	; 0x0a
    1bdc:	2a 85       	ldd	r18, Y+10	; 0x0a
    1bde:	3b 85       	ldd	r19, Y+11	; 0x0b
    1be0:	41 e0       	ldi	r20, 0x01	; 1
    1be2:	8b 81       	ldd	r24, Y+3	; 0x03
    1be4:	9c 81       	ldd	r25, Y+4	; 0x04
    1be6:	28 17       	cp	r18, r24
    1be8:	39 07       	cpc	r19, r25
    1bea:	08 f0       	brcs	.+2      	; 0x1bee <_Z11ReceiveBonev+0x3e2>
    1bec:	40 e0       	ldi	r20, 0x00	; 0
    1bee:	44 23       	and	r20, r20
    1bf0:	39 f7       	brne	.-50     	; 0x1bc0 <_Z11ReceiveBonev+0x3b4>
					state=0;
    1bf2:	1a 82       	std	Y+2, r1	; 0x02
    1bf4:	19 82       	std	Y+1, r1	; 0x01
					break;
    1bf6:	28 c2       	rjmp	.+1104   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 5
				case 6:{
					//Graceful exit.
					flagReceivingBone=fFalse;
    1bf8:	10 92 fd 01 	sts	0x01FD, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1bfc:	1d 86       	std	Y+13, r1	; 0x0d
    1bfe:	1c 86       	std	Y+12, r1	; 0x0c
    1c00:	0e c0       	rjmp	.+28     	; 0x1c1e <_Z11ReceiveBonev+0x412>
    1c02:	9e 01       	movw	r18, r28
    1c04:	22 5c       	subi	r18, 0xC2	; 194
    1c06:	3f 4f       	sbci	r19, 0xFF	; 255
    1c08:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c0a:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c0c:	82 0f       	add	r24, r18
    1c0e:	93 1f       	adc	r25, r19
    1c10:	fc 01       	movw	r30, r24
    1c12:	10 82       	st	Z, r1
    1c14:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c16:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c18:	01 96       	adiw	r24, 0x01	; 1
    1c1a:	9d 87       	std	Y+13, r25	; 0x0d
    1c1c:	8c 87       	std	Y+12, r24	; 0x0c
    1c1e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1c20:	3d 85       	ldd	r19, Y+13	; 0x0d
    1c22:	41 e0       	ldi	r20, 0x01	; 1
    1c24:	8b 81       	ldd	r24, Y+3	; 0x03
    1c26:	9c 81       	ldd	r25, Y+4	; 0x04
    1c28:	28 17       	cp	r18, r24
    1c2a:	39 07       	cpc	r19, r25
    1c2c:	08 f0       	brcs	.+2      	; 0x1c30 <_Z11ReceiveBonev+0x424>
    1c2e:	40 e0       	ldi	r20, 0x00	; 0
    1c30:	44 23       	and	r20, r20
    1c32:	39 f7       	brne	.-50     	; 0x1c02 <_Z11ReceiveBonev+0x3f6>
					state=0;
    1c34:	1a 82       	std	Y+2, r1	; 0x02
    1c36:	19 82       	std	Y+1, r1	; 0x01
					break;
    1c38:	07 c2       	rjmp	.+1038   	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 6
				case 7:{
					//Parse the string
					//Go through the string and parse for the time. Must go through the time to get the date.
					BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    1c3a:	1e 86       	std	Y+14, r1	; 0x0e
    1c3c:	1f 86       	std	Y+15, r1	; 0x0f
					int counter=1;
    1c3e:	81 e0       	ldi	r24, 0x01	; 1
    1c40:	90 e0       	ldi	r25, 0x00	; 0
    1c42:	99 8b       	std	Y+17, r25	; 0x11
    1c44:	88 8b       	std	Y+16, r24	; 0x10
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    1c46:	1e a6       	lds	r17, 0xbe
    1c48:	1d a6       	lds	r17, 0xbd
    1c4a:	18 aa       	sts	0x98, r17
    1c4c:	1f a6       	lds	r17, 0xbf
    1c4e:	1a aa       	sts	0x9a, r17
    1c50:	19 aa       	sts	0x99, r17
    1c52:	1c aa       	sts	0x9c, r17
    1c54:	1b aa       	sts	0x9b, r17
    1c56:	1e aa       	sts	0x9e, r17
    1c58:	1d aa       	sts	0x9d, r17
    1c5a:	18 ae       	sts	0xb8, r17
    1c5c:	1f aa       	sts	0x9f, r17
    1c5e:	1b 8a       	std	Y+19, r1	; 0x13
    1c60:	1a 8a       	std	Y+18, r1	; 0x12
    1c62:	1d 8a       	std	Y+21, r1	; 0x15
    1c64:	1c 8a       	std	Y+20, r1	; 0x14
    1c66:	1f 8a       	std	Y+23, r1	; 0x17
    1c68:	1e 8a       	std	Y+22, r1	; 0x16
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    1c6a:	73 c0       	rjmp	.+230    	; 0x1d52 <_Z11ReceiveBonev+0x546>
						//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
						if (recString[counter]!=':' && hms<3){
    1c6c:	9e 01       	movw	r18, r28
    1c6e:	22 5c       	subi	r18, 0xC2	; 194
    1c70:	3f 4f       	sbci	r19, 0xFF	; 255
    1c72:	88 89       	ldd	r24, Y+16	; 0x10
    1c74:	99 89       	ldd	r25, Y+17	; 0x11
    1c76:	82 0f       	add	r24, r18
    1c78:	93 1f       	adc	r25, r19
    1c7a:	fc 01       	movw	r30, r24
    1c7c:	80 81       	ld	r24, Z
    1c7e:	8a 33       	cpi	r24, 0x3A	; 58
    1c80:	e9 f0       	breq	.+58     	; 0x1cbc <_Z11ReceiveBonev+0x4b0>
    1c82:	8c 89       	ldd	r24, Y+20	; 0x14
    1c84:	9d 89       	ldd	r25, Y+21	; 0x15
    1c86:	83 30       	cpi	r24, 0x03	; 3
    1c88:	91 05       	cpc	r25, r1
    1c8a:	c4 f4       	brge	.+48     	; 0x1cbc <_Z11ReceiveBonev+0x4b0>
							tempStringNum[placement++]=recString[counter];
    1c8c:	9e 01       	movw	r18, r28
    1c8e:	22 5c       	subi	r18, 0xC2	; 194
    1c90:	3f 4f       	sbci	r19, 0xFF	; 255
    1c92:	88 89       	ldd	r24, Y+16	; 0x10
    1c94:	99 89       	ldd	r25, Y+17	; 0x11
    1c96:	82 0f       	add	r24, r18
    1c98:	93 1f       	adc	r25, r19
    1c9a:	fc 01       	movw	r30, r24
    1c9c:	40 81       	ld	r20, Z
    1c9e:	9e 01       	movw	r18, r28
    1ca0:	27 5c       	subi	r18, 0xC7	; 199
    1ca2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca4:	8e 89       	ldd	r24, Y+22	; 0x16
    1ca6:	9f 89       	ldd	r25, Y+23	; 0x17
    1ca8:	82 0f       	add	r24, r18
    1caa:	93 1f       	adc	r25, r19
    1cac:	fc 01       	movw	r30, r24
    1cae:	40 83       	st	Z, r20
    1cb0:	8e 89       	ldd	r24, Y+22	; 0x16
    1cb2:	9f 89       	ldd	r25, Y+23	; 0x17
    1cb4:	01 96       	adiw	r24, 0x01	; 1
    1cb6:	9f 8b       	std	Y+23, r25	; 0x17
    1cb8:	8e 8b       	std	Y+22, r24	; 0x16
    1cba:	46 c0       	rjmp	.+140    	; 0x1d48 <_Z11ReceiveBonev+0x53c>
						//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
						} else if (hms<2 && recString[counter] == ':') {
    1cbc:	8c 89       	ldd	r24, Y+20	; 0x14
    1cbe:	9d 89       	ldd	r25, Y+21	; 0x15
    1cc0:	82 30       	cpi	r24, 0x02	; 2
    1cc2:	91 05       	cpc	r25, r1
    1cc4:	0c f0       	brlt	.+2      	; 0x1cc8 <_Z11ReceiveBonev+0x4bc>
    1cc6:	40 c0       	rjmp	.+128    	; 0x1d48 <_Z11ReceiveBonev+0x53c>
    1cc8:	9e 01       	movw	r18, r28
    1cca:	22 5c       	subi	r18, 0xC2	; 194
    1ccc:	3f 4f       	sbci	r19, 0xFF	; 255
    1cce:	88 89       	ldd	r24, Y+16	; 0x10
    1cd0:	99 89       	ldd	r25, Y+17	; 0x11
    1cd2:	82 0f       	add	r24, r18
    1cd4:	93 1f       	adc	r25, r19
    1cd6:	fc 01       	movw	r30, r24
    1cd8:	80 81       	ld	r24, Z
    1cda:	8a 33       	cpi	r24, 0x3A	; 58
    1cdc:	a9 f5       	brne	.+106    	; 0x1d48 <_Z11ReceiveBonev+0x53c>
							tempNum[hms++] = atoi(tempStringNum);
    1cde:	ce 01       	movw	r24, r28
    1ce0:	c9 96       	adiw	r24, 0x39	; 57
    1ce2:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
    1ce6:	9c 01       	movw	r18, r24
    1ce8:	8c 89       	ldd	r24, Y+20	; 0x14
    1cea:	9d 89       	ldd	r25, Y+21	; 0x15
    1cec:	88 0f       	add	r24, r24
    1cee:	99 1f       	adc	r25, r25
    1cf0:	ae 01       	movw	r20, r28
    1cf2:	4f 5f       	subi	r20, 0xFF	; 255
    1cf4:	5f 4f       	sbci	r21, 0xFF	; 255
    1cf6:	84 0f       	add	r24, r20
    1cf8:	95 1f       	adc	r25, r21
    1cfa:	8c 96       	adiw	r24, 0x2c	; 44
    1cfc:	fc 01       	movw	r30, r24
    1cfe:	31 83       	std	Z+1, r19	; 0x01
    1d00:	20 83       	st	Z, r18
    1d02:	8c 89       	ldd	r24, Y+20	; 0x14
    1d04:	9d 89       	ldd	r25, Y+21	; 0x15
    1d06:	01 96       	adiw	r24, 0x01	; 1
    1d08:	9d 8b       	std	Y+21, r25	; 0x15
    1d0a:	8c 8b       	std	Y+20, r24	; 0x14
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1d0c:	19 8e       	std	Y+25, r1	; 0x19
    1d0e:	18 8e       	std	Y+24, r1	; 0x18
    1d10:	0e c0       	rjmp	.+28     	; 0x1d2e <_Z11ReceiveBonev+0x522>
    1d12:	9e 01       	movw	r18, r28
    1d14:	27 5c       	subi	r18, 0xC7	; 199
    1d16:	3f 4f       	sbci	r19, 0xFF	; 255
    1d18:	88 8d       	ldd	r24, Y+24	; 0x18
    1d1a:	99 8d       	ldd	r25, Y+25	; 0x19
    1d1c:	82 0f       	add	r24, r18
    1d1e:	93 1f       	adc	r25, r19
    1d20:	fc 01       	movw	r30, r24
    1d22:	10 82       	st	Z, r1
    1d24:	88 8d       	ldd	r24, Y+24	; 0x18
    1d26:	99 8d       	ldd	r25, Y+25	; 0x19
    1d28:	01 96       	adiw	r24, 0x01	; 1
    1d2a:	99 8f       	std	Y+25, r25	; 0x19
    1d2c:	88 8f       	std	Y+24, r24	; 0x18
    1d2e:	41 e0       	ldi	r20, 0x01	; 1
    1d30:	28 8d       	ldd	r18, Y+24	; 0x18
    1d32:	39 8d       	ldd	r19, Y+25	; 0x19
    1d34:	8e 89       	ldd	r24, Y+22	; 0x16
    1d36:	9f 89       	ldd	r25, Y+23	; 0x17
    1d38:	82 17       	cp	r24, r18
    1d3a:	93 07       	cpc	r25, r19
    1d3c:	0c f4       	brge	.+2      	; 0x1d40 <_Z11ReceiveBonev+0x534>
    1d3e:	40 e0       	ldi	r20, 0x00	; 0
    1d40:	44 23       	and	r20, r20
    1d42:	39 f7       	brne	.-50     	; 0x1d12 <_Z11ReceiveBonev+0x506>
							placement=0;												//reset placement
    1d44:	1f 8a       	std	Y+23, r1	; 0x17
    1d46:	1e 8a       	std	Y+22, r1	; 0x16
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
    1d48:	88 89       	ldd	r24, Y+16	; 0x10
    1d4a:	99 89       	ldd	r25, Y+17	; 0x11
    1d4c:	01 96       	adiw	r24, 0x01	; 1
    1d4e:	99 8b       	std	Y+17, r25	; 0x11
    1d50:	88 8b       	std	Y+16, r24	; 0x10
					int counter=1;
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
					char tempStringNum[5];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    1d52:	9e 01       	movw	r18, r28
    1d54:	22 5c       	subi	r18, 0xC2	; 194
    1d56:	3f 4f       	sbci	r19, 0xFF	; 255
    1d58:	88 89       	ldd	r24, Y+16	; 0x10
    1d5a:	99 89       	ldd	r25, Y+17	; 0x11
    1d5c:	82 0f       	add	r24, r18
    1d5e:	93 1f       	adc	r25, r19
    1d60:	fc 01       	movw	r30, r24
    1d62:	80 81       	ld	r24, Z
    1d64:	8f 32       	cpi	r24, 0x2F	; 47
    1d66:	69 f0       	breq	.+26     	; 0x1d82 <_Z11ReceiveBonev+0x576>
    1d68:	9e 01       	movw	r18, r28
    1d6a:	22 5c       	subi	r18, 0xC2	; 194
    1d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    1d6e:	88 89       	ldd	r24, Y+16	; 0x10
    1d70:	99 89       	ldd	r25, Y+17	; 0x11
    1d72:	82 0f       	add	r24, r18
    1d74:	93 1f       	adc	r25, r19
    1d76:	fc 01       	movw	r30, r24
    1d78:	80 81       	ld	r24, Z
    1d7a:	88 23       	and	r24, r24
    1d7c:	11 f0       	breq	.+4      	; 0x1d82 <_Z11ReceiveBonev+0x576>
    1d7e:	81 e0       	ldi	r24, 0x01	; 1
    1d80:	01 c0       	rjmp	.+2      	; 0x1d84 <_Z11ReceiveBonev+0x578>
    1d82:	80 e0       	ldi	r24, 0x00	; 0
    1d84:	88 23       	and	r24, r24
    1d86:	09 f0       	breq	.+2      	; 0x1d8a <_Z11ReceiveBonev+0x57e>
    1d88:	71 cf       	rjmp	.-286    	; 0x1c6c <_Z11ReceiveBonev+0x460>
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
					}//end while
					//Found a '/', assign tempNum otherwise exit with ACKBAD
					if (recString[counter] == '/'){
    1d8a:	9e 01       	movw	r18, r28
    1d8c:	22 5c       	subi	r18, 0xC2	; 194
    1d8e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d90:	88 89       	ldd	r24, Y+16	; 0x10
    1d92:	99 89       	ldd	r25, Y+17	; 0x11
    1d94:	82 0f       	add	r24, r18
    1d96:	93 1f       	adc	r25, r19
    1d98:	fc 01       	movw	r30, r24
    1d9a:	80 81       	ld	r24, Z
    1d9c:	8f 32       	cpi	r24, 0x2F	; 47
    1d9e:	a9 f4       	brne	.+42     	; 0x1dca <_Z11ReceiveBonev+0x5be>
						tempNum[hms] = atoi(tempStringNum);
    1da0:	ce 01       	movw	r24, r28
    1da2:	c9 96       	adiw	r24, 0x39	; 57
    1da4:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
    1da8:	9c 01       	movw	r18, r24
    1daa:	8c 89       	ldd	r24, Y+20	; 0x14
    1dac:	9d 89       	ldd	r25, Y+21	; 0x15
    1dae:	88 0f       	add	r24, r24
    1db0:	99 1f       	adc	r25, r25
    1db2:	ae 01       	movw	r20, r28
    1db4:	4f 5f       	subi	r20, 0xFF	; 255
    1db6:	5f 4f       	sbci	r21, 0xFF	; 255
    1db8:	84 0f       	add	r24, r20
    1dba:	95 1f       	adc	r25, r21
    1dbc:	8c 96       	adiw	r24, 0x2c	; 44
    1dbe:	fc 01       	movw	r30, r24
    1dc0:	31 83       	std	Z+1, r19	; 0x01
    1dc2:	20 83       	st	Z, r18
						successTime=fTrue;
    1dc4:	81 e0       	ldi	r24, 0x01	; 1
    1dc6:	8e 87       	std	Y+14, r24	; 0x0e
    1dc8:	04 c0       	rjmp	.+8      	; 0x1dd2 <_Z11ReceiveBonev+0x5c6>
					} else {
						state=4;
    1dca:	84 e0       	ldi	r24, 0x04	; 4
    1dcc:	90 e0       	ldi	r25, 0x00	; 0
    1dce:	9a 83       	std	Y+2, r25	; 0x02
    1dd0:	89 83       	std	Y+1, r24	; 0x01
					}
					
					//If flag for Date is set, then parse the string and do something with it.
					//Now get the date. have to null the tempStringNum
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1dd2:	1b 8e       	std	Y+27, r1	; 0x1b
    1dd4:	1a 8e       	std	Y+26, r1	; 0x1a
    1dd6:	0e c0       	rjmp	.+28     	; 0x1df4 <_Z11ReceiveBonev+0x5e8>
    1dd8:	9e 01       	movw	r18, r28
    1dda:	27 5c       	subi	r18, 0xC7	; 199
    1ddc:	3f 4f       	sbci	r19, 0xFF	; 255
    1dde:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1de0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1de2:	82 0f       	add	r24, r18
    1de4:	93 1f       	adc	r25, r19
    1de6:	fc 01       	movw	r30, r24
    1de8:	10 82       	st	Z, r1
    1dea:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dec:	9b 8d       	ldd	r25, Y+27	; 0x1b
    1dee:	01 96       	adiw	r24, 0x01	; 1
    1df0:	9b 8f       	std	Y+27, r25	; 0x1b
    1df2:	8a 8f       	std	Y+26, r24	; 0x1a
    1df4:	41 e0       	ldi	r20, 0x01	; 1
    1df6:	2a 8d       	ldd	r18, Y+26	; 0x1a
    1df8:	3b 8d       	ldd	r19, Y+27	; 0x1b
    1dfa:	8e 89       	ldd	r24, Y+22	; 0x16
    1dfc:	9f 89       	ldd	r25, Y+23	; 0x17
    1dfe:	82 17       	cp	r24, r18
    1e00:	93 07       	cpc	r25, r19
    1e02:	0c f4       	brge	.+2      	; 0x1e06 <_Z11ReceiveBonev+0x5fa>
    1e04:	40 e0       	ldi	r20, 0x00	; 0
    1e06:	44 23       	and	r20, r20
    1e08:	39 f7       	brne	.-50     	; 0x1dd8 <_Z11ReceiveBonev+0x5cc>
					placement=0;
    1e0a:	1f 8a       	std	Y+23, r1	; 0x17
    1e0c:	1e 8a       	std	Y+22, r1	; 0x16
					counter++;	//get past the '/'
    1e0e:	88 89       	ldd	r24, Y+16	; 0x10
    1e10:	99 89       	ldd	r25, Y+17	; 0x11
    1e12:	01 96       	adiw	r24, 0x01	; 1
    1e14:	99 8b       	std	Y+17, r25	; 0x11
    1e16:	88 8b       	std	Y+16, r24	; 0x10
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1e18:	73 c0       	rjmp	.+230    	; 0x1f00 <_Z11ReceiveBonev+0x6f4>
						//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
						if  (recString[counter] != ',' && dmy < 3){
    1e1a:	9e 01       	movw	r18, r28
    1e1c:	22 5c       	subi	r18, 0xC2	; 194
    1e1e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e20:	88 89       	ldd	r24, Y+16	; 0x10
    1e22:	99 89       	ldd	r25, Y+17	; 0x11
    1e24:	82 0f       	add	r24, r18
    1e26:	93 1f       	adc	r25, r19
    1e28:	fc 01       	movw	r30, r24
    1e2a:	80 81       	ld	r24, Z
    1e2c:	8c 32       	cpi	r24, 0x2C	; 44
    1e2e:	e9 f0       	breq	.+58     	; 0x1e6a <_Z11ReceiveBonev+0x65e>
    1e30:	8a 89       	ldd	r24, Y+18	; 0x12
    1e32:	9b 89       	ldd	r25, Y+19	; 0x13
    1e34:	83 30       	cpi	r24, 0x03	; 3
    1e36:	91 05       	cpc	r25, r1
    1e38:	c4 f4       	brge	.+48     	; 0x1e6a <_Z11ReceiveBonev+0x65e>
							tempStringNum[placement++]=recString[counter];
    1e3a:	9e 01       	movw	r18, r28
    1e3c:	22 5c       	subi	r18, 0xC2	; 194
    1e3e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e40:	88 89       	ldd	r24, Y+16	; 0x10
    1e42:	99 89       	ldd	r25, Y+17	; 0x11
    1e44:	82 0f       	add	r24, r18
    1e46:	93 1f       	adc	r25, r19
    1e48:	fc 01       	movw	r30, r24
    1e4a:	40 81       	ld	r20, Z
    1e4c:	9e 01       	movw	r18, r28
    1e4e:	27 5c       	subi	r18, 0xC7	; 199
    1e50:	3f 4f       	sbci	r19, 0xFF	; 255
    1e52:	8e 89       	ldd	r24, Y+22	; 0x16
    1e54:	9f 89       	ldd	r25, Y+23	; 0x17
    1e56:	82 0f       	add	r24, r18
    1e58:	93 1f       	adc	r25, r19
    1e5a:	fc 01       	movw	r30, r24
    1e5c:	40 83       	st	Z, r20
    1e5e:	8e 89       	ldd	r24, Y+22	; 0x16
    1e60:	9f 89       	ldd	r25, Y+23	; 0x17
    1e62:	01 96       	adiw	r24, 0x01	; 1
    1e64:	9f 8b       	std	Y+23, r25	; 0x17
    1e66:	8e 8b       	std	Y+22, r24	; 0x16
    1e68:	46 c0       	rjmp	.+140    	; 0x1ef6 <_Z11ReceiveBonev+0x6ea>
						//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
						} else if (dmy<2 && recString[counter]==','){
    1e6a:	8a 89       	ldd	r24, Y+18	; 0x12
    1e6c:	9b 89       	ldd	r25, Y+19	; 0x13
    1e6e:	82 30       	cpi	r24, 0x02	; 2
    1e70:	91 05       	cpc	r25, r1
    1e72:	0c f0       	brlt	.+2      	; 0x1e76 <_Z11ReceiveBonev+0x66a>
    1e74:	40 c0       	rjmp	.+128    	; 0x1ef6 <_Z11ReceiveBonev+0x6ea>
    1e76:	9e 01       	movw	r18, r28
    1e78:	22 5c       	subi	r18, 0xC2	; 194
    1e7a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e7c:	88 89       	ldd	r24, Y+16	; 0x10
    1e7e:	99 89       	ldd	r25, Y+17	; 0x11
    1e80:	82 0f       	add	r24, r18
    1e82:	93 1f       	adc	r25, r19
    1e84:	fc 01       	movw	r30, r24
    1e86:	80 81       	ld	r24, Z
    1e88:	8c 32       	cpi	r24, 0x2C	; 44
    1e8a:	a9 f5       	brne	.+106    	; 0x1ef6 <_Z11ReceiveBonev+0x6ea>
							tempNum1[dmy++] = atoi(tempStringNum);
    1e8c:	ce 01       	movw	r24, r28
    1e8e:	c9 96       	adiw	r24, 0x39	; 57
    1e90:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
    1e94:	9c 01       	movw	r18, r24
    1e96:	8a 89       	ldd	r24, Y+18	; 0x12
    1e98:	9b 89       	ldd	r25, Y+19	; 0x13
    1e9a:	88 0f       	add	r24, r24
    1e9c:	99 1f       	adc	r25, r25
    1e9e:	ae 01       	movw	r20, r28
    1ea0:	4f 5f       	subi	r20, 0xFF	; 255
    1ea2:	5f 4f       	sbci	r21, 0xFF	; 255
    1ea4:	84 0f       	add	r24, r20
    1ea6:	95 1f       	adc	r25, r21
    1ea8:	c2 96       	adiw	r24, 0x32	; 50
    1eaa:	fc 01       	movw	r30, r24
    1eac:	31 83       	std	Z+1, r19	; 0x01
    1eae:	20 83       	st	Z, r18
    1eb0:	8a 89       	ldd	r24, Y+18	; 0x12
    1eb2:	9b 89       	ldd	r25, Y+19	; 0x13
    1eb4:	01 96       	adiw	r24, 0x01	; 1
    1eb6:	9b 8b       	std	Y+19, r25	; 0x13
    1eb8:	8a 8b       	std	Y+18, r24	; 0x12
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    1eba:	1d 8e       	std	Y+29, r1	; 0x1d
    1ebc:	1c 8e       	std	Y+28, r1	; 0x1c
    1ebe:	0e c0       	rjmp	.+28     	; 0x1edc <_Z11ReceiveBonev+0x6d0>
    1ec0:	9e 01       	movw	r18, r28
    1ec2:	27 5c       	subi	r18, 0xC7	; 199
    1ec4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ec6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1ec8:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1eca:	82 0f       	add	r24, r18
    1ecc:	93 1f       	adc	r25, r19
    1ece:	fc 01       	movw	r30, r24
    1ed0:	10 82       	st	Z, r1
    1ed2:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1ed4:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1ed6:	01 96       	adiw	r24, 0x01	; 1
    1ed8:	9d 8f       	std	Y+29, r25	; 0x1d
    1eda:	8c 8f       	std	Y+28, r24	; 0x1c
    1edc:	41 e0       	ldi	r20, 0x01	; 1
    1ede:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1ee0:	3d 8d       	ldd	r19, Y+29	; 0x1d
    1ee2:	8e 89       	ldd	r24, Y+22	; 0x16
    1ee4:	9f 89       	ldd	r25, Y+23	; 0x17
    1ee6:	82 17       	cp	r24, r18
    1ee8:	93 07       	cpc	r25, r19
    1eea:	0c f4       	brge	.+2      	; 0x1eee <_Z11ReceiveBonev+0x6e2>
    1eec:	40 e0       	ldi	r20, 0x00	; 0
    1eee:	44 23       	and	r20, r20
    1ef0:	39 f7       	brne	.-50     	; 0x1ec0 <_Z11ReceiveBonev+0x6b4>
							placement=0;
    1ef2:	1f 8a       	std	Y+23, r1	; 0x17
    1ef4:	1e 8a       	std	Y+22, r1	; 0x16
						} else;
						counter++;							
    1ef6:	88 89       	ldd	r24, Y+16	; 0x10
    1ef8:	99 89       	ldd	r25, Y+17	; 0x11
    1efa:	01 96       	adiw	r24, 0x01	; 1
    1efc:	99 8b       	std	Y+17, r25	; 0x11
    1efe:	88 8b       	std	Y+16, r24	; 0x10
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
					placement=0;
					counter++;	//get past the '/'
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1f00:	9e 01       	movw	r18, r28
    1f02:	22 5c       	subi	r18, 0xC2	; 194
    1f04:	3f 4f       	sbci	r19, 0xFF	; 255
    1f06:	88 89       	ldd	r24, Y+16	; 0x10
    1f08:	99 89       	ldd	r25, Y+17	; 0x11
    1f0a:	82 0f       	add	r24, r18
    1f0c:	93 1f       	adc	r25, r19
    1f0e:	fc 01       	movw	r30, r24
    1f10:	80 81       	ld	r24, Z
    1f12:	8e 32       	cpi	r24, 0x2E	; 46
    1f14:	a1 f0       	breq	.+40     	; 0x1f3e <_Z11ReceiveBonev+0x732>
    1f16:	9e 01       	movw	r18, r28
    1f18:	22 5c       	subi	r18, 0xC2	; 194
    1f1a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f1c:	88 89       	ldd	r24, Y+16	; 0x10
    1f1e:	99 89       	ldd	r25, Y+17	; 0x11
    1f20:	82 0f       	add	r24, r18
    1f22:	93 1f       	adc	r25, r19
    1f24:	fc 01       	movw	r30, r24
    1f26:	80 81       	ld	r24, Z
    1f28:	88 23       	and	r24, r24
    1f2a:	49 f0       	breq	.+18     	; 0x1f3e <_Z11ReceiveBonev+0x732>
    1f2c:	28 89       	ldd	r18, Y+16	; 0x10
    1f2e:	39 89       	ldd	r19, Y+17	; 0x11
    1f30:	8b 81       	ldd	r24, Y+3	; 0x03
    1f32:	9c 81       	ldd	r25, Y+4	; 0x04
    1f34:	28 17       	cp	r18, r24
    1f36:	39 07       	cpc	r19, r25
    1f38:	11 f0       	breq	.+4      	; 0x1f3e <_Z11ReceiveBonev+0x732>
    1f3a:	81 e0       	ldi	r24, 0x01	; 1
    1f3c:	01 c0       	rjmp	.+2      	; 0x1f40 <_Z11ReceiveBonev+0x734>
    1f3e:	80 e0       	ldi	r24, 0x00	; 0
    1f40:	88 23       	and	r24, r24
    1f42:	09 f0       	breq	.+2      	; 0x1f46 <_Z11ReceiveBonev+0x73a>
    1f44:	6a cf       	rjmp	.-300    	; 0x1e1a <_Z11ReceiveBonev+0x60e>
						} else;
						counter++;							
					}//end while
					
					//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
					if (recString[counter] == '.'){
    1f46:	9e 01       	movw	r18, r28
    1f48:	22 5c       	subi	r18, 0xC2	; 194
    1f4a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f4c:	88 89       	ldd	r24, Y+16	; 0x10
    1f4e:	99 89       	ldd	r25, Y+17	; 0x11
    1f50:	82 0f       	add	r24, r18
    1f52:	93 1f       	adc	r25, r19
    1f54:	fc 01       	movw	r30, r24
    1f56:	80 81       	ld	r24, Z
    1f58:	8e 32       	cpi	r24, 0x2E	; 46
    1f5a:	a9 f4       	brne	.+42     	; 0x1f86 <_Z11ReceiveBonev+0x77a>
						tempNum1[dmy] = atoi(tempStringNum);
    1f5c:	ce 01       	movw	r24, r28
    1f5e:	c9 96       	adiw	r24, 0x39	; 57
    1f60:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
    1f64:	9c 01       	movw	r18, r24
    1f66:	8a 89       	ldd	r24, Y+18	; 0x12
    1f68:	9b 89       	ldd	r25, Y+19	; 0x13
    1f6a:	88 0f       	add	r24, r24
    1f6c:	99 1f       	adc	r25, r25
    1f6e:	ae 01       	movw	r20, r28
    1f70:	4f 5f       	subi	r20, 0xFF	; 255
    1f72:	5f 4f       	sbci	r21, 0xFF	; 255
    1f74:	84 0f       	add	r24, r20
    1f76:	95 1f       	adc	r25, r21
    1f78:	c2 96       	adiw	r24, 0x32	; 50
    1f7a:	fc 01       	movw	r30, r24
    1f7c:	31 83       	std	Z+1, r19	; 0x01
    1f7e:	20 83       	st	Z, r18
						successDate=fTrue;
    1f80:	81 e0       	ldi	r24, 0x01	; 1
    1f82:	8f 87       	std	Y+15, r24	; 0x0f
    1f84:	04 c0       	rjmp	.+8      	; 0x1f8e <_Z11ReceiveBonev+0x782>
					} else {//something in the string was wrong, ACKBAD and then exit
						state=4;
    1f86:	84 e0       	ldi	r24, 0x04	; 4
    1f88:	90 e0       	ldi	r25, 0x00	; 0
    1f8a:	9a 83       	std	Y+2, r25	; 0x02
    1f8c:	89 83       	std	Y+1, r24	; 0x01
					}	
					
					//NOw set the time and date, then save it to EEPROM
					if (successDate && successTime){
    1f8e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1f90:	88 23       	and	r24, r24
    1f92:	29 f1       	breq	.+74     	; 0x1fde <_Z11ReceiveBonev+0x7d2>
    1f94:	8e 85       	ldd	r24, Y+14	; 0x0e
    1f96:	88 23       	and	r24, r24
    1f98:	11 f1       	breq	.+68     	; 0x1fde <_Z11ReceiveBonev+0x7d2>
						currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    1f9a:	6b a9       	sts	0x4b, r22
    1f9c:	7c a9       	sts	0x4c, r23
    1f9e:	4d a9       	sts	0x4d, r20
    1fa0:	5e a9       	sts	0x4e, r21
    1fa2:	2f a9       	sts	0x4f, r18
    1fa4:	38 ad       	sts	0x68, r19
    1fa6:	84 ed       	ldi	r24, 0xD4	; 212
    1fa8:	91 e0       	ldi	r25, 0x01	; 1
    1faa:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
						currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    1fae:	6d a5       	lds	r22, 0x6d
    1fb0:	7e a5       	lds	r23, 0x6e
    1fb2:	4f a5       	lds	r20, 0x6f
    1fb4:	58 a9       	sts	0x48, r21
    1fb6:	29 a9       	sts	0x49, r18
    1fb8:	3a a9       	sts	0x4a, r19
    1fba:	84 ed       	ldi	r24, 0xD4	; 212
    1fbc:	91 e0       	ldi	r25, 0x01	; 1
    1fbe:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
						saveDateTime_eeprom(fTrue,fTrue);
    1fc2:	81 e0       	ldi	r24, 0x01	; 1
    1fc4:	61 e0       	ldi	r22, 0x01	; 1
    1fc6:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    1fca:	81 e0       	ldi	r24, 0x01	; 1
    1fcc:	80 93 03 02 	sts	0x0203, r24
						//Make sure UserCLock flags are down
						flagUserClock=fFalse;
    1fd0:	10 92 05 02 	sts	0x0205, r1
						state=3;	//Graceful exit
    1fd4:	83 e0       	ldi	r24, 0x03	; 3
    1fd6:	90 e0       	ldi	r25, 0x00	; 0
    1fd8:	9a 83       	std	Y+2, r25	; 0x02
    1fda:	89 83       	std	Y+1, r24	; 0x01
    1fdc:	2b c0       	rjmp	.+86     	; 0x2034 <_Z11ReceiveBonev+0x828>
					} else if (!(successDate && successTime) && restart){
    1fde:	8f 85       	ldd	r24, Y+15	; 0x0f
    1fe0:	88 23       	and	r24, r24
    1fe2:	19 f0       	breq	.+6      	; 0x1fea <_Z11ReceiveBonev+0x7de>
    1fe4:	8e 85       	ldd	r24, Y+14	; 0x0e
    1fe6:	88 23       	and	r24, r24
    1fe8:	71 f4       	brne	.+28     	; 0x2006 <_Z11ReceiveBonev+0x7fa>
    1fea:	80 91 0d 02 	lds	r24, 0x020D
    1fee:	88 23       	and	r24, r24
    1ff0:	51 f0       	breq	.+20     	; 0x2006 <_Z11ReceiveBonev+0x7fa>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    1ff2:	81 e0       	ldi	r24, 0x01	; 1
    1ff4:	80 93 03 02 	sts	0x0203, r24
						flagUserClock=fFalse;
    1ff8:	10 92 05 02 	sts	0x0205, r1
						state=4;	//ACKBAD
    1ffc:	84 e0       	ldi	r24, 0x04	; 4
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	9a 83       	std	Y+2, r25	; 0x02
    2002:	89 83       	std	Y+1, r24	; 0x01
    2004:	17 c0       	rjmp	.+46     	; 0x2034 <_Z11ReceiveBonev+0x828>
					} else if (!(successDate && successTime) && flagFreshStart && !restart){
    2006:	8f 85       	ldd	r24, Y+15	; 0x0f
    2008:	88 23       	and	r24, r24
    200a:	19 f0       	breq	.+6      	; 0x2012 <_Z11ReceiveBonev+0x806>
    200c:	8e 85       	ldd	r24, Y+14	; 0x0e
    200e:	88 23       	and	r24, r24
    2010:	89 f4       	brne	.+34     	; 0x2034 <_Z11ReceiveBonev+0x828>
    2012:	80 91 0e 02 	lds	r24, 0x020E
    2016:	88 23       	and	r24, r24
    2018:	69 f0       	breq	.+26     	; 0x2034 <_Z11ReceiveBonev+0x828>
    201a:	80 91 0d 02 	lds	r24, 0x020D
    201e:	88 23       	and	r24, r24
    2020:	49 f4       	brne	.+18     	; 0x2034 <_Z11ReceiveBonev+0x828>
						flagUserClock=fTrue;
    2022:	81 e0       	ldi	r24, 0x01	; 1
    2024:	80 93 05 02 	sts	0x0205, r24
						flagUpdateGAVRClock=fFalse;
    2028:	10 92 03 02 	sts	0x0203, r1
						state=4;	//ACKBAD
    202c:	84 e0       	ldi	r24, 0x04	; 4
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	9a 83       	std	Y+2, r25	; 0x02
    2032:	89 83       	std	Y+1, r24	; 0x01
					} else;		
					
					//Lower restart flags. Should have parallel case in timer just in case this state doesn't happen.
					flagFreshStart=fFalse;
    2034:	10 92 0e 02 	sts	0x020E, r1
					restart=fFalse;		
    2038:	10 92 0d 02 	sts	0x020D, r1
					break;
    203c:	05 c0       	rjmp	.+10     	; 0x2048 <_Z11ReceiveBonev+0x83c>
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
    203e:	10 92 fd 01 	sts	0x01FD, r1
    2042:	1a 82       	std	Y+2, r1	; 0x02
    2044:	19 82       	std	Y+1, r1	; 0x01
    2046:	00 00       	nop
	unsigned int state=0;
	char recChar, recString[40];
	unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	sei();
	while (flagReceivingBone){
    2048:	90 91 fd 01 	lds	r25, 0x01FD
    204c:	81 e0       	ldi	r24, 0x01	; 1
    204e:	99 23       	and	r25, r25
    2050:	09 f4       	brne	.+2      	; 0x2054 <_Z11ReceiveBonev+0x848>
    2052:	80 e0       	ldi	r24, 0x00	; 0
    2054:	88 23       	and	r24, r24
    2056:	09 f0       	breq	.+2      	; 0x205a <_Z11ReceiveBonev+0x84e>
    2058:	ec cb       	rjmp	.-2088   	; 0x1832 <_Z11ReceiveBonev+0x26>
					break;
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
			}//end switch
	}//end while(flagUARTbone)	
}//end ReceiveBone()
    205a:	cb 59       	subi	r28, 0x9B	; 155
    205c:	df 4f       	sbci	r29, 0xFF	; 255
    205e:	0f b6       	in	r0, 0x3f	; 63
    2060:	f8 94       	cli
    2062:	de bf       	out	0x3e, r29	; 62
    2064:	0f be       	out	0x3f, r0	; 63
    2066:	cd bf       	out	0x3d, r28	; 61
    2068:	df 91       	pop	r29
    206a:	cf 91       	pop	r28
    206c:	08 95       	ret

0000206e <_Z11ReceiveGAVRv>:

/*************************************************************************************************************/
void ReceiveGAVR(){
    206e:	cf 93       	push	r28
    2070:	df 93       	push	r29
    2072:	cd b7       	in	r28, 0x3d	; 61
    2074:	de b7       	in	r29, 0x3e	; 62
    2076:	c1 55       	subi	r28, 0x51	; 81
    2078:	d0 40       	sbci	r29, 0x00	; 0
    207a:	0f b6       	in	r0, 0x3f	; 63
    207c:	f8 94       	cli
    207e:	de bf       	out	0x3e, r29	; 62
    2080:	0f be       	out	0x3f, r0	; 63
    2082:	cd bf       	out	0x3d, r28	; 61
	unsigned int state=0;
    2084:	1a 82       	std	Y+2, r1	; 0x02
    2086:	19 82       	std	Y+1, r1	; 0x01
	char recChar, recString[40];
	unsigned int strLoc=0;
    2088:	1c 82       	std	Y+4, r1	; 0x04
    208a:	1b 82       	std	Y+3, r1	; 0x03
	BOOL noCarriage=fTrue;
    208c:	81 e0       	ldi	r24, 0x01	; 1
    208e:	8d 83       	std	Y+5, r24	; 0x05
	
	//While Loop
	while (flagReceivingGAVR){
    2090:	51 c3       	rjmp	.+1698   	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
			/** State 5: Exit case. Lower "flagReceivingGAVR" which causes and exit.													   **/
			/** State 6: ACKERROR state. Send "ACKERROR", then exit through state 5.													   **/
			/** State 7: Successful acquire of time/date.																				   **/
			/** Default: Set state to 0, doesn't really matter though. Exit signalling timeout to sender.								   **/
			/********************************************************************************************************************************/			
			switch(state){
    2092:	89 81       	ldd	r24, Y+1	; 0x01
    2094:	9a 81       	ldd	r25, Y+2	; 0x02
    2096:	83 30       	cpi	r24, 0x03	; 3
    2098:	91 05       	cpc	r25, r1
    209a:	09 f4       	brne	.+2      	; 0x209e <_Z11ReceiveGAVRv+0x30>
    209c:	c5 c0       	rjmp	.+394    	; 0x2228 <_Z11ReceiveGAVRv+0x1ba>
    209e:	84 30       	cpi	r24, 0x04	; 4
    20a0:	91 05       	cpc	r25, r1
    20a2:	48 f4       	brcc	.+18     	; 0x20b6 <_Z11ReceiveGAVRv+0x48>
    20a4:	81 30       	cpi	r24, 0x01	; 1
    20a6:	91 05       	cpc	r25, r1
    20a8:	09 f4       	brne	.+2      	; 0x20ac <_Z11ReceiveGAVRv+0x3e>
    20aa:	85 c0       	rjmp	.+266    	; 0x21b6 <_Z11ReceiveGAVRv+0x148>
    20ac:	82 30       	cpi	r24, 0x02	; 2
    20ae:	91 05       	cpc	r25, r1
    20b0:	08 f0       	brcs	.+2      	; 0x20b4 <_Z11ReceiveGAVRv+0x46>
    20b2:	8f c0       	rjmp	.+286    	; 0x21d2 <_Z11ReceiveGAVRv+0x164>
    20b4:	11 c0       	rjmp	.+34     	; 0x20d8 <_Z11ReceiveGAVRv+0x6a>
    20b6:	85 30       	cpi	r24, 0x05	; 5
    20b8:	91 05       	cpc	r25, r1
    20ba:	09 f4       	brne	.+2      	; 0x20be <_Z11ReceiveGAVRv+0x50>
    20bc:	ed c2       	rjmp	.+1498   	; 0x2698 <_Z11ReceiveGAVRv+0x62a>
    20be:	85 30       	cpi	r24, 0x05	; 5
    20c0:	91 05       	cpc	r25, r1
    20c2:	08 f4       	brcc	.+2      	; 0x20c6 <_Z11ReceiveGAVRv+0x58>
    20c4:	c8 c2       	rjmp	.+1424   	; 0x2656 <_Z11ReceiveGAVRv+0x5e8>
    20c6:	86 30       	cpi	r24, 0x06	; 6
    20c8:	91 05       	cpc	r25, r1
    20ca:	09 f4       	brne	.+2      	; 0x20ce <_Z11ReceiveGAVRv+0x60>
    20cc:	08 c3       	rjmp	.+1552   	; 0x26de <_Z11ReceiveGAVRv+0x670>
    20ce:	87 30       	cpi	r24, 0x07	; 7
    20d0:	91 05       	cpc	r25, r1
    20d2:	09 f4       	brne	.+2      	; 0x20d6 <_Z11ReceiveGAVRv+0x68>
    20d4:	15 c3       	rjmp	.+1578   	; 0x2700 <_Z11ReceiveGAVRv+0x692>
    20d6:	27 c3       	rjmp	.+1614   	; 0x2726 <_Z11ReceiveGAVRv+0x6b8>
				case 0:{
					//Beginning case
					strLoc=0;
    20d8:	1c 82       	std	Y+4, r1	; 0x04
    20da:	1b 82       	std	Y+3, r1	; 0x03
					recChar = UDR1;
    20dc:	8e ec       	ldi	r24, 0xCE	; 206
    20de:	90 e0       	ldi	r25, 0x00	; 0
    20e0:	fc 01       	movw	r30, r24
    20e2:	80 81       	ld	r24, Z
    20e4:	8e 8b       	std	Y+22, r24	; 0x16
					if (recChar=='.'){
    20e6:	8e 89       	ldd	r24, Y+22	; 0x16
    20e8:	8e 32       	cpi	r24, 0x2E	; 46
    20ea:	29 f4       	brne	.+10     	; 0x20f6 <_Z11ReceiveGAVRv+0x88>
						state=6;															//Go to error state.
    20ec:	86 e0       	ldi	r24, 0x06	; 6
    20ee:	90 e0       	ldi	r25, 0x00	; 0
    20f0:	9a 83       	std	Y+2, r25	; 0x02
    20f2:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
    20f4:	1f c3       	rjmp	.+1598   	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
					//Beginning case
					strLoc=0;
					recChar = UDR1;
					if (recChar=='.'){
						state=6;															//Go to error state.
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
    20f6:	9e 01       	movw	r18, r28
    20f8:	26 5d       	subi	r18, 0xD6	; 214
    20fa:	3f 4f       	sbci	r19, 0xFF	; 255
    20fc:	8b 81       	ldd	r24, Y+3	; 0x03
    20fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2100:	82 0f       	add	r24, r18
    2102:	93 1f       	adc	r25, r19
    2104:	2e 89       	ldd	r18, Y+22	; 0x16
    2106:	fc 01       	movw	r30, r24
    2108:	20 83       	st	Z, r18
    210a:	8b 81       	ldd	r24, Y+3	; 0x03
    210c:	9c 81       	ldd	r25, Y+4	; 0x04
    210e:	01 96       	adiw	r24, 0x01	; 1
    2110:	9c 83       	std	Y+4, r25	; 0x04
    2112:	8b 83       	std	Y+3, r24	; 0x03
    2114:	81 e0       	ldi	r24, 0x01	; 1
    2116:	90 e0       	ldi	r25, 0x00	; 0
    2118:	9a 83       	std	Y+2, r25	; 0x02
    211a:	89 83       	std	Y+1, r24	; 0x01
					break;
    211c:	0b c3       	rjmp	.+1558   	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						Wait_ms(100);
    211e:	84 e6       	ldi	r24, 0x64	; 100
    2120:	90 e0       	ldi	r25, 0x00	; 0
    2122:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
    2126:	00 00       	nop
    2128:	88 ec       	ldi	r24, 0xC8	; 200
    212a:	90 e0       	ldi	r25, 0x00	; 0
    212c:	fc 01       	movw	r30, r24
    212e:	80 81       	ld	r24, Z
    2130:	88 23       	and	r24, r24
    2132:	34 f0       	brlt	.+12     	; 0x2140 <_Z11ReceiveGAVRv+0xd2>
    2134:	80 91 ff 01 	lds	r24, 0x01FF
    2138:	88 23       	and	r24, r24
    213a:	11 f0       	breq	.+4      	; 0x2140 <_Z11ReceiveGAVRv+0xd2>
    213c:	81 e0       	ldi	r24, 0x01	; 1
    213e:	01 c0       	rjmp	.+2      	; 0x2142 <_Z11ReceiveGAVRv+0xd4>
    2140:	80 e0       	ldi	r24, 0x00	; 0
    2142:	88 23       	and	r24, r24
    2144:	89 f7       	brne	.-30     	; 0x2128 <_Z11ReceiveGAVRv+0xba>
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
    2146:	80 91 ff 01 	lds	r24, 0x01FF
    214a:	88 23       	and	r24, r24
    214c:	21 f4       	brne	.+8      	; 0x2156 <_Z11ReceiveGAVRv+0xe8>
    214e:	1a 82       	std	Y+2, r1	; 0x02
    2150:	19 82       	std	Y+1, r1	; 0x01
    2152:	00 00       	nop
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    2154:	ef c2       	rjmp	.+1502   	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						Wait_ms(100);
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
						if (!flagReceivingGAVR){state=0; break;}							//if there was a timeout, break out and reset state
						recChar=UDR1;
    2156:	8e ec       	ldi	r24, 0xCE	; 206
    2158:	90 e0       	ldi	r25, 0x00	; 0
    215a:	fc 01       	movw	r30, r24
    215c:	80 81       	ld	r24, Z
    215e:	8e 8b       	std	Y+22, r24	; 0x16
						recString[strLoc++]=recChar;										//'.' always included into recString
    2160:	9e 01       	movw	r18, r28
    2162:	26 5d       	subi	r18, 0xD6	; 214
    2164:	3f 4f       	sbci	r19, 0xFF	; 255
    2166:	8b 81       	ldd	r24, Y+3	; 0x03
    2168:	9c 81       	ldd	r25, Y+4	; 0x04
    216a:	82 0f       	add	r24, r18
    216c:	93 1f       	adc	r25, r19
    216e:	2e 89       	ldd	r18, Y+22	; 0x16
    2170:	fc 01       	movw	r30, r24
    2172:	20 83       	st	Z, r18
    2174:	8b 81       	ldd	r24, Y+3	; 0x03
    2176:	9c 81       	ldd	r25, Y+4	; 0x04
    2178:	01 96       	adiw	r24, 0x01	; 1
    217a:	9c 83       	std	Y+4, r25	; 0x04
    217c:	8b 83       	std	Y+3, r24	; 0x03
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    217e:	8e 89       	ldd	r24, Y+22	; 0x16
    2180:	8e 32       	cpi	r24, 0x2E	; 46
    2182:	79 f4       	brne	.+30     	; 0x21a2 <_Z11ReceiveGAVRv+0x134>
    2184:	9e 01       	movw	r18, r28
    2186:	26 5d       	subi	r18, 0xD6	; 214
    2188:	3f 4f       	sbci	r19, 0xFF	; 255
    218a:	8b 81       	ldd	r24, Y+3	; 0x03
    218c:	9c 81       	ldd	r25, Y+4	; 0x04
    218e:	82 0f       	add	r24, r18
    2190:	93 1f       	adc	r25, r19
    2192:	fc 01       	movw	r30, r24
    2194:	10 82       	st	Z, r1
    2196:	1d 82       	std	Y+5, r1	; 0x05
    2198:	82 e0       	ldi	r24, 0x02	; 2
    219a:	90 e0       	ldi	r25, 0x00	; 0
    219c:	9a 83       	std	Y+2, r25	; 0x02
    219e:	89 83       	std	Y+1, r24	; 0x01
    21a0:	0a c0       	rjmp	.+20     	; 0x21b6 <_Z11ReceiveGAVRv+0x148>
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
    21a2:	8b 81       	ldd	r24, Y+3	; 0x03
    21a4:	9c 81       	ldd	r25, Y+4	; 0x04
    21a6:	87 32       	cpi	r24, 0x27	; 39
    21a8:	91 05       	cpc	r25, r1
    21aa:	28 f0       	brcs	.+10     	; 0x21b6 <_Z11ReceiveGAVRv+0x148>
    21ac:	86 e0       	ldi	r24, 0x06	; 6
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	9a 83       	std	Y+2, r25	; 0x02
    21b2:	89 83       	std	Y+1, r24	; 0x01
    21b4:	1d 82       	std	Y+5, r1	; 0x05
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
    21b6:	8d 81       	ldd	r24, Y+5	; 0x05
    21b8:	88 23       	and	r24, r24
    21ba:	31 f0       	breq	.+12     	; 0x21c8 <_Z11ReceiveGAVRv+0x15a>
    21bc:	80 91 ff 01 	lds	r24, 0x01FF
    21c0:	88 23       	and	r24, r24
    21c2:	11 f0       	breq	.+4      	; 0x21c8 <_Z11ReceiveGAVRv+0x15a>
    21c4:	81 e0       	ldi	r24, 0x01	; 1
    21c6:	01 c0       	rjmp	.+2      	; 0x21ca <_Z11ReceiveGAVRv+0x15c>
    21c8:	80 e0       	ldi	r24, 0x00	; 0
    21ca:	88 23       	and	r24, r24
    21cc:	09 f0       	breq	.+2      	; 0x21d0 <_Z11ReceiveGAVRv+0x162>
    21ce:	a7 cf       	rjmp	.-178    	; 0x211e <_Z11ReceiveGAVRv+0xb0>
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    21d0:	b1 c2       	rjmp	.+1378   	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
    21d2:	ce 01       	movw	r24, r28
    21d4:	8a 96       	adiw	r24, 0x2a	; 42
    21d6:	22 e7       	ldi	r18, 0x72	; 114
    21d8:	31 e0       	ldi	r19, 0x01	; 1
    21da:	b9 01       	movw	r22, r18
    21dc:	48 e0       	ldi	r20, 0x08	; 8
    21de:	50 e0       	ldi	r21, 0x00	; 0
    21e0:	0e 94 45 1d 	call	0x3a8a	; 0x3a8a <strncmp>
    21e4:	00 97       	sbiw	r24, 0x00	; 0
    21e6:	29 f4       	brne	.+10     	; 0x21f2 <_Z11ReceiveGAVRv+0x184>
    21e8:	84 e0       	ldi	r24, 0x04	; 4
    21ea:	90 e0       	ldi	r25, 0x00	; 0
    21ec:	9a 83       	std	Y+2, r25	; 0x02
    21ee:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
					break;
    21f0:	a1 c2       	rjmp	.+1346   	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
					break;
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
    21f2:	8c a5       	lds	r24, 0x6c
    21f4:	91 e0       	ldi	r25, 0x01	; 1
    21f6:	8a 33       	cpi	r24, 0x3A	; 58
    21f8:	09 f0       	breq	.+2      	; 0x21fc <_Z11ReceiveGAVRv+0x18e>
    21fa:	90 e0       	ldi	r25, 0x00	; 0
    21fc:	2d a5       	lds	r18, 0x6d
    21fe:	81 e0       	ldi	r24, 0x01	; 1
    2200:	2a 33       	cpi	r18, 0x3A	; 58
    2202:	09 f0       	breq	.+2      	; 0x2206 <_Z11ReceiveGAVRv+0x198>
    2204:	80 e0       	ldi	r24, 0x00	; 0
    2206:	89 27       	eor	r24, r25
    2208:	88 23       	and	r24, r24
    220a:	49 f0       	breq	.+18     	; 0x221e <_Z11ReceiveGAVRv+0x1b0>
    220c:	83 e0       	ldi	r24, 0x03	; 3
    220e:	90 e0       	ldi	r25, 0x00	; 0
    2210:	9a 83       	std	Y+2, r25	; 0x02
    2212:	89 83       	std	Y+1, r24	; 0x01
    2214:	88 e7       	ldi	r24, 0x78	; 120
    2216:	91 e0       	ldi	r25, 0x01	; 1
    2218:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					else {state=6;}
					break;
    221c:	8b c2       	rjmp	.+1302   	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else {state=6;}
    221e:	86 e0       	ldi	r24, 0x06	; 6
    2220:	90 e0       	ldi	r25, 0x00	; 0
    2222:	9a 83       	std	Y+2, r25	; 0x02
    2224:	89 83       	std	Y+1, r24	; 0x01
					break;
    2226:	86 c2       	rjmp	.+1292   	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
				}//end case 2
				case 3:{
					//Parse for date/time case
					if (flagUserClock){
    2228:	80 91 05 02 	lds	r24, 0x0205
    222c:	88 23       	and	r24, r24
    222e:	09 f4       	brne	.+2      	; 0x2232 <_Z11ReceiveGAVRv+0x1c4>
    2230:	09 c2       	rjmp	.+1042   	; 0x2644 <_Z11ReceiveGAVRv+0x5d6>
						//Go through the string and parse for the time. Must go through the time to get the date.
						BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    2232:	1f 8a       	std	Y+23, r1	; 0x17
    2234:	18 8e       	std	Y+24, r1	; 0x18
						int counter=1;
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	90 e0       	ldi	r25, 0x00	; 0
    223a:	9f 83       	std	Y+7, r25	; 0x07
    223c:	8e 83       	std	Y+6, r24	; 0x06
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    223e:	1a 8e       	std	Y+26, r1	; 0x1a
    2240:	19 8e       	std	Y+25, r1	; 0x19
    2242:	1c 8e       	std	Y+28, r1	; 0x1c
    2244:	1b 8e       	std	Y+27, r1	; 0x1b
    2246:	1e 8e       	std	Y+30, r1	; 0x1e
    2248:	1d 8e       	std	Y+29, r1	; 0x1d
    224a:	18 a2       	lds	r17, 0x98
    224c:	1f 8e       	std	Y+31, r1	; 0x1f
    224e:	1a a2       	lds	r17, 0x9a
    2250:	19 a2       	lds	r17, 0x99
    2252:	1c a2       	lds	r17, 0x9c
    2254:	1b a2       	lds	r17, 0x9b
    2256:	19 86       	std	Y+9, r1	; 0x09
    2258:	18 86       	std	Y+8, r1	; 0x08
    225a:	1b 86       	std	Y+11, r1	; 0x0b
    225c:	1a 86       	std	Y+10, r1	; 0x0a
    225e:	1d 86       	std	Y+13, r1	; 0x0d
    2260:	1c 86       	std	Y+12, r1	; 0x0c
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    2262:	73 c0       	rjmp	.+230    	; 0x234a <_Z11ReceiveGAVRv+0x2dc>
							//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
							if (recString[counter]!=':' && hms<3){
    2264:	9e 01       	movw	r18, r28
    2266:	26 5d       	subi	r18, 0xD6	; 214
    2268:	3f 4f       	sbci	r19, 0xFF	; 255
    226a:	8e 81       	ldd	r24, Y+6	; 0x06
    226c:	9f 81       	ldd	r25, Y+7	; 0x07
    226e:	82 0f       	add	r24, r18
    2270:	93 1f       	adc	r25, r19
    2272:	fc 01       	movw	r30, r24
    2274:	80 81       	ld	r24, Z
    2276:	8a 33       	cpi	r24, 0x3A	; 58
    2278:	e9 f0       	breq	.+58     	; 0x22b4 <_Z11ReceiveGAVRv+0x246>
    227a:	8a 85       	ldd	r24, Y+10	; 0x0a
    227c:	9b 85       	ldd	r25, Y+11	; 0x0b
    227e:	83 30       	cpi	r24, 0x03	; 3
    2280:	91 05       	cpc	r25, r1
    2282:	c4 f4       	brge	.+48     	; 0x22b4 <_Z11ReceiveGAVRv+0x246>
								tempStringNum[placement++]=recString[counter];
    2284:	9e 01       	movw	r18, r28
    2286:	26 5d       	subi	r18, 0xD6	; 214
    2288:	3f 4f       	sbci	r19, 0xFF	; 255
    228a:	8e 81       	ldd	r24, Y+6	; 0x06
    228c:	9f 81       	ldd	r25, Y+7	; 0x07
    228e:	82 0f       	add	r24, r18
    2290:	93 1f       	adc	r25, r19
    2292:	fc 01       	movw	r30, r24
    2294:	40 81       	ld	r20, Z
    2296:	9e 01       	movw	r18, r28
    2298:	2b 5d       	subi	r18, 0xDB	; 219
    229a:	3f 4f       	sbci	r19, 0xFF	; 255
    229c:	8c 85       	ldd	r24, Y+12	; 0x0c
    229e:	9d 85       	ldd	r25, Y+13	; 0x0d
    22a0:	82 0f       	add	r24, r18
    22a2:	93 1f       	adc	r25, r19
    22a4:	fc 01       	movw	r30, r24
    22a6:	40 83       	st	Z, r20
    22a8:	8c 85       	ldd	r24, Y+12	; 0x0c
    22aa:	9d 85       	ldd	r25, Y+13	; 0x0d
    22ac:	01 96       	adiw	r24, 0x01	; 1
    22ae:	9d 87       	std	Y+13, r25	; 0x0d
    22b0:	8c 87       	std	Y+12, r24	; 0x0c
    22b2:	46 c0       	rjmp	.+140    	; 0x2340 <_Z11ReceiveGAVRv+0x2d2>
							//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
							} else if (hms<2 && recString[counter] == ':') {
    22b4:	8a 85       	ldd	r24, Y+10	; 0x0a
    22b6:	9b 85       	ldd	r25, Y+11	; 0x0b
    22b8:	82 30       	cpi	r24, 0x02	; 2
    22ba:	91 05       	cpc	r25, r1
    22bc:	0c f0       	brlt	.+2      	; 0x22c0 <_Z11ReceiveGAVRv+0x252>
    22be:	40 c0       	rjmp	.+128    	; 0x2340 <_Z11ReceiveGAVRv+0x2d2>
    22c0:	9e 01       	movw	r18, r28
    22c2:	26 5d       	subi	r18, 0xD6	; 214
    22c4:	3f 4f       	sbci	r19, 0xFF	; 255
    22c6:	8e 81       	ldd	r24, Y+6	; 0x06
    22c8:	9f 81       	ldd	r25, Y+7	; 0x07
    22ca:	82 0f       	add	r24, r18
    22cc:	93 1f       	adc	r25, r19
    22ce:	fc 01       	movw	r30, r24
    22d0:	80 81       	ld	r24, Z
    22d2:	8a 33       	cpi	r24, 0x3A	; 58
    22d4:	a9 f5       	brne	.+106    	; 0x2340 <_Z11ReceiveGAVRv+0x2d2>
								tempNum[hms++] = atoi(tempStringNum);
    22d6:	ce 01       	movw	r24, r28
    22d8:	85 96       	adiw	r24, 0x25	; 37
    22da:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
    22de:	9c 01       	movw	r18, r24
    22e0:	8a 85       	ldd	r24, Y+10	; 0x0a
    22e2:	9b 85       	ldd	r25, Y+11	; 0x0b
    22e4:	88 0f       	add	r24, r24
    22e6:	99 1f       	adc	r25, r25
    22e8:	ae 01       	movw	r20, r28
    22ea:	4f 5f       	subi	r20, 0xFF	; 255
    22ec:	5f 4f       	sbci	r21, 0xFF	; 255
    22ee:	84 0f       	add	r24, r20
    22f0:	95 1f       	adc	r25, r21
    22f2:	48 96       	adiw	r24, 0x18	; 24
    22f4:	fc 01       	movw	r30, r24
    22f6:	31 83       	std	Z+1, r19	; 0x01
    22f8:	20 83       	st	Z, r18
    22fa:	8a 85       	ldd	r24, Y+10	; 0x0a
    22fc:	9b 85       	ldd	r25, Y+11	; 0x0b
    22fe:	01 96       	adiw	r24, 0x01	; 1
    2300:	9b 87       	std	Y+11, r25	; 0x0b
    2302:	8a 87       	std	Y+10, r24	; 0x0a
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    2304:	1f 86       	std	Y+15, r1	; 0x0f
    2306:	1e 86       	std	Y+14, r1	; 0x0e
    2308:	0e c0       	rjmp	.+28     	; 0x2326 <_Z11ReceiveGAVRv+0x2b8>
    230a:	9e 01       	movw	r18, r28
    230c:	2b 5d       	subi	r18, 0xDB	; 219
    230e:	3f 4f       	sbci	r19, 0xFF	; 255
    2310:	8e 85       	ldd	r24, Y+14	; 0x0e
    2312:	9f 85       	ldd	r25, Y+15	; 0x0f
    2314:	82 0f       	add	r24, r18
    2316:	93 1f       	adc	r25, r19
    2318:	fc 01       	movw	r30, r24
    231a:	10 82       	st	Z, r1
    231c:	8e 85       	ldd	r24, Y+14	; 0x0e
    231e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2320:	01 96       	adiw	r24, 0x01	; 1
    2322:	9f 87       	std	Y+15, r25	; 0x0f
    2324:	8e 87       	std	Y+14, r24	; 0x0e
    2326:	41 e0       	ldi	r20, 0x01	; 1
    2328:	2e 85       	ldd	r18, Y+14	; 0x0e
    232a:	3f 85       	ldd	r19, Y+15	; 0x0f
    232c:	8c 85       	ldd	r24, Y+12	; 0x0c
    232e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2330:	82 17       	cp	r24, r18
    2332:	93 07       	cpc	r25, r19
    2334:	0c f4       	brge	.+2      	; 0x2338 <_Z11ReceiveGAVRv+0x2ca>
    2336:	40 e0       	ldi	r20, 0x00	; 0
    2338:	44 23       	and	r20, r20
    233a:	39 f7       	brne	.-50     	; 0x230a <_Z11ReceiveGAVRv+0x29c>
								placement=0;												//reset placement
    233c:	1d 86       	std	Y+13, r1	; 0x0d
    233e:	1c 86       	std	Y+12, r1	; 0x0c
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
    2340:	8e 81       	ldd	r24, Y+6	; 0x06
    2342:	9f 81       	ldd	r25, Y+7	; 0x07
    2344:	01 96       	adiw	r24, 0x01	; 1
    2346:	9f 83       	std	Y+7, r25	; 0x07
    2348:	8e 83       	std	Y+6, r24	; 0x06
						int counter=1;
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    234a:	9e 01       	movw	r18, r28
    234c:	26 5d       	subi	r18, 0xD6	; 214
    234e:	3f 4f       	sbci	r19, 0xFF	; 255
    2350:	8e 81       	ldd	r24, Y+6	; 0x06
    2352:	9f 81       	ldd	r25, Y+7	; 0x07
    2354:	82 0f       	add	r24, r18
    2356:	93 1f       	adc	r25, r19
    2358:	fc 01       	movw	r30, r24
    235a:	80 81       	ld	r24, Z
    235c:	8f 32       	cpi	r24, 0x2F	; 47
    235e:	69 f0       	breq	.+26     	; 0x237a <_Z11ReceiveGAVRv+0x30c>
    2360:	9e 01       	movw	r18, r28
    2362:	26 5d       	subi	r18, 0xD6	; 214
    2364:	3f 4f       	sbci	r19, 0xFF	; 255
    2366:	8e 81       	ldd	r24, Y+6	; 0x06
    2368:	9f 81       	ldd	r25, Y+7	; 0x07
    236a:	82 0f       	add	r24, r18
    236c:	93 1f       	adc	r25, r19
    236e:	fc 01       	movw	r30, r24
    2370:	80 81       	ld	r24, Z
    2372:	88 23       	and	r24, r24
    2374:	11 f0       	breq	.+4      	; 0x237a <_Z11ReceiveGAVRv+0x30c>
    2376:	81 e0       	ldi	r24, 0x01	; 1
    2378:	01 c0       	rjmp	.+2      	; 0x237c <_Z11ReceiveGAVRv+0x30e>
    237a:	80 e0       	ldi	r24, 0x00	; 0
    237c:	88 23       	and	r24, r24
    237e:	09 f0       	breq	.+2      	; 0x2382 <_Z11ReceiveGAVRv+0x314>
    2380:	71 cf       	rjmp	.-286    	; 0x2264 <_Z11ReceiveGAVRv+0x1f6>
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
						}//end while
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
    2382:	9e 01       	movw	r18, r28
    2384:	26 5d       	subi	r18, 0xD6	; 214
    2386:	3f 4f       	sbci	r19, 0xFF	; 255
    2388:	8e 81       	ldd	r24, Y+6	; 0x06
    238a:	9f 81       	ldd	r25, Y+7	; 0x07
    238c:	82 0f       	add	r24, r18
    238e:	93 1f       	adc	r25, r19
    2390:	fc 01       	movw	r30, r24
    2392:	80 81       	ld	r24, Z
    2394:	8f 32       	cpi	r24, 0x2F	; 47
    2396:	b9 f4       	brne	.+46     	; 0x23c6 <_Z11ReceiveGAVRv+0x358>
							tempNum[hms] = atoi(tempStringNum);
    2398:	ce 01       	movw	r24, r28
    239a:	85 96       	adiw	r24, 0x25	; 37
    239c:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
    23a0:	9c 01       	movw	r18, r24
    23a2:	8a 85       	ldd	r24, Y+10	; 0x0a
    23a4:	9b 85       	ldd	r25, Y+11	; 0x0b
    23a6:	88 0f       	add	r24, r24
    23a8:	99 1f       	adc	r25, r25
    23aa:	ae 01       	movw	r20, r28
    23ac:	4f 5f       	subi	r20, 0xFF	; 255
    23ae:	5f 4f       	sbci	r21, 0xFF	; 255
    23b0:	84 0f       	add	r24, r20
    23b2:	95 1f       	adc	r25, r21
    23b4:	48 96       	adiw	r24, 0x18	; 24
    23b6:	fc 01       	movw	r30, r24
    23b8:	31 83       	std	Z+1, r19	; 0x01
    23ba:	20 83       	st	Z, r18
							successTime=fTrue;
    23bc:	81 e0       	ldi	r24, 0x01	; 1
    23be:	8f 8b       	std	Y+23, r24	; 0x17
							break;
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    23c0:	19 8a       	std	Y+17, r1	; 0x11
    23c2:	18 8a       	std	Y+16, r1	; 0x10
    23c4:	17 c0       	rjmp	.+46     	; 0x23f4 <_Z11ReceiveGAVRv+0x386>
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
							tempNum[hms] = atoi(tempStringNum);
							successTime=fTrue;
						} else {
							state=5;
    23c6:	85 e0       	ldi	r24, 0x05	; 5
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	9a 83       	std	Y+2, r25	; 0x02
    23cc:	89 83       	std	Y+1, r24	; 0x01
							PrintGAVR("B.");
    23ce:	82 e1       	ldi	r24, 0x12	; 18
    23d0:	91 e0       	ldi	r25, 0x01	; 1
    23d2:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
							break;
    23d6:	ae c1       	rjmp	.+860    	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    23d8:	9e 01       	movw	r18, r28
    23da:	2b 5d       	subi	r18, 0xDB	; 219
    23dc:	3f 4f       	sbci	r19, 0xFF	; 255
    23de:	88 89       	ldd	r24, Y+16	; 0x10
    23e0:	99 89       	ldd	r25, Y+17	; 0x11
    23e2:	82 0f       	add	r24, r18
    23e4:	93 1f       	adc	r25, r19
    23e6:	fc 01       	movw	r30, r24
    23e8:	10 82       	st	Z, r1
    23ea:	88 89       	ldd	r24, Y+16	; 0x10
    23ec:	99 89       	ldd	r25, Y+17	; 0x11
    23ee:	01 96       	adiw	r24, 0x01	; 1
    23f0:	99 8b       	std	Y+17, r25	; 0x11
    23f2:	88 8b       	std	Y+16, r24	; 0x10
    23f4:	41 e0       	ldi	r20, 0x01	; 1
    23f6:	28 89       	ldd	r18, Y+16	; 0x10
    23f8:	39 89       	ldd	r19, Y+17	; 0x11
    23fa:	8c 85       	ldd	r24, Y+12	; 0x0c
    23fc:	9d 85       	ldd	r25, Y+13	; 0x0d
    23fe:	82 17       	cp	r24, r18
    2400:	93 07       	cpc	r25, r19
    2402:	0c f4       	brge	.+2      	; 0x2406 <_Z11ReceiveGAVRv+0x398>
    2404:	40 e0       	ldi	r20, 0x00	; 0
    2406:	44 23       	and	r20, r20
    2408:	39 f7       	brne	.-50     	; 0x23d8 <_Z11ReceiveGAVRv+0x36a>
						placement=0;
    240a:	1d 86       	std	Y+13, r1	; 0x0d
    240c:	1c 86       	std	Y+12, r1	; 0x0c
						counter++;	//get past the '/'
    240e:	8e 81       	ldd	r24, Y+6	; 0x06
    2410:	9f 81       	ldd	r25, Y+7	; 0x07
    2412:	01 96       	adiw	r24, 0x01	; 1
    2414:	9f 83       	std	Y+7, r25	; 0x07
    2416:	8e 83       	std	Y+6, r24	; 0x06
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    2418:	73 c0       	rjmp	.+230    	; 0x2500 <_Z11ReceiveGAVRv+0x492>
							//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
							if  (recString[counter] != ',' && dmy < 3){
    241a:	9e 01       	movw	r18, r28
    241c:	26 5d       	subi	r18, 0xD6	; 214
    241e:	3f 4f       	sbci	r19, 0xFF	; 255
    2420:	8e 81       	ldd	r24, Y+6	; 0x06
    2422:	9f 81       	ldd	r25, Y+7	; 0x07
    2424:	82 0f       	add	r24, r18
    2426:	93 1f       	adc	r25, r19
    2428:	fc 01       	movw	r30, r24
    242a:	80 81       	ld	r24, Z
    242c:	8c 32       	cpi	r24, 0x2C	; 44
    242e:	e9 f0       	breq	.+58     	; 0x246a <_Z11ReceiveGAVRv+0x3fc>
    2430:	88 85       	ldd	r24, Y+8	; 0x08
    2432:	99 85       	ldd	r25, Y+9	; 0x09
    2434:	83 30       	cpi	r24, 0x03	; 3
    2436:	91 05       	cpc	r25, r1
    2438:	c4 f4       	brge	.+48     	; 0x246a <_Z11ReceiveGAVRv+0x3fc>
								tempStringNum[placement++]=recString[counter];
    243a:	9e 01       	movw	r18, r28
    243c:	26 5d       	subi	r18, 0xD6	; 214
    243e:	3f 4f       	sbci	r19, 0xFF	; 255
    2440:	8e 81       	ldd	r24, Y+6	; 0x06
    2442:	9f 81       	ldd	r25, Y+7	; 0x07
    2444:	82 0f       	add	r24, r18
    2446:	93 1f       	adc	r25, r19
    2448:	fc 01       	movw	r30, r24
    244a:	40 81       	ld	r20, Z
    244c:	9e 01       	movw	r18, r28
    244e:	2b 5d       	subi	r18, 0xDB	; 219
    2450:	3f 4f       	sbci	r19, 0xFF	; 255
    2452:	8c 85       	ldd	r24, Y+12	; 0x0c
    2454:	9d 85       	ldd	r25, Y+13	; 0x0d
    2456:	82 0f       	add	r24, r18
    2458:	93 1f       	adc	r25, r19
    245a:	fc 01       	movw	r30, r24
    245c:	40 83       	st	Z, r20
    245e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2460:	9d 85       	ldd	r25, Y+13	; 0x0d
    2462:	01 96       	adiw	r24, 0x01	; 1
    2464:	9d 87       	std	Y+13, r25	; 0x0d
    2466:	8c 87       	std	Y+12, r24	; 0x0c
    2468:	46 c0       	rjmp	.+140    	; 0x24f6 <_Z11ReceiveGAVRv+0x488>
							//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
							} else if (dmy<2 && recString[counter]==','){
    246a:	88 85       	ldd	r24, Y+8	; 0x08
    246c:	99 85       	ldd	r25, Y+9	; 0x09
    246e:	82 30       	cpi	r24, 0x02	; 2
    2470:	91 05       	cpc	r25, r1
    2472:	0c f0       	brlt	.+2      	; 0x2476 <_Z11ReceiveGAVRv+0x408>
    2474:	40 c0       	rjmp	.+128    	; 0x24f6 <_Z11ReceiveGAVRv+0x488>
    2476:	9e 01       	movw	r18, r28
    2478:	26 5d       	subi	r18, 0xD6	; 214
    247a:	3f 4f       	sbci	r19, 0xFF	; 255
    247c:	8e 81       	ldd	r24, Y+6	; 0x06
    247e:	9f 81       	ldd	r25, Y+7	; 0x07
    2480:	82 0f       	add	r24, r18
    2482:	93 1f       	adc	r25, r19
    2484:	fc 01       	movw	r30, r24
    2486:	80 81       	ld	r24, Z
    2488:	8c 32       	cpi	r24, 0x2C	; 44
    248a:	a9 f5       	brne	.+106    	; 0x24f6 <_Z11ReceiveGAVRv+0x488>
								tempNum1[dmy++] = atoi(tempStringNum);
    248c:	ce 01       	movw	r24, r28
    248e:	85 96       	adiw	r24, 0x25	; 37
    2490:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
    2494:	9c 01       	movw	r18, r24
    2496:	88 85       	ldd	r24, Y+8	; 0x08
    2498:	99 85       	ldd	r25, Y+9	; 0x09
    249a:	88 0f       	add	r24, r24
    249c:	99 1f       	adc	r25, r25
    249e:	ae 01       	movw	r20, r28
    24a0:	4f 5f       	subi	r20, 0xFF	; 255
    24a2:	5f 4f       	sbci	r21, 0xFF	; 255
    24a4:	84 0f       	add	r24, r20
    24a6:	95 1f       	adc	r25, r21
    24a8:	4e 96       	adiw	r24, 0x1e	; 30
    24aa:	fc 01       	movw	r30, r24
    24ac:	31 83       	std	Z+1, r19	; 0x01
    24ae:	20 83       	st	Z, r18
    24b0:	88 85       	ldd	r24, Y+8	; 0x08
    24b2:	99 85       	ldd	r25, Y+9	; 0x09
    24b4:	01 96       	adiw	r24, 0x01	; 1
    24b6:	99 87       	std	Y+9, r25	; 0x09
    24b8:	88 87       	std	Y+8, r24	; 0x08
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    24ba:	1b 8a       	std	Y+19, r1	; 0x13
    24bc:	1a 8a       	std	Y+18, r1	; 0x12
    24be:	0e c0       	rjmp	.+28     	; 0x24dc <_Z11ReceiveGAVRv+0x46e>
    24c0:	9e 01       	movw	r18, r28
    24c2:	2b 5d       	subi	r18, 0xDB	; 219
    24c4:	3f 4f       	sbci	r19, 0xFF	; 255
    24c6:	8a 89       	ldd	r24, Y+18	; 0x12
    24c8:	9b 89       	ldd	r25, Y+19	; 0x13
    24ca:	82 0f       	add	r24, r18
    24cc:	93 1f       	adc	r25, r19
    24ce:	fc 01       	movw	r30, r24
    24d0:	10 82       	st	Z, r1
    24d2:	8a 89       	ldd	r24, Y+18	; 0x12
    24d4:	9b 89       	ldd	r25, Y+19	; 0x13
    24d6:	01 96       	adiw	r24, 0x01	; 1
    24d8:	9b 8b       	std	Y+19, r25	; 0x13
    24da:	8a 8b       	std	Y+18, r24	; 0x12
    24dc:	41 e0       	ldi	r20, 0x01	; 1
    24de:	2a 89       	ldd	r18, Y+18	; 0x12
    24e0:	3b 89       	ldd	r19, Y+19	; 0x13
    24e2:	8c 85       	ldd	r24, Y+12	; 0x0c
    24e4:	9d 85       	ldd	r25, Y+13	; 0x0d
    24e6:	82 17       	cp	r24, r18
    24e8:	93 07       	cpc	r25, r19
    24ea:	0c f4       	brge	.+2      	; 0x24ee <_Z11ReceiveGAVRv+0x480>
    24ec:	40 e0       	ldi	r20, 0x00	; 0
    24ee:	44 23       	and	r20, r20
    24f0:	39 f7       	brne	.-50     	; 0x24c0 <_Z11ReceiveGAVRv+0x452>
								placement=0;
    24f2:	1d 86       	std	Y+13, r1	; 0x0d
    24f4:	1c 86       	std	Y+12, r1	; 0x0c
							} else;
							counter++;							
    24f6:	8e 81       	ldd	r24, Y+6	; 0x06
    24f8:	9f 81       	ldd	r25, Y+7	; 0x07
    24fa:	01 96       	adiw	r24, 0x01	; 1
    24fc:	9f 83       	std	Y+7, r25	; 0x07
    24fe:	8e 83       	std	Y+6, r24	; 0x06
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
						placement=0;
						counter++;	//get past the '/'
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    2500:	9e 01       	movw	r18, r28
    2502:	26 5d       	subi	r18, 0xD6	; 214
    2504:	3f 4f       	sbci	r19, 0xFF	; 255
    2506:	8e 81       	ldd	r24, Y+6	; 0x06
    2508:	9f 81       	ldd	r25, Y+7	; 0x07
    250a:	82 0f       	add	r24, r18
    250c:	93 1f       	adc	r25, r19
    250e:	fc 01       	movw	r30, r24
    2510:	80 81       	ld	r24, Z
    2512:	8e 32       	cpi	r24, 0x2E	; 46
    2514:	a1 f0       	breq	.+40     	; 0x253e <_Z11ReceiveGAVRv+0x4d0>
    2516:	9e 01       	movw	r18, r28
    2518:	26 5d       	subi	r18, 0xD6	; 214
    251a:	3f 4f       	sbci	r19, 0xFF	; 255
    251c:	8e 81       	ldd	r24, Y+6	; 0x06
    251e:	9f 81       	ldd	r25, Y+7	; 0x07
    2520:	82 0f       	add	r24, r18
    2522:	93 1f       	adc	r25, r19
    2524:	fc 01       	movw	r30, r24
    2526:	80 81       	ld	r24, Z
    2528:	88 23       	and	r24, r24
    252a:	49 f0       	breq	.+18     	; 0x253e <_Z11ReceiveGAVRv+0x4d0>
    252c:	2e 81       	ldd	r18, Y+6	; 0x06
    252e:	3f 81       	ldd	r19, Y+7	; 0x07
    2530:	8b 81       	ldd	r24, Y+3	; 0x03
    2532:	9c 81       	ldd	r25, Y+4	; 0x04
    2534:	28 17       	cp	r18, r24
    2536:	39 07       	cpc	r19, r25
    2538:	11 f0       	breq	.+4      	; 0x253e <_Z11ReceiveGAVRv+0x4d0>
    253a:	81 e0       	ldi	r24, 0x01	; 1
    253c:	01 c0       	rjmp	.+2      	; 0x2540 <_Z11ReceiveGAVRv+0x4d2>
    253e:	80 e0       	ldi	r24, 0x00	; 0
    2540:	88 23       	and	r24, r24
    2542:	09 f0       	breq	.+2      	; 0x2546 <_Z11ReceiveGAVRv+0x4d8>
    2544:	6a cf       	rjmp	.-300    	; 0x241a <_Z11ReceiveGAVRv+0x3ac>
								placement=0;
							} else;
							counter++;							
						}//end while
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
    2546:	9e 01       	movw	r18, r28
    2548:	26 5d       	subi	r18, 0xD6	; 214
    254a:	3f 4f       	sbci	r19, 0xFF	; 255
    254c:	8e 81       	ldd	r24, Y+6	; 0x06
    254e:	9f 81       	ldd	r25, Y+7	; 0x07
    2550:	82 0f       	add	r24, r18
    2552:	93 1f       	adc	r25, r19
    2554:	fc 01       	movw	r30, r24
    2556:	80 81       	ld	r24, Z
    2558:	8e 32       	cpi	r24, 0x2E	; 46
    255a:	c1 f4       	brne	.+48     	; 0x258c <_Z11ReceiveGAVRv+0x51e>
							tempNum1[dmy] = atoi(tempStringNum);
    255c:	ce 01       	movw	r24, r28
    255e:	85 96       	adiw	r24, 0x25	; 37
    2560:	0e 94 0c 1d 	call	0x3a18	; 0x3a18 <atoi>
    2564:	9c 01       	movw	r18, r24
    2566:	88 85       	ldd	r24, Y+8	; 0x08
    2568:	99 85       	ldd	r25, Y+9	; 0x09
    256a:	88 0f       	add	r24, r24
    256c:	99 1f       	adc	r25, r25
    256e:	ae 01       	movw	r20, r28
    2570:	4f 5f       	subi	r20, 0xFF	; 255
    2572:	5f 4f       	sbci	r21, 0xFF	; 255
    2574:	84 0f       	add	r24, r20
    2576:	95 1f       	adc	r25, r21
    2578:	4e 96       	adiw	r24, 0x1e	; 30
    257a:	fc 01       	movw	r30, r24
    257c:	31 83       	std	Z+1, r19	; 0x01
    257e:	20 83       	st	Z, r18
							successDate=fTrue;
    2580:	81 e0       	ldi	r24, 0x01	; 1
    2582:	88 8f       	std	Y+24, r24	; 0x18
							state=5;
							break;
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (successDate && successTime){
    2584:	88 8d       	ldd	r24, Y+24	; 0x18
    2586:	88 23       	and	r24, r24
    2588:	51 f4       	brne	.+20     	; 0x259e <_Z11ReceiveGAVRv+0x530>
    258a:	35 c0       	rjmp	.+106    	; 0x25f6 <_Z11ReceiveGAVRv+0x588>
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
							tempNum1[dmy] = atoi(tempStringNum);
							successDate=fTrue;
						} else {//something in the string was wrong, ACKBAD and then exit
							PrintGAVR("B.");
    258c:	82 e1       	ldi	r24, 0x12	; 18
    258e:	91 e0       	ldi	r25, 0x01	; 1
    2590:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
							state=5;
    2594:	85 e0       	ldi	r24, 0x05	; 5
    2596:	90 e0       	ldi	r25, 0x00	; 0
    2598:	9a 83       	std	Y+2, r25	; 0x02
    259a:	89 83       	std	Y+1, r24	; 0x01
							break;
    259c:	cb c0       	rjmp	.+406    	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (successDate && successTime){
    259e:	8f 89       	ldd	r24, Y+23	; 0x17
    25a0:	88 23       	and	r24, r24
    25a2:	49 f1       	breq	.+82     	; 0x25f6 <_Z11ReceiveGAVRv+0x588>
							currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    25a4:	69 8d       	ldd	r22, Y+25	; 0x19
    25a6:	7a 8d       	ldd	r23, Y+26	; 0x1a
    25a8:	4b 8d       	ldd	r20, Y+27	; 0x1b
    25aa:	5c 8d       	ldd	r21, Y+28	; 0x1c
    25ac:	2d 8d       	ldd	r18, Y+29	; 0x1d
    25ae:	3e 8d       	ldd	r19, Y+30	; 0x1e
    25b0:	84 ed       	ldi	r24, 0xD4	; 212
    25b2:	91 e0       	ldi	r25, 0x01	; 1
    25b4:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
							currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    25b8:	6f 8d       	ldd	r22, Y+31	; 0x1f
    25ba:	78 a1       	lds	r23, 0x48
    25bc:	49 a1       	lds	r20, 0x49
    25be:	5a a1       	lds	r21, 0x4a
    25c0:	2b a1       	lds	r18, 0x4b
    25c2:	3c a1       	lds	r19, 0x4c
    25c4:	84 ed       	ldi	r24, 0xD4	; 212
    25c6:	91 e0       	ldi	r25, 0x01	; 1
    25c8:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
							saveDateTime_eeprom(fTrue,fTrue);
    25cc:	81 e0       	ldi	r24, 0x01	; 1
    25ce:	61 e0       	ldi	r22, 0x01	; 1
    25d0:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
							flagUserClock=fFalse;
    25d4:	10 92 05 02 	sts	0x0205, r1
							
							PrintBone("Set my time.");							
    25d8:	84 e8       	ldi	r24, 0x84	; 132
    25da:	91 e0       	ldi	r25, 0x01	; 1
    25dc:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
							//send ACK
							recString[0]='A';
    25e0:	81 e4       	ldi	r24, 0x41	; 65
    25e2:	8a a7       	lds	r24, 0x7a
							PrintGAVR(recString);
    25e4:	ce 01       	movw	r24, r28
    25e6:	8a 96       	adiw	r24, 0x2a	; 42
    25e8:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
							state=7;
    25ec:	87 e0       	ldi	r24, 0x07	; 7
    25ee:	90 e0       	ldi	r25, 0x00	; 0
    25f0:	9a 83       	std	Y+2, r25	; 0x02
    25f2:	89 83       	std	Y+1, r24	; 0x01
    25f4:	0b c0       	rjmp	.+22     	; 0x260c <_Z11ReceiveGAVRv+0x59e>
						} else {
							//Here is a choice: Do we watn  to user to indicate the time is wrong, or just make them set it? Doesn't really matter.
							flagUserClock=fTrue;
    25f6:	81 e0       	ldi	r24, 0x01	; 1
    25f8:	80 93 05 02 	sts	0x0205, r24
							PrintBone("Bad time.");
    25fc:	81 e9       	ldi	r24, 0x91	; 145
    25fe:	91 e0       	ldi	r25, 0x01	; 1
    2600:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
							state=5;
    2604:	85 e0       	ldi	r24, 0x05	; 5
    2606:	90 e0       	ldi	r25, 0x00	; 0
    2608:	9a 83       	std	Y+2, r25	; 0x02
    260a:	89 83       	std	Y+1, r24	; 0x01
						}			
						
						//If we wanted date and got it correctly, or wanted time and got it correctly, go to state 7 to ack with the appropriate response
						if (flagUserClock && successDate && successTime){
    260c:	80 91 05 02 	lds	r24, 0x0205
    2610:	88 23       	and	r24, r24
    2612:	79 f0       	breq	.+30     	; 0x2632 <_Z11ReceiveGAVRv+0x5c4>
    2614:	88 8d       	ldd	r24, Y+24	; 0x18
    2616:	88 23       	and	r24, r24
    2618:	61 f0       	breq	.+24     	; 0x2632 <_Z11ReceiveGAVRv+0x5c4>
    261a:	8f 89       	ldd	r24, Y+23	; 0x17
    261c:	88 23       	and	r24, r24
    261e:	49 f0       	breq	.+18     	; 0x2632 <_Z11ReceiveGAVRv+0x5c4>
							flagUserClock=fFalse;
    2620:	10 92 05 02 	sts	0x0205, r1
							flagWaitingForReceiveGAVR=fFalse;
    2624:	10 92 00 02 	sts	0x0200, r1
							state=7;					//Respond with correct string ACK
    2628:	87 e0       	ldi	r24, 0x07	; 7
    262a:	90 e0       	ldi	r25, 0x00	; 0
    262c:	9a 83       	std	Y+2, r25	; 0x02
    262e:	89 83       	std	Y+1, r24	; 0x01
						PrintGAVR("NO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    2630:	81 c0       	rjmp	.+258    	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
						if (flagUserClock && successDate && successTime){
							flagUserClock=fFalse;
							flagWaitingForReceiveGAVR=fFalse;
							state=7;					//Respond with correct string ACK
						} else {
							PrintGAVR("B.");
    2632:	82 e1       	ldi	r24, 0x12	; 18
    2634:	91 e0       	ldi	r25, 0x01	; 1
    2636:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
							state=5;
    263a:	85 e0       	ldi	r24, 0x05	; 5
    263c:	90 e0       	ldi	r25, 0x00	; 0
    263e:	9a 83       	std	Y+2, r25	; 0x02
    2640:	89 83       	std	Y+1, r24	; 0x01
						PrintGAVR("NO.");
						state=5;
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    2642:	78 c0       	rjmp	.+240    	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
						} else {
							PrintGAVR("B.");
							state=5;
						}																										
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("NO.");
    2644:	8b e9       	ldi	r24, 0x9B	; 155
    2646:	91 e0       	ldi	r25, 0x01	; 1
    2648:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
						state=5;
    264c:	85 e0       	ldi	r24, 0x05	; 5
    264e:	90 e0       	ldi	r25, 0x00	; 0
    2650:	9a 83       	std	Y+2, r25	; 0x02
    2652:	89 83       	std	Y+1, r24	; 0x01
					}					
					// end if-else (flagUserClock)					
					//Exit
					break;
    2654:	6f c0       	rjmp	.+222    	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
					}//end case 3				
				case 4:{
					Wait_ms(100);
    2656:	84 e6       	ldi	r24, 0x64	; 100
    2658:	90 e0       	ldi	r25, 0x00	; 0
    265a:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					//Successful SYNNEED case.
					if (!flagUserClock){	//If we don't need the date or time, update with what we have.
    265e:	80 91 05 02 	lds	r24, 0x0205
    2662:	88 23       	and	r24, r24
    2664:	61 f4       	brne	.+24     	; 0x267e <_Z11ReceiveGAVRv+0x610>
						flagUpdateGAVRClock=fTrue;
    2666:	81 e0       	ldi	r24, 0x01	; 1
    2668:	80 93 03 02 	sts	0x0203, r24
						PrintGAVR("N.");				//respond with correct ack
    266c:	82 e7       	ldi	r24, 0x72	; 114
    266e:	91 e0       	ldi	r25, 0x01	; 1
    2670:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
						PrintBone("Need.");
    2674:	8f e9       	ldi	r24, 0x9F	; 159
    2676:	91 e0       	ldi	r25, 0x01	; 1
    2678:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    267c:	08 c0       	rjmp	.+16     	; 0x268e <_Z11ReceiveGAVRv+0x620>
					} else {
						PrintBone("NO.");
    267e:	8b e9       	ldi	r24, 0x9B	; 155
    2680:	91 e0       	ldi	r25, 0x01	; 1
    2682:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
						PrintGAVR("NO.");	//say we can't give you anything, ask the user.
    2686:	8b e9       	ldi	r24, 0x9B	; 155
    2688:	91 e0       	ldi	r25, 0x01	; 1
    268a:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
						//Should be expecting something from the GAVR with user date and time, this reminds the GAVR.
					} //end if-else
					state=5;
    268e:	85 e0       	ldi	r24, 0x05	; 5
    2690:	90 e0       	ldi	r25, 0x00	; 0
    2692:	9a 83       	std	Y+2, r25	; 0x02
    2694:	89 83       	std	Y+1, r24	; 0x01
					break;					
    2696:	4e c0       	rjmp	.+156    	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
				}//end case 4
				case 5:{
					//Exit case
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    2698:	1d 8a       	std	Y+21, r1	; 0x15
    269a:	1c 8a       	std	Y+20, r1	; 0x14
    269c:	0e c0       	rjmp	.+28     	; 0x26ba <_Z11ReceiveGAVRv+0x64c>
    269e:	9e 01       	movw	r18, r28
    26a0:	26 5d       	subi	r18, 0xD6	; 214
    26a2:	3f 4f       	sbci	r19, 0xFF	; 255
    26a4:	8c 89       	ldd	r24, Y+20	; 0x14
    26a6:	9d 89       	ldd	r25, Y+21	; 0x15
    26a8:	82 0f       	add	r24, r18
    26aa:	93 1f       	adc	r25, r19
    26ac:	fc 01       	movw	r30, r24
    26ae:	10 82       	st	Z, r1
    26b0:	8c 89       	ldd	r24, Y+20	; 0x14
    26b2:	9d 89       	ldd	r25, Y+21	; 0x15
    26b4:	01 96       	adiw	r24, 0x01	; 1
    26b6:	9d 8b       	std	Y+21, r25	; 0x15
    26b8:	8c 8b       	std	Y+20, r24	; 0x14
    26ba:	2c 89       	ldd	r18, Y+20	; 0x14
    26bc:	3d 89       	ldd	r19, Y+21	; 0x15
    26be:	41 e0       	ldi	r20, 0x01	; 1
    26c0:	8b 81       	ldd	r24, Y+3	; 0x03
    26c2:	9c 81       	ldd	r25, Y+4	; 0x04
    26c4:	28 17       	cp	r18, r24
    26c6:	39 07       	cpc	r19, r25
    26c8:	08 f0       	brcs	.+2      	; 0x26cc <_Z11ReceiveGAVRv+0x65e>
    26ca:	40 e0       	ldi	r20, 0x00	; 0
    26cc:	44 23       	and	r20, r20
    26ce:	39 f7       	brne	.-50     	; 0x269e <_Z11ReceiveGAVRv+0x630>
					flagReceivingGAVR=fFalse;
    26d0:	10 92 ff 01 	sts	0x01FF, r1
					flagWaitingForReceiveGAVR=fFalse;
    26d4:	10 92 00 02 	sts	0x0200, r1
					state=0;		//just in case
    26d8:	1a 82       	std	Y+2, r1	; 0x02
    26da:	19 82       	std	Y+1, r1	; 0x01
					break;
    26dc:	2b c0       	rjmp	.+86     	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
				}//end case 5
				case 6:{
					//Error in ACK case
					Wait_ms(150);
    26de:	86 e9       	ldi	r24, 0x96	; 150
    26e0:	90 e0       	ldi	r25, 0x00	; 0
    26e2:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					PrintGAVR("E.");
    26e6:	85 e7       	ldi	r24, 0x75	; 117
    26e8:	91 e0       	ldi	r25, 0x01	; 1
    26ea:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
					PrintBone("ErrorR.");
    26ee:	85 ea       	ldi	r24, 0xA5	; 165
    26f0:	91 e0       	ldi	r25, 0x01	; 1
    26f2:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					state=5;
    26f6:	85 e0       	ldi	r24, 0x05	; 5
    26f8:	90 e0       	ldi	r25, 0x00	; 0
    26fa:	9a 83       	std	Y+2, r25	; 0x02
    26fc:	89 83       	std	Y+1, r24	; 0x01
					break;
    26fe:	1a c0       	rjmp	.+52     	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
				}//end case 6
				case 7:{
					Wait_ms(150);
    2700:	86 e9       	ldi	r24, 0x96	; 150
    2702:	90 e0       	ldi	r25, 0x00	; 0
    2704:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					//Successful grab of date/time case
					recString[0]='A';
    2708:	81 e4       	ldi	r24, 0x41	; 65
    270a:	8a a7       	lds	r24, 0x7a
					PrintGAVR(recString);
    270c:	ce 01       	movw	r24, r28
    270e:	8a 96       	adiw	r24, 0x2a	; 42
    2710:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
					state=5;
    2714:	85 e0       	ldi	r24, 0x05	; 5
    2716:	90 e0       	ldi	r25, 0x00	; 0
    2718:	9a 83       	std	Y+2, r25	; 0x02
    271a:	89 83       	std	Y+1, r24	; 0x01
					PrintBone("Success.");
    271c:	8e e4       	ldi	r24, 0x4E	; 78
    271e:	91 e0       	ldi	r25, 0x01	; 1
    2720:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
					break;		
    2724:	07 c0       	rjmp	.+14     	; 0x2734 <_Z11ReceiveGAVRv+0x6c6>
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
    2726:	1a 82       	std	Y+2, r1	; 0x02
    2728:	19 82       	std	Y+1, r1	; 0x01
    272a:	1c 82       	std	Y+4, r1	; 0x04
    272c:	1b 82       	std	Y+3, r1	; 0x03
    272e:	10 92 ff 01 	sts	0x01FF, r1
    2732:	00 00       	nop
	char recChar, recString[40];
	unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	//While Loop
	while (flagReceivingGAVR){
    2734:	90 91 ff 01 	lds	r25, 0x01FF
    2738:	81 e0       	ldi	r24, 0x01	; 1
    273a:	99 23       	and	r25, r25
    273c:	09 f4       	brne	.+2      	; 0x2740 <_Z11ReceiveGAVRv+0x6d2>
    273e:	80 e0       	ldi	r24, 0x00	; 0
    2740:	88 23       	and	r24, r24
    2742:	09 f0       	breq	.+2      	; 0x2746 <_Z11ReceiveGAVRv+0x6d8>
    2744:	a6 cc       	rjmp	.-1716   	; 0x2092 <_Z11ReceiveGAVRv+0x24>
					break;		
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
			}//end switch	
		}//end while flagReceivingGAVR	
}
    2746:	cf 5a       	subi	r28, 0xAF	; 175
    2748:	df 4f       	sbci	r29, 0xFF	; 255
    274a:	0f b6       	in	r0, 0x3f	; 63
    274c:	f8 94       	cli
    274e:	de bf       	out	0x3e, r29	; 62
    2750:	0f be       	out	0x3f, r0	; 63
    2752:	cd bf       	out	0x3d, r28	; 61
    2754:	df 91       	pop	r29
    2756:	cf 91       	pop	r28
    2758:	08 95       	ret

0000275a <_Z13printTimeDatehhh>:
/*************************************************************************************************************/
//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    275a:	cf 93       	push	r28
    275c:	df 93       	push	r29
    275e:	cd b7       	in	r28, 0x3d	; 61
    2760:	de b7       	in	r29, 0x3e	; 62
    2762:	eb 97       	sbiw	r28, 0x3b	; 59
    2764:	0f b6       	in	r0, 0x3f	; 63
    2766:	f8 94       	cli
    2768:	de bf       	out	0x3e, r29	; 62
    276a:	0f be       	out	0x3f, r0	; 63
    276c:	cd bf       	out	0x3d, r28	; 61
    276e:	89 af       	sts	0x79, r24
    2770:	6a af       	sts	0x7a, r22
    2772:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    2774:	89 ad       	sts	0x69, r24
    2776:	88 23       	and	r24, r24
    2778:	49 f1       	breq	.+82     	; 0x27cc <_Z13printTimeDatehhh+0x72>
		if (pTime){
    277a:	8a ad       	sts	0x6a, r24
    277c:	88 23       	and	r24, r24
    277e:	89 f0       	breq	.+34     	; 0x27a2 <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    2780:	84 ed       	ldi	r24, 0xD4	; 212
    2782:	91 e0       	ldi	r25, 0x01	; 1
    2784:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    2788:	9c 01       	movw	r18, r24
    278a:	ce 01       	movw	r24, r28
    278c:	01 96       	adiw	r24, 0x01	; 1
    278e:	b9 01       	movw	r22, r18
    2790:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <strcpy>
			PrintBone(tempTime);
    2794:	ce 01       	movw	r24, r28
    2796:	01 96       	adiw	r24, 0x01	; 1
    2798:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
			PutUartChBone('/');
    279c:	8f e2       	ldi	r24, 0x2F	; 47
    279e:	0e 94 32 09 	call	0x1264	; 0x1264 <_Z13PutUartChBonec>
		}
		if (pDate){
    27a2:	8b ad       	sts	0x6b, r24
    27a4:	88 23       	and	r24, r24
    27a6:	d1 f1       	breq	.+116    	; 0x281c <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    27a8:	84 ed       	ldi	r24, 0xD4	; 212
    27aa:	91 e0       	ldi	r25, 0x01	; 1
    27ac:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    27b0:	9c 01       	movw	r18, r24
    27b2:	ce 01       	movw	r24, r28
    27b4:	0c 96       	adiw	r24, 0x0c	; 12
    27b6:	b9 01       	movw	r22, r18
    27b8:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <strcpy>
			PrintBone(tempDate);
    27bc:	ce 01       	movw	r24, r28
    27be:	0c 96       	adiw	r24, 0x0c	; 12
    27c0:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
			PutUartChGAVR('.');
    27c4:	8e e2       	ldi	r24, 0x2E	; 46
    27c6:	0e 94 7d 09 	call	0x12fa	; 0x12fa <_Z13PutUartChGAVRc>
    27ca:	28 c0       	rjmp	.+80     	; 0x281c <_Z13printTimeDatehhh+0xc2>
		}
	} else { //Printing to GAVR
		if (pTime){
    27cc:	8a ad       	sts	0x6a, r24
    27ce:	88 23       	and	r24, r24
    27d0:	89 f0       	breq	.+34     	; 0x27f4 <_Z13printTimeDatehhh+0x9a>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    27d2:	84 ed       	ldi	r24, 0xD4	; 212
    27d4:	91 e0       	ldi	r25, 0x01	; 1
    27d6:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    27da:	9c 01       	movw	r18, r24
    27dc:	ce 01       	movw	r24, r28
    27de:	4d 96       	adiw	r24, 0x1d	; 29
    27e0:	b9 01       	movw	r22, r18
    27e2:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <strcpy>
			PrintGAVR(tempTime);
    27e6:	ce 01       	movw	r24, r28
    27e8:	4d 96       	adiw	r24, 0x1d	; 29
    27ea:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    27ee:	8f e2       	ldi	r24, 0x2F	; 47
    27f0:	0e 94 7d 09 	call	0x12fa	; 0x12fa <_Z13PutUartChGAVRc>
		}
		if (pDate){
    27f4:	8b ad       	sts	0x6b, r24
    27f6:	88 23       	and	r24, r24
    27f8:	89 f0       	breq	.+34     	; 0x281c <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    27fa:	84 ed       	ldi	r24, 0xD4	; 212
    27fc:	91 e0       	ldi	r25, 0x01	; 1
    27fe:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    2802:	9c 01       	movw	r18, r24
    2804:	ce 01       	movw	r24, r28
    2806:	88 96       	adiw	r24, 0x28	; 40
    2808:	b9 01       	movw	r22, r18
    280a:	0e 94 3e 1d 	call	0x3a7c	; 0x3a7c <strcpy>
			PrintGAVR(tempDate);
    280e:	ce 01       	movw	r24, r28
    2810:	88 96       	adiw	r24, 0x28	; 40
    2812:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
			PutUartChGAVR('.');
    2816:	8e e2       	ldi	r24, 0x2E	; 46
    2818:	0e 94 7d 09 	call	0x12fa	; 0x12fa <_Z13PutUartChGAVRc>
		}
	}
}
    281c:	eb 96       	adiw	r28, 0x3b	; 59
    281e:	0f b6       	in	r0, 0x3f	; 63
    2820:	f8 94       	cli
    2822:	de bf       	out	0x3e, r29	; 62
    2824:	0f be       	out	0x3f, r0	; 63
    2826:	cd bf       	out	0x3d, r28	; 61
    2828:	df 91       	pop	r29
    282a:	cf 91       	pop	r28
    282c:	08 95       	ret

0000282e <__vector_6>:
/****************************************************************************************************************/


/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
//PCINT_17: Getting information from the GAVR
ISR(PCINT2_vect){
    282e:	1f 92       	push	r1
    2830:	0f 92       	push	r0
    2832:	0f b6       	in	r0, 0x3f	; 63
    2834:	0f 92       	push	r0
    2836:	11 24       	eor	r1, r1
    2838:	2f 93       	push	r18
    283a:	3f 93       	push	r19
    283c:	4f 93       	push	r20
    283e:	5f 93       	push	r21
    2840:	6f 93       	push	r22
    2842:	7f 93       	push	r23
    2844:	8f 93       	push	r24
    2846:	9f 93       	push	r25
    2848:	af 93       	push	r26
    284a:	bf 93       	push	r27
    284c:	ef 93       	push	r30
    284e:	ff 93       	push	r31
    2850:	cf 93       	push	r28
    2852:	df 93       	push	r29
    2854:	0f 92       	push	r0
    2856:	cd b7       	in	r28, 0x3d	; 61
    2858:	de b7       	in	r29, 0x3e	; 62
	cli();
    285a:	f8 94       	cli
	if (PINC & (1 << PCINT17)){
    285c:	86 e2       	ldi	r24, 0x26	; 38
    285e:	90 e0       	ldi	r25, 0x00	; 0
    2860:	fc 01       	movw	r30, r24
    2862:	80 81       	ld	r24, Z
    2864:	88 2f       	mov	r24, r24
    2866:	90 e0       	ldi	r25, 0x00	; 0
    2868:	82 70       	andi	r24, 0x02	; 2
    286a:	90 70       	andi	r25, 0x00	; 0
    286c:	21 e0       	ldi	r18, 0x01	; 1
    286e:	00 97       	sbiw	r24, 0x00	; 0
    2870:	09 f4       	brne	.+2      	; 0x2874 <__vector_6+0x46>
    2872:	20 e0       	ldi	r18, 0x00	; 0
    2874:	22 23       	and	r18, r18
    2876:	11 f1       	breq	.+68     	; 0x28bc <__vector_6+0x8e>
		__killCommINT();
    2878:	8d e3       	ldi	r24, 0x3D	; 61
    287a:	90 e0       	ldi	r25, 0x00	; 0
    287c:	fc 01       	movw	r30, r24
    287e:	10 82       	st	Z, r1
    2880:	8d e6       	ldi	r24, 0x6D	; 109
    2882:	90 e0       	ldi	r25, 0x00	; 0
    2884:	fc 01       	movw	r30, r24
    2886:	10 82       	st	Z, r1
		//Do work, correct interrupt
		UCSR1B |= (1 << RXCIE1);
    2888:	89 ec       	ldi	r24, 0xC9	; 201
    288a:	90 e0       	ldi	r25, 0x00	; 0
    288c:	29 ec       	ldi	r18, 0xC9	; 201
    288e:	30 e0       	ldi	r19, 0x00	; 0
    2890:	f9 01       	movw	r30, r18
    2892:	20 81       	ld	r18, Z
    2894:	20 68       	ori	r18, 0x80	; 128
    2896:	fc 01       	movw	r30, r24
    2898:	20 83       	st	Z, r18
		sei();
    289a:	78 94       	sei
		flagGoToSleep=fFalse;
    289c:	10 92 fc 01 	sts	0x01FC, r1
		flagNormalMode=fFalse;
    28a0:	10 92 fe 01 	sts	0x01FE, r1
		flagWaitingForSYNGAVR=fTrue;
    28a4:	81 e0       	ldi	r24, 0x01	; 1
    28a6:	80 93 01 02 	sts	0x0201, r24
		//Acknowledge
		char dummy=UDR1;
    28aa:	8e ec       	ldi	r24, 0xCE	; 206
    28ac:	90 e0       	ldi	r25, 0x00	; 0
    28ae:	fc 01       	movw	r30, r24
    28b0:	80 81       	ld	r24, Z
    28b2:	89 83       	std	Y+1, r24	; 0x01
		PrintGAVR("A.");
    28b4:	8c e0       	ldi	r24, 0x0C	; 12
    28b6:	91 e0       	ldi	r25, 0x01	; 1
    28b8:	0e 94 9b 09 	call	0x1336	; 0x1336 <_Z9PrintGAVRPc>
	}
	sei();
    28bc:	78 94       	sei
}	
    28be:	0f 90       	pop	r0
    28c0:	df 91       	pop	r29
    28c2:	cf 91       	pop	r28
    28c4:	ff 91       	pop	r31
    28c6:	ef 91       	pop	r30
    28c8:	bf 91       	pop	r27
    28ca:	af 91       	pop	r26
    28cc:	9f 91       	pop	r25
    28ce:	8f 91       	pop	r24
    28d0:	7f 91       	pop	r23
    28d2:	6f 91       	pop	r22
    28d4:	5f 91       	pop	r21
    28d6:	4f 91       	pop	r20
    28d8:	3f 91       	pop	r19
    28da:	2f 91       	pop	r18
    28dc:	0f 90       	pop	r0
    28de:	0f be       	out	0x3f, r0	; 63
    28e0:	0f 90       	pop	r0
    28e2:	1f 90       	pop	r1
    28e4:	18 95       	reti

000028e6 <__vector_3>:
/********************************************************/
//INT2: Getting information from BeagleBone
ISR(INT2_vect){	//about to get time, get things ready
    28e6:	1f 92       	push	r1
    28e8:	0f 92       	push	r0
    28ea:	0f b6       	in	r0, 0x3f	; 63
    28ec:	0f 92       	push	r0
    28ee:	11 24       	eor	r1, r1
    28f0:	2f 93       	push	r18
    28f2:	3f 93       	push	r19
    28f4:	4f 93       	push	r20
    28f6:	5f 93       	push	r21
    28f8:	6f 93       	push	r22
    28fa:	7f 93       	push	r23
    28fc:	8f 93       	push	r24
    28fe:	9f 93       	push	r25
    2900:	af 93       	push	r26
    2902:	bf 93       	push	r27
    2904:	ef 93       	push	r30
    2906:	ff 93       	push	r31
    2908:	cf 93       	push	r28
    290a:	df 93       	push	r29
    290c:	0f 92       	push	r0
    290e:	cd b7       	in	r28, 0x3d	; 61
    2910:	de b7       	in	r29, 0x3e	; 62
	cli();
    2912:	f8 94       	cli
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    2914:	80 91 0a 02 	lds	r24, 0x020A
    2918:	88 23       	and	r24, r24
    291a:	19 f5       	brne	.+70     	; 0x2962 <__vector_3+0x7c>
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    291c:	10 92 fc 01 	sts	0x01FC, r1
		flagNormalMode=fFalse;
    2920:	10 92 fe 01 	sts	0x01FE, r1
		flagWaitingForSYNBone=fTrue;
    2924:	81 e0       	ldi	r24, 0x01	; 1
    2926:	80 93 02 02 	sts	0x0202, r24
		flagReceivingBone=fFalse;
    292a:	10 92 fd 01 	sts	0x01FD, r1
		__killCommINT();
    292e:	8d e3       	ldi	r24, 0x3D	; 61
    2930:	90 e0       	ldi	r25, 0x00	; 0
    2932:	fc 01       	movw	r30, r24
    2934:	10 82       	st	Z, r1
    2936:	8d e6       	ldi	r24, 0x6D	; 109
    2938:	90 e0       	ldi	r25, 0x00	; 0
    293a:	fc 01       	movw	r30, r24
    293c:	10 82       	st	Z, r1
		char dummy=UDR0;		//clear the register
    293e:	86 ec       	ldi	r24, 0xC6	; 198
    2940:	90 e0       	ldi	r25, 0x00	; 0
    2942:	fc 01       	movw	r30, r24
    2944:	80 81       	ld	r24, Z
    2946:	89 83       	std	Y+1, r24	; 0x01
		//Acknowledge connection, disable INT2_vect
		PrintBone("A.");
    2948:	8c e0       	ldi	r24, 0x0C	; 12
    294a:	91 e0       	ldi	r25, 0x01	; 1
    294c:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
		UCSR0B |= (1 << RXCIE0);
    2950:	81 ec       	ldi	r24, 0xC1	; 193
    2952:	90 e0       	ldi	r25, 0x00	; 0
    2954:	21 ec       	ldi	r18, 0xC1	; 193
    2956:	30 e0       	ldi	r19, 0x00	; 0
    2958:	f9 01       	movw	r30, r18
    295a:	20 81       	ld	r18, Z
    295c:	20 68       	ori	r18, 0x80	; 128
    295e:	fc 01       	movw	r30, r24
    2960:	20 83       	st	Z, r18
	}
	sei();
    2962:	78 94       	sei
}
    2964:	0f 90       	pop	r0
    2966:	df 91       	pop	r29
    2968:	cf 91       	pop	r28
    296a:	ff 91       	pop	r31
    296c:	ef 91       	pop	r30
    296e:	bf 91       	pop	r27
    2970:	af 91       	pop	r26
    2972:	9f 91       	pop	r25
    2974:	8f 91       	pop	r24
    2976:	7f 91       	pop	r23
    2978:	6f 91       	pop	r22
    297a:	5f 91       	pop	r21
    297c:	4f 91       	pop	r20
    297e:	3f 91       	pop	r19
    2980:	2f 91       	pop	r18
    2982:	0f 90       	pop	r0
    2984:	0f be       	out	0x3f, r0	; 63
    2986:	0f 90       	pop	r0
    2988:	1f 90       	pop	r1
    298a:	18 95       	reti

0000298c <__vector_20>:
/********************************************************/
//UART Receive from BeagleBone
ISR(USART0_RX_vect){
    298c:	1f 92       	push	r1
    298e:	0f 92       	push	r0
    2990:	0f b6       	in	r0, 0x3f	; 63
    2992:	0f 92       	push	r0
    2994:	11 24       	eor	r1, r1
    2996:	2f 93       	push	r18
    2998:	3f 93       	push	r19
    299a:	8f 93       	push	r24
    299c:	9f 93       	push	r25
    299e:	ef 93       	push	r30
    29a0:	ff 93       	push	r31
    29a2:	cf 93       	push	r28
    29a4:	df 93       	push	r29
    29a6:	cd b7       	in	r28, 0x3d	; 61
    29a8:	de b7       	in	r29, 0x3e	; 62
	cli();
    29aa:	f8 94       	cli
	if (flagWaitingForSYNBone){
    29ac:	80 91 02 02 	lds	r24, 0x0202
    29b0:	88 23       	and	r24, r24
    29b2:	31 f0       	breq	.+12     	; 0x29c0 <__vector_20+0x34>
		flagReceivingBone=fTrue;
    29b4:	81 e0       	ldi	r24, 0x01	; 1
    29b6:	80 93 fd 01 	sts	0x01FD, r24
		flagWaitingForSYNBone=fFalse;
    29ba:	10 92 02 02 	sts	0x0202, r1
    29be:	02 c0       	rjmp	.+4      	; 0x29c4 <__vector_20+0x38>
	} else {
		flagReceivingBone=fFalse;		//there was a timeout between the initial interrupt and when we are getting this.
    29c0:	10 92 fd 01 	sts	0x01FD, r1
	}	
	UCSR0B &= ~(1 << RXCIE0);
    29c4:	81 ec       	ldi	r24, 0xC1	; 193
    29c6:	90 e0       	ldi	r25, 0x00	; 0
    29c8:	21 ec       	ldi	r18, 0xC1	; 193
    29ca:	30 e0       	ldi	r19, 0x00	; 0
    29cc:	f9 01       	movw	r30, r18
    29ce:	20 81       	ld	r18, Z
    29d0:	2f 77       	andi	r18, 0x7F	; 127
    29d2:	fc 01       	movw	r30, r24
    29d4:	20 83       	st	Z, r18
	sei();
    29d6:	78 94       	sei
}
    29d8:	df 91       	pop	r29
    29da:	cf 91       	pop	r28
    29dc:	ff 91       	pop	r31
    29de:	ef 91       	pop	r30
    29e0:	9f 91       	pop	r25
    29e2:	8f 91       	pop	r24
    29e4:	3f 91       	pop	r19
    29e6:	2f 91       	pop	r18
    29e8:	0f 90       	pop	r0
    29ea:	0f be       	out	0x3f, r0	; 63
    29ec:	0f 90       	pop	r0
    29ee:	1f 90       	pop	r1
    29f0:	18 95       	reti

000029f2 <__vector_28>:
/********************************************************/
ISR(USART1_RX_vect){
    29f2:	1f 92       	push	r1
    29f4:	0f 92       	push	r0
    29f6:	0f b6       	in	r0, 0x3f	; 63
    29f8:	0f 92       	push	r0
    29fa:	11 24       	eor	r1, r1
    29fc:	2f 93       	push	r18
    29fe:	3f 93       	push	r19
    2a00:	4f 93       	push	r20
    2a02:	5f 93       	push	r21
    2a04:	6f 93       	push	r22
    2a06:	7f 93       	push	r23
    2a08:	8f 93       	push	r24
    2a0a:	9f 93       	push	r25
    2a0c:	af 93       	push	r26
    2a0e:	bf 93       	push	r27
    2a10:	ef 93       	push	r30
    2a12:	ff 93       	push	r31
    2a14:	cf 93       	push	r28
    2a16:	df 93       	push	r29
    2a18:	cd b7       	in	r28, 0x3d	; 61
    2a1a:	de b7       	in	r29, 0x3e	; 62
	cli();
    2a1c:	f8 94       	cli
	if (flagWaitingForSYNGAVR){
    2a1e:	80 91 01 02 	lds	r24, 0x0201
    2a22:	88 23       	and	r24, r24
    2a24:	51 f0       	breq	.+20     	; 0x2a3a <__vector_28+0x48>
		flagReceivingGAVR=fTrue;
    2a26:	81 e0       	ldi	r24, 0x01	; 1
    2a28:	80 93 ff 01 	sts	0x01FF, r24
		flagWaitingForSYNGAVR=fFalse;
    2a2c:	10 92 01 02 	sts	0x0201, r1
		PrintBone("SetReceiveG.");
    2a30:	8d ea       	ldi	r24, 0xAD	; 173
    2a32:	91 e0       	ldi	r25, 0x01	; 1
    2a34:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
    2a38:	02 c0       	rjmp	.+4      	; 0x2a3e <__vector_28+0x4c>
	}else {
		flagReceivingGAVR=fFalse;
    2a3a:	10 92 ff 01 	sts	0x01FF, r1
	}
	UCSR1B &= ~(1 <<RXCIE1);	//disable interrupt
    2a3e:	89 ec       	ldi	r24, 0xC9	; 201
    2a40:	90 e0       	ldi	r25, 0x00	; 0
    2a42:	29 ec       	ldi	r18, 0xC9	; 201
    2a44:	30 e0       	ldi	r19, 0x00	; 0
    2a46:	f9 01       	movw	r30, r18
    2a48:	20 81       	ld	r18, Z
    2a4a:	2f 77       	andi	r18, 0x7F	; 127
    2a4c:	fc 01       	movw	r30, r24
    2a4e:	20 83       	st	Z, r18
	sei();
    2a50:	78 94       	sei
}
    2a52:	df 91       	pop	r29
    2a54:	cf 91       	pop	r28
    2a56:	ff 91       	pop	r31
    2a58:	ef 91       	pop	r30
    2a5a:	bf 91       	pop	r27
    2a5c:	af 91       	pop	r26
    2a5e:	9f 91       	pop	r25
    2a60:	8f 91       	pop	r24
    2a62:	7f 91       	pop	r23
    2a64:	6f 91       	pop	r22
    2a66:	5f 91       	pop	r21
    2a68:	4f 91       	pop	r20
    2a6a:	3f 91       	pop	r19
    2a6c:	2f 91       	pop	r18
    2a6e:	0f 90       	pop	r0
    2a70:	0f be       	out	0x3f, r0	; 63
    2a72:	0f 90       	pop	r0
    2a74:	1f 90       	pop	r1
    2a76:	18 95       	reti

00002a78 <__vector_11>:

/********************************************************/
//RTC Timer.
ISR(TIMER2_OVF_vect){
    2a78:	1f 92       	push	r1
    2a7a:	0f 92       	push	r0
    2a7c:	0f b6       	in	r0, 0x3f	; 63
    2a7e:	0f 92       	push	r0
    2a80:	11 24       	eor	r1, r1
    2a82:	2f 93       	push	r18
    2a84:	3f 93       	push	r19
    2a86:	4f 93       	push	r20
    2a88:	5f 93       	push	r21
    2a8a:	6f 93       	push	r22
    2a8c:	7f 93       	push	r23
    2a8e:	8f 93       	push	r24
    2a90:	9f 93       	push	r25
    2a92:	af 93       	push	r26
    2a94:	bf 93       	push	r27
    2a96:	ef 93       	push	r30
    2a98:	ff 93       	push	r31
    2a9a:	cf 93       	push	r28
    2a9c:	df 93       	push	r29
    2a9e:	cd b7       	in	r28, 0x3d	; 61
    2aa0:	de b7       	in	r29, 0x3e	; 62
	cli();
    2aa2:	f8 94       	cli
	prtSLEEPled ^= (1 << bnSLEEPled);
    2aa4:	8b e2       	ldi	r24, 0x2B	; 43
    2aa6:	90 e0       	ldi	r25, 0x00	; 0
    2aa8:	2b e2       	ldi	r18, 0x2B	; 43
    2aaa:	30 e0       	ldi	r19, 0x00	; 0
    2aac:	f9 01       	movw	r30, r18
    2aae:	30 81       	ld	r19, Z
    2ab0:	20 e8       	ldi	r18, 0x80	; 128
    2ab2:	23 27       	eor	r18, r19
    2ab4:	fc 01       	movw	r30, r24
    2ab6:	20 83       	st	Z, r18
	static unsigned int gavrSendTimeout=0, boneReceiveTimeout=0, gavrReceiveTimeout=0, startupTimeout=0;
	
	currentTime.addSeconds(1);
    2ab8:	84 ed       	ldi	r24, 0xD4	; 212
    2aba:	91 e0       	ldi	r25, 0x01	; 1
    2abc:	61 e0       	ldi	r22, 0x01	; 1
    2abe:	70 e0       	ldi	r23, 0x00	; 0
    2ac0:	0e 94 72 06 	call	0xce4	; 0xce4 <_ZN6myTime10addSecondsEi>
	
	//GAVR Transmission Timeout
	if (flagSendingGAVR && gavrSendTimeout <=COMM_TIMEOUT_SEC){gavrSendTimeout++;}
    2ac4:	80 91 04 02 	lds	r24, 0x0204
    2ac8:	88 23       	and	r24, r24
    2aca:	89 f0       	breq	.+34     	; 0x2aee <__vector_11+0x76>
    2acc:	80 91 0f 02 	lds	r24, 0x020F
    2ad0:	90 91 10 02 	lds	r25, 0x0210
    2ad4:	89 30       	cpi	r24, 0x09	; 9
    2ad6:	91 05       	cpc	r25, r1
    2ad8:	50 f4       	brcc	.+20     	; 0x2aee <__vector_11+0x76>
    2ada:	80 91 0f 02 	lds	r24, 0x020F
    2ade:	90 91 10 02 	lds	r25, 0x0210
    2ae2:	01 96       	adiw	r24, 0x01	; 1
    2ae4:	90 93 10 02 	sts	0x0210, r25
    2ae8:	80 93 0f 02 	sts	0x020F, r24
    2aec:	43 c0       	rjmp	.+134    	; 0x2b74 <__vector_11+0xfc>
	else if (flagSendingGAVR && gavrSendTimeout > COMM_TIMEOUT_SEC){__killUARTrec();flagSendingGAVR=fFalse;flagGoToSleep=fTrue; gavrSendTimeout=0; __enableCommINT();}
    2aee:	80 91 04 02 	lds	r24, 0x0204
    2af2:	88 23       	and	r24, r24
    2af4:	89 f1       	breq	.+98     	; 0x2b58 <__vector_11+0xe0>
    2af6:	80 91 0f 02 	lds	r24, 0x020F
    2afa:	90 91 10 02 	lds	r25, 0x0210
    2afe:	89 30       	cpi	r24, 0x09	; 9
    2b00:	91 05       	cpc	r25, r1
    2b02:	50 f1       	brcs	.+84     	; 0x2b58 <__vector_11+0xe0>
    2b04:	81 ec       	ldi	r24, 0xC1	; 193
    2b06:	90 e0       	ldi	r25, 0x00	; 0
    2b08:	21 ec       	ldi	r18, 0xC1	; 193
    2b0a:	30 e0       	ldi	r19, 0x00	; 0
    2b0c:	f9 01       	movw	r30, r18
    2b0e:	20 81       	ld	r18, Z
    2b10:	20 68       	ori	r18, 0x80	; 128
    2b12:	fc 01       	movw	r30, r24
    2b14:	20 83       	st	Z, r18
    2b16:	89 ec       	ldi	r24, 0xC9	; 201
    2b18:	90 e0       	ldi	r25, 0x00	; 0
    2b1a:	29 ec       	ldi	r18, 0xC9	; 201
    2b1c:	30 e0       	ldi	r19, 0x00	; 0
    2b1e:	f9 01       	movw	r30, r18
    2b20:	20 81       	ld	r18, Z
    2b22:	20 68       	ori	r18, 0x80	; 128
    2b24:	fc 01       	movw	r30, r24
    2b26:	20 83       	st	Z, r18
    2b28:	10 92 04 02 	sts	0x0204, r1
    2b2c:	81 e0       	ldi	r24, 0x01	; 1
    2b2e:	80 93 fc 01 	sts	0x01FC, r24
    2b32:	10 92 10 02 	sts	0x0210, r1
    2b36:	10 92 0f 02 	sts	0x020F, r1
    2b3a:	8d e3       	ldi	r24, 0x3D	; 61
    2b3c:	90 e0       	ldi	r25, 0x00	; 0
    2b3e:	2d e3       	ldi	r18, 0x3D	; 61
    2b40:	30 e0       	ldi	r19, 0x00	; 0
    2b42:	f9 01       	movw	r30, r18
    2b44:	20 81       	ld	r18, Z
    2b46:	24 60       	ori	r18, 0x04	; 4
    2b48:	fc 01       	movw	r30, r24
    2b4a:	20 83       	st	Z, r18
    2b4c:	8d e6       	ldi	r24, 0x6D	; 109
    2b4e:	90 e0       	ldi	r25, 0x00	; 0
    2b50:	22 e0       	ldi	r18, 0x02	; 2
    2b52:	fc 01       	movw	r30, r24
    2b54:	20 83       	st	Z, r18
    2b56:	0e c0       	rjmp	.+28     	; 0x2b74 <__vector_11+0xfc>
	else if (!flagSendingGAVR && gavrSendTimeout > 0){gavrSendTimeout=0;}
    2b58:	80 91 04 02 	lds	r24, 0x0204
    2b5c:	88 23       	and	r24, r24
    2b5e:	51 f4       	brne	.+20     	; 0x2b74 <__vector_11+0xfc>
    2b60:	80 91 0f 02 	lds	r24, 0x020F
    2b64:	90 91 10 02 	lds	r25, 0x0210
    2b68:	00 97       	sbiw	r24, 0x00	; 0
    2b6a:	21 f0       	breq	.+8      	; 0x2b74 <__vector_11+0xfc>
    2b6c:	10 92 10 02 	sts	0x0210, r1
    2b70:	10 92 0f 02 	sts	0x020F, r1
	else;
	
	//BeagleBone Reception Timeout
	if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout <=COMM_TIMEOUT_SEC)){boneReceiveTimeout++;}
    2b74:	80 91 fd 01 	lds	r24, 0x01FD
    2b78:	88 23       	and	r24, r24
    2b7a:	21 f4       	brne	.+8      	; 0x2b84 <__vector_11+0x10c>
    2b7c:	80 91 02 02 	lds	r24, 0x0202
    2b80:	88 23       	and	r24, r24
    2b82:	89 f0       	breq	.+34     	; 0x2ba6 <__vector_11+0x12e>
    2b84:	80 91 11 02 	lds	r24, 0x0211
    2b88:	90 91 12 02 	lds	r25, 0x0212
    2b8c:	89 30       	cpi	r24, 0x09	; 9
    2b8e:	91 05       	cpc	r25, r1
    2b90:	50 f4       	brcc	.+20     	; 0x2ba6 <__vector_11+0x12e>
    2b92:	80 91 11 02 	lds	r24, 0x0211
    2b96:	90 91 12 02 	lds	r25, 0x0212
    2b9a:	01 96       	adiw	r24, 0x01	; 1
    2b9c:	90 93 12 02 	sts	0x0212, r25
    2ba0:	80 93 11 02 	sts	0x0211, r24
    2ba4:	50 c0       	rjmp	.+160    	; 0x2c46 <__vector_11+0x1ce>
	else if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout > COMM_TIMEOUT_SEC)){__killUARTrec();flagReceivingBone=fFalse; flagWaitingForSYNBone=fFalse;flagGoToSleep=fTrue; flagNormalMode=fTrue; boneReceiveTimeout=0; __enableCommINT();}
    2ba6:	80 91 fd 01 	lds	r24, 0x01FD
    2baa:	88 23       	and	r24, r24
    2bac:	21 f4       	brne	.+8      	; 0x2bb6 <__vector_11+0x13e>
    2bae:	80 91 02 02 	lds	r24, 0x0202
    2bb2:	88 23       	and	r24, r24
    2bb4:	b1 f1       	breq	.+108    	; 0x2c22 <__vector_11+0x1aa>
    2bb6:	80 91 11 02 	lds	r24, 0x0211
    2bba:	90 91 12 02 	lds	r25, 0x0212
    2bbe:	89 30       	cpi	r24, 0x09	; 9
    2bc0:	91 05       	cpc	r25, r1
    2bc2:	78 f1       	brcs	.+94     	; 0x2c22 <__vector_11+0x1aa>
    2bc4:	81 ec       	ldi	r24, 0xC1	; 193
    2bc6:	90 e0       	ldi	r25, 0x00	; 0
    2bc8:	21 ec       	ldi	r18, 0xC1	; 193
    2bca:	30 e0       	ldi	r19, 0x00	; 0
    2bcc:	f9 01       	movw	r30, r18
    2bce:	20 81       	ld	r18, Z
    2bd0:	20 68       	ori	r18, 0x80	; 128
    2bd2:	fc 01       	movw	r30, r24
    2bd4:	20 83       	st	Z, r18
    2bd6:	89 ec       	ldi	r24, 0xC9	; 201
    2bd8:	90 e0       	ldi	r25, 0x00	; 0
    2bda:	29 ec       	ldi	r18, 0xC9	; 201
    2bdc:	30 e0       	ldi	r19, 0x00	; 0
    2bde:	f9 01       	movw	r30, r18
    2be0:	20 81       	ld	r18, Z
    2be2:	20 68       	ori	r18, 0x80	; 128
    2be4:	fc 01       	movw	r30, r24
    2be6:	20 83       	st	Z, r18
    2be8:	10 92 fd 01 	sts	0x01FD, r1
    2bec:	10 92 02 02 	sts	0x0202, r1
    2bf0:	81 e0       	ldi	r24, 0x01	; 1
    2bf2:	80 93 fc 01 	sts	0x01FC, r24
    2bf6:	81 e0       	ldi	r24, 0x01	; 1
    2bf8:	80 93 fe 01 	sts	0x01FE, r24
    2bfc:	10 92 12 02 	sts	0x0212, r1
    2c00:	10 92 11 02 	sts	0x0211, r1
    2c04:	8d e3       	ldi	r24, 0x3D	; 61
    2c06:	90 e0       	ldi	r25, 0x00	; 0
    2c08:	2d e3       	ldi	r18, 0x3D	; 61
    2c0a:	30 e0       	ldi	r19, 0x00	; 0
    2c0c:	f9 01       	movw	r30, r18
    2c0e:	20 81       	ld	r18, Z
    2c10:	24 60       	ori	r18, 0x04	; 4
    2c12:	fc 01       	movw	r30, r24
    2c14:	20 83       	st	Z, r18
    2c16:	8d e6       	ldi	r24, 0x6D	; 109
    2c18:	90 e0       	ldi	r25, 0x00	; 0
    2c1a:	22 e0       	ldi	r18, 0x02	; 2
    2c1c:	fc 01       	movw	r30, r24
    2c1e:	20 83       	st	Z, r18
    2c20:	12 c0       	rjmp	.+36     	; 0x2c46 <__vector_11+0x1ce>
	else if ((!flagReceivingBone && !flagWaitingForSYNBone) && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    2c22:	80 91 fd 01 	lds	r24, 0x01FD
    2c26:	88 23       	and	r24, r24
    2c28:	71 f4       	brne	.+28     	; 0x2c46 <__vector_11+0x1ce>
    2c2a:	80 91 02 02 	lds	r24, 0x0202
    2c2e:	88 23       	and	r24, r24
    2c30:	51 f4       	brne	.+20     	; 0x2c46 <__vector_11+0x1ce>
    2c32:	80 91 11 02 	lds	r24, 0x0211
    2c36:	90 91 12 02 	lds	r25, 0x0212
    2c3a:	00 97       	sbiw	r24, 0x00	; 0
    2c3c:	21 f0       	breq	.+8      	; 0x2c46 <__vector_11+0x1ce>
    2c3e:	10 92 12 02 	sts	0x0212, r1
    2c42:	10 92 11 02 	sts	0x0211, r1
	else;

	//GAVR Reception Timeout
	if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout <= COMM_TIMEOUT_SEC){gavrReceiveTimeout++;}
    2c46:	80 91 ff 01 	lds	r24, 0x01FF
    2c4a:	88 23       	and	r24, r24
    2c4c:	21 f4       	brne	.+8      	; 0x2c56 <__vector_11+0x1de>
    2c4e:	80 91 01 02 	lds	r24, 0x0201
    2c52:	88 23       	and	r24, r24
    2c54:	89 f0       	breq	.+34     	; 0x2c78 <__vector_11+0x200>
    2c56:	80 91 13 02 	lds	r24, 0x0213
    2c5a:	90 91 14 02 	lds	r25, 0x0214
    2c5e:	89 30       	cpi	r24, 0x09	; 9
    2c60:	91 05       	cpc	r25, r1
    2c62:	50 f4       	brcc	.+20     	; 0x2c78 <__vector_11+0x200>
    2c64:	80 91 13 02 	lds	r24, 0x0213
    2c68:	90 91 14 02 	lds	r25, 0x0214
    2c6c:	01 96       	adiw	r24, 0x01	; 1
    2c6e:	90 93 14 02 	sts	0x0214, r25
    2c72:	80 93 13 02 	sts	0x0213, r24
    2c76:	50 c0       	rjmp	.+160    	; 0x2d18 <__vector_11+0x2a0>
	else if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout > COMM_TIMEOUT_SEC){__killUARTrec(); flagReceivingGAVR=fFalse;flagGoToSleep=fTrue; flagWaitingForSYNGAVR=fFalse;flagNormalMode=fTrue;gavrReceiveTimeout=0; __enableCommINT();}
    2c78:	80 91 ff 01 	lds	r24, 0x01FF
    2c7c:	88 23       	and	r24, r24
    2c7e:	21 f4       	brne	.+8      	; 0x2c88 <__vector_11+0x210>
    2c80:	80 91 01 02 	lds	r24, 0x0201
    2c84:	88 23       	and	r24, r24
    2c86:	b1 f1       	breq	.+108    	; 0x2cf4 <__vector_11+0x27c>
    2c88:	80 91 13 02 	lds	r24, 0x0213
    2c8c:	90 91 14 02 	lds	r25, 0x0214
    2c90:	89 30       	cpi	r24, 0x09	; 9
    2c92:	91 05       	cpc	r25, r1
    2c94:	78 f1       	brcs	.+94     	; 0x2cf4 <__vector_11+0x27c>
    2c96:	81 ec       	ldi	r24, 0xC1	; 193
    2c98:	90 e0       	ldi	r25, 0x00	; 0
    2c9a:	21 ec       	ldi	r18, 0xC1	; 193
    2c9c:	30 e0       	ldi	r19, 0x00	; 0
    2c9e:	f9 01       	movw	r30, r18
    2ca0:	20 81       	ld	r18, Z
    2ca2:	20 68       	ori	r18, 0x80	; 128
    2ca4:	fc 01       	movw	r30, r24
    2ca6:	20 83       	st	Z, r18
    2ca8:	89 ec       	ldi	r24, 0xC9	; 201
    2caa:	90 e0       	ldi	r25, 0x00	; 0
    2cac:	29 ec       	ldi	r18, 0xC9	; 201
    2cae:	30 e0       	ldi	r19, 0x00	; 0
    2cb0:	f9 01       	movw	r30, r18
    2cb2:	20 81       	ld	r18, Z
    2cb4:	20 68       	ori	r18, 0x80	; 128
    2cb6:	fc 01       	movw	r30, r24
    2cb8:	20 83       	st	Z, r18
    2cba:	10 92 ff 01 	sts	0x01FF, r1
    2cbe:	81 e0       	ldi	r24, 0x01	; 1
    2cc0:	80 93 fc 01 	sts	0x01FC, r24
    2cc4:	10 92 01 02 	sts	0x0201, r1
    2cc8:	81 e0       	ldi	r24, 0x01	; 1
    2cca:	80 93 fe 01 	sts	0x01FE, r24
    2cce:	10 92 14 02 	sts	0x0214, r1
    2cd2:	10 92 13 02 	sts	0x0213, r1
    2cd6:	8d e3       	ldi	r24, 0x3D	; 61
    2cd8:	90 e0       	ldi	r25, 0x00	; 0
    2cda:	2d e3       	ldi	r18, 0x3D	; 61
    2cdc:	30 e0       	ldi	r19, 0x00	; 0
    2cde:	f9 01       	movw	r30, r18
    2ce0:	20 81       	ld	r18, Z
    2ce2:	24 60       	ori	r18, 0x04	; 4
    2ce4:	fc 01       	movw	r30, r24
    2ce6:	20 83       	st	Z, r18
    2ce8:	8d e6       	ldi	r24, 0x6D	; 109
    2cea:	90 e0       	ldi	r25, 0x00	; 0
    2cec:	22 e0       	ldi	r18, 0x02	; 2
    2cee:	fc 01       	movw	r30, r24
    2cf0:	20 83       	st	Z, r18
    2cf2:	12 c0       	rjmp	.+36     	; 0x2d18 <__vector_11+0x2a0>
	else if ((!flagReceivingGAVR && !flagWaitingForSYNGAVR) && gavrReceiveTimeout > 0){gavrReceiveTimeout=0;}
    2cf4:	80 91 ff 01 	lds	r24, 0x01FF
    2cf8:	88 23       	and	r24, r24
    2cfa:	71 f4       	brne	.+28     	; 0x2d18 <__vector_11+0x2a0>
    2cfc:	80 91 01 02 	lds	r24, 0x0201
    2d00:	88 23       	and	r24, r24
    2d02:	51 f4       	brne	.+20     	; 0x2d18 <__vector_11+0x2a0>
    2d04:	80 91 13 02 	lds	r24, 0x0213
    2d08:	90 91 14 02 	lds	r25, 0x0214
    2d0c:	00 97       	sbiw	r24, 0x00	; 0
    2d0e:	21 f0       	breq	.+8      	; 0x2d18 <__vector_11+0x2a0>
    2d10:	10 92 14 02 	sts	0x0214, r1
    2d14:	10 92 13 02 	sts	0x0213, r1
	else;
	
	//Startup Tiemout for sending clock to GAVR
	if ((flagFreshStart || restart) && startupTimeout <= STARTUP_TIMEOUT_SEC){startupTimeout++;}
    2d18:	80 91 0e 02 	lds	r24, 0x020E
    2d1c:	88 23       	and	r24, r24
    2d1e:	21 f4       	brne	.+8      	; 0x2d28 <__vector_11+0x2b0>
    2d20:	80 91 0d 02 	lds	r24, 0x020D
    2d24:	88 23       	and	r24, r24
    2d26:	89 f0       	breq	.+34     	; 0x2d4a <__vector_11+0x2d2>
    2d28:	80 91 15 02 	lds	r24, 0x0215
    2d2c:	90 91 16 02 	lds	r25, 0x0216
    2d30:	8d 30       	cpi	r24, 0x0D	; 13
    2d32:	91 05       	cpc	r25, r1
    2d34:	50 f4       	brcc	.+20     	; 0x2d4a <__vector_11+0x2d2>
    2d36:	80 91 15 02 	lds	r24, 0x0215
    2d3a:	90 91 16 02 	lds	r25, 0x0216
    2d3e:	01 96       	adiw	r24, 0x01	; 1
    2d40:	90 93 16 02 	sts	0x0216, r25
    2d44:	80 93 15 02 	sts	0x0215, r24
    2d48:	51 c0       	rjmp	.+162    	; 0x2dec <__vector_11+0x374>
	else if ((flagFreshStart || restart) && startupTimeout > STARTUP_TIMEOUT_SEC){
    2d4a:	80 91 0e 02 	lds	r24, 0x020E
    2d4e:	88 23       	and	r24, r24
    2d50:	21 f4       	brne	.+8      	; 0x2d5a <__vector_11+0x2e2>
    2d52:	80 91 0d 02 	lds	r24, 0x020D
    2d56:	88 23       	and	r24, r24
    2d58:	b9 f1       	breq	.+110    	; 0x2dc8 <__vector_11+0x350>
    2d5a:	80 91 15 02 	lds	r24, 0x0215
    2d5e:	90 91 16 02 	lds	r25, 0x0216
    2d62:	8d 30       	cpi	r24, 0x0D	; 13
    2d64:	91 05       	cpc	r25, r1
    2d66:	80 f1       	brcs	.+96     	; 0x2dc8 <__vector_11+0x350>
		if (flagFreshStart){flagFreshStart=fFalse; flagUserClock=fTrue; flagUpdateGAVRClock=fFalse;}	//The GPS didn't send valid data, get user clock.
    2d68:	80 91 0e 02 	lds	r24, 0x020E
    2d6c:	88 23       	and	r24, r24
    2d6e:	41 f0       	breq	.+16     	; 0x2d80 <__vector_11+0x308>
    2d70:	10 92 0e 02 	sts	0x020E, r1
    2d74:	81 e0       	ldi	r24, 0x01	; 1
    2d76:	80 93 05 02 	sts	0x0205, r24
    2d7a:	10 92 03 02 	sts	0x0203, r1
    2d7e:	0b c0       	rjmp	.+22     	; 0x2d96 <__vector_11+0x31e>
		else if (restart){restart=fFalse; flagUserClock=fFalse; flagUpdateGAVRClock=fTrue;}				//Gps didn't send valid data, we have valid data. This is redundant to the main
    2d80:	80 91 0d 02 	lds	r24, 0x020D
    2d84:	88 23       	and	r24, r24
    2d86:	39 f0       	breq	.+14     	; 0x2d96 <__vector_11+0x31e>
    2d88:	10 92 0d 02 	sts	0x020D, r1
    2d8c:	10 92 05 02 	sts	0x0205, r1
    2d90:	81 e0       	ldi	r24, 0x01	; 1
    2d92:	80 93 03 02 	sts	0x0203, r24
		__enableCommINT();																				//--procedure that depends on "if (restart)"
    2d96:	8d e3       	ldi	r24, 0x3D	; 61
    2d98:	90 e0       	ldi	r25, 0x00	; 0
    2d9a:	2d e3       	ldi	r18, 0x3D	; 61
    2d9c:	30 e0       	ldi	r19, 0x00	; 0
    2d9e:	f9 01       	movw	r30, r18
    2da0:	20 81       	ld	r18, Z
    2da2:	24 60       	ori	r18, 0x04	; 4
    2da4:	fc 01       	movw	r30, r24
    2da6:	20 83       	st	Z, r18
    2da8:	8d e6       	ldi	r24, 0x6D	; 109
    2daa:	90 e0       	ldi	r25, 0x00	; 0
    2dac:	22 e0       	ldi	r18, 0x02	; 2
    2dae:	fc 01       	movw	r30, r24
    2db0:	20 83       	st	Z, r18
		startupTimeout=0;
    2db2:	10 92 16 02 	sts	0x0216, r1
    2db6:	10 92 15 02 	sts	0x0215, r1
		flagGoToSleep=fTrue;
    2dba:	81 e0       	ldi	r24, 0x01	; 1
    2dbc:	80 93 fc 01 	sts	0x01FC, r24
		flagNormalMode=fTrue;
    2dc0:	81 e0       	ldi	r24, 0x01	; 1
    2dc2:	80 93 fe 01 	sts	0x01FE, r24
    2dc6:	12 c0       	rjmp	.+36     	; 0x2dec <__vector_11+0x374>
	} else if (!(flagFreshStart || restart) && startupTimeout > 0){startupTimeout=0;}
    2dc8:	80 91 0e 02 	lds	r24, 0x020E
    2dcc:	88 23       	and	r24, r24
    2dce:	71 f4       	brne	.+28     	; 0x2dec <__vector_11+0x374>
    2dd0:	80 91 0d 02 	lds	r24, 0x020D
    2dd4:	88 23       	and	r24, r24
    2dd6:	51 f4       	brne	.+20     	; 0x2dec <__vector_11+0x374>
    2dd8:	80 91 15 02 	lds	r24, 0x0215
    2ddc:	90 91 16 02 	lds	r25, 0x0216
    2de0:	00 97       	sbiw	r24, 0x00	; 0
    2de2:	21 f0       	breq	.+8      	; 0x2dec <__vector_11+0x374>
    2de4:	10 92 16 02 	sts	0x0216, r1
    2de8:	10 92 15 02 	sts	0x0215, r1
	else;
	sei();
    2dec:	78 94       	sei
}//End timer 2 overflow.
    2dee:	df 91       	pop	r29
    2df0:	cf 91       	pop	r28
    2df2:	ff 91       	pop	r31
    2df4:	ef 91       	pop	r30
    2df6:	bf 91       	pop	r27
    2df8:	af 91       	pop	r26
    2dfa:	9f 91       	pop	r25
    2dfc:	8f 91       	pop	r24
    2dfe:	7f 91       	pop	r23
    2e00:	6f 91       	pop	r22
    2e02:	5f 91       	pop	r21
    2e04:	4f 91       	pop	r20
    2e06:	3f 91       	pop	r19
    2e08:	2f 91       	pop	r18
    2e0a:	0f 90       	pop	r0
    2e0c:	0f be       	out	0x3f, r0	; 63
    2e0e:	0f 90       	pop	r0
    2e10:	1f 90       	pop	r1
    2e12:	18 95       	reti

00002e14 <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    2e14:	cf 93       	push	r28
    2e16:	df 93       	push	r29
    2e18:	cd b7       	in	r28, 0x3d	; 61
    2e1a:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    2e1c:	0e 94 79 18 	call	0x30f2	; 0x30f2 <_Z10DeviceInitv>
	AppInit(MYUBRR);
    2e20:	83 e3       	ldi	r24, 0x33	; 51
    2e22:	90 e0       	ldi	r25, 0x00	; 0
    2e24:	0e 94 a0 18 	call	0x3140	; 0x3140 <_Z7AppInitj>
	EnableRTCTimer();
    2e28:	0e 94 fc 19 	call	0x33f8	; 0x33f8 <_Z14EnableRTCTimerv>
	InitBools();
    2e2c:	0e 94 d1 19 	call	0x33a2	; 0x33a2 <_Z9InitBoolsv>
	getDateTime_eeprom(fTrue,fTrue);
    2e30:	81 e0       	ldi	r24, 0x01	; 1
    2e32:	61 e0       	ldi	r22, 0x01	; 1
    2e34:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z18getDateTime_eepromhh>
	//Prep/make sure power/temp is good
	Wait_ms(2000);
    2e38:	80 ed       	ldi	r24, 0xD0	; 208
    2e3a:	97 e0       	ldi	r25, 0x07	; 7
    2e3c:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
	//GetTemp();
	TakeADC();
    2e40:	0e 94 98 1a 	call	0x3530	; 0x3530 <_Z7TakeADCv>
	flagGoodTemp=fTrue;
    2e44:	81 e0       	ldi	r24, 0x01	; 1
    2e46:	80 93 0b 02 	sts	0x020B, r24
	if (flagGoodVolts && flagGoodTemp){				//Good to power on system
    2e4a:	80 91 0c 02 	lds	r24, 0x020C
    2e4e:	88 23       	and	r24, r24
    2e50:	e1 f0       	breq	.+56     	; 0x2e8a <main+0x76>
    2e52:	80 91 0b 02 	lds	r24, 0x020B
    2e56:	88 23       	and	r24, r24
    2e58:	c1 f0       	breq	.+48     	; 0x2e8a <main+0x76>
		PowerUp(POWER_UP_INTERVAL);
    2e5a:	83 e0       	ldi	r24, 0x03	; 3
    2e5c:	90 e0       	ldi	r25, 0x00	; 0
    2e5e:	0e 94 03 1c 	call	0x3806	; 0x3806 <_Z7PowerUpj>
		__enableCommINT();
    2e62:	8d e3       	ldi	r24, 0x3D	; 61
    2e64:	90 e0       	ldi	r25, 0x00	; 0
    2e66:	2d e3       	ldi	r18, 0x3D	; 61
    2e68:	30 e0       	ldi	r19, 0x00	; 0
    2e6a:	f9 01       	movw	r30, r18
    2e6c:	20 81       	ld	r18, Z
    2e6e:	24 60       	ori	r18, 0x04	; 4
    2e70:	fc 01       	movw	r30, r24
    2e72:	20 83       	st	Z, r18
    2e74:	8d e6       	ldi	r24, 0x6D	; 109
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	22 e0       	ldi	r18, 0x02	; 2
    2e7a:	fc 01       	movw	r30, r24
    2e7c:	20 83       	st	Z, r18
		flagFreshStart=fTrue;
    2e7e:	81 e0       	ldi	r24, 0x01	; 1
    2e80:	80 93 0e 02 	sts	0x020E, r24
		flagShutdown=fFalse;
    2e84:	10 92 0a 02 	sts	0x020A, r1
    2e88:	0d c0       	rjmp	.+26     	; 0x2ea4 <main+0x90>
	} else {										//Something isn't right, don't power on the system.
		__killCommINT();
    2e8a:	8d e3       	ldi	r24, 0x3D	; 61
    2e8c:	90 e0       	ldi	r25, 0x00	; 0
    2e8e:	fc 01       	movw	r30, r24
    2e90:	10 82       	st	Z, r1
    2e92:	8d e6       	ldi	r24, 0x6D	; 109
    2e94:	90 e0       	ldi	r25, 0x00	; 0
    2e96:	fc 01       	movw	r30, r24
    2e98:	10 82       	st	Z, r1
		flagShutdown=fTrue;
    2e9a:	81 e0       	ldi	r24, 0x01	; 1
    2e9c:	80 93 0a 02 	sts	0x020A, r24
		flagFreshStart=fFalse;
    2ea0:	10 92 0e 02 	sts	0x020E, r1
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
    2ea4:	88 e2       	ldi	r24, 0x28	; 40
    2ea6:	90 e0       	ldi	r25, 0x00	; 0
    2ea8:	28 e2       	ldi	r18, 0x28	; 40
    2eaa:	30 e0       	ldi	r19, 0x00	; 0
    2eac:	f9 01       	movw	r30, r18
    2eae:	20 81       	ld	r18, Z
    2eb0:	24 60       	ori	r18, 0x04	; 4
    2eb2:	fc 01       	movw	r30, r24
    2eb4:	20 83       	st	Z, r18
    2eb6:	01 c0       	rjmp	.+2      	; 0x2eba <main+0xa6>
	//main programming loop
	while(fTrue)
    2eb8:	00 00       	nop
	{		
		//If receiving UART string, go get rest of it.
		if (flagReceivingBone){
    2eba:	80 91 fd 01 	lds	r24, 0x01FD
    2ebe:	88 23       	and	r24, r24
    2ec0:	d1 f0       	breq	.+52     	; 0x2ef6 <main+0xe2>
			ReceiveBone();
    2ec2:	0e 94 06 0c 	call	0x180c	; 0x180c <_Z11ReceiveBonev>
			Wait_sec(2);
    2ec6:	82 e0       	ldi	r24, 0x02	; 2
    2ec8:	90 e0       	ldi	r25, 0x00	; 0
    2eca:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			__enableCommINT();
    2ece:	8d e3       	ldi	r24, 0x3D	; 61
    2ed0:	90 e0       	ldi	r25, 0x00	; 0
    2ed2:	2d e3       	ldi	r18, 0x3D	; 61
    2ed4:	30 e0       	ldi	r19, 0x00	; 0
    2ed6:	f9 01       	movw	r30, r18
    2ed8:	20 81       	ld	r18, Z
    2eda:	24 60       	ori	r18, 0x04	; 4
    2edc:	fc 01       	movw	r30, r24
    2ede:	20 83       	st	Z, r18
    2ee0:	8d e6       	ldi	r24, 0x6D	; 109
    2ee2:	90 e0       	ldi	r25, 0x00	; 0
    2ee4:	22 e0       	ldi	r18, 0x02	; 2
    2ee6:	fc 01       	movw	r30, r24
    2ee8:	20 83       	st	Z, r18
			flagGoToSleep=fTrue;
    2eea:	81 e0       	ldi	r24, 0x01	; 1
    2eec:	80 93 fc 01 	sts	0x01FC, r24
			flagNormalMode=fTrue;
    2ef0:	81 e0       	ldi	r24, 0x01	; 1
    2ef2:	80 93 fe 01 	sts	0x01FE, r24
		}//end flag Receiving from Bone 
		
		//Receiving Data/Signals from GAVR
		if (flagReceivingGAVR){
    2ef6:	80 91 ff 01 	lds	r24, 0x01FF
    2efa:	88 23       	and	r24, r24
    2efc:	11 f1       	breq	.+68     	; 0x2f42 <main+0x12e>
			PrintBone("ReceivingG.");
    2efe:	8a eb       	ldi	r24, 0xBA	; 186
    2f00:	91 e0       	ldi	r25, 0x01	; 1
    2f02:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
			ReceiveGAVR();
    2f06:	0e 94 37 10 	call	0x206e	; 0x206e <_Z11ReceiveGAVRv>
			Wait_sec(2);			
    2f0a:	82 e0       	ldi	r24, 0x02	; 2
    2f0c:	90 e0       	ldi	r25, 0x00	; 0
    2f0e:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			__enableCommINT();	
    2f12:	8d e3       	ldi	r24, 0x3D	; 61
    2f14:	90 e0       	ldi	r25, 0x00	; 0
    2f16:	2d e3       	ldi	r18, 0x3D	; 61
    2f18:	30 e0       	ldi	r19, 0x00	; 0
    2f1a:	f9 01       	movw	r30, r18
    2f1c:	20 81       	ld	r18, Z
    2f1e:	24 60       	ori	r18, 0x04	; 4
    2f20:	fc 01       	movw	r30, r24
    2f22:	20 83       	st	Z, r18
    2f24:	8d e6       	ldi	r24, 0x6D	; 109
    2f26:	90 e0       	ldi	r25, 0x00	; 0
    2f28:	22 e0       	ldi	r18, 0x02	; 2
    2f2a:	fc 01       	movw	r30, r24
    2f2c:	20 83       	st	Z, r18
			if (!flagReceivingBone){
    2f2e:	80 91 fd 01 	lds	r24, 0x01FD
    2f32:	88 23       	and	r24, r24
    2f34:	31 f4       	brne	.+12     	; 0x2f42 <main+0x12e>
				flagGoToSleep=fTrue;
    2f36:	81 e0       	ldi	r24, 0x01	; 1
    2f38:	80 93 fc 01 	sts	0x01FC, r24
				flagNormalMode=fTrue;
    2f3c:	81 e0       	ldi	r24, 0x01	; 1
    2f3e:	80 93 fe 01 	sts	0x01FE, r24
			}
		}//end flag Receiving from GAVR case
		
		//Communication with GAVR. Either updating the date/time on it or asking for date and time. The internal send machine deals with the flags.
		if ((flagUpdateGAVRClock  || flagUserClock) && !flagWaitingForReceiveGAVR){
    2f42:	80 91 03 02 	lds	r24, 0x0203
    2f46:	88 23       	and	r24, r24
    2f48:	21 f4       	brne	.+8      	; 0x2f52 <main+0x13e>
    2f4a:	80 91 05 02 	lds	r24, 0x0205
    2f4e:	88 23       	and	r24, r24
    2f50:	21 f1       	breq	.+72     	; 0x2f9a <main+0x186>
    2f52:	80 91 00 02 	lds	r24, 0x0200
    2f56:	88 23       	and	r24, r24
    2f58:	01 f5       	brne	.+64     	; 0x2f9a <main+0x186>
			PrintBone("SendingG.");
    2f5a:	86 ec       	ldi	r24, 0xC6	; 198
    2f5c:	91 e0       	ldi	r25, 0x01	; 1
    2f5e:	0e 94 50 09 	call	0x12a0	; 0x12a0 <_Z9PrintBonePc>
			__killCommINT();
    2f62:	8d e3       	ldi	r24, 0x3D	; 61
    2f64:	90 e0       	ldi	r25, 0x00	; 0
    2f66:	fc 01       	movw	r30, r24
    2f68:	10 82       	st	Z, r1
    2f6a:	8d e6       	ldi	r24, 0x6D	; 109
    2f6c:	90 e0       	ldi	r25, 0x00	; 0
    2f6e:	fc 01       	movw	r30, r24
    2f70:	10 82       	st	Z, r1
			sendGAVR();
    2f72:	0e 94 cc 09 	call	0x1398	; 0x1398 <_Z8sendGAVRv>
			Wait_sec(2);
    2f76:	82 e0       	ldi	r24, 0x02	; 2
    2f78:	90 e0       	ldi	r25, 0x00	; 0
    2f7a:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			__enableCommINT();
    2f7e:	8d e3       	ldi	r24, 0x3D	; 61
    2f80:	90 e0       	ldi	r25, 0x00	; 0
    2f82:	2d e3       	ldi	r18, 0x3D	; 61
    2f84:	30 e0       	ldi	r19, 0x00	; 0
    2f86:	f9 01       	movw	r30, r18
    2f88:	20 81       	ld	r18, Z
    2f8a:	24 60       	ori	r18, 0x04	; 4
    2f8c:	fc 01       	movw	r30, r24
    2f8e:	20 83       	st	Z, r18
    2f90:	8d e6       	ldi	r24, 0x6D	; 109
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	22 e0       	ldi	r18, 0x02	; 2
    2f96:	fc 01       	movw	r30, r24
    2f98:	20 83       	st	Z, r18
		}//end send to GAVR case

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    2f9a:	80 91 fe 01 	lds	r24, 0x01FE
    2f9e:	88 23       	and	r24, r24
    2fa0:	49 f1       	breq	.+82     	; 0x2ff4 <main+0x1e0>
			if (currentTime.getMinutes()%30 == 0){
    2fa2:	84 ed       	ldi	r24, 0xD4	; 212
    2fa4:	91 e0       	ldi	r25, 0x01	; 1
    2fa6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    2faa:	9e e1       	ldi	r25, 0x1E	; 30
    2fac:	69 2f       	mov	r22, r25
    2fae:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <__udivmodqi4>
    2fb2:	89 2f       	mov	r24, r25
    2fb4:	98 2f       	mov	r25, r24
    2fb6:	81 e0       	ldi	r24, 0x01	; 1
    2fb8:	99 23       	and	r25, r25
    2fba:	09 f0       	breq	.+2      	; 0x2fbe <main+0x1aa>
    2fbc:	80 e0       	ldi	r24, 0x00	; 0
    2fbe:	88 23       	and	r24, r24
    2fc0:	c9 f0       	breq	.+50     	; 0x2ff4 <main+0x1e0>
				if (currentTime.getHours()%12 == 0){
    2fc2:	84 ed       	ldi	r24, 0xD4	; 212
    2fc4:	91 e0       	ldi	r25, 0x01	; 1
    2fc6:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    2fca:	9c e0       	ldi	r25, 0x0C	; 12
    2fcc:	69 2f       	mov	r22, r25
    2fce:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <__udivmodqi4>
    2fd2:	89 2f       	mov	r24, r25
    2fd4:	98 2f       	mov	r25, r24
    2fd6:	81 e0       	ldi	r24, 0x01	; 1
    2fd8:	99 23       	and	r25, r25
    2fda:	09 f0       	breq	.+2      	; 0x2fde <main+0x1ca>
    2fdc:	80 e0       	ldi	r24, 0x00	; 0
    2fde:	88 23       	and	r24, r24
    2fe0:	29 f0       	breq	.+10     	; 0x2fec <main+0x1d8>
					saveDateTime_eeprom(fTrue,fTrue);
    2fe2:	81 e0       	ldi	r24, 0x01	; 1
    2fe4:	61 e0       	ldi	r22, 0x01	; 1
    2fe6:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    2fea:	04 c0       	rjmp	.+8      	; 0x2ff4 <main+0x1e0>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    2fec:	81 e0       	ldi	r24, 0x01	; 1
    2fee:	60 e0       	ldi	r22, 0x00	; 0
    2ff0:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}//end time capture/save

		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    2ff4:	80 91 fe 01 	lds	r24, 0x01FE
    2ff8:	88 23       	and	r24, r24
    2ffa:	09 f1       	breq	.+66     	; 0x303e <main+0x22a>
			TakeADC();
    2ffc:	0e 94 98 1a 	call	0x3530	; 0x3530 <_Z7TakeADCv>
			//GetTemp();
			flagGoodTemp=fTrue;
    3000:	81 e0       	ldi	r24, 0x01	; 1
    3002:	80 93 0b 02 	sts	0x020B, r24
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    3006:	80 91 0c 02 	lds	r24, 0x020C
    300a:	88 23       	and	r24, r24
    300c:	71 f0       	breq	.+28     	; 0x302a <main+0x216>
    300e:	80 91 0b 02 	lds	r24, 0x020B
    3012:	88 23       	and	r24, r24
    3014:	51 f0       	breq	.+20     	; 0x302a <main+0x216>
				if(flagShutdown){restart = fTrue; flagShutdown=fFalse;}
    3016:	80 91 0a 02 	lds	r24, 0x020A
    301a:	88 23       	and	r24, r24
    301c:	81 f0       	breq	.+32     	; 0x303e <main+0x22a>
    301e:	81 e0       	ldi	r24, 0x01	; 1
    3020:	80 93 0d 02 	sts	0x020D, r24
    3024:	10 92 0a 02 	sts	0x020A, r1
    3028:	0a c0       	rjmp	.+20     	; 0x303e <main+0x22a>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (!flagShutdown){
    302a:	80 91 0a 02 	lds	r24, 0x020A
    302e:	88 23       	and	r24, r24
    3030:	31 f4       	brne	.+12     	; 0x303e <main+0x22a>
					flagNewShutdown = fTrue;
    3032:	81 e0       	ldi	r24, 0x01	; 1
    3034:	80 93 09 02 	sts	0x0209, r24
					flagShutdown=fTrue;
    3038:	81 e0       	ldi	r24, 0x01	; 1
    303a:	80 93 0a 02 	sts	0x020A, r24
				}
			}
		}//end normal mode Check Analog Signals		
		
		//Waiting...
		Wait_ms(2000);
    303e:	80 ed       	ldi	r24, 0xD0	; 208
    3040:	97 e0       	ldi	r25, 0x07	; 7
    3042:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
				
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    3046:	80 91 09 02 	lds	r24, 0x0209
    304a:	88 23       	and	r24, r24
    304c:	b9 f0       	breq	.+46     	; 0x307c <main+0x268>
			//Make sure nothing messes with the routine that we care about
			__killCommINT();
    304e:	8d e3       	ldi	r24, 0x3D	; 61
    3050:	90 e0       	ldi	r25, 0x00	; 0
    3052:	fc 01       	movw	r30, r24
    3054:	10 82       	st	Z, r1
    3056:	8d e6       	ldi	r24, 0x6D	; 109
    3058:	90 e0       	ldi	r25, 0x00	; 0
    305a:	fc 01       	movw	r30, r24
    305c:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    305e:	81 e0       	ldi	r24, 0x01	; 1
    3060:	80 93 fc 01 	sts	0x01FC, r24
			flagReceivingBone = fFalse;
    3064:	10 92 fd 01 	sts	0x01FD, r1
			flagUserClock=fFalse;						//reset this so next boot is correct. Done in restart case as well for redundancy
    3068:	10 92 05 02 	sts	0x0205, r1
			saveDateTime_eeprom(fTrue,fTrue);
    306c:	81 e0       	ldi	r24, 0x01	; 1
    306e:	61 e0       	ldi	r22, 0x01	; 1
    3070:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
			
			//Kill power--Alert comes in that function
			PowerDown();
    3074:	0e 94 59 1c 	call	0x38b2	; 0x38b2 <_Z9PowerDownv>
			flagNewShutdown = fFalse;
    3078:	10 92 09 02 	sts	0x0209, r1
		}//end new shutdown
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    307c:	80 91 0d 02 	lds	r24, 0x020D
    3080:	88 23       	and	r24, r24
    3082:	c9 f0       	breq	.+50     	; 0x30b6 <main+0x2a2>
			//Enable COmmunication protocols and then power up. Power up specifies the timing for it to happen	
			PowerUp(POWER_UP_INTERVAL);
    3084:	83 e0       	ldi	r24, 0x03	; 3
    3086:	90 e0       	ldi	r25, 0x00	; 0
    3088:	0e 94 03 1c 	call	0x3806	; 0x3806 <_Z7PowerUpj>
			__enableCommINT();
    308c:	8d e3       	ldi	r24, 0x3D	; 61
    308e:	90 e0       	ldi	r25, 0x00	; 0
    3090:	2d e3       	ldi	r18, 0x3D	; 61
    3092:	30 e0       	ldi	r19, 0x00	; 0
    3094:	f9 01       	movw	r30, r18
    3096:	20 81       	ld	r18, Z
    3098:	24 60       	ori	r18, 0x04	; 4
    309a:	fc 01       	movw	r30, r24
    309c:	20 83       	st	Z, r18
    309e:	8d e6       	ldi	r24, 0x6D	; 109
    30a0:	90 e0       	ldi	r25, 0x00	; 0
    30a2:	22 e0       	ldi	r18, 0x02	; 2
    30a4:	fc 01       	movw	r30, r24
    30a6:	20 83       	st	Z, r18
			//Update the GAVRClock since it's a restart, we have the correct date and time. If BeagleBone sends GPS data, use that to back it up.
			flagUpdateGAVRClock=fTrue;
    30a8:	81 e0       	ldi	r24, 0x01	; 1
    30aa:	80 93 03 02 	sts	0x0203, r24
			flagUserClock=fFalse;	
    30ae:	10 92 05 02 	sts	0x0205, r1
			restart=fFalse;	
    30b2:	10 92 0d 02 	sts	0x020D, r1
		}//end restart		
		
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep && !flagUserClock){GoToSleep(flagShutdown);}
    30b6:	80 91 fc 01 	lds	r24, 0x01FC
    30ba:	88 23       	and	r24, r24
    30bc:	41 f0       	breq	.+16     	; 0x30ce <main+0x2ba>
    30be:	80 91 05 02 	lds	r24, 0x0205
    30c2:	88 23       	and	r24, r24
    30c4:	21 f4       	brne	.+8      	; 0x30ce <main+0x2ba>
    30c6:	80 91 0a 02 	lds	r24, 0x020A
    30ca:	0e 94 3a 1a 	call	0x3474	; 0x3474 <_Z9GoToSleeph>
		
		//Add logic for an invalid date and time somehow getting in here
		if (flagInvalidDateTime && !flagShutdown){
    30ce:	80 91 06 02 	lds	r24, 0x0206
    30d2:	88 23       	and	r24, r24
    30d4:	09 f4       	brne	.+2      	; 0x30d8 <main+0x2c4>
    30d6:	f0 ce       	rjmp	.-544    	; 0x2eb8 <main+0xa4>
    30d8:	80 91 0a 02 	lds	r24, 0x020A
    30dc:	88 23       	and	r24, r24
    30de:	09 f0       	breq	.+2      	; 0x30e2 <main+0x2ce>
    30e0:	eb ce       	rjmp	.-554    	; 0x2eb8 <main+0xa4>
			flagInvalidDateTime=fFalse;
    30e2:	10 92 06 02 	sts	0x0206, r1
			flagUserClock=fTrue;
    30e6:	81 e0       	ldi	r24, 0x01	; 1
    30e8:	80 93 05 02 	sts	0x0205, r24
			flagUpdateGAVRClock=fFalse;
    30ec:	10 92 03 02 	sts	0x0203, r1
		flagFreshStart=fFalse;
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
	//main programming loop
	while(fTrue)
    30f0:	e3 ce       	rjmp	.-570    	; 0x2eb8 <main+0xa4>

000030f2 <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    30f2:	cf 93       	push	r28
    30f4:	df 93       	push	r29
    30f6:	cd b7       	in	r28, 0x3d	; 61
    30f8:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    30fa:	81 e2       	ldi	r24, 0x21	; 33
    30fc:	90 e0       	ldi	r25, 0x00	; 0
    30fe:	fc 01       	movw	r30, r24
    3100:	10 82       	st	Z, r1
	DDRB = 0;
    3102:	84 e2       	ldi	r24, 0x24	; 36
    3104:	90 e0       	ldi	r25, 0x00	; 0
    3106:	fc 01       	movw	r30, r24
    3108:	10 82       	st	Z, r1
	DDRC = 0;
    310a:	87 e2       	ldi	r24, 0x27	; 39
    310c:	90 e0       	ldi	r25, 0x00	; 0
    310e:	fc 01       	movw	r30, r24
    3110:	10 82       	st	Z, r1
	DDRD = 0;
    3112:	8a e2       	ldi	r24, 0x2A	; 42
    3114:	90 e0       	ldi	r25, 0x00	; 0
    3116:	fc 01       	movw	r30, r24
    3118:	10 82       	st	Z, r1
	
	PORTA = 0;
    311a:	82 e2       	ldi	r24, 0x22	; 34
    311c:	90 e0       	ldi	r25, 0x00	; 0
    311e:	fc 01       	movw	r30, r24
    3120:	10 82       	st	Z, r1
	PORTB = 0;
    3122:	85 e2       	ldi	r24, 0x25	; 37
    3124:	90 e0       	ldi	r25, 0x00	; 0
    3126:	fc 01       	movw	r30, r24
    3128:	10 82       	st	Z, r1
	PORTC = 0;
    312a:	88 e2       	ldi	r24, 0x28	; 40
    312c:	90 e0       	ldi	r25, 0x00	; 0
    312e:	fc 01       	movw	r30, r24
    3130:	10 82       	st	Z, r1
	PORTD = 0;
    3132:	8b e2       	ldi	r24, 0x2B	; 43
    3134:	90 e0       	ldi	r25, 0x00	; 0
    3136:	fc 01       	movw	r30, r24
    3138:	10 82       	st	Z, r1
}
    313a:	df 91       	pop	r29
    313c:	cf 91       	pop	r28
    313e:	08 95       	ret

00003140 <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    3140:	cf 93       	push	r28
    3142:	df 93       	push	r29
    3144:	00 d0       	rcall	.+0      	; 0x3146 <_Z7AppInitj+0x6>
    3146:	cd b7       	in	r28, 0x3d	; 61
    3148:	de b7       	in	r29, 0x3e	; 62
    314a:	9a 83       	std	Y+2, r25	; 0x02
    314c:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    314e:	84 ec       	ldi	r24, 0xC4	; 196
    3150:	90 e0       	ldi	r25, 0x00	; 0
    3152:	29 81       	ldd	r18, Y+1	; 0x01
    3154:	fc 01       	movw	r30, r24
    3156:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    3158:	85 ec       	ldi	r24, 0xC5	; 197
    315a:	90 e0       	ldi	r25, 0x00	; 0
    315c:	29 81       	ldd	r18, Y+1	; 0x01
    315e:	3a 81       	ldd	r19, Y+2	; 0x02
    3160:	23 2f       	mov	r18, r19
    3162:	33 27       	eor	r19, r19
    3164:	fc 01       	movw	r30, r24
    3166:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    3168:	81 ec       	ldi	r24, 0xC1	; 193
    316a:	90 e0       	ldi	r25, 0x00	; 0
    316c:	28 e1       	ldi	r18, 0x18	; 24
    316e:	fc 01       	movw	r30, r24
    3170:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    3172:	82 ec       	ldi	r24, 0xC2	; 194
    3174:	90 e0       	ldi	r25, 0x00	; 0
    3176:	26 e0       	ldi	r18, 0x06	; 6
    3178:	fc 01       	movw	r30, r24
    317a:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Set BAUD for UART1
	UBRR1L = ubrr;
    317c:	8c ec       	ldi	r24, 0xCC	; 204
    317e:	90 e0       	ldi	r25, 0x00	; 0
    3180:	29 81       	ldd	r18, Y+1	; 0x01
    3182:	fc 01       	movw	r30, r24
    3184:	20 83       	st	Z, r18
	UBRR1H = (ubrr >> 8);
    3186:	8d ec       	ldi	r24, 0xCD	; 205
    3188:	90 e0       	ldi	r25, 0x00	; 0
    318a:	29 81       	ldd	r18, Y+1	; 0x01
    318c:	3a 81       	ldd	r19, Y+2	; 0x02
    318e:	23 2f       	mov	r18, r19
    3190:	33 27       	eor	r19, r19
    3192:	fc 01       	movw	r30, r24
    3194:	20 83       	st	Z, r18
	//UCSR1A |= (1 << U2X1);
	
	//Enable UART_TX1 and UART_RX1
	UCSR1B = (1 << TXEN1)|(1 << RXEN1);
    3196:	89 ec       	ldi	r24, 0xC9	; 201
    3198:	90 e0       	ldi	r25, 0x00	; 0
    319a:	28 e1       	ldi	r18, 0x18	; 24
    319c:	fc 01       	movw	r30, r24
    319e:	20 83       	st	Z, r18
	UCSR1C = (1 << UCSZ11)|(1 << UCSZ10);
    31a0:	8a ec       	ldi	r24, 0xCA	; 202
    31a2:	90 e0       	ldi	r25, 0x00	; 0
    31a4:	26 e0       	ldi	r18, 0x06	; 6
    31a6:	fc 01       	movw	r30, r24
    31a8:	20 83       	st	Z, r18
	//UCSR1B |= (1 << RXCIE1);
	__killUARTrec();
    31aa:	81 ec       	ldi	r24, 0xC1	; 193
    31ac:	90 e0       	ldi	r25, 0x00	; 0
    31ae:	21 ec       	ldi	r18, 0xC1	; 193
    31b0:	30 e0       	ldi	r19, 0x00	; 0
    31b2:	f9 01       	movw	r30, r18
    31b4:	20 81       	ld	r18, Z
    31b6:	20 68       	ori	r18, 0x80	; 128
    31b8:	fc 01       	movw	r30, r24
    31ba:	20 83       	st	Z, r18
    31bc:	89 ec       	ldi	r24, 0xC9	; 201
    31be:	90 e0       	ldi	r25, 0x00	; 0
    31c0:	29 ec       	ldi	r18, 0xC9	; 201
    31c2:	30 e0       	ldi	r19, 0x00	; 0
    31c4:	f9 01       	movw	r30, r18
    31c6:	20 81       	ld	r18, Z
    31c8:	20 68       	ori	r18, 0x80	; 128
    31ca:	fc 01       	movw	r30, r24
    31cc:	20 83       	st	Z, r18
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM0)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    31ce:	84 e6       	ldi	r24, 0x64	; 100
    31d0:	90 e0       	ldi	r25, 0x00	; 0
    31d2:	24 e6       	ldi	r18, 0x64	; 100
    31d4:	30 e0       	ldi	r19, 0x00	; 0
    31d6:	f9 01       	movw	r30, r18
    31d8:	20 81       	ld	r18, Z
    31da:	2d 6a       	ori	r18, 0xAD	; 173
    31dc:	fc 01       	movw	r30, r24
    31de:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    31e0:	8a e2       	ldi	r24, 0x2A	; 42
    31e2:	90 e0       	ldi	r25, 0x00	; 0
    31e4:	2a e2       	ldi	r18, 0x2A	; 42
    31e6:	30 e0       	ldi	r19, 0x00	; 0
    31e8:	f9 01       	movw	r30, r18
    31ea:	20 81       	ld	r18, Z
    31ec:	20 68       	ori	r18, 0x80	; 128
    31ee:	fc 01       	movw	r30, r24
    31f0:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    31f2:	87 e2       	ldi	r24, 0x27	; 39
    31f4:	90 e0       	ldi	r25, 0x00	; 0
    31f6:	27 e2       	ldi	r18, 0x27	; 39
    31f8:	30 e0       	ldi	r19, 0x00	; 0
    31fa:	f9 01       	movw	r30, r18
    31fc:	20 81       	ld	r18, Z
    31fe:	24 60       	ori	r18, 0x04	; 4
    3200:	fc 01       	movw	r30, r24
    3202:	20 83       	st	Z, r18
	prtSLEEPled |= (1 << bnSLEEPled);	//turn off initially
    3204:	8b e2       	ldi	r24, 0x2B	; 43
    3206:	90 e0       	ldi	r25, 0x00	; 0
    3208:	2b e2       	ldi	r18, 0x2B	; 43
    320a:	30 e0       	ldi	r19, 0x00	; 0
    320c:	f9 01       	movw	r30, r18
    320e:	20 81       	ld	r18, Z
    3210:	20 68       	ori	r18, 0x80	; 128
    3212:	fc 01       	movw	r30, r24
    3214:	20 83       	st	Z, r18
	prtSTATUSled &= ~(1 << bnSTATUSled);	//turn on initially
    3216:	88 e2       	ldi	r24, 0x28	; 40
    3218:	90 e0       	ldi	r25, 0x00	; 0
    321a:	28 e2       	ldi	r18, 0x28	; 40
    321c:	30 e0       	ldi	r19, 0x00	; 0
    321e:	f9 01       	movw	r30, r18
    3220:	20 81       	ld	r18, Z
    3222:	2b 7f       	andi	r18, 0xFB	; 251
    3224:	fc 01       	movw	r30, r24
    3226:	20 83       	st	Z, r18
	
	//Enable BB and GAVR interrupts for COMMUNICATION
	ddrBONEINT |= (1 << bnBONEINT);
    3228:	81 e2       	ldi	r24, 0x21	; 33
    322a:	90 e0       	ldi	r25, 0x00	; 0
    322c:	21 e2       	ldi	r18, 0x21	; 33
    322e:	30 e0       	ldi	r19, 0x00	; 0
    3230:	f9 01       	movw	r30, r18
    3232:	20 81       	ld	r18, Z
    3234:	22 60       	ori	r18, 0x02	; 2
    3236:	fc 01       	movw	r30, r24
    3238:	20 83       	st	Z, r18
	ddrGAVRINT |= (1 << bnGAVRINT);
    323a:	84 e2       	ldi	r24, 0x24	; 36
    323c:	90 e0       	ldi	r25, 0x00	; 0
    323e:	24 e2       	ldi	r18, 0x24	; 36
    3240:	30 e0       	ldi	r19, 0x00	; 0
    3242:	f9 01       	movw	r30, r18
    3244:	20 81       	ld	r18, Z
    3246:	28 60       	ori	r18, 0x08	; 8
    3248:	fc 01       	movw	r30, r24
    324a:	20 83       	st	Z, r18
	prtBONEINT &= ~(1 << bnBONEINT);
    324c:	82 e2       	ldi	r24, 0x22	; 34
    324e:	90 e0       	ldi	r25, 0x00	; 0
    3250:	22 e2       	ldi	r18, 0x22	; 34
    3252:	30 e0       	ldi	r19, 0x00	; 0
    3254:	f9 01       	movw	r30, r18
    3256:	20 81       	ld	r18, Z
    3258:	2d 7f       	andi	r18, 0xFD	; 253
    325a:	fc 01       	movw	r30, r24
    325c:	20 83       	st	Z, r18
	prtGAVRINT &= ~(1 << bnGAVRINT);
    325e:	85 e2       	ldi	r24, 0x25	; 37
    3260:	90 e0       	ldi	r25, 0x00	; 0
    3262:	25 e2       	ldi	r18, 0x25	; 37
    3264:	30 e0       	ldi	r19, 0x00	; 0
    3266:	f9 01       	movw	r30, r18
    3268:	20 81       	ld	r18, Z
    326a:	27 7f       	andi	r18, 0xF7	; 247
    326c:	fc 01       	movw	r30, r24
    326e:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrInterrupts |= (1 << bnGAVRint)|(1 << bnBBint);
    3270:	81 e2       	ldi	r24, 0x21	; 33
    3272:	90 e0       	ldi	r25, 0x00	; 0
    3274:	21 e2       	ldi	r18, 0x21	; 33
    3276:	30 e0       	ldi	r19, 0x00	; 0
    3278:	f9 01       	movw	r30, r18
    327a:	20 81       	ld	r18, Z
    327c:	2c 60       	ori	r18, 0x0C	; 12
    327e:	fc 01       	movw	r30, r24
    3280:	20 83       	st	Z, r18
	prtInterrupts &= ~((1 << bnGAVRint)|(1 << bnBBint));
    3282:	82 e2       	ldi	r24, 0x22	; 34
    3284:	90 e0       	ldi	r25, 0x00	; 0
    3286:	22 e2       	ldi	r18, 0x22	; 34
    3288:	30 e0       	ldi	r19, 0x00	; 0
    328a:	f9 01       	movw	r30, r18
    328c:	20 81       	ld	r18, Z
    328e:	23 7f       	andi	r18, 0xF3	; 243
    3290:	fc 01       	movw	r30, r24
    3292:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen)|(1 << bnBBen);
    3294:	81 e2       	ldi	r24, 0x21	; 33
    3296:	90 e0       	ldi	r25, 0x00	; 0
    3298:	21 e2       	ldi	r18, 0x21	; 33
    329a:	30 e0       	ldi	r19, 0x00	; 0
    329c:	f9 01       	movw	r30, r18
    329e:	20 81       	ld	r18, Z
    32a0:	20 6f       	ori	r18, 0xF0	; 240
    32a2:	fc 01       	movw	r30, r24
    32a4:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    32a6:	84 e2       	ldi	r24, 0x24	; 36
    32a8:	90 e0       	ldi	r25, 0x00	; 0
    32aa:	24 e2       	ldi	r18, 0x24	; 36
    32ac:	30 e0       	ldi	r19, 0x00	; 0
    32ae:	f9 01       	movw	r30, r18
    32b0:	20 81       	ld	r18, Z
    32b2:	21 60       	ori	r18, 0x01	; 1
    32b4:	fc 01       	movw	r30, r24
    32b6:	20 83       	st	Z, r18
	ddrMAINen |= (1 << bnMAINen);
    32b8:	87 e2       	ldi	r24, 0x27	; 39
    32ba:	90 e0       	ldi	r25, 0x00	; 0
    32bc:	27 e2       	ldi	r18, 0x27	; 39
    32be:	30 e0       	ldi	r19, 0x00	; 0
    32c0:	f9 01       	movw	r30, r18
    32c2:	20 81       	ld	r18, Z
    32c4:	21 60       	ori	r18, 0x01	; 1
    32c6:	fc 01       	movw	r30, r24
    32c8:	20 83       	st	Z, r18
	__killMain();
    32ca:	88 e2       	ldi	r24, 0x28	; 40
    32cc:	90 e0       	ldi	r25, 0x00	; 0
    32ce:	28 e2       	ldi	r18, 0x28	; 40
    32d0:	30 e0       	ldi	r19, 0x00	; 0
    32d2:	f9 01       	movw	r30, r18
    32d4:	20 81       	ld	r18, Z
    32d6:	2e 7f       	andi	r18, 0xFE	; 254
    32d8:	fc 01       	movw	r30, r24
    32da:	20 83       	st	Z, r18
	__killBeagleBone();
    32dc:	82 e2       	ldi	r24, 0x22	; 34
    32de:	90 e0       	ldi	r25, 0x00	; 0
    32e0:	22 e2       	ldi	r18, 0x22	; 34
    32e2:	30 e0       	ldi	r19, 0x00	; 0
    32e4:	f9 01       	movw	r30, r18
    32e6:	20 81       	ld	r18, Z
    32e8:	2f 7e       	andi	r18, 0xEF	; 239
    32ea:	fc 01       	movw	r30, r24
    32ec:	20 83       	st	Z, r18
	__enableTemp();
    32ee:	85 e2       	ldi	r24, 0x25	; 37
    32f0:	90 e0       	ldi	r25, 0x00	; 0
    32f2:	25 e2       	ldi	r18, 0x25	; 37
    32f4:	30 e0       	ldi	r19, 0x00	; 0
    32f6:	f9 01       	movw	r30, r18
    32f8:	20 81       	ld	r18, Z
    32fa:	21 60       	ori	r18, 0x01	; 1
    32fc:	fc 01       	movw	r30, r24
    32fe:	20 83       	st	Z, r18
	__killLCD();
    3300:	82 e2       	ldi	r24, 0x22	; 34
    3302:	90 e0       	ldi	r25, 0x00	; 0
    3304:	22 e2       	ldi	r18, 0x22	; 34
    3306:	30 e0       	ldi	r19, 0x00	; 0
    3308:	f9 01       	movw	r30, r18
    330a:	20 81       	ld	r18, Z
    330c:	2f 7d       	andi	r18, 0xDF	; 223
    330e:	fc 01       	movw	r30, r24
    3310:	20 83       	st	Z, r18
	__killGPSandGAVR();
    3312:	82 e2       	ldi	r24, 0x22	; 34
    3314:	90 e0       	ldi	r25, 0x00	; 0
    3316:	22 e2       	ldi	r18, 0x22	; 34
    3318:	30 e0       	ldi	r19, 0x00	; 0
    331a:	f9 01       	movw	r30, r18
    331c:	20 81       	ld	r18, Z
    331e:	2f 73       	andi	r18, 0x3F	; 63
    3320:	fc 01       	movw	r30, r24
    3322:	20 83       	st	Z, r18

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	__killCommINT();
    3324:	8d e3       	ldi	r24, 0x3D	; 61
    3326:	90 e0       	ldi	r25, 0x00	; 0
    3328:	fc 01       	movw	r30, r24
    332a:	10 82       	st	Z, r1
    332c:	8d e6       	ldi	r24, 0x6D	; 109
    332e:	90 e0       	ldi	r25, 0x00	; 0
    3330:	fc 01       	movw	r30, r24
    3332:	10 82       	st	Z, r1
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    3334:	89 e6       	ldi	r24, 0x69	; 105
    3336:	90 e0       	ldi	r25, 0x00	; 0
    3338:	20 e3       	ldi	r18, 0x30	; 48
    333a:	fc 01       	movw	r30, r24
    333c:	20 83       	st	Z, r18
	//Enable PCINT17
	PCICR |= (1 << PCIE2);
    333e:	88 e6       	ldi	r24, 0x68	; 104
    3340:	90 e0       	ldi	r25, 0x00	; 0
    3342:	28 e6       	ldi	r18, 0x68	; 104
    3344:	30 e0       	ldi	r19, 0x00	; 0
    3346:	f9 01       	movw	r30, r18
    3348:	20 81       	ld	r18, Z
    334a:	24 60       	ori	r18, 0x04	; 4
    334c:	fc 01       	movw	r30, r24
    334e:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    3350:	84 e2       	ldi	r24, 0x24	; 36
    3352:	90 e0       	ldi	r25, 0x00	; 0
    3354:	24 e2       	ldi	r18, 0x24	; 36
    3356:	30 e0       	ldi	r19, 0x00	; 0
    3358:	f9 01       	movw	r30, r18
    335a:	20 81       	ld	r18, Z
    335c:	20 6b       	ori	r18, 0xB0	; 176
    335e:	fc 01       	movw	r30, r24
    3360:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    3362:	84 e2       	ldi	r24, 0x24	; 36
    3364:	90 e0       	ldi	r25, 0x00	; 0
    3366:	24 e2       	ldi	r18, 0x24	; 36
    3368:	30 e0       	ldi	r19, 0x00	; 0
    336a:	f9 01       	movw	r30, r18
    336c:	20 81       	ld	r18, Z
    336e:	2f 7b       	andi	r18, 0xBF	; 191
    3370:	fc 01       	movw	r30, r24
    3372:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    3374:	85 e2       	ldi	r24, 0x25	; 37
    3376:	90 e0       	ldi	r25, 0x00	; 0
    3378:	25 e2       	ldi	r18, 0x25	; 37
    337a:	30 e0       	ldi	r19, 0x00	; 0
    337c:	f9 01       	movw	r30, r18
    337e:	20 81       	ld	r18, Z
    3380:	20 69       	ori	r18, 0x90	; 144
    3382:	fc 01       	movw	r30, r24
    3384:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    3386:	85 e2       	ldi	r24, 0x25	; 37
    3388:	90 e0       	ldi	r25, 0x00	; 0
    338a:	25 e2       	ldi	r18, 0x25	; 37
    338c:	30 e0       	ldi	r19, 0x00	; 0
    338e:	f9 01       	movw	r30, r18
    3390:	20 81       	ld	r18, Z
    3392:	2f 7d       	andi	r18, 0xDF	; 223
    3394:	fc 01       	movw	r30, r24
    3396:	20 83       	st	Z, r18
	
}
    3398:	0f 90       	pop	r0
    339a:	0f 90       	pop	r0
    339c:	df 91       	pop	r29
    339e:	cf 91       	pop	r28
    33a0:	08 95       	ret

000033a2 <_Z9InitBoolsv>:
/*************************************************************************************************************/
void InitBools(){
    33a2:	cf 93       	push	r28
    33a4:	df 93       	push	r29
    33a6:	cd b7       	in	r28, 0x3d	; 61
    33a8:	de b7       	in	r29, 0x3e	; 62
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    33aa:	81 e0       	ldi	r24, 0x01	; 1
    33ac:	80 93 fc 01 	sts	0x01FC, r24
	flagReceivingBone = fFalse;
    33b0:	10 92 fd 01 	sts	0x01FD, r1
	flagNormalMode=fTrue;
    33b4:	81 e0       	ldi	r24, 0x01	; 1
    33b6:	80 93 fe 01 	sts	0x01FE, r24
	flagReceivingGAVR=fFalse;
    33ba:	10 92 ff 01 	sts	0x01FF, r1
	flagWaitingForReceiveGAVR=fFalse;
    33be:	10 92 00 02 	sts	0x0200, r1
	flagWaitingForSYNGAVR=fFalse;
    33c2:	10 92 01 02 	sts	0x0201, r1
	flagWaitingForSYNBone=fFalse;
    33c6:	10 92 02 02 	sts	0x0202, r1

	flagUpdateGAVRClock=fFalse;
    33ca:	10 92 03 02 	sts	0x0203, r1
	flagSendingGAVR=fFalse;
    33ce:	10 92 04 02 	sts	0x0204, r1
	flagUserClock=fFalse;
    33d2:	10 92 05 02 	sts	0x0205, r1
	flagInvalidDateTime=fFalse;
    33d6:	10 92 06 02 	sts	0x0206, r1
	flagWaitingToSendGAVR=fFalse;
    33da:	10 92 07 02 	sts	0x0207, r1
	flagGPSTime=fFalse;
    33de:	10 92 08 02 	sts	0x0208, r1
	
	restart=fFalse;
    33e2:	10 92 0d 02 	sts	0x020D, r1
	//flagNewShutdown=fFalse;
	flagShutdown=fFalse;		//Initialized in startup procedure in beginning of "main"
    33e6:	10 92 0a 02 	sts	0x020A, r1
	flagGoodVolts=fFalse;
    33ea:	10 92 0c 02 	sts	0x020C, r1
	flagGoodTemp=fFalse;
    33ee:	10 92 0b 02 	sts	0x020B, r1
	//flagFreshStart=fTrue;		//Initialized in startup procedure in beginning of "main"
}
    33f2:	df 91       	pop	r29
    33f4:	cf 91       	pop	r28
    33f6:	08 95       	ret

000033f8 <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    33f8:	cf 93       	push	r28
    33fa:	df 93       	push	r29
    33fc:	cd b7       	in	r28, 0x3d	; 61
    33fe:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    3400:	84 e6       	ldi	r24, 0x64	; 100
    3402:	90 e0       	ldi	r25, 0x00	; 0
    3404:	24 e6       	ldi	r18, 0x64	; 100
    3406:	30 e0       	ldi	r19, 0x00	; 0
    3408:	f9 01       	movw	r30, r18
    340a:	20 81       	ld	r18, Z
    340c:	2f 7b       	andi	r18, 0xBF	; 191
    340e:	fc 01       	movw	r30, r24
    3410:	20 83       	st	Z, r18
	Wait_ms(5);	//give it time to power on
    3412:	85 e0       	ldi	r24, 0x05	; 5
    3414:	90 e0       	ldi	r25, 0x00	; 0
    3416:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    341a:	86 eb       	ldi	r24, 0xB6	; 182
    341c:	90 e0       	ldi	r25, 0x00	; 0
    341e:	26 eb       	ldi	r18, 0xB6	; 182
    3420:	30 e0       	ldi	r19, 0x00	; 0
    3422:	f9 01       	movw	r30, r18
    3424:	20 81       	ld	r18, Z
    3426:	20 62       	ori	r18, 0x20	; 32
    3428:	fc 01       	movw	r30, r24
    342a:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    342c:	81 eb       	ldi	r24, 0xB1	; 177
    342e:	90 e0       	ldi	r25, 0x00	; 0
    3430:	21 eb       	ldi	r18, 0xB1	; 177
    3432:	30 e0       	ldi	r19, 0x00	; 0
    3434:	f9 01       	movw	r30, r18
    3436:	20 81       	ld	r18, Z
    3438:	25 60       	ori	r18, 0x05	; 5
    343a:	fc 01       	movw	r30, r24
    343c:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    343e:	86 eb       	ldi	r24, 0xB6	; 182
    3440:	90 e0       	ldi	r25, 0x00	; 0
    3442:	fc 01       	movw	r30, r24
    3444:	80 81       	ld	r24, Z
    3446:	88 2f       	mov	r24, r24
    3448:	90 e0       	ldi	r25, 0x00	; 0
    344a:	81 71       	andi	r24, 0x11	; 17
    344c:	90 70       	andi	r25, 0x00	; 0
    344e:	21 e0       	ldi	r18, 0x01	; 1
    3450:	00 97       	sbiw	r24, 0x00	; 0
    3452:	09 f4       	brne	.+2      	; 0x3456 <_Z14EnableRTCTimerv+0x5e>
    3454:	20 e0       	ldi	r18, 0x00	; 0
    3456:	22 23       	and	r18, r18
    3458:	91 f7       	brne	.-28     	; 0x343e <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    345a:	87 e3       	ldi	r24, 0x37	; 55
    345c:	90 e0       	ldi	r25, 0x00	; 0
    345e:	21 e0       	ldi	r18, 0x01	; 1
    3460:	fc 01       	movw	r30, r24
    3462:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    3464:	80 e7       	ldi	r24, 0x70	; 112
    3466:	90 e0       	ldi	r25, 0x00	; 0
    3468:	21 e0       	ldi	r18, 0x01	; 1
    346a:	fc 01       	movw	r30, r24
    346c:	20 83       	st	Z, r18
	
	//Away we go
}
    346e:	df 91       	pop	r29
    3470:	cf 91       	pop	r28
    3472:	08 95       	ret

00003474 <_Z9GoToSleeph>:

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    3474:	cf 93       	push	r28
    3476:	df 93       	push	r29
    3478:	00 d0       	rcall	.+0      	; 0x347a <_Z9GoToSleeph+0x6>
    347a:	00 d0       	rcall	.+0      	; 0x347c <_Z9GoToSleeph+0x8>
    347c:	0f 92       	push	r0
    347e:	cd b7       	in	r28, 0x3d	; 61
    3480:	de b7       	in	r29, 0x3e	; 62
    3482:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    3484:	78 94       	sei
		int sleepTime, sleepTicks = 0;
    3486:	1c 82       	std	Y+4, r1	; 0x04
    3488:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong){
    348a:	8d 81       	ldd	r24, Y+5	; 0x05
    348c:	88 23       	and	r24, r24
    348e:	29 f0       	breq	.+10     	; 0x349a <_Z9GoToSleeph+0x26>
			sleepTime = SLEEP_TICKS_LOWV;
    3490:	8c e0       	ldi	r24, 0x0C	; 12
    3492:	90 e0       	ldi	r25, 0x00	; 0
    3494:	9a 83       	std	Y+2, r25	; 0x02
    3496:	89 83       	std	Y+1, r24	; 0x01
    3498:	04 c0       	rjmp	.+8      	; 0x34a2 <_Z9GoToSleeph+0x2e>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    349a:	8a e0       	ldi	r24, 0x0A	; 10
    349c:	90 e0       	ldi	r25, 0x00	; 0
    349e:	9a 83       	std	Y+2, r25	; 0x02
    34a0:	89 83       	std	Y+1, r24	; 0x01
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    34a2:	88 e2       	ldi	r24, 0x28	; 40
    34a4:	90 e0       	ldi	r25, 0x00	; 0
    34a6:	28 e2       	ldi	r18, 0x28	; 40
    34a8:	30 e0       	ldi	r19, 0x00	; 0
    34aa:	f9 01       	movw	r30, r18
    34ac:	20 81       	ld	r18, Z
    34ae:	2b 7f       	andi	r18, 0xFB	; 251
    34b0:	fc 01       	movw	r30, r24
    34b2:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    34b4:	83 e5       	ldi	r24, 0x53	; 83
    34b6:	90 e0       	ldi	r25, 0x00	; 0
    34b8:	26 e0       	ldi	r18, 0x06	; 6
    34ba:	fc 01       	movw	r30, r24
    34bc:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    34be:	83 e5       	ldi	r24, 0x53	; 83
    34c0:	90 e0       	ldi	r25, 0x00	; 0
    34c2:	23 e5       	ldi	r18, 0x53	; 83
    34c4:	30 e0       	ldi	r19, 0x00	; 0
    34c6:	f9 01       	movw	r30, r18
    34c8:	20 81       	ld	r18, Z
    34ca:	21 60       	ori	r18, 0x01	; 1
    34cc:	fc 01       	movw	r30, r24
    34ce:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    34d0:	81 e0       	ldi	r24, 0x01	; 1
    34d2:	90 e0       	ldi	r25, 0x00	; 0
    34d4:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    34d8:	06 c0       	rjmp	.+12     	; 0x34e6 <_Z9GoToSleeph+0x72>
			asm volatile("SLEEP");
    34da:	88 95       	sleep
			sleepTicks++;
    34dc:	8b 81       	ldd	r24, Y+3	; 0x03
    34de:	9c 81       	ldd	r25, Y+4	; 0x04
    34e0:	01 96       	adiw	r24, 0x01	; 1
    34e2:	9c 83       	std	Y+4, r25	; 0x04
    34e4:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    34e6:	2b 81       	ldd	r18, Y+3	; 0x03
    34e8:	3c 81       	ldd	r19, Y+4	; 0x04
    34ea:	89 81       	ldd	r24, Y+1	; 0x01
    34ec:	9a 81       	ldd	r25, Y+2	; 0x02
    34ee:	28 17       	cp	r18, r24
    34f0:	39 07       	cpc	r19, r25
    34f2:	34 f4       	brge	.+12     	; 0x3500 <_Z9GoToSleeph+0x8c>
    34f4:	80 91 fc 01 	lds	r24, 0x01FC
    34f8:	88 23       	and	r24, r24
    34fa:	11 f0       	breq	.+4      	; 0x3500 <_Z9GoToSleeph+0x8c>
    34fc:	81 e0       	ldi	r24, 0x01	; 1
    34fe:	01 c0       	rjmp	.+2      	; 0x3502 <_Z9GoToSleeph+0x8e>
    3500:	80 e0       	ldi	r24, 0x00	; 0
    3502:	88 23       	and	r24, r24
    3504:	51 f7       	brne	.-44     	; 0x34da <_Z9GoToSleeph+0x66>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(1);
    3506:	81 e0       	ldi	r24, 0x01	; 1
    3508:	90 e0       	ldi	r25, 0x00	; 0
    350a:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSTATUSled |= (1 << bnSTATUSled);
    350e:	88 e2       	ldi	r24, 0x28	; 40
    3510:	90 e0       	ldi	r25, 0x00	; 0
    3512:	28 e2       	ldi	r18, 0x28	; 40
    3514:	30 e0       	ldi	r19, 0x00	; 0
    3516:	f9 01       	movw	r30, r18
    3518:	20 81       	ld	r18, Z
    351a:	24 60       	ori	r18, 0x04	; 4
    351c:	fc 01       	movw	r30, r24
    351e:	20 83       	st	Z, r18
}
    3520:	0f 90       	pop	r0
    3522:	0f 90       	pop	r0
    3524:	0f 90       	pop	r0
    3526:	0f 90       	pop	r0
    3528:	0f 90       	pop	r0
    352a:	df 91       	pop	r29
    352c:	cf 91       	pop	r28
    352e:	08 95       	ret

00003530 <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    3530:	cf 93       	push	r28
    3532:	df 93       	push	r29
    3534:	cd b7       	in	r28, 0x3d	; 61
    3536:	de b7       	in	r29, 0x3e	; 62
    3538:	2e 97       	sbiw	r28, 0x0e	; 14
    353a:	0f b6       	in	r0, 0x3f	; 63
    353c:	f8 94       	cli
    353e:	de bf       	out	0x3e, r29	; 62
    3540:	0f be       	out	0x3f, r0	; 63
    3542:	cd bf       	out	0x3d, r28	; 61
	WORD adcReading = 0;
    3544:	1c 82       	std	Y+4, r1	; 0x04
    3546:	1b 82       	std	Y+3, r1	; 0x03
	
	prtInterrupts |= (1 << bnBBint);
    3548:	82 e2       	ldi	r24, 0x22	; 34
    354a:	90 e0       	ldi	r25, 0x00	; 0
    354c:	22 e2       	ldi	r18, 0x22	; 34
    354e:	30 e0       	ldi	r19, 0x00	; 0
    3550:	f9 01       	movw	r30, r18
    3552:	20 81       	ld	r18, Z
    3554:	24 60       	ori	r18, 0x04	; 4
    3556:	fc 01       	movw	r30, r24
    3558:	20 83       	st	Z, r18
	
	__killCommINT();
    355a:	8d e3       	ldi	r24, 0x3D	; 61
    355c:	90 e0       	ldi	r25, 0x00	; 0
    355e:	fc 01       	movw	r30, r24
    3560:	10 82       	st	Z, r1
    3562:	8d e6       	ldi	r24, 0x6D	; 109
    3564:	90 e0       	ldi	r25, 0x00	; 0
    3566:	fc 01       	movw	r30, r24
    3568:	10 82       	st	Z, r1
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    356a:	84 e6       	ldi	r24, 0x64	; 100
    356c:	90 e0       	ldi	r25, 0x00	; 0
    356e:	24 e6       	ldi	r18, 0x64	; 100
    3570:	30 e0       	ldi	r19, 0x00	; 0
    3572:	f9 01       	movw	r30, r18
    3574:	20 81       	ld	r18, Z
    3576:	2e 7f       	andi	r18, 0xFE	; 254
    3578:	fc 01       	movw	r30, r24
    357a:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    357c:	8c e7       	ldi	r24, 0x7C	; 124
    357e:	90 e0       	ldi	r25, 0x00	; 0
    3580:	2c e7       	ldi	r18, 0x7C	; 124
    3582:	30 e0       	ldi	r19, 0x00	; 0
    3584:	f9 01       	movw	r30, r18
    3586:	20 81       	ld	r18, Z
    3588:	20 68       	ori	r18, 0x80	; 128
    358a:	fc 01       	movw	r30, r24
    358c:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    358e:	8a e7       	ldi	r24, 0x7A	; 122
    3590:	90 e0       	ldi	r25, 0x00	; 0
    3592:	2a e7       	ldi	r18, 0x7A	; 122
    3594:	30 e0       	ldi	r19, 0x00	; 0
    3596:	f9 01       	movw	r30, r18
    3598:	20 81       	ld	r18, Z
    359a:	24 68       	ori	r18, 0x84	; 132
    359c:	fc 01       	movw	r30, r24
    359e:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    35a0:	8e e7       	ldi	r24, 0x7E	; 126
    35a2:	90 e0       	ldi	r25, 0x00	; 0
    35a4:	2e ef       	ldi	r18, 0xFE	; 254
    35a6:	fc 01       	movw	r30, r24
    35a8:	20 83       	st	Z, r18
	Wait_ms(2);									//Tim for registers to setup
    35aa:	82 e0       	ldi	r24, 0x02	; 2
    35ac:	90 e0       	ldi	r25, 0x00	; 0
    35ae:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
	
	//cli();
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    35b2:	1a 82       	std	Y+2, r1	; 0x02
    35b4:	19 82       	std	Y+1, r1	; 0x01
    35b6:	1c c0       	rjmp	.+56     	; 0x35f0 <_Z7TakeADCv+0xc0>
    35b8:	8a e7       	ldi	r24, 0x7A	; 122
    35ba:	90 e0       	ldi	r25, 0x00	; 0
    35bc:	2a e7       	ldi	r18, 0x7A	; 122
    35be:	30 e0       	ldi	r19, 0x00	; 0
    35c0:	f9 01       	movw	r30, r18
    35c2:	20 81       	ld	r18, Z
    35c4:	20 64       	ori	r18, 0x40	; 64
    35c6:	fc 01       	movw	r30, r24
    35c8:	20 83       	st	Z, r18
    35ca:	8a e7       	ldi	r24, 0x7A	; 122
    35cc:	90 e0       	ldi	r25, 0x00	; 0
    35ce:	fc 01       	movw	r30, r24
    35d0:	80 81       	ld	r24, Z
    35d2:	88 2f       	mov	r24, r24
    35d4:	90 e0       	ldi	r25, 0x00	; 0
    35d6:	80 74       	andi	r24, 0x40	; 64
    35d8:	90 70       	andi	r25, 0x00	; 0
    35da:	21 e0       	ldi	r18, 0x01	; 1
    35dc:	00 97       	sbiw	r24, 0x00	; 0
    35de:	09 f4       	brne	.+2      	; 0x35e2 <_Z7TakeADCv+0xb2>
    35e0:	20 e0       	ldi	r18, 0x00	; 0
    35e2:	22 23       	and	r18, r18
    35e4:	91 f7       	brne	.-28     	; 0x35ca <_Z7TakeADCv+0x9a>
    35e6:	89 81       	ldd	r24, Y+1	; 0x01
    35e8:	9a 81       	ldd	r25, Y+2	; 0x02
    35ea:	01 96       	adiw	r24, 0x01	; 1
    35ec:	9a 83       	std	Y+2, r25	; 0x02
    35ee:	89 83       	std	Y+1, r24	; 0x01
    35f0:	21 e0       	ldi	r18, 0x01	; 1
    35f2:	89 81       	ldd	r24, Y+1	; 0x01
    35f4:	9a 81       	ldd	r25, Y+2	; 0x02
    35f6:	82 30       	cpi	r24, 0x02	; 2
    35f8:	91 05       	cpc	r25, r1
    35fa:	0c f0       	brlt	.+2      	; 0x35fe <_Z7TakeADCv+0xce>
    35fc:	20 e0       	ldi	r18, 0x00	; 0
    35fe:	22 23       	and	r18, r18
    3600:	d9 f6       	brne	.-74     	; 0x35b8 <_Z7TakeADCv+0x88>
	
	//Re-enable interrupts	
	//sei();
	
	//Put conversion into buffer
	adcReading = ADCL;
    3602:	88 e7       	ldi	r24, 0x78	; 120
    3604:	90 e0       	ldi	r25, 0x00	; 0
    3606:	fc 01       	movw	r30, r24
    3608:	80 81       	ld	r24, Z
    360a:	88 2f       	mov	r24, r24
    360c:	90 e0       	ldi	r25, 0x00	; 0
    360e:	9c 83       	std	Y+4, r25	; 0x04
    3610:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    3612:	89 e7       	ldi	r24, 0x79	; 121
    3614:	90 e0       	ldi	r25, 0x00	; 0
    3616:	fc 01       	movw	r30, r24
    3618:	80 81       	ld	r24, Z
    361a:	88 2f       	mov	r24, r24
    361c:	90 e0       	ldi	r25, 0x00	; 0
    361e:	98 2f       	mov	r25, r24
    3620:	88 27       	eor	r24, r24
    3622:	2b 81       	ldd	r18, Y+3	; 0x03
    3624:	3c 81       	ldd	r19, Y+4	; 0x04
    3626:	82 2b       	or	r24, r18
    3628:	93 2b       	or	r25, r19
    362a:	9c 83       	std	Y+4, r25	; 0x04
    362c:	8b 83       	std	Y+3, r24	; 0x03
		
	//Assign global reading and set flag
	globalADC=adcReading;
    362e:	8b 81       	ldd	r24, Y+3	; 0x03
    3630:	9c 81       	ldd	r25, Y+4	; 0x04
    3632:	90 93 d1 01 	sts	0x01D1, r25
    3636:	80 93 d0 01 	sts	0x01D0, r24
	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    363a:	21 e0       	ldi	r18, 0x01	; 1
    363c:	8b 81       	ldd	r24, Y+3	; 0x03
    363e:	9c 81       	ldd	r25, Y+4	; 0x04
    3640:	f3 e0       	ldi	r31, 0x03	; 3
    3642:	82 37       	cpi	r24, 0x72	; 114
    3644:	9f 07       	cpc	r25, r31
    3646:	08 f4       	brcc	.+2      	; 0x364a <_Z7TakeADCv+0x11a>
    3648:	20 e0       	ldi	r18, 0x00	; 0
    364a:	20 93 0c 02 	sts	0x020C, r18
		
	//Disable ADC hardware/registers
	ADCSRA = 0;
    364e:	8a e7       	ldi	r24, 0x7A	; 122
    3650:	90 e0       	ldi	r25, 0x00	; 0
    3652:	fc 01       	movw	r30, r24
    3654:	10 82       	st	Z, r1
	ADMUX = 0;
    3656:	8c e7       	ldi	r24, 0x7C	; 124
    3658:	90 e0       	ldi	r25, 0x00	; 0
    365a:	fc 01       	movw	r30, r24
    365c:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    365e:	8e e7       	ldi	r24, 0x7E	; 126
    3660:	90 e0       	ldi	r25, 0x00	; 0
    3662:	2e e7       	ldi	r18, 0x7E	; 126
    3664:	30 e0       	ldi	r19, 0x00	; 0
    3666:	f9 01       	movw	r30, r18
    3668:	20 81       	ld	r18, Z
    366a:	21 60       	ori	r18, 0x01	; 1
    366c:	fc 01       	movw	r30, r24
    366e:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    3670:	84 e6       	ldi	r24, 0x64	; 100
    3672:	90 e0       	ldi	r25, 0x00	; 0
    3674:	24 e6       	ldi	r18, 0x64	; 100
    3676:	30 e0       	ldi	r19, 0x00	; 0
    3678:	f9 01       	movw	r30, r18
    367a:	20 81       	ld	r18, Z
    367c:	21 60       	ori	r18, 0x01	; 1
    367e:	fc 01       	movw	r30, r24
    3680:	20 83       	st	Z, r18

	char tempString[10];
	itoa(globalADC,tempString,10);
    3682:	80 91 d0 01 	lds	r24, 0x01D0
    3686:	90 91 d1 01 	lds	r25, 0x01D1
    368a:	9e 01       	movw	r18, r28
    368c:	2b 5f       	subi	r18, 0xFB	; 251
    368e:	3f 4f       	sbci	r19, 0xFF	; 255
    3690:	b9 01       	movw	r22, r18
    3692:	4a e0       	ldi	r20, 0x0A	; 10
    3694:	50 e0       	ldi	r21, 0x00	; 0
    3696:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <itoa>
	tempString[9]='\0';
    369a:	1e 86       	std	Y+14, r1	; 0x0e
	//PrintBone("ADC: ");
	//PrintBone(tempString);
	prtInterrupts &= ~(1 << bnBBint);
    369c:	82 e2       	ldi	r24, 0x22	; 34
    369e:	90 e0       	ldi	r25, 0x00	; 0
    36a0:	22 e2       	ldi	r18, 0x22	; 34
    36a2:	30 e0       	ldi	r19, 0x00	; 0
    36a4:	f9 01       	movw	r30, r18
    36a6:	20 81       	ld	r18, Z
    36a8:	2b 7f       	andi	r18, 0xFB	; 251
    36aa:	fc 01       	movw	r30, r24
    36ac:	20 83       	st	Z, r18
	__enableCommINT();
    36ae:	8d e3       	ldi	r24, 0x3D	; 61
    36b0:	90 e0       	ldi	r25, 0x00	; 0
    36b2:	2d e3       	ldi	r18, 0x3D	; 61
    36b4:	30 e0       	ldi	r19, 0x00	; 0
    36b6:	f9 01       	movw	r30, r18
    36b8:	20 81       	ld	r18, Z
    36ba:	24 60       	ori	r18, 0x04	; 4
    36bc:	fc 01       	movw	r30, r24
    36be:	20 83       	st	Z, r18
    36c0:	8d e6       	ldi	r24, 0x6D	; 109
    36c2:	90 e0       	ldi	r25, 0x00	; 0
    36c4:	22 e0       	ldi	r18, 0x02	; 2
    36c6:	fc 01       	movw	r30, r24
    36c8:	20 83       	st	Z, r18
}
    36ca:	2e 96       	adiw	r28, 0x0e	; 14
    36cc:	0f b6       	in	r0, 0x3f	; 63
    36ce:	f8 94       	cli
    36d0:	de bf       	out	0x3e, r29	; 62
    36d2:	0f be       	out	0x3f, r0	; 63
    36d4:	cd bf       	out	0x3d, r28	; 61
    36d6:	df 91       	pop	r29
    36d8:	cf 91       	pop	r28
    36da:	08 95       	ret

000036dc <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    36dc:	cf 93       	push	r28
    36de:	df 93       	push	r29
    36e0:	cd b7       	in	r28, 0x3d	; 61
    36e2:	de b7       	in	r29, 0x3e	; 62
    36e4:	2b 97       	sbiw	r28, 0x0b	; 11
    36e6:	0f b6       	in	r0, 0x3f	; 63
    36e8:	f8 94       	cli
    36ea:	de bf       	out	0x3e, r29	; 62
    36ec:	0f be       	out	0x3f, r0	; 63
    36ee:	cd bf       	out	0x3d, r28	; 61
	WORD rawTemp = 0;
    36f0:	1a 82       	std	Y+2, r1	; 0x02
    36f2:	19 82       	std	Y+1, r1	; 0x01

	__killCommINT();
    36f4:	8d e3       	ldi	r24, 0x3D	; 61
    36f6:	90 e0       	ldi	r25, 0x00	; 0
    36f8:	fc 01       	movw	r30, r24
    36fa:	10 82       	st	Z, r1
    36fc:	8d e6       	ldi	r24, 0x6D	; 109
    36fe:	90 e0       	ldi	r25, 0x00	; 0
    3700:	fc 01       	movw	r30, r24
    3702:	10 82       	st	Z, r1

	PRR0 &= ~(1 << PRSPI);	
    3704:	84 e6       	ldi	r24, 0x64	; 100
    3706:	90 e0       	ldi	r25, 0x00	; 0
    3708:	24 e6       	ldi	r18, 0x64	; 100
    370a:	30 e0       	ldi	r19, 0x00	; 0
    370c:	f9 01       	movw	r30, r18
    370e:	20 81       	ld	r18, Z
    3710:	2b 7f       	andi	r18, 0xFB	; 251
    3712:	fc 01       	movw	r30, r24
    3714:	20 83       	st	Z, r18
	SPCR |= (1 << MSTR)|(1 << SPE)|(1 << SPR0);			//enables SPI, master, fck/64
    3716:	8c e4       	ldi	r24, 0x4C	; 76
    3718:	90 e0       	ldi	r25, 0x00	; 0
    371a:	2c e4       	ldi	r18, 0x4C	; 76
    371c:	30 e0       	ldi	r19, 0x00	; 0
    371e:	f9 01       	movw	r30, r18
    3720:	20 81       	ld	r18, Z
    3722:	21 65       	ori	r18, 0x51	; 81
    3724:	fc 01       	movw	r30, r24
    3726:	20 83       	st	Z, r18
	Wait_sec(2);
    3728:	82 e0       	ldi	r24, 0x02	; 2
    372a:	90 e0       	ldi	r25, 0x00	; 0
    372c:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    3730:	85 e2       	ldi	r24, 0x25	; 37
    3732:	90 e0       	ldi	r25, 0x00	; 0
    3734:	25 e2       	ldi	r18, 0x25	; 37
    3736:	30 e0       	ldi	r19, 0x00	; 0
    3738:	f9 01       	movw	r30, r18
    373a:	20 81       	ld	r18, Z
    373c:	2f 76       	andi	r18, 0x6F	; 111
    373e:	fc 01       	movw	r30, r24
    3740:	20 83       	st	Z, r18
	
	cli();
    3742:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR = 0x00;
    3744:	8e e4       	ldi	r24, 0x4E	; 78
    3746:	90 e0       	ldi	r25, 0x00	; 0
    3748:	fc 01       	movw	r30, r24
    374a:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR & (1 << SPIF)));
    374c:	00 00       	nop
    374e:	8d e4       	ldi	r24, 0x4D	; 77
    3750:	90 e0       	ldi	r25, 0x00	; 0
    3752:	fc 01       	movw	r30, r24
    3754:	80 81       	ld	r24, Z
    3756:	80 95       	com	r24
    3758:	88 1f       	adc	r24, r24
    375a:	88 27       	eor	r24, r24
    375c:	88 1f       	adc	r24, r24
    375e:	88 23       	and	r24, r24
    3760:	b1 f7       	brne	.-20     	; 0x374e <_Z7GetTempv+0x72>
	rawTemp = (SPDR0 << 8);
    3762:	1a 82       	std	Y+2, r1	; 0x02
    3764:	19 82       	std	Y+1, r1	; 0x01
	SPDR = 0x00;
    3766:	8e e4       	ldi	r24, 0x4E	; 78
    3768:	90 e0       	ldi	r25, 0x00	; 0
    376a:	fc 01       	movw	r30, r24
    376c:	10 82       	st	Z, r1
	while (!(SPSR & (1 << SPIF)));
    376e:	00 00       	nop
    3770:	8d e4       	ldi	r24, 0x4D	; 77
    3772:	90 e0       	ldi	r25, 0x00	; 0
    3774:	fc 01       	movw	r30, r24
    3776:	80 81       	ld	r24, Z
    3778:	80 95       	com	r24
    377a:	88 1f       	adc	r24, r24
    377c:	88 27       	eor	r24, r24
    377e:	88 1f       	adc	r24, r24
    3780:	88 23       	and	r24, r24
    3782:	b1 f7       	brne	.-20     	; 0x3770 <_Z7GetTempv+0x94>
	rawTemp |= SPDR0;
	
	//Set flag to correct value, update global value
	//flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
	globalTemp=rawTemp;
    3784:	89 81       	ldd	r24, Y+1	; 0x01
    3786:	9a 81       	ldd	r25, Y+2	; 0x02
    3788:	90 93 d3 01 	sts	0x01D3, r25
    378c:	80 93 d2 01 	sts	0x01D2, r24
	
	//re enable interrupts
	sei();
    3790:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    3792:	85 e2       	ldi	r24, 0x25	; 37
    3794:	90 e0       	ldi	r25, 0x00	; 0
    3796:	25 e2       	ldi	r18, 0x25	; 37
    3798:	30 e0       	ldi	r19, 0x00	; 0
    379a:	f9 01       	movw	r30, r18
    379c:	20 81       	ld	r18, Z
    379e:	20 69       	ori	r18, 0x90	; 144
    37a0:	fc 01       	movw	r30, r24
    37a2:	20 83       	st	Z, r18
	SPCR=0x00;	
    37a4:	8c e4       	ldi	r24, 0x4C	; 76
    37a6:	90 e0       	ldi	r25, 0x00	; 0
    37a8:	fc 01       	movw	r30, r24
    37aa:	10 82       	st	Z, r1
	//__killTemp();
	PRR0 |= (1 << PRSPI);
    37ac:	84 e6       	ldi	r24, 0x64	; 100
    37ae:	90 e0       	ldi	r25, 0x00	; 0
    37b0:	24 e6       	ldi	r18, 0x64	; 100
    37b2:	30 e0       	ldi	r19, 0x00	; 0
    37b4:	f9 01       	movw	r30, r18
    37b6:	20 81       	ld	r18, Z
    37b8:	24 60       	ori	r18, 0x04	; 4
    37ba:	fc 01       	movw	r30, r24
    37bc:	20 83       	st	Z, r18
	
	char tempString[9];
	itoa(globalTemp,tempString,10);
    37be:	80 91 d2 01 	lds	r24, 0x01D2
    37c2:	90 91 d3 01 	lds	r25, 0x01D3
    37c6:	9e 01       	movw	r18, r28
    37c8:	2d 5f       	subi	r18, 0xFD	; 253
    37ca:	3f 4f       	sbci	r19, 0xFF	; 255
    37cc:	b9 01       	movw	r22, r18
    37ce:	4a e0       	ldi	r20, 0x0A	; 10
    37d0:	50 e0       	ldi	r21, 0x00	; 0
    37d2:	0e 94 53 1d 	call	0x3aa6	; 0x3aa6 <itoa>
	tempString[8]='\0';
    37d6:	1b 86       	std	Y+11, r1	; 0x0b

	__enableCommINT();
    37d8:	8d e3       	ldi	r24, 0x3D	; 61
    37da:	90 e0       	ldi	r25, 0x00	; 0
    37dc:	2d e3       	ldi	r18, 0x3D	; 61
    37de:	30 e0       	ldi	r19, 0x00	; 0
    37e0:	f9 01       	movw	r30, r18
    37e2:	20 81       	ld	r18, Z
    37e4:	24 60       	ori	r18, 0x04	; 4
    37e6:	fc 01       	movw	r30, r24
    37e8:	20 83       	st	Z, r18
    37ea:	8d e6       	ldi	r24, 0x6D	; 109
    37ec:	90 e0       	ldi	r25, 0x00	; 0
    37ee:	22 e0       	ldi	r18, 0x02	; 2
    37f0:	fc 01       	movw	r30, r24
    37f2:	20 83       	st	Z, r18
}
    37f4:	2b 96       	adiw	r28, 0x0b	; 11
    37f6:	0f b6       	in	r0, 0x3f	; 63
    37f8:	f8 94       	cli
    37fa:	de bf       	out	0x3e, r29	; 62
    37fc:	0f be       	out	0x3f, r0	; 63
    37fe:	cd bf       	out	0x3d, r28	; 61
    3800:	df 91       	pop	r29
    3802:	cf 91       	pop	r28
    3804:	08 95       	ret

00003806 <_Z7PowerUpj>:
/*************************************************************************************************************/
void PowerUp(WORD interval){
    3806:	cf 93       	push	r28
    3808:	df 93       	push	r29
    380a:	00 d0       	rcall	.+0      	; 0x380c <_Z7PowerUpj+0x6>
    380c:	cd b7       	in	r28, 0x3d	; 61
    380e:	de b7       	in	r29, 0x3e	; 62
    3810:	9a 83       	std	Y+2, r25	; 0x02
    3812:	89 83       	std	Y+1, r24	; 0x01
	__killCommINT();
    3814:	8d e3       	ldi	r24, 0x3D	; 61
    3816:	90 e0       	ldi	r25, 0x00	; 0
    3818:	fc 01       	movw	r30, r24
    381a:	10 82       	st	Z, r1
    381c:	8d e6       	ldi	r24, 0x6D	; 109
    381e:	90 e0       	ldi	r25, 0x00	; 0
    3820:	fc 01       	movw	r30, r24
    3822:	10 82       	st	Z, r1
	
	//First power on main regulator
	__enableMain();
    3824:	88 e2       	ldi	r24, 0x28	; 40
    3826:	90 e0       	ldi	r25, 0x00	; 0
    3828:	28 e2       	ldi	r18, 0x28	; 40
    382a:	30 e0       	ldi	r19, 0x00	; 0
    382c:	f9 01       	movw	r30, r18
    382e:	20 81       	ld	r18, Z
    3830:	21 60       	ori	r18, 0x01	; 1
    3832:	fc 01       	movw	r30, r24
    3834:	20 83       	st	Z, r18
	Wait_sec(interval);
    3836:	89 81       	ldd	r24, Y+1	; 0x01
    3838:	9a 81       	ldd	r25, Y+2	; 0x02
    383a:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	//__enableBeagleBone();
	//Wait_sec(interval);
	//while (!(pinBBio & (1 << bnW0B9)));	//Wait for GPIO line to go high
	
	//Power on GAVR and Enable GPS
	__enableGPSandGAVR();
    383e:	82 e2       	ldi	r24, 0x22	; 34
    3840:	90 e0       	ldi	r25, 0x00	; 0
    3842:	22 e2       	ldi	r18, 0x22	; 34
    3844:	30 e0       	ldi	r19, 0x00	; 0
    3846:	f9 01       	movw	r30, r18
    3848:	20 81       	ld	r18, Z
    384a:	20 6c       	ori	r18, 0xC0	; 192
    384c:	fc 01       	movw	r30, r24
    384e:	20 83       	st	Z, r18
	//Wait_sec(interval);
	//while (!(pinGAVRio & (1 << bnW3G0)));	//Wait for GPIO line to go high signifying correct boot
	if (restart){
    3850:	80 91 0d 02 	lds	r24, 0x020D
    3854:	88 23       	and	r24, r24
    3856:	b1 f0       	breq	.+44     	; 0x3884 <_Z7PowerUpj+0x7e>
		prtInterrupts |= (1 << bnGAVRint);
    3858:	82 e2       	ldi	r24, 0x22	; 34
    385a:	90 e0       	ldi	r25, 0x00	; 0
    385c:	22 e2       	ldi	r18, 0x22	; 34
    385e:	30 e0       	ldi	r19, 0x00	; 0
    3860:	f9 01       	movw	r30, r18
    3862:	20 81       	ld	r18, Z
    3864:	28 60       	ori	r18, 0x08	; 8
    3866:	fc 01       	movw	r30, r24
    3868:	20 83       	st	Z, r18
		Wait_ms(200); 
    386a:	88 ec       	ldi	r24, 0xC8	; 200
    386c:	90 e0       	ldi	r25, 0x00	; 0
    386e:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		prtInterrupts  &= ~(1 << bnGAVRint);	//sends interrupt to come out of power-down, waits, goes forward.
    3872:	82 e2       	ldi	r24, 0x22	; 34
    3874:	90 e0       	ldi	r25, 0x00	; 0
    3876:	22 e2       	ldi	r18, 0x22	; 34
    3878:	30 e0       	ldi	r19, 0x00	; 0
    387a:	f9 01       	movw	r30, r18
    387c:	20 81       	ld	r18, Z
    387e:	27 7f       	andi	r18, 0xF7	; 247
    3880:	fc 01       	movw	r30, r24
    3882:	20 83       	st	Z, r18
	}
	//Power on LCD
	//__enableLCD();
	Wait_sec(interval);
    3884:	89 81       	ldd	r24, Y+1	; 0x01
    3886:	9a 81       	ldd	r25, Y+2	; 0x02
    3888:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	
	__enableCommINT();
    388c:	8d e3       	ldi	r24, 0x3D	; 61
    388e:	90 e0       	ldi	r25, 0x00	; 0
    3890:	2d e3       	ldi	r18, 0x3D	; 61
    3892:	30 e0       	ldi	r19, 0x00	; 0
    3894:	f9 01       	movw	r30, r18
    3896:	20 81       	ld	r18, Z
    3898:	24 60       	ori	r18, 0x04	; 4
    389a:	fc 01       	movw	r30, r24
    389c:	20 83       	st	Z, r18
    389e:	8d e6       	ldi	r24, 0x6D	; 109
    38a0:	90 e0       	ldi	r25, 0x00	; 0
    38a2:	22 e0       	ldi	r18, 0x02	; 2
    38a4:	fc 01       	movw	r30, r24
    38a6:	20 83       	st	Z, r18
	
}
    38a8:	0f 90       	pop	r0
    38aa:	0f 90       	pop	r0
    38ac:	df 91       	pop	r29
    38ae:	cf 91       	pop	r28
    38b0:	08 95       	ret

000038b2 <_Z9PowerDownv>:
/*************************************************************************************************************/
void PowerDown(){
    38b2:	cf 93       	push	r28
    38b4:	df 93       	push	r29
    38b6:	cd b7       	in	r28, 0x3d	; 61
    38b8:	de b7       	in	r29, 0x3e	; 62
	__killCommINT();
    38ba:	8d e3       	ldi	r24, 0x3D	; 61
    38bc:	90 e0       	ldi	r25, 0x00	; 0
    38be:	fc 01       	movw	r30, r24
    38c0:	10 82       	st	Z, r1
    38c2:	8d e6       	ldi	r24, 0x6D	; 109
    38c4:	90 e0       	ldi	r25, 0x00	; 0
    38c6:	fc 01       	movw	r30, r24
    38c8:	10 82       	st	Z, r1

	//Signify interrupts, wait 6 seconds for all processing to stop.
	prtInterrupts |= (1 << bnBBint)|(1 << bnGAVRint);
    38ca:	82 e2       	ldi	r24, 0x22	; 34
    38cc:	90 e0       	ldi	r25, 0x00	; 0
    38ce:	22 e2       	ldi	r18, 0x22	; 34
    38d0:	30 e0       	ldi	r19, 0x00	; 0
    38d2:	f9 01       	movw	r30, r18
    38d4:	20 81       	ld	r18, Z
    38d6:	2c 60       	ori	r18, 0x0C	; 12
    38d8:	fc 01       	movw	r30, r24
    38da:	20 83       	st	Z, r18
	Wait_sec(6);
    38dc:	86 e0       	ldi	r24, 0x06	; 6
    38de:	90 e0       	ldi	r25, 0x00	; 0
    38e0:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	prtInterrupts &= ~((1 << bnBBint)|(1 << bnGAVRint));
    38e4:	82 e2       	ldi	r24, 0x22	; 34
    38e6:	90 e0       	ldi	r25, 0x00	; 0
    38e8:	22 e2       	ldi	r18, 0x22	; 34
    38ea:	30 e0       	ldi	r19, 0x00	; 0
    38ec:	f9 01       	movw	r30, r18
    38ee:	20 81       	ld	r18, Z
    38f0:	23 7f       	andi	r18, 0xF3	; 243
    38f2:	fc 01       	movw	r30, r24
    38f4:	20 83       	st	Z, r18
	__killLCD();
    38f6:	82 e2       	ldi	r24, 0x22	; 34
    38f8:	90 e0       	ldi	r25, 0x00	; 0
    38fa:	22 e2       	ldi	r18, 0x22	; 34
    38fc:	30 e0       	ldi	r19, 0x00	; 0
    38fe:	f9 01       	movw	r30, r18
    3900:	20 81       	ld	r18, Z
    3902:	2f 7d       	andi	r18, 0xDF	; 223
    3904:	fc 01       	movw	r30, r24
    3906:	20 83       	st	Z, r18
	__killGPSandGAVR();
    3908:	82 e2       	ldi	r24, 0x22	; 34
    390a:	90 e0       	ldi	r25, 0x00	; 0
    390c:	22 e2       	ldi	r18, 0x22	; 34
    390e:	30 e0       	ldi	r19, 0x00	; 0
    3910:	f9 01       	movw	r30, r18
    3912:	20 81       	ld	r18, Z
    3914:	2f 73       	andi	r18, 0x3F	; 63
    3916:	fc 01       	movw	r30, r24
    3918:	20 83       	st	Z, r18
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
    391a:	86 e0       	ldi	r24, 0x06	; 6
    391c:	90 e0       	ldi	r25, 0x00	; 0
    391e:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	__killBeagleBone();
    3922:	82 e2       	ldi	r24, 0x22	; 34
    3924:	90 e0       	ldi	r25, 0x00	; 0
    3926:	22 e2       	ldi	r18, 0x22	; 34
    3928:	30 e0       	ldi	r19, 0x00	; 0
    392a:	f9 01       	movw	r30, r18
    392c:	20 81       	ld	r18, Z
    392e:	2f 7e       	andi	r18, 0xEF	; 239
    3930:	fc 01       	movw	r30, r24
    3932:	20 83       	st	Z, r18
	__killMain();
    3934:	88 e2       	ldi	r24, 0x28	; 40
    3936:	90 e0       	ldi	r25, 0x00	; 0
    3938:	28 e2       	ldi	r18, 0x28	; 40
    393a:	30 e0       	ldi	r19, 0x00	; 0
    393c:	f9 01       	movw	r30, r18
    393e:	20 81       	ld	r18, Z
    3940:	2e 7f       	andi	r18, 0xFE	; 254
    3942:	fc 01       	movw	r30, r24
    3944:	20 83       	st	Z, r18
}
    3946:	df 91       	pop	r29
    3948:	cf 91       	pop	r28
    394a:	08 95       	ret

0000394c <_Z41__static_initialization_and_destruction_0ii>:
    394c:	cf 93       	push	r28
    394e:	df 93       	push	r29
    3950:	00 d0       	rcall	.+0      	; 0x3952 <_Z41__static_initialization_and_destruction_0ii+0x6>
    3952:	00 d0       	rcall	.+0      	; 0x3954 <_Z41__static_initialization_and_destruction_0ii+0x8>
    3954:	cd b7       	in	r28, 0x3d	; 61
    3956:	de b7       	in	r29, 0x3e	; 62
    3958:	9a 83       	std	Y+2, r25	; 0x02
    395a:	89 83       	std	Y+1, r24	; 0x01
    395c:	7c 83       	std	Y+4, r23	; 0x04
    395e:	6b 83       	std	Y+3, r22	; 0x03
    3960:	89 81       	ldd	r24, Y+1	; 0x01
    3962:	9a 81       	ldd	r25, Y+2	; 0x02
    3964:	81 30       	cpi	r24, 0x01	; 1
    3966:	91 05       	cpc	r25, r1
    3968:	51 f4       	brne	.+20     	; 0x397e <_Z41__static_initialization_and_destruction_0ii+0x32>
    396a:	8b 81       	ldd	r24, Y+3	; 0x03
    396c:	9c 81       	ldd	r25, Y+4	; 0x04
    396e:	2f ef       	ldi	r18, 0xFF	; 255
    3970:	8f 3f       	cpi	r24, 0xFF	; 255
    3972:	92 07       	cpc	r25, r18
    3974:	21 f4       	brne	.+8      	; 0x397e <_Z41__static_initialization_and_destruction_0ii+0x32>

/*********************************************GLOBAL VARIABLES***************************************************/
/****************************************************************************************************************/
WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    3976:	84 ed       	ldi	r24, 0xD4	; 212
    3978:	91 e0       	ldi	r25, 0x01	; 1
    397a:	0e 94 10 04 	call	0x820	; 0x820 <_ZN6myTimeC1Ev>
	
	//Give the BeagleBone another 6 seconds to finish it's stuff, then kill it
	Wait_sec(6);
	__killBeagleBone();
	__killMain();
}
    397e:	0f 90       	pop	r0
    3980:	0f 90       	pop	r0
    3982:	0f 90       	pop	r0
    3984:	0f 90       	pop	r0
    3986:	df 91       	pop	r29
    3988:	cf 91       	pop	r28
    398a:	08 95       	ret

0000398c <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    398c:	cf 93       	push	r28
    398e:	df 93       	push	r29
    3990:	cd b7       	in	r28, 0x3d	; 61
    3992:	de b7       	in	r29, 0x3e	; 62
    3994:	81 e0       	ldi	r24, 0x01	; 1
    3996:	90 e0       	ldi	r25, 0x00	; 0
    3998:	6f ef       	ldi	r22, 0xFF	; 255
    399a:	7f ef       	ldi	r23, 0xFF	; 255
    399c:	0e 94 a6 1c 	call	0x394c	; 0x394c <_Z41__static_initialization_and_destruction_0ii>
    39a0:	df 91       	pop	r29
    39a2:	cf 91       	pop	r28
    39a4:	08 95       	ret

000039a6 <__udivmodqi4>:
    39a6:	99 1b       	sub	r25, r25
    39a8:	79 e0       	ldi	r23, 0x09	; 9
    39aa:	04 c0       	rjmp	.+8      	; 0x39b4 <__udivmodqi4_ep>

000039ac <__udivmodqi4_loop>:
    39ac:	99 1f       	adc	r25, r25
    39ae:	96 17       	cp	r25, r22
    39b0:	08 f0       	brcs	.+2      	; 0x39b4 <__udivmodqi4_ep>
    39b2:	96 1b       	sub	r25, r22

000039b4 <__udivmodqi4_ep>:
    39b4:	88 1f       	adc	r24, r24
    39b6:	7a 95       	dec	r23
    39b8:	c9 f7       	brne	.-14     	; 0x39ac <__udivmodqi4_loop>
    39ba:	80 95       	com	r24
    39bc:	08 95       	ret

000039be <__divmodhi4>:
    39be:	97 fb       	bst	r25, 7
    39c0:	09 2e       	mov	r0, r25
    39c2:	07 26       	eor	r0, r23
    39c4:	0a d0       	rcall	.+20     	; 0x39da <__divmodhi4_neg1>
    39c6:	77 fd       	sbrc	r23, 7
    39c8:	04 d0       	rcall	.+8      	; 0x39d2 <__divmodhi4_neg2>
    39ca:	0c d0       	rcall	.+24     	; 0x39e4 <__udivmodhi4>
    39cc:	06 d0       	rcall	.+12     	; 0x39da <__divmodhi4_neg1>
    39ce:	00 20       	and	r0, r0
    39d0:	1a f4       	brpl	.+6      	; 0x39d8 <__divmodhi4_exit>

000039d2 <__divmodhi4_neg2>:
    39d2:	70 95       	com	r23
    39d4:	61 95       	neg	r22
    39d6:	7f 4f       	sbci	r23, 0xFF	; 255

000039d8 <__divmodhi4_exit>:
    39d8:	08 95       	ret

000039da <__divmodhi4_neg1>:
    39da:	f6 f7       	brtc	.-4      	; 0x39d8 <__divmodhi4_exit>
    39dc:	90 95       	com	r25
    39de:	81 95       	neg	r24
    39e0:	9f 4f       	sbci	r25, 0xFF	; 255
    39e2:	08 95       	ret

000039e4 <__udivmodhi4>:
    39e4:	aa 1b       	sub	r26, r26
    39e6:	bb 1b       	sub	r27, r27
    39e8:	51 e1       	ldi	r21, 0x11	; 17
    39ea:	07 c0       	rjmp	.+14     	; 0x39fa <__udivmodhi4_ep>

000039ec <__udivmodhi4_loop>:
    39ec:	aa 1f       	adc	r26, r26
    39ee:	bb 1f       	adc	r27, r27
    39f0:	a6 17       	cp	r26, r22
    39f2:	b7 07       	cpc	r27, r23
    39f4:	10 f0       	brcs	.+4      	; 0x39fa <__udivmodhi4_ep>
    39f6:	a6 1b       	sub	r26, r22
    39f8:	b7 0b       	sbc	r27, r23

000039fa <__udivmodhi4_ep>:
    39fa:	88 1f       	adc	r24, r24
    39fc:	99 1f       	adc	r25, r25
    39fe:	5a 95       	dec	r21
    3a00:	a9 f7       	brne	.-22     	; 0x39ec <__udivmodhi4_loop>
    3a02:	80 95       	com	r24
    3a04:	90 95       	com	r25
    3a06:	bc 01       	movw	r22, r24
    3a08:	cd 01       	movw	r24, r26
    3a0a:	08 95       	ret

00003a0c <__tablejump2__>:
    3a0c:	ee 0f       	add	r30, r30
    3a0e:	ff 1f       	adc	r31, r31

00003a10 <__tablejump__>:
    3a10:	05 90       	lpm	r0, Z+
    3a12:	f4 91       	lpm	r31, Z
    3a14:	e0 2d       	mov	r30, r0
    3a16:	09 94       	ijmp

00003a18 <atoi>:
    3a18:	fc 01       	movw	r30, r24
    3a1a:	88 27       	eor	r24, r24
    3a1c:	99 27       	eor	r25, r25
    3a1e:	e8 94       	clt
    3a20:	21 91       	ld	r18, Z+
    3a22:	20 32       	cpi	r18, 0x20	; 32
    3a24:	e9 f3       	breq	.-6      	; 0x3a20 <atoi+0x8>
    3a26:	29 30       	cpi	r18, 0x09	; 9
    3a28:	10 f0       	brcs	.+4      	; 0x3a2e <atoi+0x16>
    3a2a:	2e 30       	cpi	r18, 0x0E	; 14
    3a2c:	c8 f3       	brcs	.-14     	; 0x3a20 <atoi+0x8>
    3a2e:	2b 32       	cpi	r18, 0x2B	; 43
    3a30:	41 f0       	breq	.+16     	; 0x3a42 <atoi+0x2a>
    3a32:	2d 32       	cpi	r18, 0x2D	; 45
    3a34:	39 f4       	brne	.+14     	; 0x3a44 <atoi+0x2c>
    3a36:	68 94       	set
    3a38:	04 c0       	rjmp	.+8      	; 0x3a42 <atoi+0x2a>
    3a3a:	0e 94 74 1d 	call	0x3ae8	; 0x3ae8 <__mulhi_const_10>
    3a3e:	82 0f       	add	r24, r18
    3a40:	91 1d       	adc	r25, r1
    3a42:	21 91       	ld	r18, Z+
    3a44:	20 53       	subi	r18, 0x30	; 48
    3a46:	2a 30       	cpi	r18, 0x0A	; 10
    3a48:	c0 f3       	brcs	.-16     	; 0x3a3a <atoi+0x22>
    3a4a:	1e f4       	brtc	.+6      	; 0x3a52 <atoi+0x3a>
    3a4c:	90 95       	com	r25
    3a4e:	81 95       	neg	r24
    3a50:	9f 4f       	sbci	r25, 0xFF	; 255
    3a52:	08 95       	ret

00003a54 <strcat>:
    3a54:	fb 01       	movw	r30, r22
    3a56:	dc 01       	movw	r26, r24
    3a58:	0d 90       	ld	r0, X+
    3a5a:	00 20       	and	r0, r0
    3a5c:	e9 f7       	brne	.-6      	; 0x3a58 <strcat+0x4>
    3a5e:	11 97       	sbiw	r26, 0x01	; 1
    3a60:	01 90       	ld	r0, Z+
    3a62:	0d 92       	st	X+, r0
    3a64:	00 20       	and	r0, r0
    3a66:	e1 f7       	brne	.-8      	; 0x3a60 <strcat+0xc>
    3a68:	08 95       	ret

00003a6a <strcmp>:
    3a6a:	fb 01       	movw	r30, r22
    3a6c:	dc 01       	movw	r26, r24
    3a6e:	8d 91       	ld	r24, X+
    3a70:	01 90       	ld	r0, Z+
    3a72:	80 19       	sub	r24, r0
    3a74:	01 10       	cpse	r0, r1
    3a76:	d9 f3       	breq	.-10     	; 0x3a6e <strcmp+0x4>
    3a78:	99 0b       	sbc	r25, r25
    3a7a:	08 95       	ret

00003a7c <strcpy>:
    3a7c:	fb 01       	movw	r30, r22
    3a7e:	dc 01       	movw	r26, r24
    3a80:	01 90       	ld	r0, Z+
    3a82:	0d 92       	st	X+, r0
    3a84:	00 20       	and	r0, r0
    3a86:	e1 f7       	brne	.-8      	; 0x3a80 <strcpy+0x4>
    3a88:	08 95       	ret

00003a8a <strncmp>:
    3a8a:	fb 01       	movw	r30, r22
    3a8c:	dc 01       	movw	r26, r24
    3a8e:	41 50       	subi	r20, 0x01	; 1
    3a90:	50 40       	sbci	r21, 0x00	; 0
    3a92:	30 f0       	brcs	.+12     	; 0x3aa0 <strncmp+0x16>
    3a94:	8d 91       	ld	r24, X+
    3a96:	01 90       	ld	r0, Z+
    3a98:	80 19       	sub	r24, r0
    3a9a:	19 f4       	brne	.+6      	; 0x3aa2 <strncmp+0x18>
    3a9c:	00 20       	and	r0, r0
    3a9e:	b9 f7       	brne	.-18     	; 0x3a8e <strncmp+0x4>
    3aa0:	88 1b       	sub	r24, r24
    3aa2:	99 0b       	sbc	r25, r25
    3aa4:	08 95       	ret

00003aa6 <itoa>:
    3aa6:	fb 01       	movw	r30, r22
    3aa8:	9f 01       	movw	r18, r30
    3aaa:	e8 94       	clt
    3aac:	42 30       	cpi	r20, 0x02	; 2
    3aae:	c4 f0       	brlt	.+48     	; 0x3ae0 <itoa+0x3a>
    3ab0:	45 32       	cpi	r20, 0x25	; 37
    3ab2:	b4 f4       	brge	.+44     	; 0x3ae0 <itoa+0x3a>
    3ab4:	4a 30       	cpi	r20, 0x0A	; 10
    3ab6:	29 f4       	brne	.+10     	; 0x3ac2 <itoa+0x1c>
    3ab8:	97 fb       	bst	r25, 7
    3aba:	1e f4       	brtc	.+6      	; 0x3ac2 <itoa+0x1c>
    3abc:	90 95       	com	r25
    3abe:	81 95       	neg	r24
    3ac0:	9f 4f       	sbci	r25, 0xFF	; 255
    3ac2:	64 2f       	mov	r22, r20
    3ac4:	77 27       	eor	r23, r23
    3ac6:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <__udivmodhi4>
    3aca:	80 5d       	subi	r24, 0xD0	; 208
    3acc:	8a 33       	cpi	r24, 0x3A	; 58
    3ace:	0c f0       	brlt	.+2      	; 0x3ad2 <itoa+0x2c>
    3ad0:	89 5d       	subi	r24, 0xD9	; 217
    3ad2:	81 93       	st	Z+, r24
    3ad4:	cb 01       	movw	r24, r22
    3ad6:	00 97       	sbiw	r24, 0x00	; 0
    3ad8:	a1 f7       	brne	.-24     	; 0x3ac2 <itoa+0x1c>
    3ada:	16 f4       	brtc	.+4      	; 0x3ae0 <itoa+0x3a>
    3adc:	5d e2       	ldi	r21, 0x2D	; 45
    3ade:	51 93       	st	Z+, r21
    3ae0:	10 82       	st	Z, r1
    3ae2:	c9 01       	movw	r24, r18
    3ae4:	0c 94 b3 1d 	jmp	0x3b66	; 0x3b66 <strrev>

00003ae8 <__mulhi_const_10>:
    3ae8:	7a e0       	ldi	r23, 0x0A	; 10
    3aea:	97 9f       	mul	r25, r23
    3aec:	90 2d       	mov	r25, r0
    3aee:	87 9f       	mul	r24, r23
    3af0:	80 2d       	mov	r24, r0
    3af2:	91 0d       	add	r25, r1
    3af4:	11 24       	eor	r1, r1
    3af6:	08 95       	ret

00003af8 <utoa>:
    3af8:	fb 01       	movw	r30, r22
    3afa:	9f 01       	movw	r18, r30
    3afc:	42 30       	cpi	r20, 0x02	; 2
    3afe:	74 f0       	brlt	.+28     	; 0x3b1c <utoa+0x24>
    3b00:	45 32       	cpi	r20, 0x25	; 37
    3b02:	64 f4       	brge	.+24     	; 0x3b1c <utoa+0x24>
    3b04:	64 2f       	mov	r22, r20
    3b06:	77 27       	eor	r23, r23
    3b08:	0e 94 f2 1c 	call	0x39e4	; 0x39e4 <__udivmodhi4>
    3b0c:	80 5d       	subi	r24, 0xD0	; 208
    3b0e:	8a 33       	cpi	r24, 0x3A	; 58
    3b10:	0c f0       	brlt	.+2      	; 0x3b14 <utoa+0x1c>
    3b12:	89 5d       	subi	r24, 0xD9	; 217
    3b14:	81 93       	st	Z+, r24
    3b16:	cb 01       	movw	r24, r22
    3b18:	00 97       	sbiw	r24, 0x00	; 0
    3b1a:	a1 f7       	brne	.-24     	; 0x3b04 <utoa+0xc>
    3b1c:	10 82       	st	Z, r1
    3b1e:	c9 01       	movw	r24, r18
    3b20:	0c 94 b3 1d 	jmp	0x3b66	; 0x3b66 <strrev>

00003b24 <__eerd_byte_m644pa>:
    3b24:	f9 99       	sbic	0x1f, 1	; 31
    3b26:	fe cf       	rjmp	.-4      	; 0x3b24 <__eerd_byte_m644pa>
    3b28:	92 bd       	out	0x22, r25	; 34
    3b2a:	81 bd       	out	0x21, r24	; 33
    3b2c:	f8 9a       	sbi	0x1f, 0	; 31
    3b2e:	99 27       	eor	r25, r25
    3b30:	80 b5       	in	r24, 0x20	; 32
    3b32:	08 95       	ret

00003b34 <__eerd_word_m644pa>:
    3b34:	a8 e1       	ldi	r26, 0x18	; 24
    3b36:	b0 e0       	ldi	r27, 0x00	; 0
    3b38:	42 e0       	ldi	r20, 0x02	; 2
    3b3a:	50 e0       	ldi	r21, 0x00	; 0
    3b3c:	0c 94 c5 1d 	jmp	0x3b8a	; 0x3b8a <__eerd_blraw_m644pa>

00003b40 <__eewr_byte_m644pa>:
    3b40:	26 2f       	mov	r18, r22

00003b42 <__eewr_r18_m644pa>:
    3b42:	f9 99       	sbic	0x1f, 1	; 31
    3b44:	fe cf       	rjmp	.-4      	; 0x3b42 <__eewr_r18_m644pa>
    3b46:	1f ba       	out	0x1f, r1	; 31
    3b48:	92 bd       	out	0x22, r25	; 34
    3b4a:	81 bd       	out	0x21, r24	; 33
    3b4c:	20 bd       	out	0x20, r18	; 32
    3b4e:	0f b6       	in	r0, 0x3f	; 63
    3b50:	f8 94       	cli
    3b52:	fa 9a       	sbi	0x1f, 2	; 31
    3b54:	f9 9a       	sbi	0x1f, 1	; 31
    3b56:	0f be       	out	0x3f, r0	; 63
    3b58:	01 96       	adiw	r24, 0x01	; 1
    3b5a:	08 95       	ret

00003b5c <__eewr_word_m644pa>:
    3b5c:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <__eewr_byte_m644pa>
    3b60:	27 2f       	mov	r18, r23
    3b62:	0c 94 a1 1d 	jmp	0x3b42	; 0x3b42 <__eewr_r18_m644pa>

00003b66 <strrev>:
    3b66:	dc 01       	movw	r26, r24
    3b68:	fc 01       	movw	r30, r24
    3b6a:	67 2f       	mov	r22, r23
    3b6c:	71 91       	ld	r23, Z+
    3b6e:	77 23       	and	r23, r23
    3b70:	e1 f7       	brne	.-8      	; 0x3b6a <strrev+0x4>
    3b72:	32 97       	sbiw	r30, 0x02	; 2
    3b74:	04 c0       	rjmp	.+8      	; 0x3b7e <strrev+0x18>
    3b76:	7c 91       	ld	r23, X
    3b78:	6d 93       	st	X+, r22
    3b7a:	70 83       	st	Z, r23
    3b7c:	62 91       	ld	r22, -Z
    3b7e:	ae 17       	cp	r26, r30
    3b80:	bf 07       	cpc	r27, r31
    3b82:	c8 f3       	brcs	.-14     	; 0x3b76 <strrev+0x10>
    3b84:	08 95       	ret

00003b86 <__eerd_block_m644pa>:
    3b86:	dc 01       	movw	r26, r24
    3b88:	cb 01       	movw	r24, r22

00003b8a <__eerd_blraw_m644pa>:
    3b8a:	fc 01       	movw	r30, r24
    3b8c:	f9 99       	sbic	0x1f, 1	; 31
    3b8e:	fe cf       	rjmp	.-4      	; 0x3b8c <__eerd_blraw_m644pa+0x2>
    3b90:	06 c0       	rjmp	.+12     	; 0x3b9e <__eerd_blraw_m644pa+0x14>
    3b92:	f2 bd       	out	0x22, r31	; 34
    3b94:	e1 bd       	out	0x21, r30	; 33
    3b96:	f8 9a       	sbi	0x1f, 0	; 31
    3b98:	31 96       	adiw	r30, 0x01	; 1
    3b9a:	00 b4       	in	r0, 0x20	; 32
    3b9c:	0d 92       	st	X+, r0
    3b9e:	41 50       	subi	r20, 0x01	; 1
    3ba0:	50 40       	sbci	r21, 0x00	; 0
    3ba2:	b8 f7       	brcc	.-18     	; 0x3b92 <__eerd_blraw_m644pa+0x8>
    3ba4:	08 95       	ret

00003ba6 <_exit>:
    3ba6:	f8 94       	cli

00003ba8 <__stop_program>:
    3ba8:	ff cf       	rjmp	.-2      	; 0x3ba8 <__stop_program>
