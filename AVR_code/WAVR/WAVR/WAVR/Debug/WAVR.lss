
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000072  00800100  00002ba0  00002c54  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002ba0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000041  00800172  00800172  00002cc6  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  00002cc6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00001008  00000000  00000000  00002cd0  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000522  00000000  00000000  00003cd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  00004200  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001f6e  00000000  00000000  00004320  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000397  00000000  00000000  0000628e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000d81  00000000  00000000  00006625  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000788  00000000  00000000  000073a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000009ec  00000000  00000000  00007b30  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000fe0  00000000  00000000  0000851c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 40 0a 	jmp	0x1480	; 0x1480 <__vector_3>
      10:	0c 94 30 0a 	jmp	0x1460	; 0x1460 <__vector_4>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 81 0a 	jmp	0x1502	; 0x1502 <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 fd 0a 	jmp	0x15fa	; 0x15fa <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	e5 14       	cp	r14, r5

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d8 e0       	ldi	r29, 0x08	; 8
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	e0 ea       	ldi	r30, 0xA0	; 160
      92:	fb e2       	ldi	r31, 0x2B	; 43
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	a2 37       	cpi	r26, 0x72	; 114
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a2 e7       	ldi	r26, 0x72	; 114
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	a3 3b       	cpi	r26, 0xB3	; 179
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 27 15 	call	0x2a4e	; 0x2a4e <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 2b 0b 	call	0x1656	; 0x1656 <main>
      ca:	0c 94 ce 15 	jmp	0x2b9c	; 0x2b9c <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
	
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	cd b7       	in	r28, 0x3d	; 61
     60a:	de b7       	in	r29, 0x3e	; 62
     60c:	2d 97       	sbiw	r28, 0x0d	; 13
     60e:	0f b6       	in	r0, 0x3f	; 63
     610:	f8 94       	cli
     612:	de bf       	out	0x3e, r29	; 62
     614:	0f be       	out	0x3f, r0	; 63
     616:	cd bf       	out	0x3d, r28	; 61
     618:	9d 87       	std	Y+13, r25	; 0x0d
     61a:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     61c:	8c 85       	ldd	r24, Y+12	; 0x0c
     61e:	9d 85       	ldd	r25, Y+13	; 0x0d
     620:	fc 01       	movw	r30, r24
     622:	80 81       	ld	r24, Z
     624:	91 81       	ldd	r25, Z+1	; 0x01
     626:	9e 01       	movw	r18, r28
     628:	2f 5f       	subi	r18, 0xFF	; 255
     62a:	3f 4f       	sbci	r19, 0xFF	; 255
     62c:	b9 01       	movw	r22, r18
     62e:	4a e0       	ldi	r20, 0x0A	; 10
     630:	50 e0       	ldi	r21, 0x00	; 0
     632:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <itoa>
	itoa(day,dayString,10);
     636:	8c 85       	ldd	r24, Y+12	; 0x0c
     638:	9d 85       	ldd	r25, Y+13	; 0x0d
     63a:	fc 01       	movw	r30, r24
     63c:	82 81       	ldd	r24, Z+2	; 0x02
     63e:	93 81       	ldd	r25, Z+3	; 0x03
     640:	9e 01       	movw	r18, r28
     642:	2c 5f       	subi	r18, 0xFC	; 252
     644:	3f 4f       	sbci	r19, 0xFF	; 255
     646:	b9 01       	movw	r22, r18
     648:	4a e0       	ldi	r20, 0x0A	; 10
     64a:	50 e0       	ldi	r21, 0x00	; 0
     64c:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <itoa>
	itoa(year,yearString,10);
     650:	8c 85       	ldd	r24, Y+12	; 0x0c
     652:	9d 85       	ldd	r25, Y+13	; 0x0d
     654:	fc 01       	movw	r30, r24
     656:	84 81       	ldd	r24, Z+4	; 0x04
     658:	95 81       	ldd	r25, Z+5	; 0x05
     65a:	9e 01       	movw	r18, r28
     65c:	29 5f       	subi	r18, 0xF9	; 249
     65e:	3f 4f       	sbci	r19, 0xFF	; 255
     660:	b9 01       	movw	r22, r18
     662:	4a e0       	ldi	r20, 0x0A	; 10
     664:	50 e0       	ldi	r21, 0x00	; 0
     666:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <itoa>
	strcpy(dateString,monthString);
     66a:	8c 85       	ldd	r24, Y+12	; 0x0c
     66c:	9d 85       	ldd	r25, Y+13	; 0x0d
     66e:	06 96       	adiw	r24, 0x06	; 6
     670:	9e 01       	movw	r18, r28
     672:	2f 5f       	subi	r18, 0xFF	; 255
     674:	3f 4f       	sbci	r19, 0xFF	; 255
     676:	b9 01       	movw	r22, r18
     678:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
	strcat(dateString,",");
     67c:	8c 85       	ldd	r24, Y+12	; 0x0c
     67e:	9d 85       	ldd	r25, Y+13	; 0x0d
     680:	9c 01       	movw	r18, r24
     682:	2a 5f       	subi	r18, 0xFA	; 250
     684:	3f 4f       	sbci	r19, 0xFF	; 255
     686:	c9 01       	movw	r24, r18
     688:	ac 01       	movw	r20, r24
     68a:	fa 01       	movw	r30, r20
     68c:	01 90       	ld	r0, Z+
     68e:	00 20       	and	r0, r0
     690:	e9 f7       	brne	.-6      	; 0x68c <_ZN6myDate7getDateEv+0x88>
     692:	cf 01       	movw	r24, r30
     694:	01 97       	sbiw	r24, 0x01	; 1
     696:	84 1b       	sub	r24, r20
     698:	95 0b       	sbc	r25, r21
     69a:	82 0f       	add	r24, r18
     69c:	93 1f       	adc	r25, r19
     69e:	2c e2       	ldi	r18, 0x2C	; 44
     6a0:	30 e0       	ldi	r19, 0x00	; 0
     6a2:	fc 01       	movw	r30, r24
     6a4:	31 83       	std	Z+1, r19	; 0x01
     6a6:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     6a8:	8c 85       	ldd	r24, Y+12	; 0x0c
     6aa:	9d 85       	ldd	r25, Y+13	; 0x0d
     6ac:	06 96       	adiw	r24, 0x06	; 6
     6ae:	9e 01       	movw	r18, r28
     6b0:	2c 5f       	subi	r18, 0xFC	; 252
     6b2:	3f 4f       	sbci	r19, 0xFF	; 255
     6b4:	b9 01       	movw	r22, r18
     6b6:	0e 94 49 15 	call	0x2a92	; 0x2a92 <strcat>
	strcat(dateString,",");
     6ba:	8c 85       	ldd	r24, Y+12	; 0x0c
     6bc:	9d 85       	ldd	r25, Y+13	; 0x0d
     6be:	9c 01       	movw	r18, r24
     6c0:	2a 5f       	subi	r18, 0xFA	; 250
     6c2:	3f 4f       	sbci	r19, 0xFF	; 255
     6c4:	c9 01       	movw	r24, r18
     6c6:	ac 01       	movw	r20, r24
     6c8:	fa 01       	movw	r30, r20
     6ca:	01 90       	ld	r0, Z+
     6cc:	00 20       	and	r0, r0
     6ce:	e9 f7       	brne	.-6      	; 0x6ca <_ZN6myDate7getDateEv+0xc6>
     6d0:	cf 01       	movw	r24, r30
     6d2:	01 97       	sbiw	r24, 0x01	; 1
     6d4:	84 1b       	sub	r24, r20
     6d6:	95 0b       	sbc	r25, r21
     6d8:	82 0f       	add	r24, r18
     6da:	93 1f       	adc	r25, r19
     6dc:	2c e2       	ldi	r18, 0x2C	; 44
     6de:	30 e0       	ldi	r19, 0x00	; 0
     6e0:	fc 01       	movw	r30, r24
     6e2:	31 83       	std	Z+1, r19	; 0x01
     6e4:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     6e6:	8c 85       	ldd	r24, Y+12	; 0x0c
     6e8:	9d 85       	ldd	r25, Y+13	; 0x0d
     6ea:	06 96       	adiw	r24, 0x06	; 6
     6ec:	9e 01       	movw	r18, r28
     6ee:	29 5f       	subi	r18, 0xF9	; 249
     6f0:	3f 4f       	sbci	r19, 0xFF	; 255
     6f2:	b9 01       	movw	r22, r18
     6f4:	0e 94 49 15 	call	0x2a92	; 0x2a92 <strcat>
	dateString[15] = ' ';
     6f8:	8c 85       	ldd	r24, Y+12	; 0x0c
     6fa:	9d 85       	ldd	r25, Y+13	; 0x0d
     6fc:	20 e2       	ldi	r18, 0x20	; 32
     6fe:	fc 01       	movw	r30, r24
     700:	25 8b       	std	Z+21, r18	; 0x15
	dateString[16] = '\0';
     702:	8c 85       	ldd	r24, Y+12	; 0x0c
     704:	9d 85       	ldd	r25, Y+13	; 0x0d
     706:	fc 01       	movw	r30, r24
     708:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     70a:	8c 85       	ldd	r24, Y+12	; 0x0c
     70c:	9d 85       	ldd	r25, Y+13	; 0x0d
     70e:	06 96       	adiw	r24, 0x06	; 6
     710:	2d 96       	adiw	r28, 0x0d	; 13
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	de bf       	out	0x3e, r29	; 62
     718:	0f be       	out	0x3f, r0	; 63
     71a:	cd bf       	out	0x3d, r28	; 61
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	08 95       	ret

00000722 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     722:	cf 93       	push	r28
     724:	df 93       	push	r29
     726:	00 d0       	rcall	.+0      	; 0x728 <_ZN6myTimeC1Ev+0x6>
     728:	cd b7       	in	r28, 0x3d	; 61
     72a:	de b7       	in	r29, 0x3e	; 62
     72c:	9a 83       	std	Y+2, r25	; 0x02
     72e:	89 83       	std	Y+1, r24	; 0x01
     730:	89 81       	ldd	r24, Y+1	; 0x01
     732:	9a 81       	ldd	r25, Y+2	; 0x02
     734:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     738:	89 81       	ldd	r24, Y+1	; 0x01
     73a:	9a 81       	ldd	r25, Y+2	; 0x02
     73c:	60 e0       	ldi	r22, 0x00	; 0
     73e:	70 e0       	ldi	r23, 0x00	; 0
     740:	40 e0       	ldi	r20, 0x00	; 0
     742:	50 e0       	ldi	r21, 0x00	; 0
     744:	20 e0       	ldi	r18, 0x00	; 0
     746:	30 e0       	ldi	r19, 0x00	; 0
     748:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
}
     74c:	0f 90       	pop	r0
     74e:	0f 90       	pop	r0
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	08 95       	ret

00000756 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     756:	cf 93       	push	r28
     758:	df 93       	push	r29
     75a:	cd b7       	in	r28, 0x3d	; 61
     75c:	de b7       	in	r29, 0x3e	; 62
     75e:	28 97       	sbiw	r28, 0x08	; 8
     760:	0f b6       	in	r0, 0x3f	; 63
     762:	f8 94       	cli
     764:	de bf       	out	0x3e, r29	; 62
     766:	0f be       	out	0x3f, r0	; 63
     768:	cd bf       	out	0x3d, r28	; 61
     76a:	9a 83       	std	Y+2, r25	; 0x02
     76c:	89 83       	std	Y+1, r24	; 0x01
     76e:	7c 83       	std	Y+4, r23	; 0x04
     770:	6b 83       	std	Y+3, r22	; 0x03
     772:	5e 83       	std	Y+6, r21	; 0x06
     774:	4d 83       	std	Y+5, r20	; 0x05
     776:	38 87       	std	Y+8, r19	; 0x08
     778:	2f 83       	std	Y+7, r18	; 0x07
     77a:	89 81       	ldd	r24, Y+1	; 0x01
     77c:	9a 81       	ldd	r25, Y+2	; 0x02
     77e:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     782:	89 81       	ldd	r24, Y+1	; 0x01
     784:	9a 81       	ldd	r25, Y+2	; 0x02
     786:	6b 81       	ldd	r22, Y+3	; 0x03
     788:	7c 81       	ldd	r23, Y+4	; 0x04
     78a:	4d 81       	ldd	r20, Y+5	; 0x05
     78c:	5e 81       	ldd	r21, Y+6	; 0x06
     78e:	2f 81       	ldd	r18, Y+7	; 0x07
     790:	38 85       	ldd	r19, Y+8	; 0x08
     792:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
}
     796:	28 96       	adiw	r28, 0x08	; 8
     798:	0f b6       	in	r0, 0x3f	; 63
     79a:	f8 94       	cli
     79c:	de bf       	out	0x3e, r29	; 62
     79e:	0f be       	out	0x3f, r0	; 63
     7a0:	cd bf       	out	0x3d, r28	; 61
     7a2:	df 91       	pop	r29
     7a4:	cf 91       	pop	r28
     7a6:	08 95       	ret

000007a8 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     7a8:	cf 92       	push	r12
     7aa:	df 92       	push	r13
     7ac:	ef 92       	push	r14
     7ae:	ff 92       	push	r15
     7b0:	0f 93       	push	r16
     7b2:	1f 93       	push	r17
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
     7bc:	2e 97       	sbiw	r28, 0x0e	; 14
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	f8 94       	cli
     7c2:	de bf       	out	0x3e, r29	; 62
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	cd bf       	out	0x3d, r28	; 61
     7c8:	9a 83       	std	Y+2, r25	; 0x02
     7ca:	89 83       	std	Y+1, r24	; 0x01
     7cc:	7c 83       	std	Y+4, r23	; 0x04
     7ce:	6b 83       	std	Y+3, r22	; 0x03
     7d0:	5e 83       	std	Y+6, r21	; 0x06
     7d2:	4d 83       	std	Y+5, r20	; 0x05
     7d4:	38 87       	std	Y+8, r19	; 0x08
     7d6:	2f 83       	std	Y+7, r18	; 0x07
     7d8:	1a 87       	std	Y+10, r17	; 0x0a
     7da:	09 87       	std	Y+9, r16	; 0x09
     7dc:	fc 86       	std	Y+12, r15	; 0x0c
     7de:	eb 86       	std	Y+11, r14	; 0x0b
     7e0:	de 86       	std	Y+14, r13	; 0x0e
     7e2:	cd 86       	std	Y+13, r12	; 0x0d
     7e4:	89 81       	ldd	r24, Y+1	; 0x01
     7e6:	9a 81       	ldd	r25, Y+2	; 0x02
     7e8:	69 85       	ldd	r22, Y+9	; 0x09
     7ea:	7a 85       	ldd	r23, Y+10	; 0x0a
     7ec:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ee:	5c 85       	ldd	r21, Y+12	; 0x0c
     7f0:	2d 85       	ldd	r18, Y+13	; 0x0d
     7f2:	3e 85       	ldd	r19, Y+14	; 0x0e
     7f4:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     7f8:	89 81       	ldd	r24, Y+1	; 0x01
     7fa:	9a 81       	ldd	r25, Y+2	; 0x02
     7fc:	6b 81       	ldd	r22, Y+3	; 0x03
     7fe:	7c 81       	ldd	r23, Y+4	; 0x04
     800:	4d 81       	ldd	r20, Y+5	; 0x05
     802:	5e 81       	ldd	r21, Y+6	; 0x06
     804:	2f 81       	ldd	r18, Y+7	; 0x07
     806:	38 85       	ldd	r19, Y+8	; 0x08
     808:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
}
     80c:	2e 96       	adiw	r28, 0x0e	; 14
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	de bf       	out	0x3e, r29	; 62
     814:	0f be       	out	0x3f, r0	; 63
     816:	cd bf       	out	0x3d, r28	; 61
     818:	df 91       	pop	r29
     81a:	cf 91       	pop	r28
     81c:	1f 91       	pop	r17
     81e:	0f 91       	pop	r16
     820:	ff 90       	pop	r15
     822:	ef 90       	pop	r14
     824:	df 90       	pop	r13
     826:	cf 90       	pop	r12
     828:	08 95       	ret

0000082a <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	00 d0       	rcall	.+0      	; 0x830 <_ZN6myTime10getSecondsEv+0x6>
     830:	cd b7       	in	r28, 0x3d	; 61
     832:	de b7       	in	r29, 0x3e	; 62
     834:	9a 83       	std	Y+2, r25	; 0x02
     836:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     838:	89 81       	ldd	r24, Y+1	; 0x01
     83a:	9a 81       	ldd	r25, Y+2	; 0x02
     83c:	fc 01       	movw	r30, r24
     83e:	83 8d       	ldd	r24, Z+27	; 0x1b
     840:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     842:	0f 90       	pop	r0
     844:	0f 90       	pop	r0
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	08 95       	ret

0000084c <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     84c:	cf 93       	push	r28
     84e:	df 93       	push	r29
     850:	00 d0       	rcall	.+0      	; 0x852 <_ZN6myTime10getMinutesEv+0x6>
     852:	cd b7       	in	r28, 0x3d	; 61
     854:	de b7       	in	r29, 0x3e	; 62
     856:	9a 83       	std	Y+2, r25	; 0x02
     858:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     85a:	89 81       	ldd	r24, Y+1	; 0x01
     85c:	9a 81       	ldd	r25, Y+2	; 0x02
     85e:	fc 01       	movw	r30, r24
     860:	81 8d       	ldd	r24, Z+25	; 0x19
     862:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     864:	0f 90       	pop	r0
     866:	0f 90       	pop	r0
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	08 95       	ret

0000086e <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
     872:	00 d0       	rcall	.+0      	; 0x874 <_ZN6myTime8getHoursEv+0x6>
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
     878:	9a 83       	std	Y+2, r25	; 0x02
     87a:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     87c:	89 81       	ldd	r24, Y+1	; 0x01
     87e:	9a 81       	ldd	r25, Y+2	; 0x02
     880:	fc 01       	movw	r30, r24
     882:	87 89       	ldd	r24, Z+23	; 0x17
     884:	90 8d       	ldd	r25, Z+24	; 0x18
}
     886:	0f 90       	pop	r0
     888:	0f 90       	pop	r0
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	08 95       	ret

00000890 <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	cd b7       	in	r28, 0x3d	; 61
     896:	de b7       	in	r29, 0x3e	; 62
     898:	a2 97       	sbiw	r28, 0x22	; 34
     89a:	0f b6       	in	r0, 0x3f	; 63
     89c:	f8 94       	cli
     89e:	de bf       	out	0x3e, r29	; 62
     8a0:	0f be       	out	0x3f, r0	; 63
     8a2:	cd bf       	out	0x3d, r28	; 61
     8a4:	98 a3       	lds	r25, 0x58
     8a6:	8f 8f       	std	Y+31, r24	; 0x1f
     8a8:	7a a3       	lds	r23, 0x5a
     8aa:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     8ac:	ce 01       	movw	r24, r28
     8ae:	0b 96       	adiw	r24, 0x0b	; 11
     8b0:	29 a1       	lds	r18, 0x49
     8b2:	3a a1       	lds	r19, 0x4a
     8b4:	b9 01       	movw	r22, r18
     8b6:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
	for (int j=0; j<3; j++){
     8ba:	1a 82       	std	Y+2, r1	; 0x02
     8bc:	19 82       	std	Y+1, r1	; 0x01
     8be:	43 c0       	rjmp	.+134    	; 0x946 <__stack+0x47>
		for (int i=0; i<2; i++){
     8c0:	1c 82       	std	Y+4, r1	; 0x04
     8c2:	1b 82       	std	Y+3, r1	; 0x03
     8c4:	20 c0       	rjmp	.+64     	; 0x906 <__stack+0x7>
				tempString[i]=currentString[i+j*3];
     8c6:	29 81       	ldd	r18, Y+1	; 0x01
     8c8:	3a 81       	ldd	r19, Y+2	; 0x02
     8ca:	c9 01       	movw	r24, r18
     8cc:	88 0f       	add	r24, r24
     8ce:	99 1f       	adc	r25, r25
     8d0:	28 0f       	add	r18, r24
     8d2:	39 1f       	adc	r19, r25
     8d4:	8b 81       	ldd	r24, Y+3	; 0x03
     8d6:	9c 81       	ldd	r25, Y+4	; 0x04
     8d8:	82 0f       	add	r24, r18
     8da:	93 1f       	adc	r25, r19
     8dc:	9e 01       	movw	r18, r28
     8de:	25 5f       	subi	r18, 0xF5	; 245
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	82 0f       	add	r24, r18
     8e4:	93 1f       	adc	r25, r19
     8e6:	fc 01       	movw	r30, r24
     8e8:	40 81       	ld	r20, Z
     8ea:	9e 01       	movw	r18, r28
     8ec:	2b 5e       	subi	r18, 0xEB	; 235
     8ee:	3f 4f       	sbci	r19, 0xFF	; 255
     8f0:	8b 81       	ldd	r24, Y+3	; 0x03
     8f2:	9c 81       	ldd	r25, Y+4	; 0x04
     8f4:	82 0f       	add	r24, r18
     8f6:	93 1f       	adc	r25, r19
     8f8:	fc 01       	movw	r30, r24
     8fa:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     8fc:	8b 81       	ldd	r24, Y+3	; 0x03
     8fe:	9c 81       	ldd	r25, Y+4	; 0x04
     900:	01 96       	adiw	r24, 0x01	; 1
     902:	9c 83       	std	Y+4, r25	; 0x04
     904:	8b 83       	std	Y+3, r24	; 0x03
     906:	21 e0       	ldi	r18, 0x01	; 1
     908:	8b 81       	ldd	r24, Y+3	; 0x03
     90a:	9c 81       	ldd	r25, Y+4	; 0x04
     90c:	82 30       	cpi	r24, 0x02	; 2
     90e:	91 05       	cpc	r25, r1
     910:	0c f0       	brlt	.+2      	; 0x914 <__stack+0x15>
     912:	20 e0       	ldi	r18, 0x00	; 0
     914:	22 23       	and	r18, r18
     916:	b9 f6       	brne	.-82     	; 0x8c6 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     918:	ce 01       	movw	r24, r28
     91a:	45 96       	adiw	r24, 0x15	; 21
     91c:	0e 94 2b 15 	call	0x2a56	; 0x2a56 <atoi>
     920:	9c 01       	movw	r18, r24
     922:	89 81       	ldd	r24, Y+1	; 0x01
     924:	9a 81       	ldd	r25, Y+2	; 0x02
     926:	88 0f       	add	r24, r24
     928:	99 1f       	adc	r25, r25
     92a:	ae 01       	movw	r20, r28
     92c:	4f 5f       	subi	r20, 0xFF	; 255
     92e:	5f 4f       	sbci	r21, 0xFF	; 255
     930:	84 0f       	add	r24, r20
     932:	95 1f       	adc	r25, r21
     934:	04 96       	adiw	r24, 0x04	; 4
     936:	fc 01       	movw	r30, r24
     938:	31 83       	std	Z+1, r19	; 0x01
     93a:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     93c:	89 81       	ldd	r24, Y+1	; 0x01
     93e:	9a 81       	ldd	r25, Y+2	; 0x02
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	9a 83       	std	Y+2, r25	; 0x02
     944:	89 83       	std	Y+1, r24	; 0x01
     946:	21 e0       	ldi	r18, 0x01	; 1
     948:	89 81       	ldd	r24, Y+1	; 0x01
     94a:	9a 81       	ldd	r25, Y+2	; 0x02
     94c:	83 30       	cpi	r24, 0x03	; 3
     94e:	91 05       	cpc	r25, r1
     950:	0c f0       	brlt	.+2      	; 0x954 <__stack+0x55>
     952:	20 e0       	ldi	r18, 0x00	; 0
     954:	22 23       	and	r18, r18
     956:	09 f0       	breq	.+2      	; 0x95a <__stack+0x5b>
     958:	b3 cf       	rjmp	.-154    	; 0x8c0 <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     95a:	8d 81       	ldd	r24, Y+5	; 0x05
     95c:	9e 81       	ldd	r25, Y+6	; 0x06
     95e:	47 96       	adiw	r24, 0x17	; 23
     960:	8f 32       	cpi	r24, 0x2F	; 47
     962:	91 05       	cpc	r25, r1
     964:	c0 f4       	brcc	.+48     	; 0x996 <__stack+0x97>
     966:	8f 81       	ldd	r24, Y+7	; 0x07
     968:	98 85       	ldd	r25, Y+8	; 0x08
     96a:	cb 96       	adiw	r24, 0x3b	; 59
     96c:	87 37       	cpi	r24, 0x77	; 119
     96e:	91 05       	cpc	r25, r1
     970:	90 f4       	brcc	.+36     	; 0x996 <__stack+0x97>
     972:	89 85       	ldd	r24, Y+9	; 0x09
     974:	9a 85       	ldd	r25, Y+10	; 0x0a
     976:	cb 96       	adiw	r24, 0x3b	; 59
     978:	87 37       	cpi	r24, 0x77	; 119
     97a:	91 05       	cpc	r25, r1
     97c:	60 f4       	brcc	.+24     	; 0x996 <__stack+0x97>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     97e:	6d 81       	ldd	r22, Y+5	; 0x05
     980:	7e 81       	ldd	r23, Y+6	; 0x06
     982:	4f 81       	ldd	r20, Y+7	; 0x07
     984:	58 85       	ldd	r21, Y+8	; 0x08
     986:	29 85       	ldd	r18, Y+9	; 0x09
     988:	3a 85       	ldd	r19, Y+10	; 0x0a
     98a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     98c:	98 a1       	lds	r25, 0x48
     98e:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
		return fTrue;
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	01 c0       	rjmp	.+2      	; 0x998 <__stack+0x99>
	} 
	return fFalse;
     996:	80 e0       	ldi	r24, 0x00	; 0
}
     998:	a2 96       	adiw	r28, 0x22	; 34
     99a:	0f b6       	in	r0, 0x3f	; 63
     99c:	f8 94       	cli
     99e:	de bf       	out	0x3e, r29	; 62
     9a0:	0f be       	out	0x3f, r0	; 63
     9a2:	cd bf       	out	0x3d, r28	; 61
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	08 95       	ret

000009aa <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	cd b7       	in	r28, 0x3d	; 61
     9b0:	de b7       	in	r29, 0x3e	; 62
     9b2:	28 97       	sbiw	r28, 0x08	; 8
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	de bf       	out	0x3e, r29	; 62
     9ba:	0f be       	out	0x3f, r0	; 63
     9bc:	cd bf       	out	0x3d, r28	; 61
     9be:	9a 83       	std	Y+2, r25	; 0x02
     9c0:	89 83       	std	Y+1, r24	; 0x01
     9c2:	7c 83       	std	Y+4, r23	; 0x04
     9c4:	6b 83       	std	Y+3, r22	; 0x03
     9c6:	5e 83       	std	Y+6, r21	; 0x06
     9c8:	4d 83       	std	Y+5, r20	; 0x05
     9ca:	38 87       	std	Y+8, r19	; 0x08
     9cc:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     9ce:	89 81       	ldd	r24, Y+1	; 0x01
     9d0:	9a 81       	ldd	r25, Y+2	; 0x02
     9d2:	2b 81       	ldd	r18, Y+3	; 0x03
     9d4:	3c 81       	ldd	r19, Y+4	; 0x04
     9d6:	b9 01       	movw	r22, r18
     9d8:	0e 94 05 05 	call	0xa0a	; 0xa0a <_ZN6myTime7setHourEi>
	setMinute(minute);
     9dc:	89 81       	ldd	r24, Y+1	; 0x01
     9de:	9a 81       	ldd	r25, Y+2	; 0x02
     9e0:	2d 81       	ldd	r18, Y+5	; 0x05
     9e2:	3e 81       	ldd	r19, Y+6	; 0x06
     9e4:	b9 01       	movw	r22, r18
     9e6:	0e 94 23 05 	call	0xa46	; 0xa46 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     9ea:	89 81       	ldd	r24, Y+1	; 0x01
     9ec:	9a 81       	ldd	r25, Y+2	; 0x02
     9ee:	2f 81       	ldd	r18, Y+7	; 0x07
     9f0:	38 85       	ldd	r19, Y+8	; 0x08
     9f2:	b9 01       	movw	r22, r18
     9f4:	0e 94 41 05 	call	0xa82	; 0xa82 <_ZN6myTime9setSecondEi>
}
     9f8:	28 96       	adiw	r28, 0x08	; 8
     9fa:	0f b6       	in	r0, 0x3f	; 63
     9fc:	f8 94       	cli
     9fe:	de bf       	out	0x3e, r29	; 62
     a00:	0f be       	out	0x3f, r0	; 63
     a02:	cd bf       	out	0x3d, r28	; 61
     a04:	df 91       	pop	r29
     a06:	cf 91       	pop	r28
     a08:	08 95       	ret

00000a0a <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     a0a:	cf 93       	push	r28
     a0c:	df 93       	push	r29
     a0e:	00 d0       	rcall	.+0      	; 0xa10 <_ZN6myTime7setHourEi+0x6>
     a10:	00 d0       	rcall	.+0      	; 0xa12 <_ZN6myTime7setHourEi+0x8>
     a12:	cd b7       	in	r28, 0x3d	; 61
     a14:	de b7       	in	r29, 0x3e	; 62
     a16:	9a 83       	std	Y+2, r25	; 0x02
     a18:	89 83       	std	Y+1, r24	; 0x01
     a1a:	7c 83       	std	Y+4, r23	; 0x04
     a1c:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     a1e:	8b 81       	ldd	r24, Y+3	; 0x03
     a20:	9c 81       	ldd	r25, Y+4	; 0x04
     a22:	47 96       	adiw	r24, 0x17	; 23
     a24:	8f 32       	cpi	r24, 0x2F	; 47
     a26:	91 05       	cpc	r25, r1
     a28:	38 f4       	brcc	.+14     	; 0xa38 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     a2a:	89 81       	ldd	r24, Y+1	; 0x01
     a2c:	9a 81       	ldd	r25, Y+2	; 0x02
     a2e:	2b 81       	ldd	r18, Y+3	; 0x03
     a30:	3c 81       	ldd	r19, Y+4	; 0x04
     a32:	fc 01       	movw	r30, r24
     a34:	30 8f       	std	Z+24, r19	; 0x18
     a36:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     a38:	0f 90       	pop	r0
     a3a:	0f 90       	pop	r0
     a3c:	0f 90       	pop	r0
     a3e:	0f 90       	pop	r0
     a40:	df 91       	pop	r29
     a42:	cf 91       	pop	r28
     a44:	08 95       	ret

00000a46 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     a46:	cf 93       	push	r28
     a48:	df 93       	push	r29
     a4a:	00 d0       	rcall	.+0      	; 0xa4c <_ZN6myTime9setMinuteEi+0x6>
     a4c:	00 d0       	rcall	.+0      	; 0xa4e <_ZN6myTime9setMinuteEi+0x8>
     a4e:	cd b7       	in	r28, 0x3d	; 61
     a50:	de b7       	in	r29, 0x3e	; 62
     a52:	9a 83       	std	Y+2, r25	; 0x02
     a54:	89 83       	std	Y+1, r24	; 0x01
     a56:	7c 83       	std	Y+4, r23	; 0x04
     a58:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     a5a:	8b 81       	ldd	r24, Y+3	; 0x03
     a5c:	9c 81       	ldd	r25, Y+4	; 0x04
     a5e:	cb 96       	adiw	r24, 0x3b	; 59
     a60:	87 37       	cpi	r24, 0x77	; 119
     a62:	91 05       	cpc	r25, r1
     a64:	38 f4       	brcc	.+14     	; 0xa74 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     a66:	89 81       	ldd	r24, Y+1	; 0x01
     a68:	9a 81       	ldd	r25, Y+2	; 0x02
     a6a:	2b 81       	ldd	r18, Y+3	; 0x03
     a6c:	3c 81       	ldd	r19, Y+4	; 0x04
     a6e:	fc 01       	movw	r30, r24
     a70:	32 8f       	std	Z+26, r19	; 0x1a
     a72:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     a74:	0f 90       	pop	r0
     a76:	0f 90       	pop	r0
     a78:	0f 90       	pop	r0
     a7a:	0f 90       	pop	r0
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	08 95       	ret

00000a82 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     a82:	cf 93       	push	r28
     a84:	df 93       	push	r29
     a86:	00 d0       	rcall	.+0      	; 0xa88 <_ZN6myTime9setSecondEi+0x6>
     a88:	00 d0       	rcall	.+0      	; 0xa8a <_ZN6myTime9setSecondEi+0x8>
     a8a:	cd b7       	in	r28, 0x3d	; 61
     a8c:	de b7       	in	r29, 0x3e	; 62
     a8e:	9a 83       	std	Y+2, r25	; 0x02
     a90:	89 83       	std	Y+1, r24	; 0x01
     a92:	7c 83       	std	Y+4, r23	; 0x04
     a94:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     a96:	8b 81       	ldd	r24, Y+3	; 0x03
     a98:	9c 81       	ldd	r25, Y+4	; 0x04
     a9a:	cb 96       	adiw	r24, 0x3b	; 59
     a9c:	87 37       	cpi	r24, 0x77	; 119
     a9e:	91 05       	cpc	r25, r1
     aa0:	38 f4       	brcc	.+14     	; 0xab0 <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     aa2:	89 81       	ldd	r24, Y+1	; 0x01
     aa4:	9a 81       	ldd	r25, Y+2	; 0x02
     aa6:	2b 81       	ldd	r18, Y+3	; 0x03
     aa8:	3c 81       	ldd	r19, Y+4	; 0x04
     aaa:	fc 01       	movw	r30, r24
     aac:	34 8f       	std	Z+28, r19	; 0x1c
     aae:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     ab0:	0f 90       	pop	r0
     ab2:	0f 90       	pop	r0
     ab4:	0f 90       	pop	r0
     ab6:	0f 90       	pop	r0
     ab8:	df 91       	pop	r29
     aba:	cf 91       	pop	r28
     abc:	08 95       	ret

00000abe <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29
     ac2:	cd b7       	in	r28, 0x3d	; 61
     ac4:	de b7       	in	r29, 0x3e	; 62
     ac6:	28 97       	sbiw	r28, 0x08	; 8
     ac8:	0f b6       	in	r0, 0x3f	; 63
     aca:	f8 94       	cli
     acc:	de bf       	out	0x3e, r29	; 62
     ace:	0f be       	out	0x3f, r0	; 63
     ad0:	cd bf       	out	0x3d, r28	; 61
     ad2:	9e 83       	std	Y+6, r25	; 0x06
     ad4:	8d 83       	std	Y+5, r24	; 0x05
     ad6:	78 87       	std	Y+8, r23	; 0x08
     ad8:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     ada:	8d 81       	ldd	r24, Y+5	; 0x05
     adc:	9e 81       	ldd	r25, Y+6	; 0x06
     ade:	fc 01       	movw	r30, r24
     ae0:	27 89       	ldd	r18, Z+23	; 0x17
     ae2:	30 8d       	ldd	r19, Z+24	; 0x18
     ae4:	8f 81       	ldd	r24, Y+7	; 0x07
     ae6:	98 85       	ldd	r25, Y+8	; 0x08
     ae8:	82 0f       	add	r24, r18
     aea:	93 1f       	adc	r25, r19
     aec:	9a 83       	std	Y+2, r25	; 0x02
     aee:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     af0:	89 81       	ldd	r24, Y+1	; 0x01
     af2:	9a 81       	ldd	r25, Y+2	; 0x02
     af4:	28 e1       	ldi	r18, 0x18	; 24
     af6:	30 e0       	ldi	r19, 0x00	; 0
     af8:	b9 01       	movw	r22, r18
     afa:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     afe:	9c 01       	movw	r18, r24
     b00:	8d 81       	ldd	r24, Y+5	; 0x05
     b02:	9e 81       	ldd	r25, Y+6	; 0x06
     b04:	fc 01       	movw	r30, r24
     b06:	30 8f       	std	Z+24, r19	; 0x18
     b08:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     b0a:	89 81       	ldd	r24, Y+1	; 0x01
     b0c:	9a 81       	ldd	r25, Y+2	; 0x02
     b0e:	21 e0       	ldi	r18, 0x01	; 1
     b10:	88 31       	cpi	r24, 0x18	; 24
     b12:	91 05       	cpc	r25, r1
     b14:	0c f4       	brge	.+2      	; 0xb18 <_ZN6myTime8addHoursEi+0x5a>
     b16:	20 e0       	ldi	r18, 0x00	; 0
     b18:	22 23       	and	r18, r18
     b1a:	91 f0       	breq	.+36     	; 0xb40 <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     b1c:	89 81       	ldd	r24, Y+1	; 0x01
     b1e:	9a 81       	ldd	r25, Y+2	; 0x02
     b20:	28 e1       	ldi	r18, 0x18	; 24
     b22:	30 e0       	ldi	r19, 0x00	; 0
     b24:	b9 01       	movw	r22, r18
     b26:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     b2a:	9b 01       	movw	r18, r22
     b2c:	c9 01       	movw	r24, r18
     b2e:	9c 83       	std	Y+4, r25	; 0x04
     b30:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     b32:	8d 81       	ldd	r24, Y+5	; 0x05
     b34:	9e 81       	ldd	r25, Y+6	; 0x06
     b36:	2b 81       	ldd	r18, Y+3	; 0x03
     b38:	3c 81       	ldd	r19, Y+4	; 0x04
     b3a:	b9 01       	movw	r22, r18
     b3c:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     b40:	28 96       	adiw	r28, 0x08	; 8
     b42:	0f b6       	in	r0, 0x3f	; 63
     b44:	f8 94       	cli
     b46:	de bf       	out	0x3e, r29	; 62
     b48:	0f be       	out	0x3f, r0	; 63
     b4a:	cd bf       	out	0x3d, r28	; 61
     b4c:	df 91       	pop	r29
     b4e:	cf 91       	pop	r28
     b50:	08 95       	ret

00000b52 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	cd b7       	in	r28, 0x3d	; 61
     b58:	de b7       	in	r29, 0x3e	; 62
     b5a:	28 97       	sbiw	r28, 0x08	; 8
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	de bf       	out	0x3e, r29	; 62
     b62:	0f be       	out	0x3f, r0	; 63
     b64:	cd bf       	out	0x3d, r28	; 61
     b66:	9e 83       	std	Y+6, r25	; 0x06
     b68:	8d 83       	std	Y+5, r24	; 0x05
     b6a:	78 87       	std	Y+8, r23	; 0x08
     b6c:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     b6e:	8d 81       	ldd	r24, Y+5	; 0x05
     b70:	9e 81       	ldd	r25, Y+6	; 0x06
     b72:	fc 01       	movw	r30, r24
     b74:	21 8d       	ldd	r18, Z+25	; 0x19
     b76:	32 8d       	ldd	r19, Z+26	; 0x1a
     b78:	8f 81       	ldd	r24, Y+7	; 0x07
     b7a:	98 85       	ldd	r25, Y+8	; 0x08
     b7c:	82 0f       	add	r24, r18
     b7e:	93 1f       	adc	r25, r19
     b80:	9a 83       	std	Y+2, r25	; 0x02
     b82:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	2c e3       	ldi	r18, 0x3C	; 60
     b8a:	30 e0       	ldi	r19, 0x00	; 0
     b8c:	b9 01       	movw	r22, r18
     b8e:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     b92:	9c 01       	movw	r18, r24
     b94:	8d 81       	ldd	r24, Y+5	; 0x05
     b96:	9e 81       	ldd	r25, Y+6	; 0x06
     b98:	fc 01       	movw	r30, r24
     b9a:	32 8f       	std	Z+26, r19	; 0x1a
     b9c:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	9a 81       	ldd	r25, Y+2	; 0x02
     ba2:	21 e0       	ldi	r18, 0x01	; 1
     ba4:	8c 33       	cpi	r24, 0x3C	; 60
     ba6:	91 05       	cpc	r25, r1
     ba8:	0c f4       	brge	.+2      	; 0xbac <_ZN6myTime10addMinutesEi+0x5a>
     baa:	20 e0       	ldi	r18, 0x00	; 0
     bac:	22 23       	and	r18, r18
     bae:	91 f0       	breq	.+36     	; 0xbd4 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
     bb2:	9a 81       	ldd	r25, Y+2	; 0x02
     bb4:	2c e3       	ldi	r18, 0x3C	; 60
     bb6:	30 e0       	ldi	r19, 0x00	; 0
     bb8:	b9 01       	movw	r22, r18
     bba:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     bbe:	9b 01       	movw	r18, r22
     bc0:	c9 01       	movw	r24, r18
     bc2:	9c 83       	std	Y+4, r25	; 0x04
     bc4:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     bc6:	2b 81       	ldd	r18, Y+3	; 0x03
     bc8:	3c 81       	ldd	r19, Y+4	; 0x04
     bca:	8d 81       	ldd	r24, Y+5	; 0x05
     bcc:	9e 81       	ldd	r25, Y+6	; 0x06
     bce:	b9 01       	movw	r22, r18
     bd0:	0e 94 5f 05 	call	0xabe	; 0xabe <_ZN6myTime8addHoursEi>
	}
}
     bd4:	28 96       	adiw	r28, 0x08	; 8
     bd6:	0f b6       	in	r0, 0x3f	; 63
     bd8:	f8 94       	cli
     bda:	de bf       	out	0x3e, r29	; 62
     bdc:	0f be       	out	0x3f, r0	; 63
     bde:	cd bf       	out	0x3d, r28	; 61
     be0:	df 91       	pop	r29
     be2:	cf 91       	pop	r28
     be4:	08 95       	ret

00000be6 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	cd b7       	in	r28, 0x3d	; 61
     bec:	de b7       	in	r29, 0x3e	; 62
     bee:	28 97       	sbiw	r28, 0x08	; 8
     bf0:	0f b6       	in	r0, 0x3f	; 63
     bf2:	f8 94       	cli
     bf4:	de bf       	out	0x3e, r29	; 62
     bf6:	0f be       	out	0x3f, r0	; 63
     bf8:	cd bf       	out	0x3d, r28	; 61
     bfa:	9e 83       	std	Y+6, r25	; 0x06
     bfc:	8d 83       	std	Y+5, r24	; 0x05
     bfe:	78 87       	std	Y+8, r23	; 0x08
     c00:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     c02:	8d 81       	ldd	r24, Y+5	; 0x05
     c04:	9e 81       	ldd	r25, Y+6	; 0x06
     c06:	fc 01       	movw	r30, r24
     c08:	23 8d       	ldd	r18, Z+27	; 0x1b
     c0a:	34 8d       	ldd	r19, Z+28	; 0x1c
     c0c:	8f 81       	ldd	r24, Y+7	; 0x07
     c0e:	98 85       	ldd	r25, Y+8	; 0x08
     c10:	82 0f       	add	r24, r18
     c12:	93 1f       	adc	r25, r19
     c14:	9a 83       	std	Y+2, r25	; 0x02
     c16:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     c18:	89 81       	ldd	r24, Y+1	; 0x01
     c1a:	9a 81       	ldd	r25, Y+2	; 0x02
     c1c:	2c e3       	ldi	r18, 0x3C	; 60
     c1e:	30 e0       	ldi	r19, 0x00	; 0
     c20:	b9 01       	movw	r22, r18
     c22:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     c26:	9c 01       	movw	r18, r24
     c28:	8d 81       	ldd	r24, Y+5	; 0x05
     c2a:	9e 81       	ldd	r25, Y+6	; 0x06
     c2c:	fc 01       	movw	r30, r24
     c2e:	34 8f       	std	Z+28, r19	; 0x1c
     c30:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	9a 81       	ldd	r25, Y+2	; 0x02
     c36:	21 e0       	ldi	r18, 0x01	; 1
     c38:	8c 33       	cpi	r24, 0x3C	; 60
     c3a:	91 05       	cpc	r25, r1
     c3c:	0c f4       	brge	.+2      	; 0xc40 <_ZN6myTime10addSecondsEi+0x5a>
     c3e:	20 e0       	ldi	r18, 0x00	; 0
     c40:	22 23       	and	r18, r18
     c42:	91 f0       	breq	.+36     	; 0xc68 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     c44:	89 81       	ldd	r24, Y+1	; 0x01
     c46:	9a 81       	ldd	r25, Y+2	; 0x02
     c48:	2c e3       	ldi	r18, 0x3C	; 60
     c4a:	30 e0       	ldi	r19, 0x00	; 0
     c4c:	b9 01       	movw	r22, r18
     c4e:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
     c52:	9b 01       	movw	r18, r22
     c54:	c9 01       	movw	r24, r18
     c56:	9c 83       	std	Y+4, r25	; 0x04
     c58:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     c5a:	2b 81       	ldd	r18, Y+3	; 0x03
     c5c:	3c 81       	ldd	r19, Y+4	; 0x04
     c5e:	8d 81       	ldd	r24, Y+5	; 0x05
     c60:	9e 81       	ldd	r25, Y+6	; 0x06
     c62:	b9 01       	movw	r22, r18
     c64:	0e 94 a9 05 	call	0xb52	; 0xb52 <_ZN6myTime10addMinutesEi>
	}
}
     c68:	28 96       	adiw	r28, 0x08	; 8
     c6a:	0f b6       	in	r0, 0x3f	; 63
     c6c:	f8 94       	cli
     c6e:	de bf       	out	0x3e, r29	; 62
     c70:	0f be       	out	0x3f, r0	; 63
     c72:	cd bf       	out	0x3d, r28	; 61
     c74:	df 91       	pop	r29
     c76:	cf 91       	pop	r28
     c78:	08 95       	ret

00000c7a <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     c7a:	cf 93       	push	r28
     c7c:	df 93       	push	r29
     c7e:	cd b7       	in	r28, 0x3d	; 61
     c80:	de b7       	in	r29, 0x3e	; 62
     c82:	2b 97       	sbiw	r28, 0x0b	; 11
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	f8 94       	cli
     c88:	de bf       	out	0x3e, r29	; 62
     c8a:	0f be       	out	0x3f, r0	; 63
     c8c:	cd bf       	out	0x3d, r28	; 61
     c8e:	9b 87       	std	Y+11, r25	; 0x0b
     c90:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     c92:	8a 85       	ldd	r24, Y+10	; 0x0a
     c94:	9b 85       	ldd	r25, Y+11	; 0x0b
     c96:	fc 01       	movw	r30, r24
     c98:	87 89       	ldd	r24, Z+23	; 0x17
     c9a:	90 8d       	ldd	r25, Z+24	; 0x18
     c9c:	9e 01       	movw	r18, r28
     c9e:	2f 5f       	subi	r18, 0xFF	; 255
     ca0:	3f 4f       	sbci	r19, 0xFF	; 255
     ca2:	b9 01       	movw	r22, r18
     ca4:	4a e0       	ldi	r20, 0x0A	; 10
     ca6:	50 e0       	ldi	r21, 0x00	; 0
     ca8:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <itoa>
	itoa(minute,minuteString,10);
     cac:	8a 85       	ldd	r24, Y+10	; 0x0a
     cae:	9b 85       	ldd	r25, Y+11	; 0x0b
     cb0:	fc 01       	movw	r30, r24
     cb2:	81 8d       	ldd	r24, Z+25	; 0x19
     cb4:	92 8d       	ldd	r25, Z+26	; 0x1a
     cb6:	9e 01       	movw	r18, r28
     cb8:	2c 5f       	subi	r18, 0xFC	; 252
     cba:	3f 4f       	sbci	r19, 0xFF	; 255
     cbc:	b9 01       	movw	r22, r18
     cbe:	4a e0       	ldi	r20, 0x0A	; 10
     cc0:	50 e0       	ldi	r21, 0x00	; 0
     cc2:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <itoa>
	itoa(second,secondString,10);
     cc6:	8a 85       	ldd	r24, Y+10	; 0x0a
     cc8:	9b 85       	ldd	r25, Y+11	; 0x0b
     cca:	fc 01       	movw	r30, r24
     ccc:	83 8d       	ldd	r24, Z+27	; 0x1b
     cce:	94 8d       	ldd	r25, Z+28	; 0x1c
     cd0:	9e 01       	movw	r18, r28
     cd2:	29 5f       	subi	r18, 0xF9	; 249
     cd4:	3f 4f       	sbci	r19, 0xFF	; 255
     cd6:	b9 01       	movw	r22, r18
     cd8:	4a e0       	ldi	r20, 0x0A	; 10
     cda:	50 e0       	ldi	r21, 0x00	; 0
     cdc:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <itoa>
	strcpy(timeString,hourString);
     ce0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ce2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ce4:	4d 96       	adiw	r24, 0x1d	; 29
     ce6:	9e 01       	movw	r18, r28
     ce8:	2f 5f       	subi	r18, 0xFF	; 255
     cea:	3f 4f       	sbci	r19, 0xFF	; 255
     cec:	b9 01       	movw	r22, r18
     cee:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
	strcat(timeString,":");
     cf2:	8a 85       	ldd	r24, Y+10	; 0x0a
     cf4:	9b 85       	ldd	r25, Y+11	; 0x0b
     cf6:	9c 01       	movw	r18, r24
     cf8:	23 5e       	subi	r18, 0xE3	; 227
     cfa:	3f 4f       	sbci	r19, 0xFF	; 255
     cfc:	c9 01       	movw	r24, r18
     cfe:	ac 01       	movw	r20, r24
     d00:	fa 01       	movw	r30, r20
     d02:	01 90       	ld	r0, Z+
     d04:	00 20       	and	r0, r0
     d06:	e9 f7       	brne	.-6      	; 0xd02 <_ZN6myTime7getTimeEv+0x88>
     d08:	cf 01       	movw	r24, r30
     d0a:	01 97       	sbiw	r24, 0x01	; 1
     d0c:	84 1b       	sub	r24, r20
     d0e:	95 0b       	sbc	r25, r21
     d10:	82 0f       	add	r24, r18
     d12:	93 1f       	adc	r25, r19
     d14:	2a e3       	ldi	r18, 0x3A	; 58
     d16:	30 e0       	ldi	r19, 0x00	; 0
     d18:	fc 01       	movw	r30, r24
     d1a:	31 83       	std	Z+1, r19	; 0x01
     d1c:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     d1e:	8a 85       	ldd	r24, Y+10	; 0x0a
     d20:	9b 85       	ldd	r25, Y+11	; 0x0b
     d22:	4d 96       	adiw	r24, 0x1d	; 29
     d24:	9e 01       	movw	r18, r28
     d26:	2c 5f       	subi	r18, 0xFC	; 252
     d28:	3f 4f       	sbci	r19, 0xFF	; 255
     d2a:	b9 01       	movw	r22, r18
     d2c:	0e 94 49 15 	call	0x2a92	; 0x2a92 <strcat>
	strcat(timeString,":");
     d30:	8a 85       	ldd	r24, Y+10	; 0x0a
     d32:	9b 85       	ldd	r25, Y+11	; 0x0b
     d34:	9c 01       	movw	r18, r24
     d36:	23 5e       	subi	r18, 0xE3	; 227
     d38:	3f 4f       	sbci	r19, 0xFF	; 255
     d3a:	c9 01       	movw	r24, r18
     d3c:	ac 01       	movw	r20, r24
     d3e:	fa 01       	movw	r30, r20
     d40:	01 90       	ld	r0, Z+
     d42:	00 20       	and	r0, r0
     d44:	e9 f7       	brne	.-6      	; 0xd40 <_ZN6myTime7getTimeEv+0xc6>
     d46:	cf 01       	movw	r24, r30
     d48:	01 97       	sbiw	r24, 0x01	; 1
     d4a:	84 1b       	sub	r24, r20
     d4c:	95 0b       	sbc	r25, r21
     d4e:	82 0f       	add	r24, r18
     d50:	93 1f       	adc	r25, r19
     d52:	2a e3       	ldi	r18, 0x3A	; 58
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	fc 01       	movw	r30, r24
     d58:	31 83       	std	Z+1, r19	; 0x01
     d5a:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     d5c:	8a 85       	ldd	r24, Y+10	; 0x0a
     d5e:	9b 85       	ldd	r25, Y+11	; 0x0b
     d60:	4d 96       	adiw	r24, 0x1d	; 29
     d62:	9e 01       	movw	r18, r28
     d64:	29 5f       	subi	r18, 0xF9	; 249
     d66:	3f 4f       	sbci	r19, 0xFF	; 255
     d68:	b9 01       	movw	r22, r18
     d6a:	0e 94 49 15 	call	0x2a92	; 0x2a92 <strcat>
	timeString[10] = ' ';
     d6e:	8a 85       	ldd	r24, Y+10	; 0x0a
     d70:	9b 85       	ldd	r25, Y+11	; 0x0b
     d72:	20 e2       	ldi	r18, 0x20	; 32
     d74:	fc 01       	movw	r30, r24
     d76:	27 a3       	lds	r18, 0x57
	timeString[11] = '\0';
     d78:	8a 85       	ldd	r24, Y+10	; 0x0a
     d7a:	9b 85       	ldd	r25, Y+11	; 0x0b
     d7c:	fc 01       	movw	r30, r24
     d7e:	10 a6       	lds	r17, 0xb0
	return timeString;
     d80:	8a 85       	ldd	r24, Y+10	; 0x0a
     d82:	9b 85       	ldd	r25, Y+11	; 0x0b
     d84:	4d 96       	adiw	r24, 0x1d	; 29
     d86:	2b 96       	adiw	r28, 0x0b	; 11
     d88:	0f b6       	in	r0, 0x3f	; 63
     d8a:	f8 94       	cli
     d8c:	de bf       	out	0x3e, r29	; 62
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	cd bf       	out	0x3d, r28	; 61
     d92:	df 91       	pop	r29
     d94:	cf 91       	pop	r28
     d96:	08 95       	ret

00000d98 <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 10;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     d98:	cf 93       	push	r28
     d9a:	df 93       	push	r29
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
     da0:	2f 97       	sbiw	r28, 0x0f	; 15
     da2:	0f b6       	in	r0, 0x3f	; 63
     da4:	f8 94       	cli
     da6:	de bf       	out	0x3e, r29	; 62
     da8:	0f be       	out	0x3f, r0	; 63
     daa:	cd bf       	out	0x3d, r28	; 61
     dac:	8e 87       	std	Y+14, r24	; 0x0e
     dae:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     db0:	f8 94       	cli
	if (gTime){
     db2:	8e 85       	ldd	r24, Y+14	; 0x0e
     db4:	88 23       	and	r24, r24
     db6:	09 f4       	brne	.+2      	; 0xdba <_Z18getDateTime_eepromhh+0x22>
     db8:	4b c0       	rjmp	.+150    	; 0xe50 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     dba:	1a 82       	std	Y+2, r1	; 0x02
     dbc:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     dbe:	81 e0       	ldi	r24, 0x01	; 1
     dc0:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     dc2:	2c c0       	rjmp	.+88     	; 0xe1c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     dc4:	82 e0       	ldi	r24, 0x02	; 2
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <__eerd_byte_m324pa>
     dcc:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	90 e0       	ldi	r25, 0x00	; 0
     dd2:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <__eerd_byte_m324pa>
     dd6:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     dd8:	80 e0       	ldi	r24, 0x00	; 0
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <__eerd_byte_m324pa>
     de0:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     de2:	8f 81       	ldd	r24, Y+7	; 0x07
     de4:	8c 33       	cpi	r24, 0x3C	; 60
     de6:	a8 f4       	brcc	.+42     	; 0xe12 <_Z18getDateTime_eepromhh+0x7a>
     de8:	88 85       	ldd	r24, Y+8	; 0x08
     dea:	8c 33       	cpi	r24, 0x3C	; 60
     dec:	90 f4       	brcc	.+36     	; 0xe12 <_Z18getDateTime_eepromhh+0x7a>
     dee:	89 85       	ldd	r24, Y+9	; 0x09
     df0:	88 31       	cpi	r24, 0x18	; 24
     df2:	78 f4       	brcc	.+30     	; 0xe12 <_Z18getDateTime_eepromhh+0x7a>
     df4:	89 85       	ldd	r24, Y+9	; 0x09
     df6:	68 2f       	mov	r22, r24
     df8:	70 e0       	ldi	r23, 0x00	; 0
     dfa:	88 85       	ldd	r24, Y+8	; 0x08
     dfc:	48 2f       	mov	r20, r24
     dfe:	50 e0       	ldi	r21, 0x00	; 0
     e00:	8f 81       	ldd	r24, Y+7	; 0x07
     e02:	28 2f       	mov	r18, r24
     e04:	30 e0       	ldi	r19, 0x00	; 0
     e06:	85 e8       	ldi	r24, 0x85	; 133
     e08:	91 e0       	ldi	r25, 0x01	; 1
     e0a:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
     e0e:	1b 82       	std	Y+3, r1	; 0x03
     e10:	05 c0       	rjmp	.+10     	; 0xe1c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     e12:	89 81       	ldd	r24, Y+1	; 0x01
     e14:	9a 81       	ldd	r25, Y+2	; 0x02
     e16:	01 96       	adiw	r24, 0x01	; 1
     e18:	9a 83       	std	Y+2, r25	; 0x02
     e1a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     e1c:	8b 81       	ldd	r24, Y+3	; 0x03
     e1e:	88 23       	and	r24, r24
     e20:	39 f0       	breq	.+14     	; 0xe30 <_Z18getDateTime_eepromhh+0x98>
     e22:	89 81       	ldd	r24, Y+1	; 0x01
     e24:	9a 81       	ldd	r25, Y+2	; 0x02
     e26:	83 30       	cpi	r24, 0x03	; 3
     e28:	91 05       	cpc	r25, r1
     e2a:	14 f4       	brge	.+4      	; 0xe30 <_Z18getDateTime_eepromhh+0x98>
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	01 c0       	rjmp	.+2      	; 0xe32 <_Z18getDateTime_eepromhh+0x9a>
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	88 23       	and	r24, r24
     e34:	39 f6       	brne	.-114    	; 0xdc4 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     e36:	8b 81       	ldd	r24, Y+3	; 0x03
     e38:	88 23       	and	r24, r24
     e3a:	51 f0       	breq	.+20     	; 0xe50 <_Z18getDateTime_eepromhh+0xb8>
     e3c:	85 e8       	ldi	r24, 0x85	; 133
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	61 e0       	ldi	r22, 0x01	; 1
     e42:	70 e0       	ldi	r23, 0x00	; 0
     e44:	41 e0       	ldi	r20, 0x01	; 1
     e46:	50 e0       	ldi	r21, 0x00	; 0
     e48:	21 e0       	ldi	r18, 0x01	; 1
     e4a:	30 e0       	ldi	r19, 0x00	; 0
     e4c:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     e50:	8f 85       	ldd	r24, Y+15	; 0x0f
     e52:	88 23       	and	r24, r24
     e54:	09 f4       	brne	.+2      	; 0xe58 <_Z18getDateTime_eepromhh+0xc0>
     e56:	4e c0       	rjmp	.+156    	; 0xef4 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     e58:	1d 82       	std	Y+5, r1	; 0x05
     e5a:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     e60:	2f c0       	rjmp	.+94     	; 0xec0 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     e62:	84 e0       	ldi	r24, 0x04	; 4
     e64:	90 e0       	ldi	r25, 0x00	; 0
     e66:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <__eerd_byte_m324pa>
     e6a:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     e6c:	83 e0       	ldi	r24, 0x03	; 3
     e6e:	90 e0       	ldi	r25, 0x00	; 0
     e70:	0e 94 8d 15 	call	0x2b1a	; 0x2b1a <__eerd_byte_m324pa>
     e74:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     e76:	85 e0       	ldi	r24, 0x05	; 5
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	0e 94 95 15 	call	0x2b2a	; 0x2b2a <__eerd_word_m324pa>
     e7e:	9d 87       	std	Y+13, r25	; 0x0d
     e80:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     e82:	8a 85       	ldd	r24, Y+10	; 0x0a
     e84:	8f 31       	cpi	r24, 0x1F	; 31
     e86:	b8 f4       	brcc	.+46     	; 0xeb6 <_Z18getDateTime_eepromhh+0x11e>
     e88:	8b 85       	ldd	r24, Y+11	; 0x0b
     e8a:	8d 30       	cpi	r24, 0x0D	; 13
     e8c:	a0 f4       	brcc	.+40     	; 0xeb6 <_Z18getDateTime_eepromhh+0x11e>
     e8e:	8c 85       	ldd	r24, Y+12	; 0x0c
     e90:	9d 85       	ldd	r25, Y+13	; 0x0d
     e92:	27 e2       	ldi	r18, 0x27	; 39
     e94:	80 31       	cpi	r24, 0x10	; 16
     e96:	92 07       	cpc	r25, r18
     e98:	70 f4       	brcc	.+28     	; 0xeb6 <_Z18getDateTime_eepromhh+0x11e>
     e9a:	8b 85       	ldd	r24, Y+11	; 0x0b
     e9c:	68 2f       	mov	r22, r24
     e9e:	70 e0       	ldi	r23, 0x00	; 0
     ea0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ea2:	48 2f       	mov	r20, r24
     ea4:	50 e0       	ldi	r21, 0x00	; 0
     ea6:	2c 85       	ldd	r18, Y+12	; 0x0c
     ea8:	3d 85       	ldd	r19, Y+13	; 0x0d
     eaa:	85 e8       	ldi	r24, 0x85	; 133
     eac:	91 e0       	ldi	r25, 0x01	; 1
     eae:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
     eb2:	1e 82       	std	Y+6, r1	; 0x06
     eb4:	05 c0       	rjmp	.+10     	; 0xec0 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
     eb6:	8c 81       	ldd	r24, Y+4	; 0x04
     eb8:	9d 81       	ldd	r25, Y+5	; 0x05
     eba:	01 96       	adiw	r24, 0x01	; 1
     ebc:	9d 83       	std	Y+5, r25	; 0x05
     ebe:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
     ec0:	8e 81       	ldd	r24, Y+6	; 0x06
     ec2:	88 23       	and	r24, r24
     ec4:	39 f0       	breq	.+14     	; 0xed4 <_Z18getDateTime_eepromhh+0x13c>
     ec6:	8c 81       	ldd	r24, Y+4	; 0x04
     ec8:	9d 81       	ldd	r25, Y+5	; 0x05
     eca:	83 30       	cpi	r24, 0x03	; 3
     ecc:	91 05       	cpc	r25, r1
     ece:	14 f4       	brge	.+4      	; 0xed4 <_Z18getDateTime_eepromhh+0x13c>
     ed0:	81 e0       	ldi	r24, 0x01	; 1
     ed2:	01 c0       	rjmp	.+2      	; 0xed6 <_Z18getDateTime_eepromhh+0x13e>
     ed4:	80 e0       	ldi	r24, 0x00	; 0
     ed6:	88 23       	and	r24, r24
     ed8:	21 f6       	brne	.-120    	; 0xe62 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
     eda:	8e 81       	ldd	r24, Y+6	; 0x06
     edc:	88 23       	and	r24, r24
     ede:	51 f0       	breq	.+20     	; 0xef4 <_Z18getDateTime_eepromhh+0x15c>
     ee0:	85 e8       	ldi	r24, 0x85	; 133
     ee2:	91 e0       	ldi	r25, 0x01	; 1
     ee4:	61 e0       	ldi	r22, 0x01	; 1
     ee6:	70 e0       	ldi	r23, 0x00	; 0
     ee8:	41 e0       	ldi	r20, 0x01	; 1
     eea:	50 e0       	ldi	r21, 0x00	; 0
     eec:	21 ed       	ldi	r18, 0xD1	; 209
     eee:	37 e0       	ldi	r19, 0x07	; 7
     ef0:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
     ef4:	78 94       	sei
}
     ef6:	2f 96       	adiw	r28, 0x0f	; 15
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	29 97       	sbiw	r28, 0x09	; 9
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	88 87       	std	Y+8, r24	; 0x08
     f1e:	69 87       	std	Y+9, r22	; 0x09
	cli();
     f20:	f8 94       	cli
	if (sTime){
     f22:	88 85       	ldd	r24, Y+8	; 0x08
     f24:	88 23       	and	r24, r24
     f26:	f1 f0       	breq	.+60     	; 0xf64 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
     f28:	85 e8       	ldi	r24, 0x85	; 133
     f2a:	91 e0       	ldi	r25, 0x01	; 1
     f2c:	0e 94 37 04 	call	0x86e	; 0x86e <_ZN6myTime8getHoursEv>
     f30:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
     f32:	85 e8       	ldi	r24, 0x85	; 133
     f34:	91 e0       	ldi	r25, 0x01	; 1
     f36:	0e 94 26 04 	call	0x84c	; 0x84c <_ZN6myTime10getMinutesEv>
     f3a:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
     f3c:	85 e8       	ldi	r24, 0x85	; 133
     f3e:	91 e0       	ldi	r25, 0x01	; 1
     f40:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTime10getSecondsEv>
     f44:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
     f46:	82 e0       	ldi	r24, 0x02	; 2
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	6b 81       	ldd	r22, Y+3	; 0x03
     f4c:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <__eewr_byte_m324pa>
		eeprom_write_byte(&eeMinute,tempMin);
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	90 e0       	ldi	r25, 0x00	; 0
     f54:	6a 81       	ldd	r22, Y+2	; 0x02
     f56:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <__eewr_byte_m324pa>
		eeprom_write_byte(&eeHour,tempHour);
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	69 81       	ldd	r22, Y+1	; 0x01
     f60:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <__eewr_byte_m324pa>
	}
	if (sDate){
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	88 23       	and	r24, r24
     f68:	09 f1       	breq	.+66     	; 0xfac <_Z19saveDateTime_eepromhh+0xa4>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
     f6a:	85 e8       	ldi	r24, 0x85	; 133
     f6c:	91 e0       	ldi	r25, 0x01	; 1
     f6e:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
     f72:	9d 83       	std	Y+5, r25	; 0x05
     f74:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
     f76:	85 e8       	ldi	r24, 0x85	; 133
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
     f7e:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
     f80:	85 e8       	ldi	r24, 0x85	; 133
     f82:	91 e0       	ldi	r25, 0x01	; 1
     f84:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
     f88:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
     f8a:	85 e0       	ldi	r24, 0x05	; 5
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	2c 81       	ldd	r18, Y+4	; 0x04
     f90:	3d 81       	ldd	r19, Y+5	; 0x05
     f92:	b9 01       	movw	r22, r18
     f94:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <__eewr_word_m324pa>
		eeprom_write_byte(&eeMonth,tempMonth);
     f98:	83 e0       	ldi	r24, 0x03	; 3
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	6e 81       	ldd	r22, Y+6	; 0x06
     f9e:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <__eewr_byte_m324pa>
		eeprom_write_byte(&eeDay,tempDay);
     fa2:	84 e0       	ldi	r24, 0x04	; 4
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	6f 81       	ldd	r22, Y+7	; 0x07
     fa8:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <__eewr_byte_m324pa>
	}
	sei();
     fac:	78 94       	sei
}
     fae:	29 96       	adiw	r28, 0x09	; 9
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	de bf       	out	0x3e, r29	; 62
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	cd bf       	out	0x3d, r28	; 61
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	08 95       	ret

00000fc0 <_Z13PutUartChBonec>:
//Declare external flags and clock.
extern BOOL flagSendingGAVR;
extern myTime currentTime;

/**************************************************************************************************************/
void PutUartChBone(char ch){
     fc0:	cf 93       	push	r28
     fc2:	df 93       	push	r29
     fc4:	0f 92       	push	r0
     fc6:	cd b7       	in	r28, 0x3d	; 61
     fc8:	de b7       	in	r29, 0x3e	; 62
     fca:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
     fcc:	00 00       	nop
     fce:	80 ec       	ldi	r24, 0xC0	; 192
     fd0:	90 e0       	ldi	r25, 0x00	; 0
     fd2:	fc 01       	movw	r30, r24
     fd4:	80 81       	ld	r24, Z
     fd6:	88 2f       	mov	r24, r24
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	80 72       	andi	r24, 0x20	; 32
     fdc:	90 70       	andi	r25, 0x00	; 0
     fde:	21 e0       	ldi	r18, 0x01	; 1
     fe0:	00 97       	sbiw	r24, 0x00	; 0
     fe2:	09 f0       	breq	.+2      	; 0xfe6 <_Z13PutUartChBonec+0x26>
     fe4:	20 e0       	ldi	r18, 0x00	; 0
     fe6:	22 23       	and	r18, r18
     fe8:	91 f7       	brne	.-28     	; 0xfce <_Z13PutUartChBonec+0xe>
	UDR0=ch;
     fea:	86 ec       	ldi	r24, 0xC6	; 198
     fec:	90 e0       	ldi	r25, 0x00	; 0
     fee:	29 81       	ldd	r18, Y+1	; 0x01
     ff0:	fc 01       	movw	r30, r24
     ff2:	20 83       	st	Z, r18
}
     ff4:	0f 90       	pop	r0
     ff6:	df 91       	pop	r29
     ff8:	cf 91       	pop	r28
     ffa:	08 95       	ret

00000ffc <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
     ffc:	cf 93       	push	r28
     ffe:	df 93       	push	r29
    1000:	00 d0       	rcall	.+0      	; 0x1002 <_Z9PrintBonePc+0x6>
    1002:	0f 92       	push	r0
    1004:	cd b7       	in	r28, 0x3d	; 61
    1006:	de b7       	in	r29, 0x3e	; 62
    1008:	9b 83       	std	Y+3, r25	; 0x03
    100a:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    100c:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    100e:	0e c0       	rjmp	.+28     	; 0x102c <_Z9PrintBonePc+0x30>
		PutUartChBone(string[i++]);
    1010:	89 81       	ldd	r24, Y+1	; 0x01
    1012:	88 2f       	mov	r24, r24
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	2a 81       	ldd	r18, Y+2	; 0x02
    1018:	3b 81       	ldd	r19, Y+3	; 0x03
    101a:	82 0f       	add	r24, r18
    101c:	93 1f       	adc	r25, r19
    101e:	fc 01       	movw	r30, r24
    1020:	80 81       	ld	r24, Z
    1022:	99 81       	ldd	r25, Y+1	; 0x01
    1024:	9f 5f       	subi	r25, 0xFF	; 255
    1026:	99 83       	std	Y+1, r25	; 0x01
    1028:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <_Z13PutUartChBonec>
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    102c:	89 81       	ldd	r24, Y+1	; 0x01
    102e:	88 2f       	mov	r24, r24
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	2a 81       	ldd	r18, Y+2	; 0x02
    1034:	3b 81       	ldd	r19, Y+3	; 0x03
    1036:	82 0f       	add	r24, r18
    1038:	93 1f       	adc	r25, r19
    103a:	fc 01       	movw	r30, r24
    103c:	90 81       	ld	r25, Z
    103e:	81 e0       	ldi	r24, 0x01	; 1
    1040:	99 23       	and	r25, r25
    1042:	09 f4       	brne	.+2      	; 0x1046 <_Z9PrintBonePc+0x4a>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	88 23       	and	r24, r24
    1048:	19 f7       	brne	.-58     	; 0x1010 <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i++]);
	}
}
    104a:	0f 90       	pop	r0
    104c:	0f 90       	pop	r0
    104e:	0f 90       	pop	r0
    1050:	df 91       	pop	r29
    1052:	cf 91       	pop	r28
    1054:	08 95       	ret

00001056 <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    1056:	cf 93       	push	r28
    1058:	df 93       	push	r29
    105a:	0f 92       	push	r0
    105c:	cd b7       	in	r28, 0x3d	; 61
    105e:	de b7       	in	r29, 0x3e	; 62
    1060:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    1062:	00 00       	nop
    1064:	88 ec       	ldi	r24, 0xC8	; 200
    1066:	90 e0       	ldi	r25, 0x00	; 0
    1068:	fc 01       	movw	r30, r24
    106a:	80 81       	ld	r24, Z
    106c:	88 2f       	mov	r24, r24
    106e:	90 e0       	ldi	r25, 0x00	; 0
    1070:	80 72       	andi	r24, 0x20	; 32
    1072:	90 70       	andi	r25, 0x00	; 0
    1074:	21 e0       	ldi	r18, 0x01	; 1
    1076:	00 97       	sbiw	r24, 0x00	; 0
    1078:	09 f0       	breq	.+2      	; 0x107c <_Z13PutUartChGAVRc+0x26>
    107a:	20 e0       	ldi	r18, 0x00	; 0
    107c:	22 23       	and	r18, r18
    107e:	91 f7       	brne	.-28     	; 0x1064 <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    1080:	8e ec       	ldi	r24, 0xCE	; 206
    1082:	90 e0       	ldi	r25, 0x00	; 0
    1084:	29 81       	ldd	r18, Y+1	; 0x01
    1086:	fc 01       	movw	r30, r24
    1088:	20 83       	st	Z, r18
}
    108a:	0f 90       	pop	r0
    108c:	df 91       	pop	r29
    108e:	cf 91       	pop	r28
    1090:	08 95       	ret

00001092 <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    1092:	cf 93       	push	r28
    1094:	df 93       	push	r29
    1096:	00 d0       	rcall	.+0      	; 0x1098 <_Z9PrintGAVRPc+0x6>
    1098:	0f 92       	push	r0
    109a:	cd b7       	in	r28, 0x3d	; 61
    109c:	de b7       	in	r29, 0x3e	; 62
    109e:	9b 83       	std	Y+3, r25	; 0x03
    10a0:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    10a2:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    10a4:	0e c0       	rjmp	.+28     	; 0x10c2 <_Z9PrintGAVRPc+0x30>
		PutUartChGAVR(string[i++]);
    10a6:	89 81       	ldd	r24, Y+1	; 0x01
    10a8:	88 2f       	mov	r24, r24
    10aa:	90 e0       	ldi	r25, 0x00	; 0
    10ac:	2a 81       	ldd	r18, Y+2	; 0x02
    10ae:	3b 81       	ldd	r19, Y+3	; 0x03
    10b0:	82 0f       	add	r24, r18
    10b2:	93 1f       	adc	r25, r19
    10b4:	fc 01       	movw	r30, r24
    10b6:	80 81       	ld	r24, Z
    10b8:	99 81       	ldd	r25, Y+1	; 0x01
    10ba:	9f 5f       	subi	r25, 0xFF	; 255
    10bc:	99 83       	std	Y+1, r25	; 0x01
    10be:	0e 94 2b 08 	call	0x1056	; 0x1056 <_Z13PutUartChGAVRc>
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    10c2:	89 81       	ldd	r24, Y+1	; 0x01
    10c4:	88 2f       	mov	r24, r24
    10c6:	90 e0       	ldi	r25, 0x00	; 0
    10c8:	2a 81       	ldd	r18, Y+2	; 0x02
    10ca:	3b 81       	ldd	r19, Y+3	; 0x03
    10cc:	82 0f       	add	r24, r18
    10ce:	93 1f       	adc	r25, r19
    10d0:	fc 01       	movw	r30, r24
    10d2:	90 81       	ld	r25, Z
    10d4:	81 e0       	ldi	r24, 0x01	; 1
    10d6:	99 23       	and	r25, r25
    10d8:	09 f4       	brne	.+2      	; 0x10dc <_Z9PrintGAVRPc+0x4a>
    10da:	80 e0       	ldi	r24, 0x00	; 0
    10dc:	88 23       	and	r24, r24
    10de:	19 f7       	brne	.-58     	; 0x10a6 <_Z9PrintGAVRPc+0x14>
		PutUartChGAVR(string[i++]);
	}
}
    10e0:	0f 90       	pop	r0
    10e2:	0f 90       	pop	r0
    10e4:	0f 90       	pop	r0
    10e6:	df 91       	pop	r29
    10e8:	cf 91       	pop	r28
    10ea:	08 95       	ret

000010ec <_Z10sendToGAVRv>:
/*************************************************************************************************************/

void sendToGAVR(){
    10ec:	cf 93       	push	r28
    10ee:	df 93       	push	r29
    10f0:	cd b7       	in	r28, 0x3d	; 61
    10f2:	de b7       	in	r29, 0x3e	; 62
    10f4:	6d 97       	sbiw	r28, 0x1d	; 29
    10f6:	0f b6       	in	r0, 0x3f	; 63
    10f8:	f8 94       	cli
    10fa:	de bf       	out	0x3e, r29	; 62
    10fc:	0f be       	out	0x3f, r0	; 63
    10fe:	cd bf       	out	0x3d, r28	; 61
	cli();
    1100:	f8 94       	cli
	//__disableLevel1INT();
	sei();
    1102:	78 94       	sei
	
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    1104:	81 e0       	ldi	r24, 0x01	; 1
    1106:	89 87       	std	Y+9, r24	; 0x09
	char recChar, recString[20];
	unsigned int strLoc=0;
    1108:	1a 82       	std	Y+2, r1	; 0x02
    110a:	19 82       	std	Y+1, r1	; 0x01
	
	//Going to be a global
	BOOL flagWaitingToSendGAVR=fFalse;
    110c:	1f 82       	std	Y+7, r1	; 0x07
	
	//Transmission protocol
	while (flagSendingGAVR){
    110e:	32 c1       	rjmp	.+612    	; 0x1374 <_Z10sendToGAVRv+0x288>
		/*************************************BEGIN STATE MACHINE**************************************************/
		/* */
		/* */
		//Currently state 8 is for timeout, state 9 is for overflow/going to wait 3 seconds
		switch (state){
    1110:	80 91 b1 01 	lds	r24, 0x01B1
    1114:	90 91 b2 01 	lds	r25, 0x01B2
    1118:	81 30       	cpi	r24, 0x01	; 1
    111a:	91 05       	cpc	r25, r1
    111c:	09 f4       	brne	.+2      	; 0x1120 <_Z10sendToGAVRv+0x34>
    111e:	9e c0       	rjmp	.+316    	; 0x125c <_Z10sendToGAVRv+0x170>
    1120:	81 30       	cpi	r24, 0x01	; 1
    1122:	91 05       	cpc	r25, r1
    1124:	48 f0       	brcs	.+18     	; 0x1138 <_Z10sendToGAVRv+0x4c>
    1126:	82 30       	cpi	r24, 0x02	; 2
    1128:	91 05       	cpc	r25, r1
    112a:	09 f4       	brne	.+2      	; 0x112e <_Z10sendToGAVRv+0x42>
    112c:	a5 c0       	rjmp	.+330    	; 0x1278 <_Z10sendToGAVRv+0x18c>
    112e:	83 30       	cpi	r24, 0x03	; 3
    1130:	91 05       	cpc	r25, r1
    1132:	09 f4       	brne	.+2      	; 0x1136 <_Z10sendToGAVRv+0x4a>
    1134:	f3 c0       	rjmp	.+486    	; 0x131c <_Z10sendToGAVRv+0x230>
    1136:	1e c1       	rjmp	.+572    	; 0x1374 <_Z10sendToGAVRv+0x288>
			case 0: {
				prtGAVRINT |= (1 << bnGAVRINT);
    1138:	85 e2       	ldi	r24, 0x25	; 37
    113a:	90 e0       	ldi	r25, 0x00	; 0
    113c:	25 e2       	ldi	r18, 0x25	; 37
    113e:	30 e0       	ldi	r19, 0x00	; 0
    1140:	f9 01       	movw	r30, r18
    1142:	20 81       	ld	r18, Z
    1144:	28 60       	ori	r18, 0x08	; 8
    1146:	fc 01       	movw	r30, r24
    1148:	20 83       	st	Z, r18
				for (int i=0; i<2; i++){asm volatile("nop");}
    114a:	1c 82       	std	Y+4, r1	; 0x04
    114c:	1b 82       	std	Y+3, r1	; 0x03
    114e:	06 c0       	rjmp	.+12     	; 0x115c <_Z10sendToGAVRv+0x70>
    1150:	00 00       	nop
    1152:	8b 81       	ldd	r24, Y+3	; 0x03
    1154:	9c 81       	ldd	r25, Y+4	; 0x04
    1156:	01 96       	adiw	r24, 0x01	; 1
    1158:	9c 83       	std	Y+4, r25	; 0x04
    115a:	8b 83       	std	Y+3, r24	; 0x03
    115c:	21 e0       	ldi	r18, 0x01	; 1
    115e:	8b 81       	ldd	r24, Y+3	; 0x03
    1160:	9c 81       	ldd	r25, Y+4	; 0x04
    1162:	82 30       	cpi	r24, 0x02	; 2
    1164:	91 05       	cpc	r25, r1
    1166:	0c f0       	brlt	.+2      	; 0x116a <_Z10sendToGAVRv+0x7e>
    1168:	20 e0       	ldi	r18, 0x00	; 0
    116a:	22 23       	and	r18, r18
    116c:	89 f7       	brne	.-30     	; 0x1150 <_Z10sendToGAVRv+0x64>
				prtGAVRINT &= ~(1 << bnGAVRINT);
    116e:	85 e2       	ldi	r24, 0x25	; 37
    1170:	90 e0       	ldi	r25, 0x00	; 0
    1172:	25 e2       	ldi	r18, 0x25	; 37
    1174:	30 e0       	ldi	r19, 0x00	; 0
    1176:	f9 01       	movw	r30, r18
    1178:	20 81       	ld	r18, Z
    117a:	27 7f       	andi	r18, 0xF7	; 247
    117c:	fc 01       	movw	r30, r24
    117e:	20 83       	st	Z, r18
				state=1;
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	90 e0       	ldi	r25, 0x00	; 0
    1184:	90 93 b2 01 	sts	0x01B2, r25
    1188:	80 93 b1 01 	sts	0x01B1, r24
				break;
    118c:	f3 c0       	rjmp	.+486    	; 0x1374 <_Z10sendToGAVRv+0x288>
			}//end case 0
			case 1: {
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);
    118e:	00 00       	nop
    1190:	88 ec       	ldi	r24, 0xC8	; 200
    1192:	90 e0       	ldi	r25, 0x00	; 0
    1194:	fc 01       	movw	r30, r24
    1196:	80 81       	ld	r24, Z
    1198:	88 23       	and	r24, r24
    119a:	34 f0       	brlt	.+12     	; 0x11a8 <_Z10sendToGAVRv+0xbc>
    119c:	80 91 7a 01 	lds	r24, 0x017A
    11a0:	88 23       	and	r24, r24
    11a2:	11 f0       	breq	.+4      	; 0x11a8 <_Z10sendToGAVRv+0xbc>
    11a4:	81 e0       	ldi	r24, 0x01	; 1
    11a6:	01 c0       	rjmp	.+2      	; 0x11aa <_Z10sendToGAVRv+0xbe>
    11a8:	80 e0       	ldi	r24, 0x00	; 0
    11aa:	88 23       	and	r24, r24
    11ac:	89 f7       	brne	.-30     	; 0x1190 <_Z10sendToGAVRv+0xa4>
					if (!flagSendingGAVR){state=8; break;}
    11ae:	80 91 7a 01 	lds	r24, 0x017A
    11b2:	88 23       	and	r24, r24
    11b4:	41 f4       	brne	.+16     	; 0x11c6 <_Z10sendToGAVRv+0xda>
    11b6:	88 e0       	ldi	r24, 0x08	; 8
    11b8:	90 e0       	ldi	r25, 0x00	; 0
    11ba:	90 93 b2 01 	sts	0x01B2, r25
    11be:	80 93 b1 01 	sts	0x01B1, r24
    11c2:	00 00       	nop
							recString[strLoc++] = recChar;
							if (strLoc >= 19){strLoc = 0; noCarriage = fFalse; flagWaitingToSendGAVR=fTrue;state=9;}
						}//end if-else
					}//end if-else	
				}//end while
				break;
    11c4:	d7 c0       	rjmp	.+430    	; 0x1374 <_Z10sendToGAVRv+0x288>
			case 1: {
				while (noCarriage && flagSendingGAVR){
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);
					if (!flagSendingGAVR){state=8; break;}
					else {
						recChar=UDR1;
    11c6:	8e ec       	ldi	r24, 0xCE	; 206
    11c8:	90 e0       	ldi	r25, 0x00	; 0
    11ca:	fc 01       	movw	r30, r24
    11cc:	80 81       	ld	r24, Z
    11ce:	88 87       	std	Y+8, r24	; 0x08
						recString[strLoc++]=recChar;
    11d0:	9e 01       	movw	r18, r28
    11d2:	26 5f       	subi	r18, 0xF6	; 246
    11d4:	3f 4f       	sbci	r19, 0xFF	; 255
    11d6:	89 81       	ldd	r24, Y+1	; 0x01
    11d8:	9a 81       	ldd	r25, Y+2	; 0x02
    11da:	82 0f       	add	r24, r18
    11dc:	93 1f       	adc	r25, r19
    11de:	28 85       	ldd	r18, Y+8	; 0x08
    11e0:	fc 01       	movw	r30, r24
    11e2:	20 83       	st	Z, r18
    11e4:	89 81       	ldd	r24, Y+1	; 0x01
    11e6:	9a 81       	ldd	r25, Y+2	; 0x02
    11e8:	01 96       	adiw	r24, 0x01	; 1
    11ea:	9a 83       	std	Y+2, r25	; 0x02
    11ec:	89 83       	std	Y+1, r24	; 0x01
						if (recChar=='.'){recString[strLoc++]='\0'; state=2;}
    11ee:	88 85       	ldd	r24, Y+8	; 0x08
    11f0:	8e 32       	cpi	r24, 0x2E	; 46
    11f2:	a9 f4       	brne	.+42     	; 0x121e <_Z10sendToGAVRv+0x132>
    11f4:	9e 01       	movw	r18, r28
    11f6:	26 5f       	subi	r18, 0xF6	; 246
    11f8:	3f 4f       	sbci	r19, 0xFF	; 255
    11fa:	89 81       	ldd	r24, Y+1	; 0x01
    11fc:	9a 81       	ldd	r25, Y+2	; 0x02
    11fe:	82 0f       	add	r24, r18
    1200:	93 1f       	adc	r25, r19
    1202:	fc 01       	movw	r30, r24
    1204:	10 82       	st	Z, r1
    1206:	89 81       	ldd	r24, Y+1	; 0x01
    1208:	9a 81       	ldd	r25, Y+2	; 0x02
    120a:	01 96       	adiw	r24, 0x01	; 1
    120c:	9a 83       	std	Y+2, r25	; 0x02
    120e:	89 83       	std	Y+1, r24	; 0x01
    1210:	82 e0       	ldi	r24, 0x02	; 2
    1212:	90 e0       	ldi	r25, 0x00	; 0
    1214:	90 93 b2 01 	sts	0x01B2, r25
    1218:	80 93 b1 01 	sts	0x01B1, r24
    121c:	1f c0       	rjmp	.+62     	; 0x125c <_Z10sendToGAVRv+0x170>
						else {
							recString[strLoc++] = recChar;
    121e:	9e 01       	movw	r18, r28
    1220:	26 5f       	subi	r18, 0xF6	; 246
    1222:	3f 4f       	sbci	r19, 0xFF	; 255
    1224:	89 81       	ldd	r24, Y+1	; 0x01
    1226:	9a 81       	ldd	r25, Y+2	; 0x02
    1228:	82 0f       	add	r24, r18
    122a:	93 1f       	adc	r25, r19
    122c:	28 85       	ldd	r18, Y+8	; 0x08
    122e:	fc 01       	movw	r30, r24
    1230:	20 83       	st	Z, r18
    1232:	89 81       	ldd	r24, Y+1	; 0x01
    1234:	9a 81       	ldd	r25, Y+2	; 0x02
    1236:	01 96       	adiw	r24, 0x01	; 1
    1238:	9a 83       	std	Y+2, r25	; 0x02
    123a:	89 83       	std	Y+1, r24	; 0x01
							if (strLoc >= 19){strLoc = 0; noCarriage = fFalse; flagWaitingToSendGAVR=fTrue;state=9;}
    123c:	89 81       	ldd	r24, Y+1	; 0x01
    123e:	9a 81       	ldd	r25, Y+2	; 0x02
    1240:	83 31       	cpi	r24, 0x13	; 19
    1242:	91 05       	cpc	r25, r1
    1244:	58 f0       	brcs	.+22     	; 0x125c <_Z10sendToGAVRv+0x170>
    1246:	1a 82       	std	Y+2, r1	; 0x02
    1248:	19 82       	std	Y+1, r1	; 0x01
    124a:	19 86       	std	Y+9, r1	; 0x09
    124c:	81 e0       	ldi	r24, 0x01	; 1
    124e:	8f 83       	std	Y+7, r24	; 0x07
    1250:	89 e0       	ldi	r24, 0x09	; 9
    1252:	90 e0       	ldi	r25, 0x00	; 0
    1254:	90 93 b2 01 	sts	0x01B2, r25
    1258:	80 93 b1 01 	sts	0x01B1, r24
				prtGAVRINT &= ~(1 << bnGAVRINT);
				state=1;
				break;
			}//end case 0
			case 1: {
				while (noCarriage && flagSendingGAVR){
    125c:	89 85       	ldd	r24, Y+9	; 0x09
    125e:	88 23       	and	r24, r24
    1260:	31 f0       	breq	.+12     	; 0x126e <_Z10sendToGAVRv+0x182>
    1262:	80 91 7a 01 	lds	r24, 0x017A
    1266:	88 23       	and	r24, r24
    1268:	11 f0       	breq	.+4      	; 0x126e <_Z10sendToGAVRv+0x182>
    126a:	81 e0       	ldi	r24, 0x01	; 1
    126c:	01 c0       	rjmp	.+2      	; 0x1270 <_Z10sendToGAVRv+0x184>
    126e:	80 e0       	ldi	r24, 0x00	; 0
    1270:	88 23       	and	r24, r24
    1272:	09 f0       	breq	.+2      	; 0x1276 <_Z10sendToGAVRv+0x18a>
    1274:	8c cf       	rjmp	.-232    	; 0x118e <_Z10sendToGAVRv+0xa2>
							recString[strLoc++] = recChar;
							if (strLoc >= 19){strLoc = 0; noCarriage = fFalse; flagWaitingToSendGAVR=fTrue;state=9;}
						}//end if-else
					}//end if-else	
				}//end while
				break;
    1276:	7e c0       	rjmp	.+252    	; 0x1374 <_Z10sendToGAVRv+0x288>
				}//end case 1
			case 2: {
				if (strcmp(recString,"ACKW.")){state=3;}
    1278:	ce 01       	movw	r24, r28
    127a:	0a 96       	adiw	r24, 0x0a	; 10
    127c:	20 e0       	ldi	r18, 0x00	; 0
    127e:	31 e0       	ldi	r19, 0x01	; 1
    1280:	b9 01       	movw	r22, r18
    1282:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1286:	00 97       	sbiw	r24, 0x00	; 0
    1288:	39 f0       	breq	.+14     	; 0x1298 <_Z10sendToGAVRv+0x1ac>
    128a:	83 e0       	ldi	r24, 0x03	; 3
    128c:	90 e0       	ldi	r25, 0x00	; 0
    128e:	90 93 b2 01 	sts	0x01B2, r25
    1292:	80 93 b1 01 	sts	0x01B1, r24
				else if (strcmp(recString,"ACKGT")){state=5;}
				else if (strcmp(recString,"ACKGB")){state=6;}
				//send string case.
				else if (strcmp(recString,"  ")){/**do something**/;}
				else{flagWaitingToSendGAVR=fTrue;state=9;}
				break;
    1296:	6d c0       	rjmp	.+218    	; 0x1372 <_Z10sendToGAVRv+0x286>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (strcmp(recString,"ACKW.")){state=3;}
				else if (strcmp(recString,"ACKGD")){state=4;}
    1298:	ce 01       	movw	r24, r28
    129a:	0a 96       	adiw	r24, 0x0a	; 10
    129c:	26 e0       	ldi	r18, 0x06	; 6
    129e:	31 e0       	ldi	r19, 0x01	; 1
    12a0:	b9 01       	movw	r22, r18
    12a2:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    12a6:	00 97       	sbiw	r24, 0x00	; 0
    12a8:	39 f0       	breq	.+14     	; 0x12b8 <_Z10sendToGAVRv+0x1cc>
    12aa:	84 e0       	ldi	r24, 0x04	; 4
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	90 93 b2 01 	sts	0x01B2, r25
    12b2:	80 93 b1 01 	sts	0x01B1, r24
				else if (strcmp(recString,"ACKGT")){state=5;}
				else if (strcmp(recString,"ACKGB")){state=6;}
				//send string case.
				else if (strcmp(recString,"  ")){/**do something**/;}
				else{flagWaitingToSendGAVR=fTrue;state=9;}
				break;
    12b6:	5d c0       	rjmp	.+186    	; 0x1372 <_Z10sendToGAVRv+0x286>
				break;
				}//end case 1
			case 2: {
				if (strcmp(recString,"ACKW.")){state=3;}
				else if (strcmp(recString,"ACKGD")){state=4;}
				else if (strcmp(recString,"ACKGT")){state=5;}
    12b8:	ce 01       	movw	r24, r28
    12ba:	0a 96       	adiw	r24, 0x0a	; 10
    12bc:	2c e0       	ldi	r18, 0x0C	; 12
    12be:	31 e0       	ldi	r19, 0x01	; 1
    12c0:	b9 01       	movw	r22, r18
    12c2:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    12c6:	00 97       	sbiw	r24, 0x00	; 0
    12c8:	39 f0       	breq	.+14     	; 0x12d8 <_Z10sendToGAVRv+0x1ec>
    12ca:	85 e0       	ldi	r24, 0x05	; 5
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	90 93 b2 01 	sts	0x01B2, r25
    12d2:	80 93 b1 01 	sts	0x01B1, r24
				else if (strcmp(recString,"ACKGB")){state=6;}
				//send string case.
				else if (strcmp(recString,"  ")){/**do something**/;}
				else{flagWaitingToSendGAVR=fTrue;state=9;}
				break;
    12d6:	4d c0       	rjmp	.+154    	; 0x1372 <_Z10sendToGAVRv+0x286>
				}//end case 1
			case 2: {
				if (strcmp(recString,"ACKW.")){state=3;}
				else if (strcmp(recString,"ACKGD")){state=4;}
				else if (strcmp(recString,"ACKGT")){state=5;}
				else if (strcmp(recString,"ACKGB")){state=6;}
    12d8:	ce 01       	movw	r24, r28
    12da:	0a 96       	adiw	r24, 0x0a	; 10
    12dc:	22 e1       	ldi	r18, 0x12	; 18
    12de:	31 e0       	ldi	r19, 0x01	; 1
    12e0:	b9 01       	movw	r22, r18
    12e2:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    12e6:	00 97       	sbiw	r24, 0x00	; 0
    12e8:	39 f0       	breq	.+14     	; 0x12f8 <_Z10sendToGAVRv+0x20c>
    12ea:	86 e0       	ldi	r24, 0x06	; 6
    12ec:	90 e0       	ldi	r25, 0x00	; 0
    12ee:	90 93 b2 01 	sts	0x01B2, r25
    12f2:	80 93 b1 01 	sts	0x01B1, r24
				//send string case.
				else if (strcmp(recString,"  ")){/**do something**/;}
				else{flagWaitingToSendGAVR=fTrue;state=9;}
				break;
    12f6:	3d c0       	rjmp	.+122    	; 0x1372 <_Z10sendToGAVRv+0x286>
				if (strcmp(recString,"ACKW.")){state=3;}
				else if (strcmp(recString,"ACKGD")){state=4;}
				else if (strcmp(recString,"ACKGT")){state=5;}
				else if (strcmp(recString,"ACKGB")){state=6;}
				//send string case.
				else if (strcmp(recString,"  ")){/**do something**/;}
    12f8:	ce 01       	movw	r24, r28
    12fa:	0a 96       	adiw	r24, 0x0a	; 10
    12fc:	28 e1       	ldi	r18, 0x18	; 24
    12fe:	31 e0       	ldi	r19, 0x01	; 1
    1300:	b9 01       	movw	r22, r18
    1302:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1306:	00 97       	sbiw	r24, 0x00	; 0
    1308:	a1 f5       	brne	.+104    	; 0x1372 <_Z10sendToGAVRv+0x286>
				else{flagWaitingToSendGAVR=fTrue;state=9;}
    130a:	81 e0       	ldi	r24, 0x01	; 1
    130c:	8f 83       	std	Y+7, r24	; 0x07
    130e:	89 e0       	ldi	r24, 0x09	; 9
    1310:	90 e0       	ldi	r25, 0x00	; 0
    1312:	90 93 b2 01 	sts	0x01B2, r25
    1316:	80 93 b1 01 	sts	0x01B1, r24
				break;
    131a:	2b c0       	rjmp	.+86     	; 0x1372 <_Z10sendToGAVRv+0x286>
				}//end case 2
			case 3:{
				if (fTrue){
					PrintGAVR("SYNGD.");
    131c:	8b e1       	ldi	r24, 0x1B	; 27
    131e:	91 e0       	ldi	r25, 0x01	; 1
    1320:	0e 94 49 08 	call	0x1092	; 0x1092 <_Z9PrintGAVRPc>
				} else if (fFalse){
					//Print this;
				} else;				
				for (int i=0; i<strLoc; i++){
    1324:	1e 82       	std	Y+6, r1	; 0x06
    1326:	1d 82       	std	Y+5, r1	; 0x05
    1328:	0e c0       	rjmp	.+28     	; 0x1346 <_Z10sendToGAVRv+0x25a>
					recString[i]=NULL;
    132a:	9e 01       	movw	r18, r28
    132c:	26 5f       	subi	r18, 0xF6	; 246
    132e:	3f 4f       	sbci	r19, 0xFF	; 255
    1330:	8d 81       	ldd	r24, Y+5	; 0x05
    1332:	9e 81       	ldd	r25, Y+6	; 0x06
    1334:	82 0f       	add	r24, r18
    1336:	93 1f       	adc	r25, r19
    1338:	fc 01       	movw	r30, r24
    133a:	10 82       	st	Z, r1
				if (fTrue){
					PrintGAVR("SYNGD.");
				} else if (fFalse){
					//Print this;
				} else;				
				for (int i=0; i<strLoc; i++){
    133c:	8d 81       	ldd	r24, Y+5	; 0x05
    133e:	9e 81       	ldd	r25, Y+6	; 0x06
    1340:	01 96       	adiw	r24, 0x01	; 1
    1342:	9e 83       	std	Y+6, r25	; 0x06
    1344:	8d 83       	std	Y+5, r24	; 0x05
    1346:	2d 81       	ldd	r18, Y+5	; 0x05
    1348:	3e 81       	ldd	r19, Y+6	; 0x06
    134a:	41 e0       	ldi	r20, 0x01	; 1
    134c:	89 81       	ldd	r24, Y+1	; 0x01
    134e:	9a 81       	ldd	r25, Y+2	; 0x02
    1350:	28 17       	cp	r18, r24
    1352:	39 07       	cpc	r19, r25
    1354:	08 f0       	brcs	.+2      	; 0x1358 <_Z10sendToGAVRv+0x26c>
    1356:	40 e0       	ldi	r20, 0x00	; 0
    1358:	44 23       	and	r20, r20
    135a:	39 f7       	brne	.-50     	; 0x132a <_Z10sendToGAVRv+0x23e>
					recString[i]=NULL;
				}
				noCarriage=fTrue;
    135c:	81 e0       	ldi	r24, 0x01	; 1
    135e:	89 87       	std	Y+9, r24	; 0x09
				strLoc=0;
    1360:	1a 82       	std	Y+2, r1	; 0x02
    1362:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    1364:	81 e0       	ldi	r24, 0x01	; 1
    1366:	90 e0       	ldi	r25, 0x00	; 0
    1368:	90 93 b2 01 	sts	0x01B2, r25
    136c:	80 93 b1 01 	sts	0x01B1, r24
				break;
    1370:	01 c0       	rjmp	.+2      	; 0x1374 <_Z10sendToGAVRv+0x288>
				else if (strcmp(recString,"ACKGT")){state=5;}
				else if (strcmp(recString,"ACKGB")){state=6;}
				//send string case.
				else if (strcmp(recString,"  ")){/**do something**/;}
				else{flagWaitingToSendGAVR=fTrue;state=9;}
				break;
    1372:	00 00       	nop
	
	//Going to be a global
	BOOL flagWaitingToSendGAVR=fFalse;
	
	//Transmission protocol
	while (flagSendingGAVR){
    1374:	90 91 7a 01 	lds	r25, 0x017A
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	99 23       	and	r25, r25
    137c:	09 f4       	brne	.+2      	; 0x1380 <_Z10sendToGAVRv+0x294>
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	88 23       	and	r24, r24
    1382:	09 f0       	breq	.+2      	; 0x1386 <_Z10sendToGAVRv+0x29a>
    1384:	c5 ce       	rjmp	.-630    	; 0x1110 <_Z10sendToGAVRv+0x24>
		
		
		
	}//end while
	
}//end function 	
    1386:	6d 96       	adiw	r28, 0x1d	; 29
    1388:	0f b6       	in	r0, 0x3f	; 63
    138a:	f8 94       	cli
    138c:	de bf       	out	0x3e, r29	; 62
    138e:	0f be       	out	0x3f, r0	; 63
    1390:	cd bf       	out	0x3d, r28	; 61
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	08 95       	ret

00001398 <_Z13printTimeDatehhh>:
	

/*************************************************************************************************************/

//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    1398:	cf 93       	push	r28
    139a:	df 93       	push	r29
    139c:	cd b7       	in	r28, 0x3d	; 61
    139e:	de b7       	in	r29, 0x3e	; 62
    13a0:	eb 97       	sbiw	r28, 0x3b	; 59
    13a2:	0f b6       	in	r0, 0x3f	; 63
    13a4:	f8 94       	cli
    13a6:	de bf       	out	0x3e, r29	; 62
    13a8:	0f be       	out	0x3f, r0	; 63
    13aa:	cd bf       	out	0x3d, r28	; 61
    13ac:	89 af       	sts	0x79, r24
    13ae:	6a af       	sts	0x7a, r22
    13b0:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    13b2:	89 ad       	sts	0x69, r24
    13b4:	88 23       	and	r24, r24
    13b6:	31 f1       	breq	.+76     	; 0x1404 <_Z13printTimeDatehhh+0x6c>
	if (pTime){
    13b8:	8a ad       	sts	0x6a, r24
    13ba:	88 23       	and	r24, r24
    13bc:	89 f0       	breq	.+34     	; 0x13e0 <_Z13printTimeDatehhh+0x48>
		char tempTime[11];
		strcpy(tempTime,currentTime.getTime());
    13be:	85 e8       	ldi	r24, 0x85	; 133
    13c0:	91 e0       	ldi	r25, 0x01	; 1
    13c2:	0e 94 3d 06 	call	0xc7a	; 0xc7a <_ZN6myTime7getTimeEv>
    13c6:	9c 01       	movw	r18, r24
    13c8:	ce 01       	movw	r24, r28
    13ca:	01 96       	adiw	r24, 0x01	; 1
    13cc:	b9 01       	movw	r22, r18
    13ce:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
		PrintBone(tempTime);
    13d2:	ce 01       	movw	r24, r28
    13d4:	01 96       	adiw	r24, 0x01	; 1
    13d6:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
		PutUartChBone('/');
    13da:	8f e2       	ldi	r24, 0x2F	; 47
    13dc:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <_Z13PutUartChBonec>
	}
	if (pDate){
    13e0:	8b ad       	sts	0x6b, r24
    13e2:	88 23       	and	r24, r24
    13e4:	a1 f1       	breq	.+104    	; 0x144e <_Z13printTimeDatehhh+0xb6>
		char tempDate[17];
		strcpy(tempDate,currentTime.getDate());
    13e6:	85 e8       	ldi	r24, 0x85	; 133
    13e8:	91 e0       	ldi	r25, 0x01	; 1
    13ea:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate7getDateEv>
    13ee:	9c 01       	movw	r18, r24
    13f0:	ce 01       	movw	r24, r28
    13f2:	0c 96       	adiw	r24, 0x0c	; 12
    13f4:	b9 01       	movw	r22, r18
    13f6:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
		PrintBone(tempDate);
    13fa:	ce 01       	movw	r24, r28
    13fc:	0c 96       	adiw	r24, 0x0c	; 12
    13fe:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    1402:	25 c0       	rjmp	.+74     	; 0x144e <_Z13printTimeDatehhh+0xb6>
	}
} else { //Printing to GAVR
if (pTime){
    1404:	8a ad       	sts	0x6a, r24
    1406:	88 23       	and	r24, r24
    1408:	89 f0       	breq	.+34     	; 0x142c <_Z13printTimeDatehhh+0x94>
	char tempTime[11];
	strcpy(tempTime,currentTime.getTime());
    140a:	85 e8       	ldi	r24, 0x85	; 133
    140c:	91 e0       	ldi	r25, 0x01	; 1
    140e:	0e 94 3d 06 	call	0xc7a	; 0xc7a <_ZN6myTime7getTimeEv>
    1412:	9c 01       	movw	r18, r24
    1414:	ce 01       	movw	r24, r28
    1416:	4d 96       	adiw	r24, 0x1d	; 29
    1418:	b9 01       	movw	r22, r18
    141a:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
	PrintGAVR(tempTime);
    141e:	ce 01       	movw	r24, r28
    1420:	4d 96       	adiw	r24, 0x1d	; 29
    1422:	0e 94 49 08 	call	0x1092	; 0x1092 <_Z9PrintGAVRPc>
	PutUartChGAVR('/');
    1426:	8f e2       	ldi	r24, 0x2F	; 47
    1428:	0e 94 2b 08 	call	0x1056	; 0x1056 <_Z13PutUartChGAVRc>
}
if (pDate){
    142c:	8b ad       	sts	0x6b, r24
    142e:	88 23       	and	r24, r24
    1430:	71 f0       	breq	.+28     	; 0x144e <_Z13printTimeDatehhh+0xb6>
	char tempDate[17];
	strcpy(tempDate,currentTime.getDate());
    1432:	85 e8       	ldi	r24, 0x85	; 133
    1434:	91 e0       	ldi	r25, 0x01	; 1
    1436:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate7getDateEv>
    143a:	9c 01       	movw	r18, r24
    143c:	ce 01       	movw	r24, r28
    143e:	88 96       	adiw	r24, 0x28	; 40
    1440:	b9 01       	movw	r22, r18
    1442:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
	PrintGAVR(tempDate);
    1446:	ce 01       	movw	r24, r28
    1448:	88 96       	adiw	r24, 0x28	; 40
    144a:	0e 94 49 08 	call	0x1092	; 0x1092 <_Z9PrintGAVRPc>
}
	}
}
    144e:	eb 96       	adiw	r28, 0x3b	; 59
    1450:	0f b6       	in	r0, 0x3f	; 63
    1452:	f8 94       	cli
    1454:	de bf       	out	0x3e, r29	; 62
    1456:	0f be       	out	0x3f, r0	; 63
    1458:	cd bf       	out	0x3d, r28	; 61
    145a:	df 91       	pop	r29
    145c:	cf 91       	pop	r28
    145e:	08 95       	ret

00001460 <__vector_4>:
volatile WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.

/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
ISR(PCINT0_vect){
    1460:	1f 92       	push	r1
    1462:	0f 92       	push	r0
    1464:	0f b6       	in	r0, 0x3f	; 63
    1466:	0f 92       	push	r0
    1468:	11 24       	eor	r1, r1
    146a:	cf 93       	push	r28
    146c:	df 93       	push	r29
    146e:	cd b7       	in	r28, 0x3d	; 61
    1470:	de b7       	in	r29, 0x3e	; 62
	
	
}	
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	0f 90       	pop	r0
    1478:	0f be       	out	0x3f, r0	; 63
    147a:	0f 90       	pop	r0
    147c:	1f 90       	pop	r1
    147e:	18 95       	reti

00001480 <__vector_3>:


ISR(INT2_vect){	//about to get time, get things ready
    1480:	1f 92       	push	r1
    1482:	0f 92       	push	r0
    1484:	0f b6       	in	r0, 0x3f	; 63
    1486:	0f 92       	push	r0
    1488:	11 24       	eor	r1, r1
    148a:	2f 93       	push	r18
    148c:	3f 93       	push	r19
    148e:	4f 93       	push	r20
    1490:	5f 93       	push	r21
    1492:	6f 93       	push	r22
    1494:	7f 93       	push	r23
    1496:	8f 93       	push	r24
    1498:	9f 93       	push	r25
    149a:	af 93       	push	r26
    149c:	bf 93       	push	r27
    149e:	ef 93       	push	r30
    14a0:	ff 93       	push	r31
    14a2:	cf 93       	push	r28
    14a4:	df 93       	push	r29
    14a6:	cd b7       	in	r28, 0x3d	; 61
    14a8:	de b7       	in	r29, 0x3e	; 62
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    14aa:	90 91 7c 01 	lds	r25, 0x017C
    14ae:	81 e0       	ldi	r24, 0x01	; 1
    14b0:	99 23       	and	r25, r25
    14b2:	09 f0       	breq	.+2      	; 0x14b6 <__vector_3+0x36>
    14b4:	80 e0       	ldi	r24, 0x00	; 0
    14b6:	88 23       	and	r24, r24
    14b8:	89 f0       	breq	.+34     	; 0x14dc <__vector_3+0x5c>
		UCSR0B |= (1 << RXCIE0);
    14ba:	81 ec       	ldi	r24, 0xC1	; 193
    14bc:	90 e0       	ldi	r25, 0x00	; 0
    14be:	21 ec       	ldi	r18, 0xC1	; 193
    14c0:	30 e0       	ldi	r19, 0x00	; 0
    14c2:	f9 01       	movw	r30, r18
    14c4:	20 81       	ld	r18, Z
    14c6:	20 68       	ori	r18, 0x80	; 128
    14c8:	fc 01       	movw	r30, r24
    14ca:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    14cc:	10 92 72 01 	sts	0x0172, r1
		flagNormalMode=fFalse;
    14d0:	10 92 74 01 	sts	0x0174, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("ACKT");
    14d4:	82 e2       	ldi	r24, 0x22	; 34
    14d6:	91 e0       	ldi	r25, 0x01	; 1
    14d8:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
	}	
}
    14dc:	df 91       	pop	r29
    14de:	cf 91       	pop	r28
    14e0:	ff 91       	pop	r31
    14e2:	ef 91       	pop	r30
    14e4:	bf 91       	pop	r27
    14e6:	af 91       	pop	r26
    14e8:	9f 91       	pop	r25
    14ea:	8f 91       	pop	r24
    14ec:	7f 91       	pop	r23
    14ee:	6f 91       	pop	r22
    14f0:	5f 91       	pop	r21
    14f2:	4f 91       	pop	r20
    14f4:	3f 91       	pop	r19
    14f6:	2f 91       	pop	r18
    14f8:	0f 90       	pop	r0
    14fa:	0f be       	out	0x3f, r0	; 63
    14fc:	0f 90       	pop	r0
    14fe:	1f 90       	pop	r1
    1500:	18 95       	reti

00001502 <__vector_11>:

ISR(TIMER2_OVF_vect){
    1502:	1f 92       	push	r1
    1504:	0f 92       	push	r0
    1506:	0f b6       	in	r0, 0x3f	; 63
    1508:	0f 92       	push	r0
    150a:	11 24       	eor	r1, r1
    150c:	2f 93       	push	r18
    150e:	3f 93       	push	r19
    1510:	4f 93       	push	r20
    1512:	5f 93       	push	r21
    1514:	6f 93       	push	r22
    1516:	7f 93       	push	r23
    1518:	8f 93       	push	r24
    151a:	9f 93       	push	r25
    151c:	af 93       	push	r26
    151e:	bf 93       	push	r27
    1520:	ef 93       	push	r30
    1522:	ff 93       	push	r31
    1524:	cf 93       	push	r28
    1526:	df 93       	push	r29
    1528:	cd b7       	in	r28, 0x3d	; 61
    152a:	de b7       	in	r29, 0x3e	; 62
	volatile static int timeOut = 0;
	volatile static int gavrTimeout=0;
	
	currentTime.addSeconds(1);
    152c:	85 e8       	ldi	r24, 0x85	; 133
    152e:	91 e0       	ldi	r25, 0x01	; 1
    1530:	61 e0       	ldi	r22, 0x01	; 1
    1532:	70 e0       	ldi	r23, 0x00	; 0
    1534:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN6myTime10addSecondsEi>
	if ((flagUARTbone == fTrue || flagGoToSleep == fFalse) && !flagNewShutdown && !restart){ //if waiting for a character in Receive0() or in main program without sleep
    1538:	80 91 73 01 	lds	r24, 0x0173
    153c:	81 30       	cpi	r24, 0x01	; 1
    153e:	21 f0       	breq	.+8      	; 0x1548 <__vector_11+0x46>
    1540:	80 91 72 01 	lds	r24, 0x0172
    1544:	88 23       	and	r24, r24
    1546:	51 f4       	brne	.+20     	; 0x155c <__vector_11+0x5a>
    1548:	80 91 7b 01 	lds	r24, 0x017B
    154c:	88 23       	and	r24, r24
    154e:	31 f4       	brne	.+12     	; 0x155c <__vector_11+0x5a>
    1550:	80 91 7f 01 	lds	r24, 0x017F
    1554:	88 23       	and	r24, r24
    1556:	11 f4       	brne	.+4      	; 0x155c <__vector_11+0x5a>
    1558:	81 e0       	ldi	r24, 0x01	; 1
    155a:	01 c0       	rjmp	.+2      	; 0x155e <__vector_11+0x5c>
    155c:	80 e0       	ldi	r24, 0x00	; 0
    155e:	88 23       	and	r24, r24
    1560:	51 f1       	breq	.+84     	; 0x15b6 <__vector_11+0xb4>
		timeOut++;
    1562:	80 91 ad 01 	lds	r24, 0x01AD
    1566:	90 91 ae 01 	lds	r25, 0x01AE
    156a:	01 96       	adiw	r24, 0x01	; 1
    156c:	90 93 ae 01 	sts	0x01AE, r25
    1570:	80 93 ad 01 	sts	0x01AD, r24
		if (timeOut >= 6){
    1574:	80 91 ad 01 	lds	r24, 0x01AD
    1578:	90 91 ae 01 	lds	r25, 0x01AE
    157c:	21 e0       	ldi	r18, 0x01	; 1
    157e:	86 30       	cpi	r24, 0x06	; 6
    1580:	91 05       	cpc	r25, r1
    1582:	0c f4       	brge	.+2      	; 0x1586 <__vector_11+0x84>
    1584:	20 e0       	ldi	r18, 0x00	; 0
    1586:	22 23       	and	r18, r18
    1588:	29 f1       	breq	.+74     	; 0x15d4 <__vector_11+0xd2>
			EIMSK |= (1 << INT2);		//re-enable INT2
    158a:	8d e3       	ldi	r24, 0x3D	; 61
    158c:	90 e0       	ldi	r25, 0x00	; 0
    158e:	2d e3       	ldi	r18, 0x3D	; 61
    1590:	30 e0       	ldi	r19, 0x00	; 0
    1592:	f9 01       	movw	r30, r18
    1594:	20 81       	ld	r18, Z
    1596:	24 60       	ori	r18, 0x04	; 4
    1598:	fc 01       	movw	r30, r24
    159a:	20 83       	st	Z, r18
			flagUARTbone = fFalse;
    159c:	10 92 73 01 	sts	0x0173, r1
			flagGoToSleep = fTrue;
    15a0:	81 e0       	ldi	r24, 0x01	; 1
    15a2:	80 93 72 01 	sts	0x0172, r24
			flagNormalMode=fTrue;
    15a6:	81 e0       	ldi	r24, 0x01	; 1
    15a8:	80 93 74 01 	sts	0x0174, r24
			timeOut = 0;
    15ac:	10 92 ae 01 	sts	0x01AE, r1
    15b0:	10 92 ad 01 	sts	0x01AD, r1
    15b4:	0f c0       	rjmp	.+30     	; 0x15d4 <__vector_11+0xd2>
		}
	} else if (timeOut > 0){
    15b6:	80 91 ad 01 	lds	r24, 0x01AD
    15ba:	90 91 ae 01 	lds	r25, 0x01AE
    15be:	21 e0       	ldi	r18, 0x01	; 1
    15c0:	18 16       	cp	r1, r24
    15c2:	19 06       	cpc	r1, r25
    15c4:	0c f0       	brlt	.+2      	; 0x15c8 <__vector_11+0xc6>
    15c6:	20 e0       	ldi	r18, 0x00	; 0
    15c8:	22 23       	and	r18, r18
    15ca:	21 f0       	breq	.+8      	; 0x15d4 <__vector_11+0xd2>
		timeOut = 0;
    15cc:	10 92 ae 01 	sts	0x01AE, r1
    15d0:	10 92 ad 01 	sts	0x01AD, r1
	} else;
	/* This doesnt work
	if (flagSendingGAVR){gavrTimeout++;}
	if (gavrTimeout>10 && flagSendingGAVR){noTimeout=fFalse; flagSendingGAVR=fFalse;gavrTimeout=0;}
	else; 	*/
}
    15d4:	df 91       	pop	r29
    15d6:	cf 91       	pop	r28
    15d8:	ff 91       	pop	r31
    15da:	ef 91       	pop	r30
    15dc:	bf 91       	pop	r27
    15de:	af 91       	pop	r26
    15e0:	9f 91       	pop	r25
    15e2:	8f 91       	pop	r24
    15e4:	7f 91       	pop	r23
    15e6:	6f 91       	pop	r22
    15e8:	5f 91       	pop	r21
    15ea:	4f 91       	pop	r20
    15ec:	3f 91       	pop	r19
    15ee:	2f 91       	pop	r18
    15f0:	0f 90       	pop	r0
    15f2:	0f be       	out	0x3f, r0	; 63
    15f4:	0f 90       	pop	r0
    15f6:	1f 90       	pop	r1
    15f8:	18 95       	reti

000015fa <__vector_20>:

ISR(USART0_RX_vect){
    15fa:	1f 92       	push	r1
    15fc:	0f 92       	push	r0
    15fe:	0f b6       	in	r0, 0x3f	; 63
    1600:	0f 92       	push	r0
    1602:	11 24       	eor	r1, r1
    1604:	2f 93       	push	r18
    1606:	3f 93       	push	r19
    1608:	8f 93       	push	r24
    160a:	9f 93       	push	r25
    160c:	ef 93       	push	r30
    160e:	ff 93       	push	r31
    1610:	cf 93       	push	r28
    1612:	df 93       	push	r29
    1614:	cd b7       	in	r28, 0x3d	; 61
    1616:	de b7       	in	r29, 0x3e	; 62
	UCSR0B &= ~(1 << RXCIE0);
    1618:	81 ec       	ldi	r24, 0xC1	; 193
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	21 ec       	ldi	r18, 0xC1	; 193
    161e:	30 e0       	ldi	r19, 0x00	; 0
    1620:	f9 01       	movw	r30, r18
    1622:	20 81       	ld	r18, Z
    1624:	2f 77       	andi	r18, 0x7F	; 127
    1626:	fc 01       	movw	r30, r24
    1628:	20 83       	st	Z, r18
	EIMSK=0x00;
    162a:	8d e3       	ldi	r24, 0x3D	; 61
    162c:	90 e0       	ldi	r25, 0x00	; 0
    162e:	fc 01       	movw	r30, r24
    1630:	10 82       	st	Z, r1
	flagUARTbone=fTrue;
    1632:	81 e0       	ldi	r24, 0x01	; 1
    1634:	80 93 73 01 	sts	0x0173, r24
	flagNormalMode=fFalse;
    1638:	10 92 74 01 	sts	0x0174, r1
}
    163c:	df 91       	pop	r29
    163e:	cf 91       	pop	r28
    1640:	ff 91       	pop	r31
    1642:	ef 91       	pop	r30
    1644:	9f 91       	pop	r25
    1646:	8f 91       	pop	r24
    1648:	3f 91       	pop	r19
    164a:	2f 91       	pop	r18
    164c:	0f 90       	pop	r0
    164e:	0f be       	out	0x3f, r0	; 63
    1650:	0f 90       	pop	r0
    1652:	1f 90       	pop	r1
    1654:	18 95       	reti

00001656 <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    1656:	cf 93       	push	r28
    1658:	df 93       	push	r29
    165a:	00 d0       	rcall	.+0      	; 0x165c <main+0x6>
    165c:	cd b7       	in	r28, 0x3d	; 61
    165e:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    1660:	0e 94 ce 0c 	call	0x199c	; 0x199c <_Z10DeviceInitv>
	AppInit(MYUBRR);
    1664:	81 e8       	ldi	r24, 0x81	; 129
    1666:	90 e0       	ldi	r25, 0x00	; 0
    1668:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <_Z7AppInitj>
	EnableRTCTimer();
    166c:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <_Z14EnableRTCTimerv>
	getDateTime_eeprom(fTrue,fTrue);
    1670:	81 e0       	ldi	r24, 0x01	; 1
    1672:	61 e0       	ldi	r22, 0x01	; 1
    1674:	0e 94 cc 06 	call	0xd98	; 0xd98 <_Z18getDateTime_eepromhh>
	sei();
    1678:	78 94       	sei
	//Prep/make sure power/temp is good
	GetTemp();
    167a:	0e 94 94 11 	call	0x2328	; 0x2328 <_Z7GetTempv>
	//flagGoodTemp=fTrue;
	TakeADC();
    167e:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <_Z7TakeADCv>
	if (flagGoodVolts && flagGoodTemp){__powPeriph();flagFreshStart=fTrue;}
    1682:	80 91 7e 01 	lds	r24, 0x017E
    1686:	88 23       	and	r24, r24
    1688:	31 f0       	breq	.+12     	; 0x1696 <main+0x40>
    168a:	80 91 7d 01 	lds	r24, 0x017D
    168e:	88 23       	and	r24, r24
    1690:	11 f0       	breq	.+4      	; 0x1696 <main+0x40>
    1692:	81 e0       	ldi	r24, 0x01	; 1
    1694:	01 c0       	rjmp	.+2      	; 0x1698 <main+0x42>
    1696:	80 e0       	ldi	r24, 0x00	; 0
    1698:	88 23       	and	r24, r24
    169a:	b1 f0       	breq	.+44     	; 0x16c8 <main+0x72>
    169c:	82 e2       	ldi	r24, 0x22	; 34
    169e:	90 e0       	ldi	r25, 0x00	; 0
    16a0:	22 e2       	ldi	r18, 0x22	; 34
    16a2:	30 e0       	ldi	r19, 0x00	; 0
    16a4:	f9 01       	movw	r30, r18
    16a6:	20 81       	ld	r18, Z
    16a8:	20 6e       	ori	r18, 0xE0	; 224
    16aa:	fc 01       	movw	r30, r24
    16ac:	20 83       	st	Z, r18
    16ae:	85 e2       	ldi	r24, 0x25	; 37
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	25 e2       	ldi	r18, 0x25	; 37
    16b4:	30 e0       	ldi	r19, 0x00	; 0
    16b6:	f9 01       	movw	r30, r18
    16b8:	20 81       	ld	r18, Z
    16ba:	21 60       	ori	r18, 0x01	; 1
    16bc:	fc 01       	movw	r30, r24
    16be:	20 83       	st	Z, r18
    16c0:	81 e0       	ldi	r24, 0x01	; 1
    16c2:	80 93 80 01 	sts	0x0180, r24
    16c6:	07 c0       	rjmp	.+14     	; 0x16d6 <main+0x80>
	else {flagNormalMode=fTrue;flagFreshStart=fFalse;}
    16c8:	81 e0       	ldi	r24, 0x01	; 1
    16ca:	80 93 74 01 	sts	0x0174, r24
    16ce:	10 92 80 01 	sts	0x0180, r1
    16d2:	01 c0       	rjmp	.+2      	; 0x16d6 <main+0x80>
	//main programming loop
	while(fTrue)
    16d4:	00 00       	nop
	{				
		//If receiving UART string, go get rest of it.
		if (flagUARTbone){
    16d6:	90 91 73 01 	lds	r25, 0x0173
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	99 23       	and	r25, r25
    16de:	09 f4       	brne	.+2      	; 0x16e2 <main+0x8c>
    16e0:	80 e0       	ldi	r24, 0x00	; 0
    16e2:	88 23       	and	r24, r24
    16e4:	99 f0       	breq	.+38     	; 0x170c <main+0xb6>
			EIMSK=0;
    16e6:	8d e3       	ldi	r24, 0x3D	; 61
    16e8:	90 e0       	ldi	r25, 0x00	; 0
    16ea:	fc 01       	movw	r30, r24
    16ec:	10 82       	st	Z, r1
			ReceiveBone();
    16ee:	0e 94 75 0e 	call	0x1cea	; 0x1cea <_Z11ReceiveBonev>
			flagUARTbone = fFalse; 
    16f2:	10 92 73 01 	sts	0x0173, r1
			//PCIMSK |= (1 << PCINT0);
			EIMSK = (1 << INT2);											//enable INT2 interrupt vector again.
    16f6:	8d e3       	ldi	r24, 0x3D	; 61
    16f8:	90 e0       	ldi	r25, 0x00	; 0
    16fa:	24 e0       	ldi	r18, 0x04	; 4
    16fc:	fc 01       	movw	r30, r24
    16fe:	20 83       	st	Z, r18
			flagGoToSleep = fTrue;
    1700:	81 e0       	ldi	r24, 0x01	; 1
    1702:	80 93 72 01 	sts	0x0172, r24
			flagNormalMode=fTrue;
    1706:	81 e0       	ldi	r24, 0x01	; 1
    1708:	80 93 74 01 	sts	0x0174, r24
		}
	
		if (flagUpdateGAVRTime || flagUpdateGAVRDate){
    170c:	80 91 77 01 	lds	r24, 0x0177
    1710:	88 23       	and	r24, r24
    1712:	21 f4       	brne	.+8      	; 0x171c <main+0xc6>
    1714:	80 91 78 01 	lds	r24, 0x0178
    1718:	88 23       	and	r24, r24
    171a:	11 f0       	breq	.+4      	; 0x1720 <main+0xca>
    171c:	81 e0       	ldi	r24, 0x01	; 1
    171e:	01 c0       	rjmp	.+2      	; 0x1722 <main+0xcc>
    1720:	80 e0       	ldi	r24, 0x00	; 0
    1722:	88 23       	and	r24, r24
    1724:	49 f0       	breq	.+18     	; 0x1738 <main+0xe2>
			//kill INT2, updating GAVR
			EIMSK=0x00;
    1726:	8d e3       	ldi	r24, 0x3D	; 61
    1728:	90 e0       	ldi	r25, 0x00	; 0
    172a:	fc 01       	movw	r30, r24
    172c:	10 82       	st	Z, r1
			//SendTimeDateGAVR(flagUpdateGAVRTime,flagUpdateGAVRDate);
			EIMSK = (1 << INT2);
    172e:	8d e3       	ldi	r24, 0x3D	; 61
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	24 e0       	ldi	r18, 0x04	; 4
    1734:	fc 01       	movw	r30, r24
    1736:	20 83       	st	Z, r18
		}

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    1738:	90 91 74 01 	lds	r25, 0x0174
    173c:	81 e0       	ldi	r24, 0x01	; 1
    173e:	99 23       	and	r25, r25
    1740:	09 f4       	brne	.+2      	; 0x1744 <main+0xee>
    1742:	80 e0       	ldi	r24, 0x00	; 0
    1744:	88 23       	and	r24, r24
    1746:	49 f1       	breq	.+82     	; 0x179a <main+0x144>
			if (currentTime.getMinutes()%30 == 0){
    1748:	85 e8       	ldi	r24, 0x85	; 133
    174a:	91 e0       	ldi	r25, 0x01	; 1
    174c:	0e 94 26 04 	call	0x84c	; 0x84c <_ZN6myTime10getMinutesEv>
    1750:	9e e1       	ldi	r25, 0x1E	; 30
    1752:	69 2f       	mov	r22, r25
    1754:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <__udivmodqi4>
    1758:	89 2f       	mov	r24, r25
    175a:	98 2f       	mov	r25, r24
    175c:	81 e0       	ldi	r24, 0x01	; 1
    175e:	99 23       	and	r25, r25
    1760:	09 f0       	breq	.+2      	; 0x1764 <main+0x10e>
    1762:	80 e0       	ldi	r24, 0x00	; 0
    1764:	88 23       	and	r24, r24
    1766:	c9 f0       	breq	.+50     	; 0x179a <main+0x144>
				if (currentTime.getHours()%12 == 0){
    1768:	85 e8       	ldi	r24, 0x85	; 133
    176a:	91 e0       	ldi	r25, 0x01	; 1
    176c:	0e 94 37 04 	call	0x86e	; 0x86e <_ZN6myTime8getHoursEv>
    1770:	9c e0       	ldi	r25, 0x0C	; 12
    1772:	69 2f       	mov	r22, r25
    1774:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <__udivmodqi4>
    1778:	89 2f       	mov	r24, r25
    177a:	98 2f       	mov	r25, r24
    177c:	81 e0       	ldi	r24, 0x01	; 1
    177e:	99 23       	and	r25, r25
    1780:	09 f0       	breq	.+2      	; 0x1784 <main+0x12e>
    1782:	80 e0       	ldi	r24, 0x00	; 0
    1784:	88 23       	and	r24, r24
    1786:	29 f0       	breq	.+10     	; 0x1792 <main+0x13c>
					saveDateTime_eeprom(fTrue,fTrue);
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	61 e0       	ldi	r22, 0x01	; 1
    178c:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1790:	04 c0       	rjmp	.+8      	; 0x179a <main+0x144>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    1792:	81 e0       	ldi	r24, 0x01	; 1
    1794:	60 e0       	ldi	r22, 0x00	; 0
    1796:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}
		
		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    179a:	90 91 74 01 	lds	r25, 0x0174
    179e:	81 e0       	ldi	r24, 0x01	; 1
    17a0:	99 23       	and	r25, r25
    17a2:	09 f4       	brne	.+2      	; 0x17a6 <main+0x150>
    17a4:	80 e0       	ldi	r24, 0x00	; 0
    17a6:	88 23       	and	r24, r24
    17a8:	09 f4       	brne	.+2      	; 0x17ac <main+0x156>
    17aa:	3f c0       	rjmp	.+126    	; 0x182a <main+0x1d4>
			TakeADC();
    17ac:	0e 94 f3 10 	call	0x21e6	; 0x21e6 <_Z7TakeADCv>
			GetTemp();
    17b0:	0e 94 94 11 	call	0x2328	; 0x2328 <_Z7GetTempv>
			//If both are good & shutodwn is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    17b4:	80 91 7e 01 	lds	r24, 0x017E
    17b8:	88 23       	and	r24, r24
    17ba:	31 f0       	breq	.+12     	; 0x17c8 <main+0x172>
    17bc:	80 91 7d 01 	lds	r24, 0x017D
    17c0:	88 23       	and	r24, r24
    17c2:	11 f0       	breq	.+4      	; 0x17c8 <main+0x172>
    17c4:	81 e0       	ldi	r24, 0x01	; 1
    17c6:	01 c0       	rjmp	.+2      	; 0x17ca <main+0x174>
    17c8:	80 e0       	ldi	r24, 0x00	; 0
    17ca:	88 23       	and	r24, r24
    17cc:	01 f1       	breq	.+64     	; 0x180e <main+0x1b8>
				__powPeriph();
    17ce:	82 e2       	ldi	r24, 0x22	; 34
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	22 e2       	ldi	r18, 0x22	; 34
    17d4:	30 e0       	ldi	r19, 0x00	; 0
    17d6:	f9 01       	movw	r30, r18
    17d8:	20 81       	ld	r18, Z
    17da:	20 6e       	ori	r18, 0xE0	; 224
    17dc:	fc 01       	movw	r30, r24
    17de:	20 83       	st	Z, r18
    17e0:	85 e2       	ldi	r24, 0x25	; 37
    17e2:	90 e0       	ldi	r25, 0x00	; 0
    17e4:	25 e2       	ldi	r18, 0x25	; 37
    17e6:	30 e0       	ldi	r19, 0x00	; 0
    17e8:	f9 01       	movw	r30, r18
    17ea:	20 81       	ld	r18, Z
    17ec:	21 60       	ori	r18, 0x01	; 1
    17ee:	fc 01       	movw	r30, r24
    17f0:	20 83       	st	Z, r18
				if( flagShutdown == fTrue){restart = fTrue;}
    17f2:	90 91 7c 01 	lds	r25, 0x017C
    17f6:	81 e0       	ldi	r24, 0x01	; 1
    17f8:	91 30       	cpi	r25, 0x01	; 1
    17fa:	09 f0       	breq	.+2      	; 0x17fe <main+0x1a8>
    17fc:	80 e0       	ldi	r24, 0x00	; 0
    17fe:	88 23       	and	r24, r24
    1800:	19 f0       	breq	.+6      	; 0x1808 <main+0x1b2>
    1802:	81 e0       	ldi	r24, 0x01	; 1
    1804:	80 93 7f 01 	sts	0x017F, r24
				flagShutdown = fFalse;
    1808:	10 92 7c 01 	sts	0x017C, r1
    180c:	0e c0       	rjmp	.+28     	; 0x182a <main+0x1d4>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (flagShutdown == fFalse){
    180e:	90 91 7c 01 	lds	r25, 0x017C
    1812:	81 e0       	ldi	r24, 0x01	; 1
    1814:	99 23       	and	r25, r25
    1816:	09 f0       	breq	.+2      	; 0x181a <main+0x1c4>
    1818:	80 e0       	ldi	r24, 0x00	; 0
    181a:	88 23       	and	r24, r24
    181c:	19 f0       	breq	.+6      	; 0x1824 <main+0x1ce>
					flagNewShutdown = fTrue;
    181e:	81 e0       	ldi	r24, 0x01	; 1
    1820:	80 93 7b 01 	sts	0x017B, r24
				}
				flagShutdown = fTrue;
    1824:	81 e0       	ldi	r24, 0x01	; 1
    1826:	80 93 7c 01 	sts	0x017C, r24
			}
		}			
		
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    182a:	90 91 7b 01 	lds	r25, 0x017B
    182e:	81 e0       	ldi	r24, 0x01	; 1
    1830:	99 23       	and	r25, r25
    1832:	09 f4       	brne	.+2      	; 0x1836 <main+0x1e0>
    1834:	80 e0       	ldi	r24, 0x00	; 0
    1836:	88 23       	and	r24, r24
    1838:	09 f4       	brne	.+2      	; 0x183c <main+0x1e6>
    183a:	63 c0       	rjmp	.+198    	; 0x1902 <main+0x2ac>
			//Make sure nothing messes with the routine that we care about
			EIMSK = 0;
    183c:	8d e3       	ldi	r24, 0x3D	; 61
    183e:	90 e0       	ldi	r25, 0x00	; 0
    1840:	fc 01       	movw	r30, r24
    1842:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    1844:	81 e0       	ldi	r24, 0x01	; 1
    1846:	80 93 72 01 	sts	0x0172, r24
			flagUARTbone = fFalse;
    184a:	10 92 73 01 	sts	0x0173, r1
			saveDateTime_eeprom(fTrue,fTrue);
    184e:	81 e0       	ldi	r24, 0x01	; 1
    1850:	61 e0       	ldi	r22, 0x01	; 1
    1852:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
			
			//Alert BeagleBone and Graphics AVR that powerdown is imminent=> raise SHUTDOWN PINS for 3 clk cycles
			prtBBleds |= (1 << bnBBint);
    1856:	82 e2       	ldi	r24, 0x22	; 34
    1858:	90 e0       	ldi	r25, 0x00	; 0
    185a:	22 e2       	ldi	r18, 0x22	; 34
    185c:	30 e0       	ldi	r19, 0x00	; 0
    185e:	f9 01       	movw	r30, r18
    1860:	20 81       	ld	r18, Z
    1862:	22 60       	ori	r18, 0x02	; 2
    1864:	fc 01       	movw	r30, r24
    1866:	20 83       	st	Z, r18
			prtGAVRleds |= (1 << bnGAVRint);
    1868:	82 e2       	ldi	r24, 0x22	; 34
    186a:	90 e0       	ldi	r25, 0x00	; 0
    186c:	22 e2       	ldi	r18, 0x22	; 34
    186e:	30 e0       	ldi	r19, 0x00	; 0
    1870:	f9 01       	movw	r30, r18
    1872:	20 81       	ld	r18, Z
    1874:	28 60       	ori	r18, 0x08	; 8
    1876:	fc 01       	movw	r30, r24
    1878:	20 83       	st	Z, r18
			if (!flagGoodTemp){
    187a:	90 91 7d 01 	lds	r25, 0x017D
    187e:	81 e0       	ldi	r24, 0x01	; 1
    1880:	99 23       	and	r25, r25
    1882:	09 f0       	breq	.+2      	; 0x1886 <main+0x230>
    1884:	80 e0       	ldi	r24, 0x00	; 0
    1886:	88 23       	and	r24, r24
    1888:	91 f0       	breq	.+36     	; 0x18ae <main+0x258>
				prtBBleds |= (1 << bnBBtemp);
    188a:	82 e2       	ldi	r24, 0x22	; 34
    188c:	90 e0       	ldi	r25, 0x00	; 0
    188e:	22 e2       	ldi	r18, 0x22	; 34
    1890:	30 e0       	ldi	r19, 0x00	; 0
    1892:	f9 01       	movw	r30, r18
    1894:	20 81       	ld	r18, Z
    1896:	24 60       	ori	r18, 0x04	; 4
    1898:	fc 01       	movw	r30, r24
    189a:	20 83       	st	Z, r18
				prtGAVRleds |= (1 << bnGAVRtemp);
    189c:	82 e2       	ldi	r24, 0x22	; 34
    189e:	90 e0       	ldi	r25, 0x00	; 0
    18a0:	22 e2       	ldi	r18, 0x22	; 34
    18a2:	30 e0       	ldi	r19, 0x00	; 0
    18a4:	f9 01       	movw	r30, r18
    18a6:	20 81       	ld	r18, Z
    18a8:	20 61       	ori	r18, 0x10	; 16
    18aa:	fc 01       	movw	r30, r24
    18ac:	20 83       	st	Z, r18
			}
			
			//Five seconds for processing to finish on other chips
			Wait_sec(6);	
    18ae:	86 e0       	ldi	r24, 0x06	; 6
    18b0:	90 e0       	ldi	r25, 0x00	; 0
    18b2:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <_Z8Wait_seci>
			
			prtBBleds &= ~((1 << bnBBint)|(1 << bnBBtemp));
    18b6:	82 e2       	ldi	r24, 0x22	; 34
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	22 e2       	ldi	r18, 0x22	; 34
    18bc:	30 e0       	ldi	r19, 0x00	; 0
    18be:	f9 01       	movw	r30, r18
    18c0:	20 81       	ld	r18, Z
    18c2:	29 7f       	andi	r18, 0xF9	; 249
    18c4:	fc 01       	movw	r30, r24
    18c6:	20 83       	st	Z, r18
			prtGAVRleds &= ~((1 << bnGAVRint)|(1 << bnGAVRtemp));
    18c8:	82 e2       	ldi	r24, 0x22	; 34
    18ca:	90 e0       	ldi	r25, 0x00	; 0
    18cc:	22 e2       	ldi	r18, 0x22	; 34
    18ce:	30 e0       	ldi	r19, 0x00	; 0
    18d0:	f9 01       	movw	r30, r18
    18d2:	20 81       	ld	r18, Z
    18d4:	27 7e       	andi	r18, 0xE7	; 231
    18d6:	fc 01       	movw	r30, r24
    18d8:	20 83       	st	Z, r18
			
			//Kill power
			__killPeriphPow();
    18da:	82 e2       	ldi	r24, 0x22	; 34
    18dc:	90 e0       	ldi	r25, 0x00	; 0
    18de:	22 e2       	ldi	r18, 0x22	; 34
    18e0:	30 e0       	ldi	r19, 0x00	; 0
    18e2:	f9 01       	movw	r30, r18
    18e4:	20 81       	ld	r18, Z
    18e6:	2f 71       	andi	r18, 0x1F	; 31
    18e8:	fc 01       	movw	r30, r24
    18ea:	20 83       	st	Z, r18
    18ec:	85 e2       	ldi	r24, 0x25	; 37
    18ee:	90 e0       	ldi	r25, 0x00	; 0
    18f0:	25 e2       	ldi	r18, 0x25	; 37
    18f2:	30 e0       	ldi	r19, 0x00	; 0
    18f4:	f9 01       	movw	r30, r18
    18f6:	20 81       	ld	r18, Z
    18f8:	2e 7f       	andi	r18, 0xFE	; 254
    18fa:	fc 01       	movw	r30, r24
    18fc:	20 83       	st	Z, r18
			flagNewShutdown = fFalse;
    18fe:	10 92 7b 01 	sts	0x017B, r1
		}
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    1902:	90 91 7f 01 	lds	r25, 0x017F
    1906:	81 e0       	ldi	r24, 0x01	; 1
    1908:	99 23       	and	r25, r25
    190a:	09 f4       	brne	.+2      	; 0x190e <main+0x2b8>
    190c:	80 e0       	ldi	r24, 0x00	; 0
    190e:	88 23       	and	r24, r24
    1910:	b9 f1       	breq	.+110    	; 0x1980 <main+0x32a>
			EIMSK = (1 << INT2);	//enable BONE interrupt. Will come out with newest time. Give it 10 seconds to kill
    1912:	8d e3       	ldi	r24, 0x3D	; 61
    1914:	90 e0       	ldi	r25, 0x00	; 0
    1916:	24 e0       	ldi	r18, 0x04	; 4
    1918:	fc 01       	movw	r30, r24
    191a:	20 83       	st	Z, r18
			__powPeriph();
    191c:	82 e2       	ldi	r24, 0x22	; 34
    191e:	90 e0       	ldi	r25, 0x00	; 0
    1920:	22 e2       	ldi	r18, 0x22	; 34
    1922:	30 e0       	ldi	r19, 0x00	; 0
    1924:	f9 01       	movw	r30, r18
    1926:	20 81       	ld	r18, Z
    1928:	20 6e       	ori	r18, 0xE0	; 224
    192a:	fc 01       	movw	r30, r24
    192c:	20 83       	st	Z, r18
    192e:	85 e2       	ldi	r24, 0x25	; 37
    1930:	90 e0       	ldi	r25, 0x00	; 0
    1932:	25 e2       	ldi	r18, 0x25	; 37
    1934:	30 e0       	ldi	r19, 0x00	; 0
    1936:	f9 01       	movw	r30, r18
    1938:	20 81       	ld	r18, Z
    193a:	21 60       	ori	r18, 0x01	; 1
    193c:	fc 01       	movw	r30, r24
    193e:	20 83       	st	Z, r18
			//Check to see if pins are ready. Use timeout of 10 seconds for pins to come high.
			int waitTime = 0;
    1940:	1a 82       	std	Y+2, r1	; 0x02
    1942:	19 82       	std	Y+1, r1	; 0x01
			while (waitTime < 3 && restart){waitTime++; Wait_sec(1);}
    1944:	09 c0       	rjmp	.+18     	; 0x1958 <main+0x302>
    1946:	89 81       	ldd	r24, Y+1	; 0x01
    1948:	9a 81       	ldd	r25, Y+2	; 0x02
    194a:	01 96       	adiw	r24, 0x01	; 1
    194c:	9a 83       	std	Y+2, r25	; 0x02
    194e:	89 83       	std	Y+1, r24	; 0x01
    1950:	81 e0       	ldi	r24, 0x01	; 1
    1952:	90 e0       	ldi	r25, 0x00	; 0
    1954:	0e 94 3d 0e 	call	0x1c7a	; 0x1c7a <_Z8Wait_seci>
    1958:	89 81       	ldd	r24, Y+1	; 0x01
    195a:	9a 81       	ldd	r25, Y+2	; 0x02
    195c:	83 30       	cpi	r24, 0x03	; 3
    195e:	91 05       	cpc	r25, r1
    1960:	34 f4       	brge	.+12     	; 0x196e <main+0x318>
    1962:	80 91 7f 01 	lds	r24, 0x017F
    1966:	88 23       	and	r24, r24
    1968:	11 f0       	breq	.+4      	; 0x196e <main+0x318>
    196a:	81 e0       	ldi	r24, 0x01	; 1
    196c:	01 c0       	rjmp	.+2      	; 0x1970 <main+0x31a>
    196e:	80 e0       	ldi	r24, 0x00	; 0
    1970:	88 23       	and	r24, r24
    1972:	49 f7       	brne	.-46     	; 0x1946 <main+0x2f0>
			flagUpdateGAVRDate=fTrue;
    1974:	81 e0       	ldi	r24, 0x01	; 1
    1976:	80 93 78 01 	sts	0x0178, r24
			flagUpdateGAVRTime=fTrue;
    197a:	81 e0       	ldi	r24, 0x01	; 1
    197c:	80 93 77 01 	sts	0x0177, r24
			//get an updated date and time from the BeagleBone. Always update GAVR.			
		}		
		
			
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep){GoToSleep(flagShutdown);}
    1980:	90 91 72 01 	lds	r25, 0x0172
    1984:	81 e0       	ldi	r24, 0x01	; 1
    1986:	99 23       	and	r25, r25
    1988:	09 f4       	brne	.+2      	; 0x198c <main+0x336>
    198a:	80 e0       	ldi	r24, 0x00	; 0
    198c:	88 23       	and	r24, r24
    198e:	09 f4       	brne	.+2      	; 0x1992 <main+0x33c>
    1990:	a1 ce       	rjmp	.-702    	; 0x16d4 <main+0x7e>
    1992:	80 91 7c 01 	lds	r24, 0x017C
    1996:	0e 94 76 10 	call	0x20ec	; 0x20ec <_Z9GoToSleeph>
	//flagGoodTemp=fTrue;
	TakeADC();
	if (flagGoodVolts && flagGoodTemp){__powPeriph();flagFreshStart=fTrue;}
	else {flagNormalMode=fTrue;flagFreshStart=fFalse;}
	//main programming loop
	while(fTrue)
    199a:	9c ce       	rjmp	.-712    	; 0x16d4 <main+0x7e>

0000199c <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    199c:	cf 93       	push	r28
    199e:	df 93       	push	r29
    19a0:	cd b7       	in	r28, 0x3d	; 61
    19a2:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    19a4:	81 e2       	ldi	r24, 0x21	; 33
    19a6:	90 e0       	ldi	r25, 0x00	; 0
    19a8:	fc 01       	movw	r30, r24
    19aa:	10 82       	st	Z, r1
	DDRB = 0;
    19ac:	84 e2       	ldi	r24, 0x24	; 36
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	fc 01       	movw	r30, r24
    19b2:	10 82       	st	Z, r1
	DDRC = 0;
    19b4:	87 e2       	ldi	r24, 0x27	; 39
    19b6:	90 e0       	ldi	r25, 0x00	; 0
    19b8:	fc 01       	movw	r30, r24
    19ba:	10 82       	st	Z, r1
	DDRD = 0;
    19bc:	8a e2       	ldi	r24, 0x2A	; 42
    19be:	90 e0       	ldi	r25, 0x00	; 0
    19c0:	fc 01       	movw	r30, r24
    19c2:	10 82       	st	Z, r1
	
	PORTA = 0;
    19c4:	82 e2       	ldi	r24, 0x22	; 34
    19c6:	90 e0       	ldi	r25, 0x00	; 0
    19c8:	fc 01       	movw	r30, r24
    19ca:	10 82       	st	Z, r1
	PORTB = 0;
    19cc:	85 e2       	ldi	r24, 0x25	; 37
    19ce:	90 e0       	ldi	r25, 0x00	; 0
    19d0:	fc 01       	movw	r30, r24
    19d2:	10 82       	st	Z, r1
	PORTC = 0;
    19d4:	88 e2       	ldi	r24, 0x28	; 40
    19d6:	90 e0       	ldi	r25, 0x00	; 0
    19d8:	fc 01       	movw	r30, r24
    19da:	10 82       	st	Z, r1
	PORTD = 0;
    19dc:	8b e2       	ldi	r24, 0x2B	; 43
    19de:	90 e0       	ldi	r25, 0x00	; 0
    19e0:	fc 01       	movw	r30, r24
    19e2:	10 82       	st	Z, r1
}
    19e4:	df 91       	pop	r29
    19e6:	cf 91       	pop	r28
    19e8:	08 95       	ret

000019ea <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    19ea:	cf 93       	push	r28
    19ec:	df 93       	push	r29
    19ee:	00 d0       	rcall	.+0      	; 0x19f0 <_Z7AppInitj+0x6>
    19f0:	cd b7       	in	r28, 0x3d	; 61
    19f2:	de b7       	in	r29, 0x3e	; 62
    19f4:	9a 83       	std	Y+2, r25	; 0x02
    19f6:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    19f8:	84 ec       	ldi	r24, 0xC4	; 196
    19fa:	90 e0       	ldi	r25, 0x00	; 0
    19fc:	29 81       	ldd	r18, Y+1	; 0x01
    19fe:	fc 01       	movw	r30, r24
    1a00:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    1a02:	85 ec       	ldi	r24, 0xC5	; 197
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	29 81       	ldd	r18, Y+1	; 0x01
    1a08:	3a 81       	ldd	r19, Y+2	; 0x02
    1a0a:	23 2f       	mov	r18, r19
    1a0c:	33 27       	eor	r19, r19
    1a0e:	fc 01       	movw	r30, r24
    1a10:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    1a12:	81 ec       	ldi	r24, 0xC1	; 193
    1a14:	90 e0       	ldi	r25, 0x00	; 0
    1a16:	28 e1       	ldi	r18, 0x18	; 24
    1a18:	fc 01       	movw	r30, r24
    1a1a:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    1a1c:	82 ec       	ldi	r24, 0xC2	; 194
    1a1e:	90 e0       	ldi	r25, 0x00	; 0
    1a20:	26 e0       	ldi	r18, 0x06	; 6
    1a22:	fc 01       	movw	r30, r24
    1a24:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM2)|(1 << PRTIM0)|(1 << PRUSART1)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    1a26:	84 e6       	ldi	r24, 0x64	; 100
    1a28:	90 e0       	ldi	r25, 0x00	; 0
    1a2a:	24 e6       	ldi	r18, 0x64	; 100
    1a2c:	30 e0       	ldi	r19, 0x00	; 0
    1a2e:	f9 01       	movw	r30, r18
    1a30:	20 81       	ld	r18, Z
    1a32:	2d 6f       	ori	r18, 0xFD	; 253
    1a34:	fc 01       	movw	r30, r24
    1a36:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    1a38:	8a e2       	ldi	r24, 0x2A	; 42
    1a3a:	90 e0       	ldi	r25, 0x00	; 0
    1a3c:	2a e2       	ldi	r18, 0x2A	; 42
    1a3e:	30 e0       	ldi	r19, 0x00	; 0
    1a40:	f9 01       	movw	r30, r18
    1a42:	20 81       	ld	r18, Z
    1a44:	20 68       	ori	r18, 0x80	; 128
    1a46:	fc 01       	movw	r30, r24
    1a48:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    1a4a:	87 e2       	ldi	r24, 0x27	; 39
    1a4c:	90 e0       	ldi	r25, 0x00	; 0
    1a4e:	27 e2       	ldi	r18, 0x27	; 39
    1a50:	30 e0       	ldi	r19, 0x00	; 0
    1a52:	f9 01       	movw	r30, r18
    1a54:	20 81       	ld	r18, Z
    1a56:	24 60       	ori	r18, 0x04	; 4
    1a58:	fc 01       	movw	r30, r24
    1a5a:	20 83       	st	Z, r18
	prtSLEEPled &= ~(1 << bnSLEEPled);	//turn off initially
    1a5c:	8b e2       	ldi	r24, 0x2B	; 43
    1a5e:	90 e0       	ldi	r25, 0x00	; 0
    1a60:	2b e2       	ldi	r18, 0x2B	; 43
    1a62:	30 e0       	ldi	r19, 0x00	; 0
    1a64:	f9 01       	movw	r30, r18
    1a66:	20 81       	ld	r18, Z
    1a68:	2f 77       	andi	r18, 0x7F	; 127
    1a6a:	fc 01       	movw	r30, r24
    1a6c:	20 83       	st	Z, r18
	prtSTATUSled |= (1 << bnSTATUSled);	//turn on initially
    1a6e:	88 e2       	ldi	r24, 0x28	; 40
    1a70:	90 e0       	ldi	r25, 0x00	; 0
    1a72:	28 e2       	ldi	r18, 0x28	; 40
    1a74:	30 e0       	ldi	r19, 0x00	; 0
    1a76:	f9 01       	movw	r30, r18
    1a78:	20 81       	ld	r18, Z
    1a7a:	24 60       	ori	r18, 0x04	; 4
    1a7c:	fc 01       	movw	r30, r24
    1a7e:	20 83       	st	Z, r18
	
	//Enable BB and GAVR alert pins...outputs, no pull by default.
	ddrBBleds |= (1 << bnBBint)|(1 << bnBBtemp);
    1a80:	81 e2       	ldi	r24, 0x21	; 33
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	21 e2       	ldi	r18, 0x21	; 33
    1a86:	30 e0       	ldi	r19, 0x00	; 0
    1a88:	f9 01       	movw	r30, r18
    1a8a:	20 81       	ld	r18, Z
    1a8c:	26 60       	ori	r18, 0x06	; 6
    1a8e:	fc 01       	movw	r30, r24
    1a90:	20 83       	st	Z, r18
	ddrGAVRleds |= (1 << bnGAVRint)|(1 << bnGAVRtemp);
    1a92:	81 e2       	ldi	r24, 0x21	; 33
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	21 e2       	ldi	r18, 0x21	; 33
    1a98:	30 e0       	ldi	r19, 0x00	; 0
    1a9a:	f9 01       	movw	r30, r18
    1a9c:	20 81       	ld	r18, Z
    1a9e:	28 61       	ori	r18, 0x18	; 24
    1aa0:	fc 01       	movw	r30, r24
    1aa2:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrGAVRINT |= (1 << bnGAVRINT);
    1aa4:	84 e2       	ldi	r24, 0x24	; 36
    1aa6:	90 e0       	ldi	r25, 0x00	; 0
    1aa8:	24 e2       	ldi	r18, 0x24	; 36
    1aaa:	30 e0       	ldi	r19, 0x00	; 0
    1aac:	f9 01       	movw	r30, r18
    1aae:	20 81       	ld	r18, Z
    1ab0:	28 60       	ori	r18, 0x08	; 8
    1ab2:	fc 01       	movw	r30, r24
    1ab4:	20 83       	st	Z, r18
	prtGAVRINT &=  ~(1 << bnGAVRINT);	//set low at first
    1ab6:	85 e2       	ldi	r24, 0x25	; 37
    1ab8:	90 e0       	ldi	r25, 0x00	; 0
    1aba:	25 e2       	ldi	r18, 0x25	; 37
    1abc:	30 e0       	ldi	r19, 0x00	; 0
    1abe:	f9 01       	movw	r30, r18
    1ac0:	20 81       	ld	r18, Z
    1ac2:	27 7f       	andi	r18, 0xF7	; 247
    1ac4:	fc 01       	movw	r30, r24
    1ac6:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen);
    1ac8:	81 e2       	ldi	r24, 0x21	; 33
    1aca:	90 e0       	ldi	r25, 0x00	; 0
    1acc:	21 e2       	ldi	r18, 0x21	; 33
    1ace:	30 e0       	ldi	r19, 0x00	; 0
    1ad0:	f9 01       	movw	r30, r18
    1ad2:	20 81       	ld	r18, Z
    1ad4:	20 6e       	ori	r18, 0xE0	; 224
    1ad6:	fc 01       	movw	r30, r24
    1ad8:	20 83       	st	Z, r18
	ddrBBen |= (1 << bnBBen);
    1ada:	84 e2       	ldi	r24, 0x24	; 36
    1adc:	90 e0       	ldi	r25, 0x00	; 0
    1ade:	24 e2       	ldi	r18, 0x24	; 36
    1ae0:	30 e0       	ldi	r19, 0x00	; 0
    1ae2:	f9 01       	movw	r30, r18
    1ae4:	20 81       	ld	r18, Z
    1ae6:	21 60       	ori	r18, 0x01	; 1
    1ae8:	fc 01       	movw	r30, r24
    1aea:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    1aec:	84 e2       	ldi	r24, 0x24	; 36
    1aee:	90 e0       	ldi	r25, 0x00	; 0
    1af0:	24 e2       	ldi	r18, 0x24	; 36
    1af2:	30 e0       	ldi	r19, 0x00	; 0
    1af4:	f9 01       	movw	r30, r18
    1af6:	20 81       	ld	r18, Z
    1af8:	22 60       	ori	r18, 0x02	; 2
    1afa:	fc 01       	movw	r30, r24
    1afc:	20 83       	st	Z, r18
	prtTEMPen |= (1 << bnTEMPen);
    1afe:	85 e2       	ldi	r24, 0x25	; 37
    1b00:	90 e0       	ldi	r25, 0x00	; 0
    1b02:	25 e2       	ldi	r18, 0x25	; 37
    1b04:	30 e0       	ldi	r19, 0x00	; 0
    1b06:	f9 01       	movw	r30, r18
    1b08:	20 81       	ld	r18, Z
    1b0a:	22 60       	ori	r18, 0x02	; 2
    1b0c:	fc 01       	movw	r30, r24
    1b0e:	20 83       	st	Z, r18
	

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    1b10:	89 e6       	ldi	r24, 0x69	; 105
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	20 e3       	ldi	r18, 0x30	; 48
    1b16:	fc 01       	movw	r30, r24
    1b18:	20 83       	st	Z, r18
	EIMSK = (1 << INT2);			//enable INT2 global interrupt
    1b1a:	8d e3       	ldi	r24, 0x3D	; 61
    1b1c:	90 e0       	ldi	r25, 0x00	; 0
    1b1e:	24 e0       	ldi	r18, 0x04	; 4
    1b20:	fc 01       	movw	r30, r24
    1b22:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    1b24:	84 e2       	ldi	r24, 0x24	; 36
    1b26:	90 e0       	ldi	r25, 0x00	; 0
    1b28:	24 e2       	ldi	r18, 0x24	; 36
    1b2a:	30 e0       	ldi	r19, 0x00	; 0
    1b2c:	f9 01       	movw	r30, r18
    1b2e:	20 81       	ld	r18, Z
    1b30:	20 6b       	ori	r18, 0xB0	; 176
    1b32:	fc 01       	movw	r30, r24
    1b34:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    1b36:	84 e2       	ldi	r24, 0x24	; 36
    1b38:	90 e0       	ldi	r25, 0x00	; 0
    1b3a:	24 e2       	ldi	r18, 0x24	; 36
    1b3c:	30 e0       	ldi	r19, 0x00	; 0
    1b3e:	f9 01       	movw	r30, r18
    1b40:	20 81       	ld	r18, Z
    1b42:	2f 7b       	andi	r18, 0xBF	; 191
    1b44:	fc 01       	movw	r30, r24
    1b46:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    1b48:	85 e2       	ldi	r24, 0x25	; 37
    1b4a:	90 e0       	ldi	r25, 0x00	; 0
    1b4c:	25 e2       	ldi	r18, 0x25	; 37
    1b4e:	30 e0       	ldi	r19, 0x00	; 0
    1b50:	f9 01       	movw	r30, r18
    1b52:	20 81       	ld	r18, Z
    1b54:	20 69       	ori	r18, 0x90	; 144
    1b56:	fc 01       	movw	r30, r24
    1b58:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    1b5a:	85 e2       	ldi	r24, 0x25	; 37
    1b5c:	90 e0       	ldi	r25, 0x00	; 0
    1b5e:	25 e2       	ldi	r18, 0x25	; 37
    1b60:	30 e0       	ldi	r19, 0x00	; 0
    1b62:	f9 01       	movw	r30, r18
    1b64:	20 81       	ld	r18, Z
    1b66:	2f 7d       	andi	r18, 0xDF	; 223
    1b68:	fc 01       	movw	r30, r24
    1b6a:	20 83       	st	Z, r18
	
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    1b6c:	81 e0       	ldi	r24, 0x01	; 1
    1b6e:	80 93 72 01 	sts	0x0172, r24
	flagShutdown  = fFalse;
    1b72:	10 92 7c 01 	sts	0x017C, r1
	flagUARTbone = fFalse;
    1b76:	10 92 73 01 	sts	0x0173, r1
	flagNormalMode=fTrue;
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	80 93 74 01 	sts	0x0174, r24
	restart=fFalse;
    1b80:	10 92 7f 01 	sts	0x017F, r1
	flagNewShutdown=fFalse;
    1b84:	10 92 7b 01 	sts	0x017B, r1
	flagSendingGAVR=fFalse;
    1b88:	10 92 7a 01 	sts	0x017A, r1
	noTimeout=fTrue;
    1b8c:	81 e0       	ldi	r24, 0x01	; 1
    1b8e:	80 93 79 01 	sts	0x0179, r24
}
    1b92:	0f 90       	pop	r0
    1b94:	0f 90       	pop	r0
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	08 95       	ret

00001b9c <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    1b9c:	cf 93       	push	r28
    1b9e:	df 93       	push	r29
    1ba0:	cd b7       	in	r28, 0x3d	; 61
    1ba2:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    1ba4:	84 e6       	ldi	r24, 0x64	; 100
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	24 e6       	ldi	r18, 0x64	; 100
    1baa:	30 e0       	ldi	r19, 0x00	; 0
    1bac:	f9 01       	movw	r30, r18
    1bae:	20 81       	ld	r18, Z
    1bb0:	2f 7b       	andi	r18, 0xBF	; 191
    1bb2:	fc 01       	movw	r30, r24
    1bb4:	20 83       	st	Z, r18
	Wait_ms(1);	//give it time to power on
    1bb6:	81 e0       	ldi	r24, 0x01	; 1
    1bb8:	90 e0       	ldi	r25, 0x00	; 0
    1bba:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    1bbe:	86 eb       	ldi	r24, 0xB6	; 182
    1bc0:	90 e0       	ldi	r25, 0x00	; 0
    1bc2:	26 eb       	ldi	r18, 0xB6	; 182
    1bc4:	30 e0       	ldi	r19, 0x00	; 0
    1bc6:	f9 01       	movw	r30, r18
    1bc8:	20 81       	ld	r18, Z
    1bca:	20 62       	ori	r18, 0x20	; 32
    1bcc:	fc 01       	movw	r30, r24
    1bce:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    1bd0:	81 eb       	ldi	r24, 0xB1	; 177
    1bd2:	90 e0       	ldi	r25, 0x00	; 0
    1bd4:	21 eb       	ldi	r18, 0xB1	; 177
    1bd6:	30 e0       	ldi	r19, 0x00	; 0
    1bd8:	f9 01       	movw	r30, r18
    1bda:	20 81       	ld	r18, Z
    1bdc:	25 60       	ori	r18, 0x05	; 5
    1bde:	fc 01       	movw	r30, r24
    1be0:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    1be2:	86 eb       	ldi	r24, 0xB6	; 182
    1be4:	90 e0       	ldi	r25, 0x00	; 0
    1be6:	fc 01       	movw	r30, r24
    1be8:	80 81       	ld	r24, Z
    1bea:	88 2f       	mov	r24, r24
    1bec:	90 e0       	ldi	r25, 0x00	; 0
    1bee:	81 71       	andi	r24, 0x11	; 17
    1bf0:	90 70       	andi	r25, 0x00	; 0
    1bf2:	21 e0       	ldi	r18, 0x01	; 1
    1bf4:	00 97       	sbiw	r24, 0x00	; 0
    1bf6:	09 f4       	brne	.+2      	; 0x1bfa <_Z14EnableRTCTimerv+0x5e>
    1bf8:	20 e0       	ldi	r18, 0x00	; 0
    1bfa:	22 23       	and	r18, r18
    1bfc:	91 f7       	brne	.-28     	; 0x1be2 <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    1bfe:	87 e3       	ldi	r24, 0x37	; 55
    1c00:	90 e0       	ldi	r25, 0x00	; 0
    1c02:	21 e0       	ldi	r18, 0x01	; 1
    1c04:	fc 01       	movw	r30, r24
    1c06:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    1c08:	80 e7       	ldi	r24, 0x70	; 112
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	21 e0       	ldi	r18, 0x01	; 1
    1c0e:	fc 01       	movw	r30, r24
    1c10:	20 83       	st	Z, r18
	
	//Away we go
}
    1c12:	df 91       	pop	r29
    1c14:	cf 91       	pop	r28
    1c16:	08 95       	ret

00001c18 <_Z7Wait_msi>:
/*************************************************************************************************************/
void Wait_ms(volatile int delay)
{
    1c18:	cf 93       	push	r28
    1c1a:	df 93       	push	r29
    1c1c:	00 d0       	rcall	.+0      	; 0x1c1e <_Z7Wait_msi+0x6>
    1c1e:	00 d0       	rcall	.+0      	; 0x1c20 <_Z7Wait_msi+0x8>
    1c20:	cd b7       	in	r28, 0x3d	; 61
    1c22:	de b7       	in	r29, 0x3e	; 62
    1c24:	9c 83       	std	Y+4, r25	; 0x04
    1c26:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    1c28:	18 c0       	rjmp	.+48     	; 0x1c5a <_Z7Wait_msi+0x42>
		for(i = 0; i < 800; i++){
    1c2a:	1a 82       	std	Y+2, r1	; 0x02
    1c2c:	19 82       	std	Y+1, r1	; 0x01
    1c2e:	06 c0       	rjmp	.+12     	; 0x1c3c <_Z7Wait_msi+0x24>
			asm volatile("nop");
    1c30:	00 00       	nop
void Wait_ms(volatile int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 800; i++){
    1c32:	89 81       	ldd	r24, Y+1	; 0x01
    1c34:	9a 81       	ldd	r25, Y+2	; 0x02
    1c36:	01 96       	adiw	r24, 0x01	; 1
    1c38:	9a 83       	std	Y+2, r25	; 0x02
    1c3a:	89 83       	std	Y+1, r24	; 0x01
    1c3c:	89 81       	ldd	r24, Y+1	; 0x01
    1c3e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c40:	21 e0       	ldi	r18, 0x01	; 1
    1c42:	33 e0       	ldi	r19, 0x03	; 3
    1c44:	80 32       	cpi	r24, 0x20	; 32
    1c46:	93 07       	cpc	r25, r19
    1c48:	0c f0       	brlt	.+2      	; 0x1c4c <_Z7Wait_msi+0x34>
    1c4a:	20 e0       	ldi	r18, 0x00	; 0
    1c4c:	22 23       	and	r18, r18
    1c4e:	81 f7       	brne	.-32     	; 0x1c30 <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    1c50:	8b 81       	ldd	r24, Y+3	; 0x03
    1c52:	9c 81       	ldd	r25, Y+4	; 0x04
    1c54:	01 97       	sbiw	r24, 0x01	; 1
    1c56:	9c 83       	std	Y+4, r25	; 0x04
    1c58:	8b 83       	std	Y+3, r24	; 0x03
/*************************************************************************************************************/
void Wait_ms(volatile int delay)
{
	volatile int i;

	while(delay > 0){
    1c5a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c5c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c5e:	21 e0       	ldi	r18, 0x01	; 1
    1c60:	18 16       	cp	r1, r24
    1c62:	19 06       	cpc	r1, r25
    1c64:	0c f0       	brlt	.+2      	; 0x1c68 <_Z7Wait_msi+0x50>
    1c66:	20 e0       	ldi	r18, 0x00	; 0
    1c68:	22 23       	and	r18, r18
    1c6a:	f9 f6       	brne	.-66     	; 0x1c2a <_Z7Wait_msi+0x12>
		for(i = 0; i < 800; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    1c6c:	0f 90       	pop	r0
    1c6e:	0f 90       	pop	r0
    1c70:	0f 90       	pop	r0
    1c72:	0f 90       	pop	r0
    1c74:	df 91       	pop	r29
    1c76:	cf 91       	pop	r28
    1c78:	08 95       	ret

00001c7a <_Z8Wait_seci>:
/*************************************************************************************************************/
void Wait_sec(volatile int sec){
    1c7a:	cf 93       	push	r28
    1c7c:	df 93       	push	r29
    1c7e:	00 d0       	rcall	.+0      	; 0x1c80 <_Z8Wait_seci+0x6>
    1c80:	00 d0       	rcall	.+0      	; 0x1c82 <_Z8Wait_seci+0x8>
    1c82:	00 d0       	rcall	.+0      	; 0x1c84 <_Z8Wait_seci+0xa>
    1c84:	cd b7       	in	r28, 0x3d	; 61
    1c86:	de b7       	in	r29, 0x3e	; 62
    1c88:	9e 83       	std	Y+6, r25	; 0x06
    1c8a:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    1c8c:	85 e8       	ldi	r24, 0x85	; 133
    1c8e:	91 e0       	ldi	r25, 0x01	; 1
    1c90:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTime10getSecondsEv>
    1c94:	88 2f       	mov	r24, r24
    1c96:	90 e0       	ldi	r25, 0x00	; 0
    1c98:	9a 83       	std	Y+2, r25	; 0x02
    1c9a:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    1c9c:	29 81       	ldd	r18, Y+1	; 0x01
    1c9e:	3a 81       	ldd	r19, Y+2	; 0x02
    1ca0:	8d 81       	ldd	r24, Y+5	; 0x05
    1ca2:	9e 81       	ldd	r25, Y+6	; 0x06
    1ca4:	82 0f       	add	r24, r18
    1ca6:	93 1f       	adc	r25, r19
    1ca8:	2c e3       	ldi	r18, 0x3C	; 60
    1caa:	30 e0       	ldi	r19, 0x00	; 0
    1cac:	b9 01       	movw	r22, r18
    1cae:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
    1cb2:	9c 83       	std	Y+4, r25	; 0x04
    1cb4:	8b 83       	std	Y+3, r24	; 0x03
	while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    1cb6:	01 c0       	rjmp	.+2      	; 0x1cba <_Z8Wait_seci+0x40>
    1cb8:	00 00       	nop
    1cba:	85 e8       	ldi	r24, 0x85	; 133
    1cbc:	91 e0       	ldi	r25, 0x01	; 1
    1cbe:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTime10getSecondsEv>
    1cc2:	28 2f       	mov	r18, r24
    1cc4:	30 e0       	ldi	r19, 0x00	; 0
    1cc6:	8b 81       	ldd	r24, Y+3	; 0x03
    1cc8:	9c 81       	ldd	r25, Y+4	; 0x04
    1cca:	41 e0       	ldi	r20, 0x01	; 1
    1ccc:	28 17       	cp	r18, r24
    1cce:	39 07       	cpc	r19, r25
    1cd0:	09 f4       	brne	.+2      	; 0x1cd4 <_Z8Wait_seci+0x5a>
    1cd2:	40 e0       	ldi	r20, 0x00	; 0
    1cd4:	44 23       	and	r20, r20
    1cd6:	81 f7       	brne	.-32     	; 0x1cb8 <_Z8Wait_seci+0x3e>
}
    1cd8:	26 96       	adiw	r28, 0x06	; 6
    1cda:	0f b6       	in	r0, 0x3f	; 63
    1cdc:	f8 94       	cli
    1cde:	de bf       	out	0x3e, r29	; 62
    1ce0:	0f be       	out	0x3f, r0	; 63
    1ce2:	cd bf       	out	0x3d, r28	; 61
    1ce4:	df 91       	pop	r29
    1ce6:	cf 91       	pop	r28
    1ce8:	08 95       	ret

00001cea <_Z11ReceiveBonev>:

/*************************************************************************************************************/
void ReceiveBone(){
    1cea:	cf 93       	push	r28
    1cec:	df 93       	push	r29
    1cee:	cd b7       	in	r28, 0x3d	; 61
    1cf0:	de b7       	in	r29, 0x3e	; 62
    1cf2:	a7 97       	sbiw	r28, 0x27	; 39
    1cf4:	0f b6       	in	r0, 0x3f	; 63
    1cf6:	f8 94       	cli
    1cf8:	de bf       	out	0x3e, r29	; 62
    1cfa:	0f be       	out	0x3f, r0	; 63
    1cfc:	cd bf       	out	0x3d, r28	; 61
	//Declare variables
	BOOL noCarriage = fTrue;
    1cfe:	81 e0       	ldi	r24, 0x01	; 1
    1d00:	89 83       	std	Y+1, r24	; 0x01
	char recString[20];
	char recChar;
	volatile int strLoc = 0;
    1d02:	19 8e       	std	Y+25, r1	; 0x19
    1d04:	18 8e       	std	Y+24, r1	; 0x18
	
	recChar = UDR0;
    1d06:	86 ec       	ldi	r24, 0xC6	; 198
    1d08:	90 e0       	ldi	r25, 0x00	; 0
    1d0a:	fc 01       	movw	r30, r24
    1d0c:	80 81       	ld	r24, Z
    1d0e:	8a 83       	std	Y+2, r24	; 0x02
	if (recChar=='.'){
    1d10:	8a 81       	ldd	r24, Y+2	; 0x02
    1d12:	8e 32       	cpi	r24, 0x2E	; 46
    1d14:	29 f4       	brne	.+10     	; 0x1d20 <_Z11ReceiveBonev+0x36>
		PutUartChBone(recChar);
    1d16:	8a 81       	ldd	r24, Y+2	; 0x02
    1d18:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <_Z13PutUartChBonec>
		noCarriage=fFalse;
    1d1c:	19 82       	std	Y+1, r1	; 0x01
	} else {
		recString[strLoc]=recChar;
		strLoc++;
	}
	while (noCarriage && flagUARTbone){ //flag goes down if a timeout occurs.
    1d1e:	d0 c1       	rjmp	.+928    	; 0x20c0 <_Z11ReceiveBonev+0x3d6>
	recChar = UDR0;
	if (recChar=='.'){
		PutUartChBone(recChar);
		noCarriage=fFalse;
	} else {
		recString[strLoc]=recChar;
    1d20:	88 8d       	ldd	r24, Y+24	; 0x18
    1d22:	99 8d       	ldd	r25, Y+25	; 0x19
    1d24:	9e 01       	movw	r18, r28
    1d26:	2c 5f       	subi	r18, 0xFC	; 252
    1d28:	3f 4f       	sbci	r19, 0xFF	; 255
    1d2a:	82 0f       	add	r24, r18
    1d2c:	93 1f       	adc	r25, r19
    1d2e:	2a 81       	ldd	r18, Y+2	; 0x02
    1d30:	fc 01       	movw	r30, r24
    1d32:	20 83       	st	Z, r18
		strLoc++;
    1d34:	88 8d       	ldd	r24, Y+24	; 0x18
    1d36:	99 8d       	ldd	r25, Y+25	; 0x19
    1d38:	01 96       	adiw	r24, 0x01	; 1
    1d3a:	99 8f       	std	Y+25, r25	; 0x19
    1d3c:	88 8f       	std	Y+24, r24	; 0x18
	}
	while (noCarriage && flagUARTbone){ //flag goes down if a timeout occurs.
    1d3e:	c0 c1       	rjmp	.+896    	; 0x20c0 <_Z11ReceiveBonev+0x3d6>
		recChar=UDR0; //dump, don't needit. wait for nextone
    1d40:	86 ec       	ldi	r24, 0xC6	; 198
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	fc 01       	movw	r30, r24
    1d46:	80 81       	ld	r24, Z
    1d48:	8a 83       	std	Y+2, r24	; 0x02
		while (!(UCSR0A & (1 << RXC0)) && flagUARTbone);
    1d4a:	00 00       	nop
    1d4c:	80 ec       	ldi	r24, 0xC0	; 192
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	fc 01       	movw	r30, r24
    1d52:	80 81       	ld	r24, Z
    1d54:	88 23       	and	r24, r24
    1d56:	34 f0       	brlt	.+12     	; 0x1d64 <_Z11ReceiveBonev+0x7a>
    1d58:	80 91 73 01 	lds	r24, 0x0173
    1d5c:	88 23       	and	r24, r24
    1d5e:	11 f0       	breq	.+4      	; 0x1d64 <_Z11ReceiveBonev+0x7a>
    1d60:	81 e0       	ldi	r24, 0x01	; 1
    1d62:	01 c0       	rjmp	.+2      	; 0x1d66 <_Z11ReceiveBonev+0x7c>
    1d64:	80 e0       	ldi	r24, 0x00	; 0
    1d66:	88 23       	and	r24, r24
    1d68:	89 f7       	brne	.-30     	; 0x1d4c <_Z11ReceiveBonev+0x62>
		recChar = UDR0;
    1d6a:	86 ec       	ldi	r24, 0xC6	; 198
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	fc 01       	movw	r30, r24
    1d70:	80 81       	ld	r24, Z
    1d72:	8a 83       	std	Y+2, r24	; 0x02
		//Put string together. Carriage return is dunzo.
		if (recChar == '.'){
    1d74:	8a 81       	ldd	r24, Y+2	; 0x02
    1d76:	8e 32       	cpi	r24, 0x2E	; 46
    1d78:	09 f0       	breq	.+2      	; 0x1d7c <_Z11ReceiveBonev+0x92>
    1d7a:	85 c1       	rjmp	.+778    	; 0x2086 <_Z11ReceiveBonev+0x39c>
			recString[strLoc] = '\0';
    1d7c:	88 8d       	ldd	r24, Y+24	; 0x18
    1d7e:	99 8d       	ldd	r25, Y+25	; 0x19
    1d80:	9e 01       	movw	r18, r28
    1d82:	2c 5f       	subi	r18, 0xFC	; 252
    1d84:	3f 4f       	sbci	r19, 0xFF	; 255
    1d86:	82 0f       	add	r24, r18
    1d88:	93 1f       	adc	r25, r19
    1d8a:	fc 01       	movw	r30, r24
    1d8c:	10 82       	st	Z, r1
			//See what it's asking for
			if (!strcmp(recString,"date")){printTimeDate(fTrue,fFalse,fTrue);}
    1d8e:	ce 01       	movw	r24, r28
    1d90:	04 96       	adiw	r24, 0x04	; 4
    1d92:	27 e2       	ldi	r18, 0x27	; 39
    1d94:	31 e0       	ldi	r19, 0x01	; 1
    1d96:	b9 01       	movw	r22, r18
    1d98:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1d9c:	00 97       	sbiw	r24, 0x00	; 0
    1d9e:	31 f4       	brne	.+12     	; 0x1dac <_Z11ReceiveBonev+0xc2>
    1da0:	81 e0       	ldi	r24, 0x01	; 1
    1da2:	60 e0       	ldi	r22, 0x00	; 0
    1da4:	41 e0       	ldi	r20, 0x01	; 1
    1da6:	0e 94 cc 09 	call	0x1398	; 0x1398 <_Z13printTimeDatehhh>
    1daa:	6b c1       	rjmp	.+726    	; 0x2082 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"time")){printTimeDate(fTrue,fTrue,fFalse);}
    1dac:	ce 01       	movw	r24, r28
    1dae:	04 96       	adiw	r24, 0x04	; 4
    1db0:	2c e2       	ldi	r18, 0x2C	; 44
    1db2:	31 e0       	ldi	r19, 0x01	; 1
    1db4:	b9 01       	movw	r22, r18
    1db6:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1dba:	00 97       	sbiw	r24, 0x00	; 0
    1dbc:	31 f4       	brne	.+12     	; 0x1dca <_Z11ReceiveBonev+0xe0>
    1dbe:	81 e0       	ldi	r24, 0x01	; 1
    1dc0:	61 e0       	ldi	r22, 0x01	; 1
    1dc2:	40 e0       	ldi	r20, 0x00	; 0
    1dc4:	0e 94 cc 09 	call	0x1398	; 0x1398 <_Z13printTimeDatehhh>
    1dc8:	5c c1       	rjmp	.+696    	; 0x2082 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"both")){printTimeDate(fTrue,fTrue,fTrue);}
    1dca:	ce 01       	movw	r24, r28
    1dcc:	04 96       	adiw	r24, 0x04	; 4
    1dce:	21 e3       	ldi	r18, 0x31	; 49
    1dd0:	31 e0       	ldi	r19, 0x01	; 1
    1dd2:	b9 01       	movw	r22, r18
    1dd4:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1dd8:	00 97       	sbiw	r24, 0x00	; 0
    1dda:	31 f4       	brne	.+12     	; 0x1de8 <_Z11ReceiveBonev+0xfe>
    1ddc:	81 e0       	ldi	r24, 0x01	; 1
    1dde:	61 e0       	ldi	r22, 0x01	; 1
    1de0:	41 e0       	ldi	r20, 0x01	; 1
    1de2:	0e 94 cc 09 	call	0x1398	; 0x1398 <_Z13printTimeDatehhh>
    1de6:	4d c1       	rjmp	.+666    	; 0x2082 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"save")){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);}
    1de8:	ce 01       	movw	r24, r28
    1dea:	04 96       	adiw	r24, 0x04	; 4
    1dec:	26 e3       	ldi	r18, 0x36	; 54
    1dee:	31 e0       	ldi	r19, 0x01	; 1
    1df0:	b9 01       	movw	r22, r18
    1df2:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1df6:	00 97       	sbiw	r24, 0x00	; 0
    1df8:	49 f4       	brne	.+18     	; 0x1e0c <_Z11ReceiveBonev+0x122>
    1dfa:	81 e0       	ldi	r24, 0x01	; 1
    1dfc:	60 e0       	ldi	r22, 0x00	; 0
    1dfe:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1e02:	ce 01       	movw	r24, r28
    1e04:	04 96       	adiw	r24, 0x04	; 4
    1e06:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    1e0a:	3b c1       	rjmp	.+630    	; 0x2082 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"adc")){char tempChar[7]; itoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);}
    1e0c:	ce 01       	movw	r24, r28
    1e0e:	04 96       	adiw	r24, 0x04	; 4
    1e10:	2b e3       	ldi	r18, 0x3B	; 59
    1e12:	31 e0       	ldi	r19, 0x01	; 1
    1e14:	b9 01       	movw	r22, r18
    1e16:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1e1a:	00 97       	sbiw	r24, 0x00	; 0
    1e1c:	91 f4       	brne	.+36     	; 0x1e42 <_Z11ReceiveBonev+0x158>
    1e1e:	80 91 81 01 	lds	r24, 0x0181
    1e22:	90 91 82 01 	lds	r25, 0x0182
    1e26:	9e 01       	movw	r18, r28
    1e28:	26 5e       	subi	r18, 0xE6	; 230
    1e2a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e2c:	b9 01       	movw	r22, r18
    1e2e:	4a e0       	ldi	r20, 0x0A	; 10
    1e30:	50 e0       	ldi	r21, 0x00	; 0
    1e32:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <itoa>
    1e36:	18 a2       	lds	r17, 0x98
    1e38:	ce 01       	movw	r24, r28
    1e3a:	4a 96       	adiw	r24, 0x1a	; 26
    1e3c:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    1e40:	20 c1       	rjmp	.+576    	; 0x2082 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"temp")){char tempChar[7]; itoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);}
    1e42:	ce 01       	movw	r24, r28
    1e44:	04 96       	adiw	r24, 0x04	; 4
    1e46:	2f e3       	ldi	r18, 0x3F	; 63
    1e48:	31 e0       	ldi	r19, 0x01	; 1
    1e4a:	b9 01       	movw	r22, r18
    1e4c:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1e50:	00 97       	sbiw	r24, 0x00	; 0
    1e52:	91 f4       	brne	.+36     	; 0x1e78 <_Z11ReceiveBonev+0x18e>
    1e54:	80 91 83 01 	lds	r24, 0x0183
    1e58:	90 91 84 01 	lds	r25, 0x0184
    1e5c:	9e 01       	movw	r18, r28
    1e5e:	2f 5d       	subi	r18, 0xDF	; 223
    1e60:	3f 4f       	sbci	r19, 0xFF	; 255
    1e62:	b9 01       	movw	r22, r18
    1e64:	4a e0       	ldi	r20, 0x0A	; 10
    1e66:	50 e0       	ldi	r21, 0x00	; 0
    1e68:	0e 94 64 15 	call	0x2ac8	; 0x2ac8 <itoa>
    1e6c:	1f a2       	lds	r17, 0x9f
    1e6e:	ce 01       	movw	r24, r28
    1e70:	81 96       	adiw	r24, 0x21	; 33
    1e72:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    1e76:	05 c1       	rjmp	.+522    	; 0x2082 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"NONE") && (restart || flagFreshStart)){ //If we are starting up again, we need to alert GAVR and clear the flags
    1e78:	ce 01       	movw	r24, r28
    1e7a:	04 96       	adiw	r24, 0x04	; 4
    1e7c:	24 e4       	ldi	r18, 0x44	; 68
    1e7e:	31 e0       	ldi	r19, 0x01	; 1
    1e80:	b9 01       	movw	r22, r18
    1e82:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    1e86:	00 97       	sbiw	r24, 0x00	; 0
    1e88:	51 f4       	brne	.+20     	; 0x1e9e <_Z11ReceiveBonev+0x1b4>
    1e8a:	80 91 7f 01 	lds	r24, 0x017F
    1e8e:	88 23       	and	r24, r24
    1e90:	21 f4       	brne	.+8      	; 0x1e9a <_Z11ReceiveBonev+0x1b0>
    1e92:	80 91 80 01 	lds	r24, 0x0180
    1e96:	88 23       	and	r24, r24
    1e98:	11 f0       	breq	.+4      	; 0x1e9e <_Z11ReceiveBonev+0x1b4>
    1e9a:	81 e0       	ldi	r24, 0x01	; 1
    1e9c:	01 c0       	rjmp	.+2      	; 0x1ea0 <_Z11ReceiveBonev+0x1b6>
    1e9e:	80 e0       	ldi	r24, 0x00	; 0
    1ea0:	88 23       	and	r24, r24
    1ea2:	f9 f0       	breq	.+62     	; 0x1ee2 <_Z11ReceiveBonev+0x1f8>
				PrintBone("ACKNONE");
    1ea4:	89 e4       	ldi	r24, 0x49	; 73
    1ea6:	91 e0       	ldi	r25, 0x01	; 1
    1ea8:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
				if (flagFreshStart){flagFreshStart=fFalse;}
    1eac:	90 91 80 01 	lds	r25, 0x0180
    1eb0:	81 e0       	ldi	r24, 0x01	; 1
    1eb2:	99 23       	and	r25, r25
    1eb4:	09 f4       	brne	.+2      	; 0x1eb8 <_Z11ReceiveBonev+0x1ce>
    1eb6:	80 e0       	ldi	r24, 0x00	; 0
    1eb8:	88 23       	and	r24, r24
    1eba:	11 f0       	breq	.+4      	; 0x1ec0 <_Z11ReceiveBonev+0x1d6>
    1ebc:	10 92 80 01 	sts	0x0180, r1
				if (restart){restart=fFalse;}
    1ec0:	90 91 7f 01 	lds	r25, 0x017F
    1ec4:	81 e0       	ldi	r24, 0x01	; 1
    1ec6:	99 23       	and	r25, r25
    1ec8:	09 f4       	brne	.+2      	; 0x1ecc <_Z11ReceiveBonev+0x1e2>
    1eca:	80 e0       	ldi	r24, 0x00	; 0
    1ecc:	88 23       	and	r24, r24
    1ece:	11 f0       	breq	.+4      	; 0x1ed4 <_Z11ReceiveBonev+0x1ea>
    1ed0:	10 92 7f 01 	sts	0x017F, r1
				flagUserTime=fTrue;
    1ed4:	81 e0       	ldi	r24, 0x01	; 1
    1ed6:	80 93 75 01 	sts	0x0175, r24
				flagUserDate=fTrue;
    1eda:	81 e0       	ldi	r24, 0x01	; 1
    1edc:	80 93 76 01 	sts	0x0176, r24
    1ee0:	d0 c0       	rjmp	.+416    	; 0x2082 <_Z11ReceiveBonev+0x398>
			} else if (recString[2] == ':'){//valid string. Update the time anyways. Comes in every 20 minutes or so...
    1ee2:	8e 81       	ldd	r24, Y+6	; 0x06
    1ee4:	8a 33       	cpi	r24, 0x3A	; 58
    1ee6:	09 f0       	breq	.+2      	; 0x1eea <_Z11ReceiveBonev+0x200>
    1ee8:	c4 c0       	rjmp	.+392    	; 0x2072 <_Z11ReceiveBonev+0x388>
				cli();
    1eea:	f8 94       	cli
				BOOL success=currentTime.setTime(recString);
    1eec:	85 e8       	ldi	r24, 0x85	; 133
    1eee:	91 e0       	ldi	r25, 0x01	; 1
    1ef0:	9e 01       	movw	r18, r28
    1ef2:	2c 5f       	subi	r18, 0xFC	; 252
    1ef4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ef6:	b9 01       	movw	r22, r18
    1ef8:	0e 94 48 04 	call	0x890	; 0x890 <_ZN6myTime7setTimeEPc>
    1efc:	8b 83       	std	Y+3, r24	; 0x03
				sei();
    1efe:	78 94       	sei
				if (restart){restart=fFalse;} 
    1f00:	90 91 7f 01 	lds	r25, 0x017F
    1f04:	81 e0       	ldi	r24, 0x01	; 1
    1f06:	99 23       	and	r25, r25
    1f08:	09 f4       	brne	.+2      	; 0x1f0c <_Z11ReceiveBonev+0x222>
    1f0a:	80 e0       	ldi	r24, 0x00	; 0
    1f0c:	88 23       	and	r24, r24
    1f0e:	11 f0       	breq	.+4      	; 0x1f14 <_Z11ReceiveBonev+0x22a>
    1f10:	10 92 7f 01 	sts	0x017F, r1
				if (flagFreshStart){flagFreshStart=fFalse;}
    1f14:	90 91 80 01 	lds	r25, 0x0180
    1f18:	81 e0       	ldi	r24, 0x01	; 1
    1f1a:	99 23       	and	r25, r25
    1f1c:	09 f4       	brne	.+2      	; 0x1f20 <_Z11ReceiveBonev+0x236>
    1f1e:	80 e0       	ldi	r24, 0x00	; 0
    1f20:	88 23       	and	r24, r24
    1f22:	11 f0       	breq	.+4      	; 0x1f28 <_Z11ReceiveBonev+0x23e>
    1f24:	10 92 80 01 	sts	0x0180, r1
				PrintBone("ACK");
    1f28:	81 e5       	ldi	r24, 0x51	; 81
    1f2a:	91 e0       	ldi	r25, 0x01	; 1
    1f2c:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
				if (success && !restart && !flagFreshStart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRTime=fTrue; PrintBone(recString);}
    1f30:	8b 81       	ldd	r24, Y+3	; 0x03
    1f32:	88 23       	and	r24, r24
    1f34:	51 f0       	breq	.+20     	; 0x1f4a <_Z11ReceiveBonev+0x260>
    1f36:	80 91 7f 01 	lds	r24, 0x017F
    1f3a:	88 23       	and	r24, r24
    1f3c:	31 f4       	brne	.+12     	; 0x1f4a <_Z11ReceiveBonev+0x260>
    1f3e:	80 91 80 01 	lds	r24, 0x0180
    1f42:	88 23       	and	r24, r24
    1f44:	11 f4       	brne	.+4      	; 0x1f4a <_Z11ReceiveBonev+0x260>
    1f46:	81 e0       	ldi	r24, 0x01	; 1
    1f48:	01 c0       	rjmp	.+2      	; 0x1f4c <_Z11ReceiveBonev+0x262>
    1f4a:	80 e0       	ldi	r24, 0x00	; 0
    1f4c:	88 23       	and	r24, r24
    1f4e:	61 f0       	breq	.+24     	; 0x1f68 <_Z11ReceiveBonev+0x27e>
    1f50:	81 e0       	ldi	r24, 0x01	; 1
    1f52:	60 e0       	ldi	r22, 0x00	; 0
    1f54:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1f58:	81 e0       	ldi	r24, 0x01	; 1
    1f5a:	80 93 77 01 	sts	0x0177, r24
    1f5e:	ce 01       	movw	r24, r28
    1f60:	04 96       	adiw	r24, 0x04	; 4
    1f62:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    1f66:	70 c0       	rjmp	.+224    	; 0x2048 <_Z11ReceiveBonev+0x35e>
				else if (success && !restart && flagFreshStart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRTime=fTrue; flagUserDate=fTrue; PrintBone(recString);}
    1f68:	8b 81       	ldd	r24, Y+3	; 0x03
    1f6a:	88 23       	and	r24, r24
    1f6c:	51 f0       	breq	.+20     	; 0x1f82 <_Z11ReceiveBonev+0x298>
    1f6e:	80 91 7f 01 	lds	r24, 0x017F
    1f72:	88 23       	and	r24, r24
    1f74:	31 f4       	brne	.+12     	; 0x1f82 <_Z11ReceiveBonev+0x298>
    1f76:	80 91 80 01 	lds	r24, 0x0180
    1f7a:	88 23       	and	r24, r24
    1f7c:	11 f0       	breq	.+4      	; 0x1f82 <_Z11ReceiveBonev+0x298>
    1f7e:	81 e0       	ldi	r24, 0x01	; 1
    1f80:	01 c0       	rjmp	.+2      	; 0x1f84 <_Z11ReceiveBonev+0x29a>
    1f82:	80 e0       	ldi	r24, 0x00	; 0
    1f84:	88 23       	and	r24, r24
    1f86:	79 f0       	breq	.+30     	; 0x1fa6 <_Z11ReceiveBonev+0x2bc>
    1f88:	81 e0       	ldi	r24, 0x01	; 1
    1f8a:	60 e0       	ldi	r22, 0x00	; 0
    1f8c:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1f90:	81 e0       	ldi	r24, 0x01	; 1
    1f92:	80 93 77 01 	sts	0x0177, r24
    1f96:	81 e0       	ldi	r24, 0x01	; 1
    1f98:	80 93 76 01 	sts	0x0176, r24
    1f9c:	ce 01       	movw	r24, r28
    1f9e:	04 96       	adiw	r24, 0x04	; 4
    1fa0:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    1fa4:	51 c0       	rjmp	.+162    	; 0x2048 <_Z11ReceiveBonev+0x35e>
				else if (success && restart && !flagFreshStart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRDate=fTrue; flagUpdateGAVRTime=fTrue; PrintBone(recString);}
    1fa6:	8b 81       	ldd	r24, Y+3	; 0x03
    1fa8:	88 23       	and	r24, r24
    1faa:	51 f0       	breq	.+20     	; 0x1fc0 <_Z11ReceiveBonev+0x2d6>
    1fac:	80 91 7f 01 	lds	r24, 0x017F
    1fb0:	88 23       	and	r24, r24
    1fb2:	31 f0       	breq	.+12     	; 0x1fc0 <_Z11ReceiveBonev+0x2d6>
    1fb4:	80 91 80 01 	lds	r24, 0x0180
    1fb8:	88 23       	and	r24, r24
    1fba:	11 f4       	brne	.+4      	; 0x1fc0 <_Z11ReceiveBonev+0x2d6>
    1fbc:	81 e0       	ldi	r24, 0x01	; 1
    1fbe:	01 c0       	rjmp	.+2      	; 0x1fc2 <_Z11ReceiveBonev+0x2d8>
    1fc0:	80 e0       	ldi	r24, 0x00	; 0
    1fc2:	88 23       	and	r24, r24
    1fc4:	79 f0       	breq	.+30     	; 0x1fe4 <_Z11ReceiveBonev+0x2fa>
    1fc6:	81 e0       	ldi	r24, 0x01	; 1
    1fc8:	60 e0       	ldi	r22, 0x00	; 0
    1fca:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1fce:	81 e0       	ldi	r24, 0x01	; 1
    1fd0:	80 93 78 01 	sts	0x0178, r24
    1fd4:	81 e0       	ldi	r24, 0x01	; 1
    1fd6:	80 93 77 01 	sts	0x0177, r24
    1fda:	ce 01       	movw	r24, r28
    1fdc:	04 96       	adiw	r24, 0x04	; 4
    1fde:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    1fe2:	32 c0       	rjmp	.+100    	; 0x2048 <_Z11ReceiveBonev+0x35e>
				else if (!success && restart){flagUpdateGAVRTime=fTrue; flagUpdateGAVRDate=fTrue; PrintBone("bad");}	//sends eeprom time and date
    1fe4:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe6:	88 23       	and	r24, r24
    1fe8:	31 f4       	brne	.+12     	; 0x1ff6 <_Z11ReceiveBonev+0x30c>
    1fea:	80 91 7f 01 	lds	r24, 0x017F
    1fee:	88 23       	and	r24, r24
    1ff0:	11 f0       	breq	.+4      	; 0x1ff6 <_Z11ReceiveBonev+0x30c>
    1ff2:	81 e0       	ldi	r24, 0x01	; 1
    1ff4:	01 c0       	rjmp	.+2      	; 0x1ff8 <_Z11ReceiveBonev+0x30e>
    1ff6:	80 e0       	ldi	r24, 0x00	; 0
    1ff8:	88 23       	and	r24, r24
    1ffa:	59 f0       	breq	.+22     	; 0x2012 <_Z11ReceiveBonev+0x328>
    1ffc:	81 e0       	ldi	r24, 0x01	; 1
    1ffe:	80 93 77 01 	sts	0x0177, r24
    2002:	81 e0       	ldi	r24, 0x01	; 1
    2004:	80 93 78 01 	sts	0x0178, r24
    2008:	85 e5       	ldi	r24, 0x55	; 85
    200a:	91 e0       	ldi	r25, 0x01	; 1
    200c:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    2010:	1b c0       	rjmp	.+54     	; 0x2048 <_Z11ReceiveBonev+0x35e>
				else if (!success && flagFreshStart){flagUserTime=fTrue; flagUserDate=fTrue; PrintBone("bad");} //need to get user time and date
    2012:	8b 81       	ldd	r24, Y+3	; 0x03
    2014:	88 23       	and	r24, r24
    2016:	31 f4       	brne	.+12     	; 0x2024 <_Z11ReceiveBonev+0x33a>
    2018:	80 91 80 01 	lds	r24, 0x0180
    201c:	88 23       	and	r24, r24
    201e:	11 f0       	breq	.+4      	; 0x2024 <_Z11ReceiveBonev+0x33a>
    2020:	81 e0       	ldi	r24, 0x01	; 1
    2022:	01 c0       	rjmp	.+2      	; 0x2026 <_Z11ReceiveBonev+0x33c>
    2024:	80 e0       	ldi	r24, 0x00	; 0
    2026:	88 23       	and	r24, r24
    2028:	59 f0       	breq	.+22     	; 0x2040 <_Z11ReceiveBonev+0x356>
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	80 93 75 01 	sts	0x0175, r24
    2030:	81 e0       	ldi	r24, 0x01	; 1
    2032:	80 93 76 01 	sts	0x0176, r24
    2036:	85 e5       	ldi	r24, 0x55	; 85
    2038:	91 e0       	ldi	r25, 0x01	; 1
    203a:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
    203e:	04 c0       	rjmp	.+8      	; 0x2048 <_Z11ReceiveBonev+0x35e>
				else {PrintBone("bad");}
    2040:	85 e5       	ldi	r24, 0x55	; 85
    2042:	91 e0       	ldi	r25, 0x01	; 1
    2044:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
				//Reset flags for startup
				if (restart){restart=fFalse;}
    2048:	90 91 7f 01 	lds	r25, 0x017F
    204c:	81 e0       	ldi	r24, 0x01	; 1
    204e:	99 23       	and	r25, r25
    2050:	09 f4       	brne	.+2      	; 0x2054 <_Z11ReceiveBonev+0x36a>
    2052:	80 e0       	ldi	r24, 0x00	; 0
    2054:	88 23       	and	r24, r24
    2056:	11 f0       	breq	.+4      	; 0x205c <_Z11ReceiveBonev+0x372>
    2058:	10 92 7f 01 	sts	0x017F, r1
				if (flagFreshStart){flagFreshStart=fFalse;}		
    205c:	90 91 80 01 	lds	r25, 0x0180
    2060:	81 e0       	ldi	r24, 0x01	; 1
    2062:	99 23       	and	r25, r25
    2064:	09 f4       	brne	.+2      	; 0x2068 <_Z11ReceiveBonev+0x37e>
    2066:	80 e0       	ldi	r24, 0x00	; 0
    2068:	88 23       	and	r24, r24
    206a:	59 f0       	breq	.+22     	; 0x2082 <_Z11ReceiveBonev+0x398>
    206c:	10 92 80 01 	sts	0x0180, r1
    2070:	08 c0       	rjmp	.+16     	; 0x2082 <_Z11ReceiveBonev+0x398>
			} else {
				PrintBone("ACK"); 
    2072:	81 e5       	ldi	r24, 0x51	; 81
    2074:	91 e0       	ldi	r25, 0x01	; 1
    2076:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
				PrintBone(recString);
    207a:	ce 01       	movw	r24, r28
    207c:	04 96       	adiw	r24, 0x04	; 4
    207e:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
			}
			noCarriage = fFalse;
    2082:	19 82       	std	Y+1, r1	; 0x01
    2084:	1d c0       	rjmp	.+58     	; 0x20c0 <_Z11ReceiveBonev+0x3d6>
		} else {
			recString[strLoc++] = recChar;
    2086:	88 8d       	ldd	r24, Y+24	; 0x18
    2088:	99 8d       	ldd	r25, Y+25	; 0x19
    208a:	9e 01       	movw	r18, r28
    208c:	2c 5f       	subi	r18, 0xFC	; 252
    208e:	3f 4f       	sbci	r19, 0xFF	; 255
    2090:	28 0f       	add	r18, r24
    2092:	39 1f       	adc	r19, r25
    2094:	4a 81       	ldd	r20, Y+2	; 0x02
    2096:	f9 01       	movw	r30, r18
    2098:	40 83       	st	Z, r20
    209a:	01 96       	adiw	r24, 0x01	; 1
    209c:	99 8f       	std	Y+25, r25	; 0x19
    209e:	88 8f       	std	Y+24, r24	; 0x18
			if (strLoc >= 19){strLoc = 0; noCarriage = fFalse; PrintBone("ACKERROR");}
    20a0:	88 8d       	ldd	r24, Y+24	; 0x18
    20a2:	99 8d       	ldd	r25, Y+25	; 0x19
    20a4:	21 e0       	ldi	r18, 0x01	; 1
    20a6:	83 31       	cpi	r24, 0x13	; 19
    20a8:	91 05       	cpc	r25, r1
    20aa:	0c f4       	brge	.+2      	; 0x20ae <_Z11ReceiveBonev+0x3c4>
    20ac:	20 e0       	ldi	r18, 0x00	; 0
    20ae:	22 23       	and	r18, r18
    20b0:	39 f0       	breq	.+14     	; 0x20c0 <_Z11ReceiveBonev+0x3d6>
    20b2:	19 8e       	std	Y+25, r1	; 0x19
    20b4:	18 8e       	std	Y+24, r1	; 0x18
    20b6:	19 82       	std	Y+1, r1	; 0x01
    20b8:	89 e5       	ldi	r24, 0x59	; 89
    20ba:	91 e0       	ldi	r25, 0x01	; 1
    20bc:	0e 94 fe 07 	call	0xffc	; 0xffc <_Z9PrintBonePc>
		noCarriage=fFalse;
	} else {
		recString[strLoc]=recChar;
		strLoc++;
	}
	while (noCarriage && flagUARTbone){ //flag goes down if a timeout occurs.
    20c0:	89 81       	ldd	r24, Y+1	; 0x01
    20c2:	88 23       	and	r24, r24
    20c4:	31 f0       	breq	.+12     	; 0x20d2 <_Z11ReceiveBonev+0x3e8>
    20c6:	80 91 73 01 	lds	r24, 0x0173
    20ca:	88 23       	and	r24, r24
    20cc:	11 f0       	breq	.+4      	; 0x20d2 <_Z11ReceiveBonev+0x3e8>
    20ce:	81 e0       	ldi	r24, 0x01	; 1
    20d0:	01 c0       	rjmp	.+2      	; 0x20d4 <_Z11ReceiveBonev+0x3ea>
    20d2:	80 e0       	ldi	r24, 0x00	; 0
    20d4:	88 23       	and	r24, r24
    20d6:	09 f0       	breq	.+2      	; 0x20da <_Z11ReceiveBonev+0x3f0>
    20d8:	33 ce       	rjmp	.-922    	; 0x1d40 <_Z11ReceiveBonev+0x56>
		} else {
			recString[strLoc++] = recChar;
			if (strLoc >= 19){strLoc = 0; noCarriage = fFalse; PrintBone("ACKERROR");}
		}	
	}	
}
    20da:	a7 96       	adiw	r28, 0x27	; 39
    20dc:	0f b6       	in	r0, 0x3f	; 63
    20de:	f8 94       	cli
    20e0:	de bf       	out	0x3e, r29	; 62
    20e2:	0f be       	out	0x3f, r0	; 63
    20e4:	cd bf       	out	0x3d, r28	; 61
    20e6:	df 91       	pop	r29
    20e8:	cf 91       	pop	r28
    20ea:	08 95       	ret

000020ec <_Z9GoToSleeph>:

/*************************************************************************************************************/

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    20ec:	cf 93       	push	r28
    20ee:	df 93       	push	r29
    20f0:	00 d0       	rcall	.+0      	; 0x20f2 <_Z9GoToSleeph+0x6>
    20f2:	00 d0       	rcall	.+0      	; 0x20f4 <_Z9GoToSleeph+0x8>
    20f4:	0f 92       	push	r0
    20f6:	cd b7       	in	r28, 0x3d	; 61
    20f8:	de b7       	in	r29, 0x3e	; 62
    20fa:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    20fc:	78 94       	sei
		volatile int sleepTime, sleepTicks = 0;
    20fe:	1c 82       	std	Y+4, r1	; 0x04
    2100:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong == fTrue){
    2102:	8d 81       	ldd	r24, Y+5	; 0x05
    2104:	81 30       	cpi	r24, 0x01	; 1
    2106:	49 f4       	brne	.+18     	; 0x211a <_Z9GoToSleeph+0x2e>
			sleepTime = SLEEP_TICKS_LOWV;
    2108:	8c e0       	ldi	r24, 0x0C	; 12
    210a:	90 e0       	ldi	r25, 0x00	; 0
    210c:	9a 83       	std	Y+2, r25	; 0x02
    210e:	89 83       	std	Y+1, r24	; 0x01
			EIMSK = 0;						//no int2
    2110:	8d e3       	ldi	r24, 0x3D	; 61
    2112:	90 e0       	ldi	r25, 0x00	; 0
    2114:	fc 01       	movw	r30, r24
    2116:	10 82       	st	Z, r1
    2118:	0d c0       	rjmp	.+26     	; 0x2134 <_Z9GoToSleeph+0x48>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    211a:	8a e0       	ldi	r24, 0x0A	; 10
    211c:	90 e0       	ldi	r25, 0x00	; 0
    211e:	9a 83       	std	Y+2, r25	; 0x02
    2120:	89 83       	std	Y+1, r24	; 0x01
			EIMSK |= (1 << INT2);			//int2 is allowed.
    2122:	8d e3       	ldi	r24, 0x3D	; 61
    2124:	90 e0       	ldi	r25, 0x00	; 0
    2126:	2d e3       	ldi	r18, 0x3D	; 61
    2128:	30 e0       	ldi	r19, 0x00	; 0
    212a:	f9 01       	movw	r30, r18
    212c:	20 81       	ld	r18, Z
    212e:	24 60       	ori	r18, 0x04	; 4
    2130:	fc 01       	movw	r30, r24
    2132:	20 83       	st	Z, r18
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    2134:	88 e2       	ldi	r24, 0x28	; 40
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	28 e2       	ldi	r18, 0x28	; 40
    213a:	30 e0       	ldi	r19, 0x00	; 0
    213c:	f9 01       	movw	r30, r18
    213e:	20 81       	ld	r18, Z
    2140:	2b 7f       	andi	r18, 0xFB	; 251
    2142:	fc 01       	movw	r30, r24
    2144:	20 83       	st	Z, r18
		prtSLEEPled |= (1 << bnSLEEPled);
    2146:	8b e2       	ldi	r24, 0x2B	; 43
    2148:	90 e0       	ldi	r25, 0x00	; 0
    214a:	2b e2       	ldi	r18, 0x2B	; 43
    214c:	30 e0       	ldi	r19, 0x00	; 0
    214e:	f9 01       	movw	r30, r18
    2150:	20 81       	ld	r18, Z
    2152:	20 68       	ori	r18, 0x80	; 128
    2154:	fc 01       	movw	r30, r24
    2156:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    2158:	83 e5       	ldi	r24, 0x53	; 83
    215a:	90 e0       	ldi	r25, 0x00	; 0
    215c:	26 e0       	ldi	r18, 0x06	; 6
    215e:	fc 01       	movw	r30, r24
    2160:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    2162:	83 e5       	ldi	r24, 0x53	; 83
    2164:	90 e0       	ldi	r25, 0x00	; 0
    2166:	23 e5       	ldi	r18, 0x53	; 83
    2168:	30 e0       	ldi	r19, 0x00	; 0
    216a:	f9 01       	movw	r30, r18
    216c:	20 81       	ld	r18, Z
    216e:	21 60       	ori	r18, 0x01	; 1
    2170:	fc 01       	movw	r30, r24
    2172:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    2174:	81 e0       	ldi	r24, 0x01	; 1
    2176:	90 e0       	ldi	r25, 0x00	; 0
    2178:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    217c:	06 c0       	rjmp	.+12     	; 0x218a <_Z9GoToSleeph+0x9e>
			asm volatile("SLEEP");
    217e:	88 95       	sleep
			sleepTicks++;
    2180:	8b 81       	ldd	r24, Y+3	; 0x03
    2182:	9c 81       	ldd	r25, Y+4	; 0x04
    2184:	01 96       	adiw	r24, 0x01	; 1
    2186:	9c 83       	std	Y+4, r25	; 0x04
    2188:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    218a:	2b 81       	ldd	r18, Y+3	; 0x03
    218c:	3c 81       	ldd	r19, Y+4	; 0x04
    218e:	89 81       	ldd	r24, Y+1	; 0x01
    2190:	9a 81       	ldd	r25, Y+2	; 0x02
    2192:	28 17       	cp	r18, r24
    2194:	39 07       	cpc	r19, r25
    2196:	34 f4       	brge	.+12     	; 0x21a4 <_Z9GoToSleeph+0xb8>
    2198:	80 91 72 01 	lds	r24, 0x0172
    219c:	88 23       	and	r24, r24
    219e:	11 f0       	breq	.+4      	; 0x21a4 <_Z9GoToSleeph+0xb8>
    21a0:	81 e0       	ldi	r24, 0x01	; 1
    21a2:	01 c0       	rjmp	.+2      	; 0x21a6 <_Z9GoToSleeph+0xba>
    21a4:	80 e0       	ldi	r24, 0x00	; 0
    21a6:	88 23       	and	r24, r24
    21a8:	51 f7       	brne	.-44     	; 0x217e <_Z9GoToSleeph+0x92>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(10);
    21aa:	8a e0       	ldi	r24, 0x0A	; 10
    21ac:	90 e0       	ldi	r25, 0x00	; 0
    21ae:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSLEEPled &= ~(1 << bnSLEEPled);
    21b2:	8b e2       	ldi	r24, 0x2B	; 43
    21b4:	90 e0       	ldi	r25, 0x00	; 0
    21b6:	2b e2       	ldi	r18, 0x2B	; 43
    21b8:	30 e0       	ldi	r19, 0x00	; 0
    21ba:	f9 01       	movw	r30, r18
    21bc:	20 81       	ld	r18, Z
    21be:	2f 77       	andi	r18, 0x7F	; 127
    21c0:	fc 01       	movw	r30, r24
    21c2:	20 83       	st	Z, r18
		prtSTATUSled |= (1 << bnSTATUSled);
    21c4:	88 e2       	ldi	r24, 0x28	; 40
    21c6:	90 e0       	ldi	r25, 0x00	; 0
    21c8:	28 e2       	ldi	r18, 0x28	; 40
    21ca:	30 e0       	ldi	r19, 0x00	; 0
    21cc:	f9 01       	movw	r30, r18
    21ce:	20 81       	ld	r18, Z
    21d0:	24 60       	ori	r18, 0x04	; 4
    21d2:	fc 01       	movw	r30, r24
    21d4:	20 83       	st	Z, r18
}
    21d6:	0f 90       	pop	r0
    21d8:	0f 90       	pop	r0
    21da:	0f 90       	pop	r0
    21dc:	0f 90       	pop	r0
    21de:	0f 90       	pop	r0
    21e0:	df 91       	pop	r29
    21e2:	cf 91       	pop	r28
    21e4:	08 95       	ret

000021e6 <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    21e6:	cf 93       	push	r28
    21e8:	df 93       	push	r29
    21ea:	00 d0       	rcall	.+0      	; 0x21ec <_Z7TakeADCv+0x6>
    21ec:	00 d0       	rcall	.+0      	; 0x21ee <_Z7TakeADCv+0x8>
    21ee:	cd b7       	in	r28, 0x3d	; 61
    21f0:	de b7       	in	r29, 0x3e	; 62
	WORD adcReading = 0;
    21f2:	1c 82       	std	Y+4, r1	; 0x04
    21f4:	1b 82       	std	Y+3, r1	; 0x03
	
	cli();
    21f6:	f8 94       	cli
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    21f8:	84 e6       	ldi	r24, 0x64	; 100
    21fa:	90 e0       	ldi	r25, 0x00	; 0
    21fc:	24 e6       	ldi	r18, 0x64	; 100
    21fe:	30 e0       	ldi	r19, 0x00	; 0
    2200:	f9 01       	movw	r30, r18
    2202:	20 81       	ld	r18, Z
    2204:	2e 7f       	andi	r18, 0xFE	; 254
    2206:	fc 01       	movw	r30, r24
    2208:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    220a:	8c e7       	ldi	r24, 0x7C	; 124
    220c:	90 e0       	ldi	r25, 0x00	; 0
    220e:	2c e7       	ldi	r18, 0x7C	; 124
    2210:	30 e0       	ldi	r19, 0x00	; 0
    2212:	f9 01       	movw	r30, r18
    2214:	20 81       	ld	r18, Z
    2216:	20 68       	ori	r18, 0x80	; 128
    2218:	fc 01       	movw	r30, r24
    221a:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    221c:	8a e7       	ldi	r24, 0x7A	; 122
    221e:	90 e0       	ldi	r25, 0x00	; 0
    2220:	2a e7       	ldi	r18, 0x7A	; 122
    2222:	30 e0       	ldi	r19, 0x00	; 0
    2224:	f9 01       	movw	r30, r18
    2226:	20 81       	ld	r18, Z
    2228:	24 68       	ori	r18, 0x84	; 132
    222a:	fc 01       	movw	r30, r24
    222c:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    222e:	8e e7       	ldi	r24, 0x7E	; 126
    2230:	90 e0       	ldi	r25, 0x00	; 0
    2232:	2e ef       	ldi	r18, 0xFE	; 254
    2234:	fc 01       	movw	r30, r24
    2236:	20 83       	st	Z, r18
	Wait_ms(5);									//Tim for registers to setup
    2238:	85 e0       	ldi	r24, 0x05	; 5
    223a:	90 e0       	ldi	r25, 0x00	; 0
    223c:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <_Z7Wait_msi>
	
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    2240:	1a 82       	std	Y+2, r1	; 0x02
    2242:	19 82       	std	Y+1, r1	; 0x01
    2244:	1c c0       	rjmp	.+56     	; 0x227e <_Z7TakeADCv+0x98>
    2246:	8a e7       	ldi	r24, 0x7A	; 122
    2248:	90 e0       	ldi	r25, 0x00	; 0
    224a:	2a e7       	ldi	r18, 0x7A	; 122
    224c:	30 e0       	ldi	r19, 0x00	; 0
    224e:	f9 01       	movw	r30, r18
    2250:	20 81       	ld	r18, Z
    2252:	20 64       	ori	r18, 0x40	; 64
    2254:	fc 01       	movw	r30, r24
    2256:	20 83       	st	Z, r18
    2258:	8a e7       	ldi	r24, 0x7A	; 122
    225a:	90 e0       	ldi	r25, 0x00	; 0
    225c:	fc 01       	movw	r30, r24
    225e:	80 81       	ld	r24, Z
    2260:	88 2f       	mov	r24, r24
    2262:	90 e0       	ldi	r25, 0x00	; 0
    2264:	80 74       	andi	r24, 0x40	; 64
    2266:	90 70       	andi	r25, 0x00	; 0
    2268:	21 e0       	ldi	r18, 0x01	; 1
    226a:	00 97       	sbiw	r24, 0x00	; 0
    226c:	09 f4       	brne	.+2      	; 0x2270 <_Z7TakeADCv+0x8a>
    226e:	20 e0       	ldi	r18, 0x00	; 0
    2270:	22 23       	and	r18, r18
    2272:	91 f7       	brne	.-28     	; 0x2258 <_Z7TakeADCv+0x72>
    2274:	89 81       	ldd	r24, Y+1	; 0x01
    2276:	9a 81       	ldd	r25, Y+2	; 0x02
    2278:	01 96       	adiw	r24, 0x01	; 1
    227a:	9a 83       	std	Y+2, r25	; 0x02
    227c:	89 83       	std	Y+1, r24	; 0x01
    227e:	21 e0       	ldi	r18, 0x01	; 1
    2280:	89 81       	ldd	r24, Y+1	; 0x01
    2282:	9a 81       	ldd	r25, Y+2	; 0x02
    2284:	82 30       	cpi	r24, 0x02	; 2
    2286:	91 05       	cpc	r25, r1
    2288:	0c f0       	brlt	.+2      	; 0x228c <_Z7TakeADCv+0xa6>
    228a:	20 e0       	ldi	r18, 0x00	; 0
    228c:	22 23       	and	r18, r18
    228e:	d9 f6       	brne	.-74     	; 0x2246 <_Z7TakeADCv+0x60>
	
	//Put conversion into buffer
	adcReading = ADCL;
    2290:	88 e7       	ldi	r24, 0x78	; 120
    2292:	90 e0       	ldi	r25, 0x00	; 0
    2294:	fc 01       	movw	r30, r24
    2296:	80 81       	ld	r24, Z
    2298:	88 2f       	mov	r24, r24
    229a:	90 e0       	ldi	r25, 0x00	; 0
    229c:	9c 83       	std	Y+4, r25	; 0x04
    229e:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    22a0:	89 e7       	ldi	r24, 0x79	; 121
    22a2:	90 e0       	ldi	r25, 0x00	; 0
    22a4:	fc 01       	movw	r30, r24
    22a6:	80 81       	ld	r24, Z
    22a8:	88 2f       	mov	r24, r24
    22aa:	90 e0       	ldi	r25, 0x00	; 0
    22ac:	98 2f       	mov	r25, r24
    22ae:	88 27       	eor	r24, r24
    22b0:	2b 81       	ldd	r18, Y+3	; 0x03
    22b2:	3c 81       	ldd	r19, Y+4	; 0x04
    22b4:	82 2b       	or	r24, r18
    22b6:	93 2b       	or	r25, r19
    22b8:	9c 83       	std	Y+4, r25	; 0x04
    22ba:	8b 83       	std	Y+3, r24	; 0x03
	
	//Re-enable interrupts
	sei();
    22bc:	78 94       	sei
	
	//Disable ADC hardware/registers
	ADCSRA = 0;
    22be:	8a e7       	ldi	r24, 0x7A	; 122
    22c0:	90 e0       	ldi	r25, 0x00	; 0
    22c2:	fc 01       	movw	r30, r24
    22c4:	10 82       	st	Z, r1
	ADMUX = 0;
    22c6:	8c e7       	ldi	r24, 0x7C	; 124
    22c8:	90 e0       	ldi	r25, 0x00	; 0
    22ca:	fc 01       	movw	r30, r24
    22cc:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    22ce:	8e e7       	ldi	r24, 0x7E	; 126
    22d0:	90 e0       	ldi	r25, 0x00	; 0
    22d2:	2e e7       	ldi	r18, 0x7E	; 126
    22d4:	30 e0       	ldi	r19, 0x00	; 0
    22d6:	f9 01       	movw	r30, r18
    22d8:	20 81       	ld	r18, Z
    22da:	21 60       	ori	r18, 0x01	; 1
    22dc:	fc 01       	movw	r30, r24
    22de:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    22e0:	84 e6       	ldi	r24, 0x64	; 100
    22e2:	90 e0       	ldi	r25, 0x00	; 0
    22e4:	24 e6       	ldi	r18, 0x64	; 100
    22e6:	30 e0       	ldi	r19, 0x00	; 0
    22e8:	f9 01       	movw	r30, r18
    22ea:	20 81       	ld	r18, Z
    22ec:	21 60       	ori	r18, 0x01	; 1
    22ee:	fc 01       	movw	r30, r24
    22f0:	20 83       	st	Z, r18
	
	//Do work
	Wait_ms(5);
    22f2:	85 e0       	ldi	r24, 0x05	; 5
    22f4:	90 e0       	ldi	r25, 0x00	; 0
    22f6:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <_Z7Wait_msi>

	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    22fa:	21 e0       	ldi	r18, 0x01	; 1
    22fc:	8b 81       	ldd	r24, Y+3	; 0x03
    22fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2300:	f1 e0       	ldi	r31, 0x01	; 1
    2302:	8c 32       	cpi	r24, 0x2C	; 44
    2304:	9f 07       	cpc	r25, r31
    2306:	08 f4       	brcc	.+2      	; 0x230a <_Z7TakeADCv+0x124>
    2308:	20 e0       	ldi	r18, 0x00	; 0
    230a:	20 93 7e 01 	sts	0x017E, r18
	
	globalADC=adcReading;
    230e:	8b 81       	ldd	r24, Y+3	; 0x03
    2310:	9c 81       	ldd	r25, Y+4	; 0x04
    2312:	90 93 82 01 	sts	0x0182, r25
    2316:	80 93 81 01 	sts	0x0181, r24
}
    231a:	0f 90       	pop	r0
    231c:	0f 90       	pop	r0
    231e:	0f 90       	pop	r0
    2320:	0f 90       	pop	r0
    2322:	df 91       	pop	r29
    2324:	cf 91       	pop	r28
    2326:	08 95       	ret

00002328 <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    2328:	cf 93       	push	r28
    232a:	df 93       	push	r29
    232c:	00 d0       	rcall	.+0      	; 0x232e <_Z7GetTempv+0x6>
    232e:	cd b7       	in	r28, 0x3d	; 61
    2330:	de b7       	in	r29, 0x3e	; 62
	WORD rawTemp = 0;
    2332:	1a 82       	std	Y+2, r1	; 0x02
    2334:	19 82       	std	Y+1, r1	; 0x01
	
	//Power on temp monitor, let it settle
	//prtTEMPen |= (1 << bnTEMPen);
	PRR0 &= ~(1 << PRSPI);	
    2336:	84 e6       	ldi	r24, 0x64	; 100
    2338:	90 e0       	ldi	r25, 0x00	; 0
    233a:	24 e6       	ldi	r18, 0x64	; 100
    233c:	30 e0       	ldi	r19, 0x00	; 0
    233e:	f9 01       	movw	r30, r18
    2340:	20 81       	ld	r18, Z
    2342:	2b 7f       	andi	r18, 0xFB	; 251
    2344:	fc 01       	movw	r30, r24
    2346:	20 83       	st	Z, r18
	SPCR0 |= (1 << MSTR0)|(1 << SPE0)|(1 << SPR00);			//enables SPI, master, fck/64
    2348:	8c e4       	ldi	r24, 0x4C	; 76
    234a:	90 e0       	ldi	r25, 0x00	; 0
    234c:	2c e4       	ldi	r18, 0x4C	; 76
    234e:	30 e0       	ldi	r19, 0x00	; 0
    2350:	f9 01       	movw	r30, r18
    2352:	20 81       	ld	r18, Z
    2354:	21 65       	ori	r18, 0x51	; 81
    2356:	fc 01       	movw	r30, r24
    2358:	20 83       	st	Z, r18
	Wait_ms(200);
    235a:	88 ec       	ldi	r24, 0xC8	; 200
    235c:	90 e0       	ldi	r25, 0x00	; 0
    235e:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <_Z7Wait_msi>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    2362:	85 e2       	ldi	r24, 0x25	; 37
    2364:	90 e0       	ldi	r25, 0x00	; 0
    2366:	25 e2       	ldi	r18, 0x25	; 37
    2368:	30 e0       	ldi	r19, 0x00	; 0
    236a:	f9 01       	movw	r30, r18
    236c:	20 81       	ld	r18, Z
    236e:	2f 76       	andi	r18, 0x6F	; 111
    2370:	fc 01       	movw	r30, r24
    2372:	20 83       	st	Z, r18
	
	cli();
    2374:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR0 = 0x00;
    2376:	8e e4       	ldi	r24, 0x4E	; 78
    2378:	90 e0       	ldi	r25, 0x00	; 0
    237a:	fc 01       	movw	r30, r24
    237c:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR0 & (1 << SPIF0)));
    237e:	00 00       	nop
    2380:	8d e4       	ldi	r24, 0x4D	; 77
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	fc 01       	movw	r30, r24
    2386:	80 81       	ld	r24, Z
    2388:	80 95       	com	r24
    238a:	88 1f       	adc	r24, r24
    238c:	88 27       	eor	r24, r24
    238e:	88 1f       	adc	r24, r24
    2390:	88 23       	and	r24, r24
    2392:	b1 f7       	brne	.-20     	; 0x2380 <_Z7GetTempv+0x58>
	rawTemp = (SPDR0 << 8);
    2394:	8e e4       	ldi	r24, 0x4E	; 78
    2396:	90 e0       	ldi	r25, 0x00	; 0
    2398:	fc 01       	movw	r30, r24
    239a:	80 81       	ld	r24, Z
    239c:	88 2f       	mov	r24, r24
    239e:	90 e0       	ldi	r25, 0x00	; 0
    23a0:	98 2f       	mov	r25, r24
    23a2:	88 27       	eor	r24, r24
    23a4:	9a 83       	std	Y+2, r25	; 0x02
    23a6:	89 83       	std	Y+1, r24	; 0x01
	SPDR0 = 0x00;
    23a8:	8e e4       	ldi	r24, 0x4E	; 78
    23aa:	90 e0       	ldi	r25, 0x00	; 0
    23ac:	fc 01       	movw	r30, r24
    23ae:	10 82       	st	Z, r1
	while (!(SPSR0 & (1 << SPIF0)));
    23b0:	00 00       	nop
    23b2:	8d e4       	ldi	r24, 0x4D	; 77
    23b4:	90 e0       	ldi	r25, 0x00	; 0
    23b6:	fc 01       	movw	r30, r24
    23b8:	80 81       	ld	r24, Z
    23ba:	80 95       	com	r24
    23bc:	88 1f       	adc	r24, r24
    23be:	88 27       	eor	r24, r24
    23c0:	88 1f       	adc	r24, r24
    23c2:	88 23       	and	r24, r24
    23c4:	b1 f7       	brne	.-20     	; 0x23b2 <_Z7GetTempv+0x8a>
	rawTemp |= SPDR0;
    23c6:	8e e4       	ldi	r24, 0x4E	; 78
    23c8:	90 e0       	ldi	r25, 0x00	; 0
    23ca:	fc 01       	movw	r30, r24
    23cc:	80 81       	ld	r24, Z
    23ce:	88 2f       	mov	r24, r24
    23d0:	90 e0       	ldi	r25, 0x00	; 0
    23d2:	29 81       	ldd	r18, Y+1	; 0x01
    23d4:	3a 81       	ldd	r19, Y+2	; 0x02
    23d6:	82 2b       	or	r24, r18
    23d8:	93 2b       	or	r25, r19
    23da:	9a 83       	std	Y+2, r25	; 0x02
    23dc:	89 83       	std	Y+1, r24	; 0x01
	//Set flag to correct value.
	flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
    23de:	89 81       	ldd	r24, Y+1	; 0x01
    23e0:	9a 81       	ldd	r25, Y+2	; 0x02
    23e2:	f2 e3       	ldi	r31, 0x32	; 50
    23e4:	84 36       	cpi	r24, 0x64	; 100
    23e6:	9f 07       	cpc	r25, r31
    23e8:	10 f4       	brcc	.+4      	; 0x23ee <_Z7GetTempv+0xc6>
    23ea:	81 e0       	ldi	r24, 0x01	; 1
    23ec:	01 c0       	rjmp	.+2      	; 0x23f0 <_Z7GetTempv+0xc8>
    23ee:	80 e0       	ldi	r24, 0x00	; 0
    23f0:	80 93 7d 01 	sts	0x017D, r24
	//re enable interrupts
	sei();
    23f4:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    23f6:	85 e2       	ldi	r24, 0x25	; 37
    23f8:	90 e0       	ldi	r25, 0x00	; 0
    23fa:	25 e2       	ldi	r18, 0x25	; 37
    23fc:	30 e0       	ldi	r19, 0x00	; 0
    23fe:	f9 01       	movw	r30, r18
    2400:	20 81       	ld	r18, Z
    2402:	20 69       	ori	r18, 0x90	; 144
    2404:	fc 01       	movw	r30, r24
    2406:	20 83       	st	Z, r18
	SPCR0=0x00;	
    2408:	8c e4       	ldi	r24, 0x4C	; 76
    240a:	90 e0       	ldi	r25, 0x00	; 0
    240c:	fc 01       	movw	r30, r24
    240e:	10 82       	st	Z, r1
	//prtTEMPen &= ~(1 << bnTEMPen);
	PRR0 |= (1 << PRSPI);
    2410:	84 e6       	ldi	r24, 0x64	; 100
    2412:	90 e0       	ldi	r25, 0x00	; 0
    2414:	24 e6       	ldi	r18, 0x64	; 100
    2416:	30 e0       	ldi	r19, 0x00	; 0
    2418:	f9 01       	movw	r30, r18
    241a:	20 81       	ld	r18, Z
    241c:	24 60       	ori	r18, 0x04	; 4
    241e:	fc 01       	movw	r30, r24
    2420:	20 83       	st	Z, r18

	globalTemp=rawTemp;
    2422:	89 81       	ldd	r24, Y+1	; 0x01
    2424:	9a 81       	ldd	r25, Y+2	; 0x02
    2426:	90 93 84 01 	sts	0x0184, r25
    242a:	80 93 83 01 	sts	0x0183, r24
}
    242e:	0f 90       	pop	r0
    2430:	0f 90       	pop	r0
    2432:	df 91       	pop	r29
    2434:	cf 91       	pop	r28
    2436:	08 95       	ret

00002438 <_Z16SendTimeDateGAVRhh>:
/*************************************************************************************************************/
//10 second timeout for this.
void SendTimeDateGAVR(BOOL sTime, BOOL sDate){
    2438:	cf 93       	push	r28
    243a:	df 93       	push	r29
    243c:	cd b7       	in	r28, 0x3d	; 61
    243e:	de b7       	in	r29, 0x3e	; 62
    2440:	cb 58       	subi	r28, 0x8B	; 139
    2442:	d0 40       	sbci	r29, 0x00	; 0
    2444:	0f b6       	in	r0, 0x3f	; 63
    2446:	f8 94       	cli
    2448:	de bf       	out	0x3e, r29	; 62
    244a:	0f be       	out	0x3f, r0	; 63
    244c:	cd bf       	out	0x3d, r28	; 61
    244e:	9e 01       	movw	r18, r28
    2450:	26 57       	subi	r18, 0x76	; 118
    2452:	3f 4f       	sbci	r19, 0xFF	; 255
    2454:	f9 01       	movw	r30, r18
    2456:	80 83       	st	Z, r24
    2458:	ce 01       	movw	r24, r28
    245a:	85 57       	subi	r24, 0x75	; 117
    245c:	9f 4f       	sbci	r25, 0xFF	; 255
    245e:	fc 01       	movw	r30, r24
    2460:	60 83       	st	Z, r22
	flagSendingGAVR=fTrue;
    2462:	81 e0       	ldi	r24, 0x01	; 1
    2464:	80 93 7a 01 	sts	0x017A, r24
	prtSLEEPled |= (1 << bnSLEEPled);
    2468:	8b e2       	ldi	r24, 0x2B	; 43
    246a:	90 e0       	ldi	r25, 0x00	; 0
    246c:	2b e2       	ldi	r18, 0x2B	; 43
    246e:	30 e0       	ldi	r19, 0x00	; 0
    2470:	f9 01       	movw	r30, r18
    2472:	20 81       	ld	r18, Z
    2474:	20 68       	ori	r18, 0x80	; 128
    2476:	fc 01       	movw	r30, r24
    2478:	20 83       	st	Z, r18
	volatile int state=0;
    247a:	1f 82       	std	Y+7, r1	; 0x07
    247c:	1e 82       	std	Y+6, r1	; 0x06
	BOOL communicating=fTrue;
    247e:	81 e0       	ldi	r24, 0x01	; 1
    2480:	89 83       	std	Y+1, r24	; 0x01
	noTimeout=fTrue;
    2482:	81 e0       	ldi	r24, 0x01	; 1
    2484:	80 93 79 01 	sts	0x0179, r24
	volatile int beginningSecond=currentTime.getSeconds();
    2488:	85 e8       	ldi	r24, 0x85	; 133
    248a:	91 e0       	ldi	r25, 0x01	; 1
    248c:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTime10getSecondsEv>
    2490:	88 2f       	mov	r24, r24
    2492:	90 e0       	ldi	r25, 0x00	; 0
    2494:	99 87       	std	Y+9, r25	; 0x09
    2496:	88 87       	std	Y+8, r24	; 0x08
	volatile int endingSecond=(10+beginningSecond)%60;
    2498:	88 85       	ldd	r24, Y+8	; 0x08
    249a:	99 85       	ldd	r25, Y+9	; 0x09
    249c:	0a 96       	adiw	r24, 0x0a	; 10
    249e:	2c e3       	ldi	r18, 0x3C	; 60
    24a0:	30 e0       	ldi	r19, 0x00	; 0
    24a2:	b9 01       	movw	r22, r18
    24a4:	0e 94 fe 14 	call	0x29fc	; 0x29fc <__divmodhi4>
    24a8:	9b 87       	std	Y+11, r25	; 0x0b
    24aa:	8a 87       	std	Y+10, r24	; 0x0a
	char sentString[30];	//string that was sent, need it for error checking
	//Make sure we should be sending something
	if (sTime || sDate){communicating=fTrue;}
    24ac:	ce 01       	movw	r24, r28
    24ae:	86 57       	subi	r24, 0x76	; 118
    24b0:	9f 4f       	sbci	r25, 0xFF	; 255
    24b2:	fc 01       	movw	r30, r24
    24b4:	80 81       	ld	r24, Z
    24b6:	88 23       	and	r24, r24
    24b8:	39 f4       	brne	.+14     	; 0x24c8 <_Z16SendTimeDateGAVRhh+0x90>
    24ba:	ce 01       	movw	r24, r28
    24bc:	85 57       	subi	r24, 0x75	; 117
    24be:	9f 4f       	sbci	r25, 0xFF	; 255
    24c0:	fc 01       	movw	r30, r24
    24c2:	80 81       	ld	r24, Z
    24c4:	88 23       	and	r24, r24
    24c6:	19 f0       	breq	.+6      	; 0x24ce <_Z16SendTimeDateGAVRhh+0x96>
    24c8:	81 e0       	ldi	r24, 0x01	; 1
    24ca:	89 83       	std	Y+1, r24	; 0x01
	else {communicating=fFalse;}
	//Main sending  loop
	while(communicating && noTimeout){
    24cc:	00 c2       	rjmp	.+1024   	; 0x28ce <_Z16SendTimeDateGAVRhh+0x496>
	volatile int beginningSecond=currentTime.getSeconds();
	volatile int endingSecond=(10+beginningSecond)%60;
	char sentString[30];	//string that was sent, need it for error checking
	//Make sure we should be sending something
	if (sTime || sDate){communicating=fTrue;}
	else {communicating=fFalse;}
    24ce:	19 82       	std	Y+1, r1	; 0x01
	//Main sending  loop
	while(communicating && noTimeout){
    24d0:	fe c1       	rjmp	.+1020   	; 0x28ce <_Z16SendTimeDateGAVRhh+0x496>
		switch(state){
    24d2:	8e 81       	ldd	r24, Y+6	; 0x06
    24d4:	9f 81       	ldd	r25, Y+7	; 0x07
    24d6:	81 30       	cpi	r24, 0x01	; 1
    24d8:	91 05       	cpc	r25, r1
    24da:	79 f1       	breq	.+94     	; 0x253a <_Z16SendTimeDateGAVRhh+0x102>
    24dc:	82 30       	cpi	r24, 0x02	; 2
    24de:	91 05       	cpc	r25, r1
    24e0:	09 f4       	brne	.+2      	; 0x24e4 <_Z16SendTimeDateGAVRhh+0xac>
    24e2:	30 c1       	rjmp	.+608    	; 0x2744 <_Z16SendTimeDateGAVRhh+0x30c>
    24e4:	00 97       	sbiw	r24, 0x00	; 0
    24e6:	09 f0       	breq	.+2      	; 0x24ea <_Z16SendTimeDateGAVRhh+0xb2>
    24e8:	de c1       	rjmp	.+956    	; 0x28a6 <_Z16SendTimeDateGAVRhh+0x46e>
			case 0:{
				//Send interrupt to GAVR, wait for  ACKW
				prtGAVRINT |= (1 << bnGAVRINT);
    24ea:	85 e2       	ldi	r24, 0x25	; 37
    24ec:	90 e0       	ldi	r25, 0x00	; 0
    24ee:	25 e2       	ldi	r18, 0x25	; 37
    24f0:	30 e0       	ldi	r19, 0x00	; 0
    24f2:	f9 01       	movw	r30, r18
    24f4:	20 81       	ld	r18, Z
    24f6:	28 60       	ori	r18, 0x08	; 8
    24f8:	fc 01       	movw	r30, r24
    24fa:	20 83       	st	Z, r18
				for (volatile int i=0; i<2;i++){asm volatile("nop");}	
    24fc:	1b a6       	lds	r17, 0xbb
    24fe:	1a a6       	lds	r17, 0xba
    2500:	06 c0       	rjmp	.+12     	; 0x250e <_Z16SendTimeDateGAVRhh+0xd6>
    2502:	00 00       	nop
    2504:	8a a5       	lds	r24, 0x6a
    2506:	9b a5       	lds	r25, 0x6b
    2508:	01 96       	adiw	r24, 0x01	; 1
    250a:	9b a7       	lds	r25, 0x7b
    250c:	8a a7       	lds	r24, 0x7a
    250e:	8a a5       	lds	r24, 0x6a
    2510:	9b a5       	lds	r25, 0x6b
    2512:	21 e0       	ldi	r18, 0x01	; 1
    2514:	82 30       	cpi	r24, 0x02	; 2
    2516:	91 05       	cpc	r25, r1
    2518:	0c f0       	brlt	.+2      	; 0x251c <_Z16SendTimeDateGAVRhh+0xe4>
    251a:	20 e0       	ldi	r18, 0x00	; 0
    251c:	22 23       	and	r18, r18
    251e:	89 f7       	brne	.-30     	; 0x2502 <_Z16SendTimeDateGAVRhh+0xca>
				prtGAVRINT &= ~(1 << bnGAVRINT);
    2520:	85 e2       	ldi	r24, 0x25	; 37
    2522:	90 e0       	ldi	r25, 0x00	; 0
    2524:	25 e2       	ldi	r18, 0x25	; 37
    2526:	30 e0       	ldi	r19, 0x00	; 0
    2528:	f9 01       	movw	r30, r18
    252a:	20 81       	ld	r18, Z
    252c:	27 7f       	andi	r18, 0xF7	; 247
    252e:	fc 01       	movw	r30, r24
    2530:	20 83       	st	Z, r18
				//Wait for ACK now
				state=1;
    2532:	81 e0       	ldi	r24, 0x01	; 1
    2534:	90 e0       	ldi	r25, 0x00	; 0
    2536:	9f 83       	std	Y+7, r25	; 0x07
    2538:	8e 83       	std	Y+6, r24	; 0x06
			} case 1: {
				char recChar, recString[30];
				volatile int strLoc=0;
    253a:	ce 01       	movw	r24, r28
    253c:	86 5b       	subi	r24, 0xB6	; 182
    253e:	9f 4f       	sbci	r25, 0xFF	; 255
    2540:	fc 01       	movw	r30, r24
    2542:	11 82       	std	Z+1, r1	; 0x01
    2544:	10 82       	st	Z, r1
				BOOL noCarriage=fTrue;
    2546:	81 e0       	ldi	r24, 0x01	; 1
    2548:	8a 83       	std	Y+2, r24	; 0x02
				//We sent an interrupt, need to get an ACKW back now.
				while (noCarriage && noTimeout){
    254a:	ee c0       	rjmp	.+476    	; 0x2728 <_Z16SendTimeDateGAVRhh+0x2f0>
					while (!(UCSR1A & (1 << RXC1)) && noTimeout);
    254c:	00 00       	nop
    254e:	88 ec       	ldi	r24, 0xC8	; 200
    2550:	90 e0       	ldi	r25, 0x00	; 0
    2552:	fc 01       	movw	r30, r24
    2554:	80 81       	ld	r24, Z
    2556:	88 23       	and	r24, r24
    2558:	34 f0       	brlt	.+12     	; 0x2566 <_Z16SendTimeDateGAVRhh+0x12e>
    255a:	80 91 79 01 	lds	r24, 0x0179
    255e:	88 23       	and	r24, r24
    2560:	11 f0       	breq	.+4      	; 0x2566 <_Z16SendTimeDateGAVRhh+0x12e>
    2562:	81 e0       	ldi	r24, 0x01	; 1
    2564:	01 c0       	rjmp	.+2      	; 0x2568 <_Z16SendTimeDateGAVRhh+0x130>
    2566:	80 e0       	ldi	r24, 0x00	; 0
    2568:	88 23       	and	r24, r24
    256a:	89 f7       	brne	.-30     	; 0x254e <_Z16SendTimeDateGAVRhh+0x116>
					recChar=UDR1;
    256c:	8e ec       	ldi	r24, 0xCE	; 206
    256e:	90 e0       	ldi	r25, 0x00	; 0
    2570:	fc 01       	movw	r30, r24
    2572:	80 81       	ld	r24, Z
    2574:	8c 83       	std	Y+4, r24	; 0x04
					if (recChar=='.'){
    2576:	8c 81       	ldd	r24, Y+4	; 0x04
    2578:	8e 32       	cpi	r24, 0x2E	; 46
    257a:	09 f0       	breq	.+2      	; 0x257e <_Z16SendTimeDateGAVRhh+0x146>
    257c:	a8 c0       	rjmp	.+336    	; 0x26ce <_Z16SendTimeDateGAVRhh+0x296>
						recString[strLoc]='\0';
    257e:	ce 01       	movw	r24, r28
    2580:	86 5b       	subi	r24, 0xB6	; 182
    2582:	9f 4f       	sbci	r25, 0xFF	; 255
    2584:	fc 01       	movw	r30, r24
    2586:	80 81       	ld	r24, Z
    2588:	91 81       	ldd	r25, Z+1	; 0x01
    258a:	9e 01       	movw	r18, r28
    258c:	24 5d       	subi	r18, 0xD4	; 212
    258e:	3f 4f       	sbci	r19, 0xFF	; 255
    2590:	82 0f       	add	r24, r18
    2592:	93 1f       	adc	r25, r19
    2594:	fc 01       	movw	r30, r24
    2596:	10 82       	st	Z, r1
						noCarriage=fFalse; //get out of loop
    2598:	1a 82       	std	Y+2, r1	; 0x02
						if (!strcmp(recString,"ACKW")){//Good to send time and/or date. send and go to next state.
    259a:	ce 01       	movw	r24, r28
    259c:	8c 96       	adiw	r24, 0x2c	; 44
    259e:	22 e6       	ldi	r18, 0x62	; 98
    25a0:	31 e0       	ldi	r19, 0x01	; 1
    25a2:	b9 01       	movw	r22, r18
    25a4:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    25a8:	00 97       	sbiw	r24, 0x00	; 0
    25aa:	09 f0       	breq	.+2      	; 0x25ae <_Z16SendTimeDateGAVRhh+0x176>
    25ac:	8d c0       	rjmp	.+282    	; 0x26c8 <_Z16SendTimeDateGAVRhh+0x290>
							state=2;
    25ae:	82 e0       	ldi	r24, 0x02	; 2
    25b0:	90 e0       	ldi	r25, 0x00	; 0
    25b2:	9f 83       	std	Y+7, r25	; 0x07
    25b4:	8e 83       	std	Y+6, r24	; 0x06
							if (sTime && sDate){
    25b6:	ce 01       	movw	r24, r28
    25b8:	86 57       	subi	r24, 0x76	; 118
    25ba:	9f 4f       	sbci	r25, 0xFF	; 255
    25bc:	fc 01       	movw	r30, r24
    25be:	80 81       	ld	r24, Z
    25c0:	88 23       	and	r24, r24
    25c2:	c9 f1       	breq	.+114    	; 0x2636 <_Z16SendTimeDateGAVRhh+0x1fe>
    25c4:	ce 01       	movw	r24, r28
    25c6:	85 57       	subi	r24, 0x75	; 117
    25c8:	9f 4f       	sbci	r25, 0xFF	; 255
    25ca:	fc 01       	movw	r30, r24
    25cc:	80 81       	ld	r24, Z
    25ce:	88 23       	and	r24, r24
    25d0:	91 f1       	breq	.+100    	; 0x2636 <_Z16SendTimeDateGAVRhh+0x1fe>
								printTimeDate(fFalse,fTrue,fTrue);
    25d2:	80 e0       	ldi	r24, 0x00	; 0
    25d4:	61 e0       	ldi	r22, 0x01	; 1
    25d6:	41 e0       	ldi	r20, 0x01	; 1
    25d8:	0e 94 cc 09 	call	0x1398	; 0x1398 <_Z13printTimeDatehhh>
								PutUartChGAVR('.');
    25dc:	8e e2       	ldi	r24, 0x2E	; 46
    25de:	0e 94 2b 08 	call	0x1056	; 0x1056 <_Z13PutUartChGAVRc>
								strcpy(sentString,currentTime.getTime());
    25e2:	85 e8       	ldi	r24, 0x85	; 133
    25e4:	91 e0       	ldi	r25, 0x01	; 1
    25e6:	0e 94 3d 06 	call	0xc7a	; 0xc7a <_ZN6myTime7getTimeEv>
    25ea:	9c 01       	movw	r18, r24
    25ec:	ce 01       	movw	r24, r28
    25ee:	0c 96       	adiw	r24, 0x0c	; 12
    25f0:	b9 01       	movw	r22, r18
    25f2:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
								strcat(sentString,"/");
    25f6:	ce 01       	movw	r24, r28
    25f8:	0c 96       	adiw	r24, 0x0c	; 12
    25fa:	9c 01       	movw	r18, r24
    25fc:	f9 01       	movw	r30, r18
    25fe:	01 90       	ld	r0, Z+
    2600:	00 20       	and	r0, r0
    2602:	e9 f7       	brne	.-6      	; 0x25fe <_Z16SendTimeDateGAVRhh+0x1c6>
    2604:	cf 01       	movw	r24, r30
    2606:	01 97       	sbiw	r24, 0x01	; 1
    2608:	82 1b       	sub	r24, r18
    260a:	93 0b       	sbc	r25, r19
    260c:	9e 01       	movw	r18, r28
    260e:	24 5f       	subi	r18, 0xF4	; 244
    2610:	3f 4f       	sbci	r19, 0xFF	; 255
    2612:	82 0f       	add	r24, r18
    2614:	93 1f       	adc	r25, r19
    2616:	2f e2       	ldi	r18, 0x2F	; 47
    2618:	30 e0       	ldi	r19, 0x00	; 0
    261a:	fc 01       	movw	r30, r24
    261c:	31 83       	std	Z+1, r19	; 0x01
    261e:	20 83       	st	Z, r18
								strcat(sentString,currentTime.getDate());
    2620:	85 e8       	ldi	r24, 0x85	; 133
    2622:	91 e0       	ldi	r25, 0x01	; 1
    2624:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate7getDateEv>
    2628:	9c 01       	movw	r18, r24
    262a:	ce 01       	movw	r24, r28
    262c:	0c 96       	adiw	r24, 0x0c	; 12
    262e:	b9 01       	movw	r22, r18
    2630:	0e 94 49 15 	call	0x2a92	; 0x2a92 <strcat>
    2634:	79 c0       	rjmp	.+242    	; 0x2728 <_Z16SendTimeDateGAVRhh+0x2f0>
							} else if (sTime && !sDate){
    2636:	ce 01       	movw	r24, r28
    2638:	86 57       	subi	r24, 0x76	; 118
    263a:	9f 4f       	sbci	r25, 0xFF	; 255
    263c:	fc 01       	movw	r30, r24
    263e:	80 81       	ld	r24, Z
    2640:	88 23       	and	r24, r24
    2642:	79 f1       	breq	.+94     	; 0x26a2 <_Z16SendTimeDateGAVRhh+0x26a>
    2644:	ce 01       	movw	r24, r28
    2646:	85 57       	subi	r24, 0x75	; 117
    2648:	9f 4f       	sbci	r25, 0xFF	; 255
    264a:	fc 01       	movw	r30, r24
    264c:	80 81       	ld	r24, Z
    264e:	88 23       	and	r24, r24
    2650:	41 f5       	brne	.+80     	; 0x26a2 <_Z16SendTimeDateGAVRhh+0x26a>
								printTimeDate(fFalse,fTrue,fFalse);
    2652:	80 e0       	ldi	r24, 0x00	; 0
    2654:	61 e0       	ldi	r22, 0x01	; 1
    2656:	40 e0       	ldi	r20, 0x00	; 0
    2658:	0e 94 cc 09 	call	0x1398	; 0x1398 <_Z13printTimeDatehhh>
								PutUartChGAVR('.');
    265c:	8e e2       	ldi	r24, 0x2E	; 46
    265e:	0e 94 2b 08 	call	0x1056	; 0x1056 <_Z13PutUartChGAVRc>
								strcpy(sentString,currentTime.getTime());
    2662:	85 e8       	ldi	r24, 0x85	; 133
    2664:	91 e0       	ldi	r25, 0x01	; 1
    2666:	0e 94 3d 06 	call	0xc7a	; 0xc7a <_ZN6myTime7getTimeEv>
    266a:	9c 01       	movw	r18, r24
    266c:	ce 01       	movw	r24, r28
    266e:	0c 96       	adiw	r24, 0x0c	; 12
    2670:	b9 01       	movw	r22, r18
    2672:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
								strcat(sentString,"/");
    2676:	ce 01       	movw	r24, r28
    2678:	0c 96       	adiw	r24, 0x0c	; 12
    267a:	9c 01       	movw	r18, r24
    267c:	f9 01       	movw	r30, r18
    267e:	01 90       	ld	r0, Z+
    2680:	00 20       	and	r0, r0
    2682:	e9 f7       	brne	.-6      	; 0x267e <_Z16SendTimeDateGAVRhh+0x246>
    2684:	cf 01       	movw	r24, r30
    2686:	01 97       	sbiw	r24, 0x01	; 1
    2688:	82 1b       	sub	r24, r18
    268a:	93 0b       	sbc	r25, r19
    268c:	9e 01       	movw	r18, r28
    268e:	24 5f       	subi	r18, 0xF4	; 244
    2690:	3f 4f       	sbci	r19, 0xFF	; 255
    2692:	82 0f       	add	r24, r18
    2694:	93 1f       	adc	r25, r19
    2696:	2f e2       	ldi	r18, 0x2F	; 47
    2698:	30 e0       	ldi	r19, 0x00	; 0
    269a:	fc 01       	movw	r30, r24
    269c:	31 83       	std	Z+1, r19	; 0x01
    269e:	20 83       	st	Z, r18
    26a0:	43 c0       	rjmp	.+134    	; 0x2728 <_Z16SendTimeDateGAVRhh+0x2f0>
							} else {
								printTimeDate(fFalse,fFalse,fTrue);
    26a2:	80 e0       	ldi	r24, 0x00	; 0
    26a4:	60 e0       	ldi	r22, 0x00	; 0
    26a6:	41 e0       	ldi	r20, 0x01	; 1
    26a8:	0e 94 cc 09 	call	0x1398	; 0x1398 <_Z13printTimeDatehhh>
								PutUartChGAVR('.');
    26ac:	8e e2       	ldi	r24, 0x2E	; 46
    26ae:	0e 94 2b 08 	call	0x1056	; 0x1056 <_Z13PutUartChGAVRc>
								strcpy(sentString,currentTime.getDate());
    26b2:	85 e8       	ldi	r24, 0x85	; 133
    26b4:	91 e0       	ldi	r25, 0x01	; 1
    26b6:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate7getDateEv>
    26ba:	9c 01       	movw	r18, r24
    26bc:	ce 01       	movw	r24, r28
    26be:	0c 96       	adiw	r24, 0x0c	; 12
    26c0:	b9 01       	movw	r22, r18
    26c2:	0e 94 5d 15 	call	0x2aba	; 0x2aba <strcpy>
    26c6:	30 c0       	rjmp	.+96     	; 0x2728 <_Z16SendTimeDateGAVRhh+0x2f0>
							}													
						} else {state=0;}
    26c8:	1f 82       	std	Y+7, r1	; 0x07
    26ca:	1e 82       	std	Y+6, r1	; 0x06
    26cc:	2d c0       	rjmp	.+90     	; 0x2728 <_Z16SendTimeDateGAVRhh+0x2f0>
					} //endif carriage
					else {
						recString[strLoc++]=recChar;
    26ce:	ce 01       	movw	r24, r28
    26d0:	86 5b       	subi	r24, 0xB6	; 182
    26d2:	9f 4f       	sbci	r25, 0xFF	; 255
    26d4:	fc 01       	movw	r30, r24
    26d6:	80 81       	ld	r24, Z
    26d8:	91 81       	ldd	r25, Z+1	; 0x01
    26da:	9e 01       	movw	r18, r28
    26dc:	24 5d       	subi	r18, 0xD4	; 212
    26de:	3f 4f       	sbci	r19, 0xFF	; 255
    26e0:	28 0f       	add	r18, r24
    26e2:	39 1f       	adc	r19, r25
    26e4:	4c 81       	ldd	r20, Y+4	; 0x04
    26e6:	f9 01       	movw	r30, r18
    26e8:	40 83       	st	Z, r20
    26ea:	9c 01       	movw	r18, r24
    26ec:	2f 5f       	subi	r18, 0xFF	; 255
    26ee:	3f 4f       	sbci	r19, 0xFF	; 255
    26f0:	ce 01       	movw	r24, r28
    26f2:	86 5b       	subi	r24, 0xB6	; 182
    26f4:	9f 4f       	sbci	r25, 0xFF	; 255
    26f6:	fc 01       	movw	r30, r24
    26f8:	31 83       	std	Z+1, r19	; 0x01
    26fa:	20 83       	st	Z, r18
						if (strLoc >= 30){strLoc=0; noCarriage=fFalse; state=0;}
    26fc:	ce 01       	movw	r24, r28
    26fe:	86 5b       	subi	r24, 0xB6	; 182
    2700:	9f 4f       	sbci	r25, 0xFF	; 255
    2702:	fc 01       	movw	r30, r24
    2704:	80 81       	ld	r24, Z
    2706:	91 81       	ldd	r25, Z+1	; 0x01
    2708:	21 e0       	ldi	r18, 0x01	; 1
    270a:	8e 31       	cpi	r24, 0x1E	; 30
    270c:	91 05       	cpc	r25, r1
    270e:	0c f4       	brge	.+2      	; 0x2712 <_Z16SendTimeDateGAVRhh+0x2da>
    2710:	20 e0       	ldi	r18, 0x00	; 0
    2712:	22 23       	and	r18, r18
    2714:	49 f0       	breq	.+18     	; 0x2728 <_Z16SendTimeDateGAVRhh+0x2f0>
    2716:	ce 01       	movw	r24, r28
    2718:	86 5b       	subi	r24, 0xB6	; 182
    271a:	9f 4f       	sbci	r25, 0xFF	; 255
    271c:	fc 01       	movw	r30, r24
    271e:	11 82       	std	Z+1, r1	; 0x01
    2720:	10 82       	st	Z, r1
    2722:	1a 82       	std	Y+2, r1	; 0x02
    2724:	1f 82       	std	Y+7, r1	; 0x07
    2726:	1e 82       	std	Y+6, r1	; 0x06
			} case 1: {
				char recChar, recString[30];
				volatile int strLoc=0;
				BOOL noCarriage=fTrue;
				//We sent an interrupt, need to get an ACKW back now.
				while (noCarriage && noTimeout){
    2728:	8a 81       	ldd	r24, Y+2	; 0x02
    272a:	88 23       	and	r24, r24
    272c:	31 f0       	breq	.+12     	; 0x273a <_Z16SendTimeDateGAVRhh+0x302>
    272e:	80 91 79 01 	lds	r24, 0x0179
    2732:	88 23       	and	r24, r24
    2734:	11 f0       	breq	.+4      	; 0x273a <_Z16SendTimeDateGAVRhh+0x302>
    2736:	81 e0       	ldi	r24, 0x01	; 1
    2738:	01 c0       	rjmp	.+2      	; 0x273c <_Z16SendTimeDateGAVRhh+0x304>
    273a:	80 e0       	ldi	r24, 0x00	; 0
    273c:	88 23       	and	r24, r24
    273e:	09 f0       	breq	.+2      	; 0x2742 <_Z16SendTimeDateGAVRhh+0x30a>
    2740:	05 cf       	rjmp	.-502    	; 0x254c <_Z16SendTimeDateGAVRhh+0x114>
					else {
						recString[strLoc++]=recChar;
						if (strLoc >= 30){strLoc=0; noCarriage=fFalse; state=0;}
					} //end normal char else
				} //end receiving part
				break;//end case 1
    2742:	b4 c0       	rjmp	.+360    	; 0x28ac <_Z16SendTimeDateGAVRhh+0x474>
			} case 2: { //Need to get ACK with the date and/or time.
				char recString[30];
				char recChar;
				volatile int strLoc=0;
    2744:	ce 01       	movw	r24, r28
    2746:	86 59       	subi	r24, 0x96	; 150
    2748:	9f 4f       	sbci	r25, 0xFF	; 255
    274a:	fc 01       	movw	r30, r24
    274c:	11 82       	std	Z+1, r1	; 0x01
    274e:	10 82       	st	Z, r1
				BOOL noCarriage=fTrue;
    2750:	81 e0       	ldi	r24, 0x01	; 1
    2752:	8b 83       	std	Y+3, r24	; 0x03
				char noGoodString[30];
				strcpy(noGoodString,"ACKnogood");
    2754:	ce 01       	movw	r24, r28
    2756:	84 59       	subi	r24, 0x94	; 148
    2758:	9f 4f       	sbci	r25, 0xFF	; 255
    275a:	27 e6       	ldi	r18, 0x67	; 103
    275c:	31 e0       	ldi	r19, 0x01	; 1
    275e:	4a e0       	ldi	r20, 0x0A	; 10
    2760:	f9 01       	movw	r30, r18
    2762:	00 80       	ld	r0, Z
    2764:	2f 5f       	subi	r18, 0xFF	; 255
    2766:	3f 4f       	sbci	r19, 0xFF	; 255
    2768:	fc 01       	movw	r30, r24
    276a:	00 82       	st	Z, r0
    276c:	01 96       	adiw	r24, 0x01	; 1
    276e:	41 50       	subi	r20, 0x01	; 1
    2770:	44 23       	and	r20, r20
    2772:	b1 f7       	brne	.-20     	; 0x2760 <_Z16SendTimeDateGAVRhh+0x328>
				strcat(noGoodString,sentString);
    2774:	ce 01       	movw	r24, r28
    2776:	84 59       	subi	r24, 0x94	; 148
    2778:	9f 4f       	sbci	r25, 0xFF	; 255
    277a:	9e 01       	movw	r18, r28
    277c:	24 5f       	subi	r18, 0xF4	; 244
    277e:	3f 4f       	sbci	r19, 0xFF	; 255
    2780:	b9 01       	movw	r22, r18
    2782:	0e 94 49 15 	call	0x2a92	; 0x2a92 <strcat>
				//get the ack
				while (noCarriage && noTimeout){
    2786:	81 c0       	rjmp	.+258    	; 0x288a <_Z16SendTimeDateGAVRhh+0x452>
					while (!(UCSR1A & (1 << RXC1)) && noTimeout);
    2788:	00 00       	nop
    278a:	88 ec       	ldi	r24, 0xC8	; 200
    278c:	90 e0       	ldi	r25, 0x00	; 0
    278e:	fc 01       	movw	r30, r24
    2790:	80 81       	ld	r24, Z
    2792:	88 23       	and	r24, r24
    2794:	34 f0       	brlt	.+12     	; 0x27a2 <_Z16SendTimeDateGAVRhh+0x36a>
    2796:	80 91 79 01 	lds	r24, 0x0179
    279a:	88 23       	and	r24, r24
    279c:	11 f0       	breq	.+4      	; 0x27a2 <_Z16SendTimeDateGAVRhh+0x36a>
    279e:	81 e0       	ldi	r24, 0x01	; 1
    27a0:	01 c0       	rjmp	.+2      	; 0x27a4 <_Z16SendTimeDateGAVRhh+0x36c>
    27a2:	80 e0       	ldi	r24, 0x00	; 0
    27a4:	88 23       	and	r24, r24
    27a6:	89 f7       	brne	.-30     	; 0x278a <_Z16SendTimeDateGAVRhh+0x352>
					recChar=UDR1;
    27a8:	8e ec       	ldi	r24, 0xCE	; 206
    27aa:	90 e0       	ldi	r25, 0x00	; 0
    27ac:	fc 01       	movw	r30, r24
    27ae:	80 81       	ld	r24, Z
    27b0:	8d 83       	std	Y+5, r24	; 0x05
					if (recChar=='.'){
    27b2:	8d 81       	ldd	r24, Y+5	; 0x05
    27b4:	8e 32       	cpi	r24, 0x2E	; 46
    27b6:	e1 f5       	brne	.+120    	; 0x2830 <_Z16SendTimeDateGAVRhh+0x3f8>
						recString[strLoc]='\0';
    27b8:	ce 01       	movw	r24, r28
    27ba:	86 59       	subi	r24, 0x96	; 150
    27bc:	9f 4f       	sbci	r25, 0xFF	; 255
    27be:	fc 01       	movw	r30, r24
    27c0:	80 81       	ld	r24, Z
    27c2:	91 81       	ldd	r25, Z+1	; 0x01
    27c4:	9e 01       	movw	r18, r28
    27c6:	24 5b       	subi	r18, 0xB4	; 180
    27c8:	3f 4f       	sbci	r19, 0xFF	; 255
    27ca:	82 0f       	add	r24, r18
    27cc:	93 1f       	adc	r25, r19
    27ce:	fc 01       	movw	r30, r24
    27d0:	10 82       	st	Z, r1
						noCarriage=fFalse;
    27d2:	1b 82       	std	Y+3, r1	; 0x03
						if (!strcmp(recString,sentString)){communicating=fFalse;}
    27d4:	ce 01       	movw	r24, r28
    27d6:	84 5b       	subi	r24, 0xB4	; 180
    27d8:	9f 4f       	sbci	r25, 0xFF	; 255
    27da:	9e 01       	movw	r18, r28
    27dc:	24 5f       	subi	r18, 0xF4	; 244
    27de:	3f 4f       	sbci	r19, 0xFF	; 255
    27e0:	b9 01       	movw	r22, r18
    27e2:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    27e6:	00 97       	sbiw	r24, 0x00	; 0
    27e8:	11 f4       	brne	.+4      	; 0x27ee <_Z16SendTimeDateGAVRhh+0x3b6>
    27ea:	19 82       	std	Y+1, r1	; 0x01
    27ec:	4e c0       	rjmp	.+156    	; 0x288a <_Z16SendTimeDateGAVRhh+0x452>
						else if (!strcmp(recString,noGoodString)){state=0;} //retry the send
    27ee:	ce 01       	movw	r24, r28
    27f0:	84 5b       	subi	r24, 0xB4	; 180
    27f2:	9f 4f       	sbci	r25, 0xFF	; 255
    27f4:	9e 01       	movw	r18, r28
    27f6:	24 59       	subi	r18, 0x94	; 148
    27f8:	3f 4f       	sbci	r19, 0xFF	; 255
    27fa:	b9 01       	movw	r22, r18
    27fc:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    2800:	00 97       	sbiw	r24, 0x00	; 0
    2802:	19 f4       	brne	.+6      	; 0x280a <_Z16SendTimeDateGAVRhh+0x3d2>
    2804:	1f 82       	std	Y+7, r1	; 0x07
    2806:	1e 82       	std	Y+6, r1	; 0x06
    2808:	40 c0       	rjmp	.+128    	; 0x288a <_Z16SendTimeDateGAVRhh+0x452>
						else if (!strcmp(recString,"ACKERROR")){communicating=fFalse; flagUpdateGAVRDate=fFalse; flagUpdateGAVRTime=fFalse;} //major error, User is going to get date and time and then send it back to this WAVR												 
    280a:	ce 01       	movw	r24, r28
    280c:	84 5b       	subi	r24, 0xB4	; 180
    280e:	9f 4f       	sbci	r25, 0xFF	; 255
    2810:	29 e5       	ldi	r18, 0x59	; 89
    2812:	31 e0       	ldi	r19, 0x01	; 1
    2814:	b9 01       	movw	r22, r18
    2816:	0e 94 54 15 	call	0x2aa8	; 0x2aa8 <strcmp>
    281a:	00 97       	sbiw	r24, 0x00	; 0
    281c:	31 f4       	brne	.+12     	; 0x282a <_Z16SendTimeDateGAVRhh+0x3f2>
    281e:	19 82       	std	Y+1, r1	; 0x01
    2820:	10 92 78 01 	sts	0x0178, r1
    2824:	10 92 77 01 	sts	0x0177, r1
    2828:	30 c0       	rjmp	.+96     	; 0x288a <_Z16SendTimeDateGAVRhh+0x452>
						
						else {state=0;}
    282a:	1f 82       	std	Y+7, r1	; 0x07
    282c:	1e 82       	std	Y+6, r1	; 0x06
    282e:	2d c0       	rjmp	.+90     	; 0x288a <_Z16SendTimeDateGAVRhh+0x452>
					} else {
						recString[strLoc++]=recChar;
    2830:	ce 01       	movw	r24, r28
    2832:	86 59       	subi	r24, 0x96	; 150
    2834:	9f 4f       	sbci	r25, 0xFF	; 255
    2836:	fc 01       	movw	r30, r24
    2838:	80 81       	ld	r24, Z
    283a:	91 81       	ldd	r25, Z+1	; 0x01
    283c:	9e 01       	movw	r18, r28
    283e:	24 5b       	subi	r18, 0xB4	; 180
    2840:	3f 4f       	sbci	r19, 0xFF	; 255
    2842:	28 0f       	add	r18, r24
    2844:	39 1f       	adc	r19, r25
    2846:	4d 81       	ldd	r20, Y+5	; 0x05
    2848:	f9 01       	movw	r30, r18
    284a:	40 83       	st	Z, r20
    284c:	9c 01       	movw	r18, r24
    284e:	2f 5f       	subi	r18, 0xFF	; 255
    2850:	3f 4f       	sbci	r19, 0xFF	; 255
    2852:	ce 01       	movw	r24, r28
    2854:	86 59       	subi	r24, 0x96	; 150
    2856:	9f 4f       	sbci	r25, 0xFF	; 255
    2858:	fc 01       	movw	r30, r24
    285a:	31 83       	std	Z+1, r19	; 0x01
    285c:	20 83       	st	Z, r18
						if (strLoc > 30){strLoc=0; state=0; noCarriage=fFalse;}
    285e:	ce 01       	movw	r24, r28
    2860:	86 59       	subi	r24, 0x96	; 150
    2862:	9f 4f       	sbci	r25, 0xFF	; 255
    2864:	fc 01       	movw	r30, r24
    2866:	80 81       	ld	r24, Z
    2868:	91 81       	ldd	r25, Z+1	; 0x01
    286a:	21 e0       	ldi	r18, 0x01	; 1
    286c:	8f 31       	cpi	r24, 0x1F	; 31
    286e:	91 05       	cpc	r25, r1
    2870:	0c f4       	brge	.+2      	; 0x2874 <_Z16SendTimeDateGAVRhh+0x43c>
    2872:	20 e0       	ldi	r18, 0x00	; 0
    2874:	22 23       	and	r18, r18
    2876:	49 f0       	breq	.+18     	; 0x288a <_Z16SendTimeDateGAVRhh+0x452>
    2878:	ce 01       	movw	r24, r28
    287a:	86 59       	subi	r24, 0x96	; 150
    287c:	9f 4f       	sbci	r25, 0xFF	; 255
    287e:	fc 01       	movw	r30, r24
    2880:	11 82       	std	Z+1, r1	; 0x01
    2882:	10 82       	st	Z, r1
    2884:	1f 82       	std	Y+7, r1	; 0x07
    2886:	1e 82       	std	Y+6, r1	; 0x06
    2888:	1b 82       	std	Y+3, r1	; 0x03
				BOOL noCarriage=fTrue;
				char noGoodString[30];
				strcpy(noGoodString,"ACKnogood");
				strcat(noGoodString,sentString);
				//get the ack
				while (noCarriage && noTimeout){
    288a:	8b 81       	ldd	r24, Y+3	; 0x03
    288c:	88 23       	and	r24, r24
    288e:	31 f0       	breq	.+12     	; 0x289c <_Z16SendTimeDateGAVRhh+0x464>
    2890:	80 91 79 01 	lds	r24, 0x0179
    2894:	88 23       	and	r24, r24
    2896:	11 f0       	breq	.+4      	; 0x289c <_Z16SendTimeDateGAVRhh+0x464>
    2898:	81 e0       	ldi	r24, 0x01	; 1
    289a:	01 c0       	rjmp	.+2      	; 0x289e <_Z16SendTimeDateGAVRhh+0x466>
    289c:	80 e0       	ldi	r24, 0x00	; 0
    289e:	88 23       	and	r24, r24
    28a0:	09 f0       	breq	.+2      	; 0x28a4 <_Z16SendTimeDateGAVRhh+0x46c>
    28a2:	72 cf       	rjmp	.-284    	; 0x2788 <_Z16SendTimeDateGAVRhh+0x350>
					} else {
						recString[strLoc++]=recChar;
						if (strLoc > 30){strLoc=0; state=0; noCarriage=fFalse;}
					}
				}
				break;
    28a4:	03 c0       	rjmp	.+6      	; 0x28ac <_Z16SendTimeDateGAVRhh+0x474>
			} //end case 2
			default: {state=0; break;}
    28a6:	1f 82       	std	Y+7, r1	; 0x07
    28a8:	1e 82       	std	Y+6, r1	; 0x06
    28aa:	00 00       	nop
		} //end switch
	if (beginningSecond != endingSecond){noTimeout=fTrue;}
    28ac:	28 85       	ldd	r18, Y+8	; 0x08
    28ae:	39 85       	ldd	r19, Y+9	; 0x09
    28b0:	8a 85       	ldd	r24, Y+10	; 0x0a
    28b2:	9b 85       	ldd	r25, Y+11	; 0x0b
    28b4:	41 e0       	ldi	r20, 0x01	; 1
    28b6:	28 17       	cp	r18, r24
    28b8:	39 07       	cpc	r19, r25
    28ba:	09 f4       	brne	.+2      	; 0x28be <_Z16SendTimeDateGAVRhh+0x486>
    28bc:	40 e0       	ldi	r20, 0x00	; 0
    28be:	44 23       	and	r20, r20
    28c0:	21 f0       	breq	.+8      	; 0x28ca <_Z16SendTimeDateGAVRhh+0x492>
    28c2:	81 e0       	ldi	r24, 0x01	; 1
    28c4:	80 93 79 01 	sts	0x0179, r24
    28c8:	02 c0       	rjmp	.+4      	; 0x28ce <_Z16SendTimeDateGAVRhh+0x496>
	else {noTimeout=fFalse;}
    28ca:	10 92 79 01 	sts	0x0179, r1
	char sentString[30];	//string that was sent, need it for error checking
	//Make sure we should be sending something
	if (sTime || sDate){communicating=fTrue;}
	else {communicating=fFalse;}
	//Main sending  loop
	while(communicating && noTimeout){
    28ce:	89 81       	ldd	r24, Y+1	; 0x01
    28d0:	88 23       	and	r24, r24
    28d2:	31 f0       	breq	.+12     	; 0x28e0 <_Z16SendTimeDateGAVRhh+0x4a8>
    28d4:	80 91 79 01 	lds	r24, 0x0179
    28d8:	88 23       	and	r24, r24
    28da:	11 f0       	breq	.+4      	; 0x28e0 <_Z16SendTimeDateGAVRhh+0x4a8>
    28dc:	81 e0       	ldi	r24, 0x01	; 1
    28de:	01 c0       	rjmp	.+2      	; 0x28e2 <_Z16SendTimeDateGAVRhh+0x4aa>
    28e0:	80 e0       	ldi	r24, 0x00	; 0
    28e2:	88 23       	and	r24, r24
    28e4:	09 f0       	breq	.+2      	; 0x28e8 <_Z16SendTimeDateGAVRhh+0x4b0>
    28e6:	f5 cd       	rjmp	.-1046   	; 0x24d2 <_Z16SendTimeDateGAVRhh+0x9a>
			default: {state=0; break;}
		} //end switch
	if (beginningSecond != endingSecond){noTimeout=fTrue;}
	else {noTimeout=fFalse;}
	}//end communicationg	
	if (noTimeout){
    28e8:	90 91 79 01 	lds	r25, 0x0179
    28ec:	81 e0       	ldi	r24, 0x01	; 1
    28ee:	99 23       	and	r25, r25
    28f0:	09 f4       	brne	.+2      	; 0x28f4 <_Z16SendTimeDateGAVRhh+0x4bc>
    28f2:	80 e0       	ldi	r24, 0x00	; 0
    28f4:	88 23       	and	r24, r24
    28f6:	a1 f1       	breq	.+104    	; 0x2960 <_Z16SendTimeDateGAVRhh+0x528>
		if (sDate && sTime){flagUpdateGAVRDate=fFalse; flagUpdateGAVRTime=fFalse;}
    28f8:	ce 01       	movw	r24, r28
    28fa:	85 57       	subi	r24, 0x75	; 117
    28fc:	9f 4f       	sbci	r25, 0xFF	; 255
    28fe:	fc 01       	movw	r30, r24
    2900:	80 81       	ld	r24, Z
    2902:	88 23       	and	r24, r24
    2904:	61 f0       	breq	.+24     	; 0x291e <_Z16SendTimeDateGAVRhh+0x4e6>
    2906:	ce 01       	movw	r24, r28
    2908:	86 57       	subi	r24, 0x76	; 118
    290a:	9f 4f       	sbci	r25, 0xFF	; 255
    290c:	fc 01       	movw	r30, r24
    290e:	80 81       	ld	r24, Z
    2910:	88 23       	and	r24, r24
    2912:	29 f0       	breq	.+10     	; 0x291e <_Z16SendTimeDateGAVRhh+0x4e6>
    2914:	10 92 78 01 	sts	0x0178, r1
    2918:	10 92 77 01 	sts	0x0177, r1
    291c:	21 c0       	rjmp	.+66     	; 0x2960 <_Z16SendTimeDateGAVRhh+0x528>
		else if (sDate && !sTime){flagUpdateGAVRDate=fFalse;}
    291e:	ce 01       	movw	r24, r28
    2920:	85 57       	subi	r24, 0x75	; 117
    2922:	9f 4f       	sbci	r25, 0xFF	; 255
    2924:	fc 01       	movw	r30, r24
    2926:	80 81       	ld	r24, Z
    2928:	88 23       	and	r24, r24
    292a:	51 f0       	breq	.+20     	; 0x2940 <_Z16SendTimeDateGAVRhh+0x508>
    292c:	ce 01       	movw	r24, r28
    292e:	86 57       	subi	r24, 0x76	; 118
    2930:	9f 4f       	sbci	r25, 0xFF	; 255
    2932:	fc 01       	movw	r30, r24
    2934:	80 81       	ld	r24, Z
    2936:	88 23       	and	r24, r24
    2938:	19 f4       	brne	.+6      	; 0x2940 <_Z16SendTimeDateGAVRhh+0x508>
    293a:	10 92 78 01 	sts	0x0178, r1
    293e:	10 c0       	rjmp	.+32     	; 0x2960 <_Z16SendTimeDateGAVRhh+0x528>
		else if (sTime && !sDate){flagUpdateGAVRTime=fFalse;}
    2940:	ce 01       	movw	r24, r28
    2942:	86 57       	subi	r24, 0x76	; 118
    2944:	9f 4f       	sbci	r25, 0xFF	; 255
    2946:	fc 01       	movw	r30, r24
    2948:	80 81       	ld	r24, Z
    294a:	88 23       	and	r24, r24
    294c:	49 f0       	breq	.+18     	; 0x2960 <_Z16SendTimeDateGAVRhh+0x528>
    294e:	ce 01       	movw	r24, r28
    2950:	85 57       	subi	r24, 0x75	; 117
    2952:	9f 4f       	sbci	r25, 0xFF	; 255
    2954:	fc 01       	movw	r30, r24
    2956:	80 81       	ld	r24, Z
    2958:	88 23       	and	r24, r24
    295a:	11 f4       	brne	.+4      	; 0x2960 <_Z16SendTimeDateGAVRhh+0x528>
    295c:	10 92 77 01 	sts	0x0177, r1
		else;
	} else;
	prtSLEEPled &= ~(1 << bnSLEEPled);
    2960:	8b e2       	ldi	r24, 0x2B	; 43
    2962:	90 e0       	ldi	r25, 0x00	; 0
    2964:	2b e2       	ldi	r18, 0x2B	; 43
    2966:	30 e0       	ldi	r19, 0x00	; 0
    2968:	f9 01       	movw	r30, r18
    296a:	20 81       	ld	r18, Z
    296c:	2f 77       	andi	r18, 0x7F	; 127
    296e:	fc 01       	movw	r30, r24
    2970:	20 83       	st	Z, r18
	flagSendingGAVR=fFalse;			
    2972:	10 92 7a 01 	sts	0x017A, r1
} //end function
    2976:	c5 57       	subi	r28, 0x75	; 117
    2978:	df 4f       	sbci	r29, 0xFF	; 255
    297a:	0f b6       	in	r0, 0x3f	; 63
    297c:	f8 94       	cli
    297e:	de bf       	out	0x3e, r29	; 62
    2980:	0f be       	out	0x3f, r0	; 63
    2982:	cd bf       	out	0x3d, r28	; 61
    2984:	df 91       	pop	r29
    2986:	cf 91       	pop	r28
    2988:	08 95       	ret

0000298a <_Z41__static_initialization_and_destruction_0ii>:
    298a:	cf 93       	push	r28
    298c:	df 93       	push	r29
    298e:	00 d0       	rcall	.+0      	; 0x2990 <_Z41__static_initialization_and_destruction_0ii+0x6>
    2990:	00 d0       	rcall	.+0      	; 0x2992 <_Z41__static_initialization_and_destruction_0ii+0x8>
    2992:	cd b7       	in	r28, 0x3d	; 61
    2994:	de b7       	in	r29, 0x3e	; 62
    2996:	9a 83       	std	Y+2, r25	; 0x02
    2998:	89 83       	std	Y+1, r24	; 0x01
    299a:	7c 83       	std	Y+4, r23	; 0x04
    299c:	6b 83       	std	Y+3, r22	; 0x03
    299e:	89 81       	ldd	r24, Y+1	; 0x01
    29a0:	9a 81       	ldd	r25, Y+2	; 0x02
    29a2:	81 30       	cpi	r24, 0x01	; 1
    29a4:	91 05       	cpc	r25, r1
    29a6:	51 f4       	brne	.+20     	; 0x29bc <_Z41__static_initialization_and_destruction_0ii+0x32>
    29a8:	8b 81       	ldd	r24, Y+3	; 0x03
    29aa:	9c 81       	ldd	r25, Y+4	; 0x04
    29ac:	2f ef       	ldi	r18, 0xFF	; 255
    29ae:	8f 3f       	cpi	r24, 0xFF	; 255
    29b0:	92 07       	cpc	r25, r18
    29b2:	21 f4       	brne	.+8      	; 0x29bc <_Z41__static_initialization_and_destruction_0ii+0x32>
volatile BOOL flagUpdateGAVRTime, flagUpdateGAVRDate, noTimeout;
BOOL flagSendingGAVR;
volatile BOOL flagNewShutdown, flagShutdown,flagGoodTemp, flagGoodVolts, restart,flagFreshStart;
volatile WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    29b4:	85 e8       	ldi	r24, 0x85	; 133
    29b6:	91 e0       	ldi	r25, 0x01	; 1
    29b8:	0e 94 91 03 	call	0x722	; 0x722 <_ZN6myTimeC1Ev>
		else if (sTime && !sDate){flagUpdateGAVRTime=fFalse;}
		else;
	} else;
	prtSLEEPled &= ~(1 << bnSLEEPled);
	flagSendingGAVR=fFalse;			
} //end function
    29bc:	0f 90       	pop	r0
    29be:	0f 90       	pop	r0
    29c0:	0f 90       	pop	r0
    29c2:	0f 90       	pop	r0
    29c4:	df 91       	pop	r29
    29c6:	cf 91       	pop	r28
    29c8:	08 95       	ret

000029ca <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    29ca:	cf 93       	push	r28
    29cc:	df 93       	push	r29
    29ce:	cd b7       	in	r28, 0x3d	; 61
    29d0:	de b7       	in	r29, 0x3e	; 62
    29d2:	81 e0       	ldi	r24, 0x01	; 1
    29d4:	90 e0       	ldi	r25, 0x00	; 0
    29d6:	6f ef       	ldi	r22, 0xFF	; 255
    29d8:	7f ef       	ldi	r23, 0xFF	; 255
    29da:	0e 94 c5 14 	call	0x298a	; 0x298a <_Z41__static_initialization_and_destruction_0ii>
    29de:	df 91       	pop	r29
    29e0:	cf 91       	pop	r28
    29e2:	08 95       	ret

000029e4 <__udivmodqi4>:
    29e4:	99 1b       	sub	r25, r25
    29e6:	79 e0       	ldi	r23, 0x09	; 9
    29e8:	04 c0       	rjmp	.+8      	; 0x29f2 <__udivmodqi4_ep>

000029ea <__udivmodqi4_loop>:
    29ea:	99 1f       	adc	r25, r25
    29ec:	96 17       	cp	r25, r22
    29ee:	08 f0       	brcs	.+2      	; 0x29f2 <__udivmodqi4_ep>
    29f0:	96 1b       	sub	r25, r22

000029f2 <__udivmodqi4_ep>:
    29f2:	88 1f       	adc	r24, r24
    29f4:	7a 95       	dec	r23
    29f6:	c9 f7       	brne	.-14     	; 0x29ea <__udivmodqi4_loop>
    29f8:	80 95       	com	r24
    29fa:	08 95       	ret

000029fc <__divmodhi4>:
    29fc:	97 fb       	bst	r25, 7
    29fe:	09 2e       	mov	r0, r25
    2a00:	07 26       	eor	r0, r23
    2a02:	0a d0       	rcall	.+20     	; 0x2a18 <__divmodhi4_neg1>
    2a04:	77 fd       	sbrc	r23, 7
    2a06:	04 d0       	rcall	.+8      	; 0x2a10 <__divmodhi4_neg2>
    2a08:	0c d0       	rcall	.+24     	; 0x2a22 <__udivmodhi4>
    2a0a:	06 d0       	rcall	.+12     	; 0x2a18 <__divmodhi4_neg1>
    2a0c:	00 20       	and	r0, r0
    2a0e:	1a f4       	brpl	.+6      	; 0x2a16 <__divmodhi4_exit>

00002a10 <__divmodhi4_neg2>:
    2a10:	70 95       	com	r23
    2a12:	61 95       	neg	r22
    2a14:	7f 4f       	sbci	r23, 0xFF	; 255

00002a16 <__divmodhi4_exit>:
    2a16:	08 95       	ret

00002a18 <__divmodhi4_neg1>:
    2a18:	f6 f7       	brtc	.-4      	; 0x2a16 <__divmodhi4_exit>
    2a1a:	90 95       	com	r25
    2a1c:	81 95       	neg	r24
    2a1e:	9f 4f       	sbci	r25, 0xFF	; 255
    2a20:	08 95       	ret

00002a22 <__udivmodhi4>:
    2a22:	aa 1b       	sub	r26, r26
    2a24:	bb 1b       	sub	r27, r27
    2a26:	51 e1       	ldi	r21, 0x11	; 17
    2a28:	07 c0       	rjmp	.+14     	; 0x2a38 <__udivmodhi4_ep>

00002a2a <__udivmodhi4_loop>:
    2a2a:	aa 1f       	adc	r26, r26
    2a2c:	bb 1f       	adc	r27, r27
    2a2e:	a6 17       	cp	r26, r22
    2a30:	b7 07       	cpc	r27, r23
    2a32:	10 f0       	brcs	.+4      	; 0x2a38 <__udivmodhi4_ep>
    2a34:	a6 1b       	sub	r26, r22
    2a36:	b7 0b       	sbc	r27, r23

00002a38 <__udivmodhi4_ep>:
    2a38:	88 1f       	adc	r24, r24
    2a3a:	99 1f       	adc	r25, r25
    2a3c:	5a 95       	dec	r21
    2a3e:	a9 f7       	brne	.-22     	; 0x2a2a <__udivmodhi4_loop>
    2a40:	80 95       	com	r24
    2a42:	90 95       	com	r25
    2a44:	bc 01       	movw	r22, r24
    2a46:	cd 01       	movw	r24, r26
    2a48:	08 95       	ret

00002a4a <__tablejump2__>:
    2a4a:	ee 0f       	add	r30, r30
    2a4c:	ff 1f       	adc	r31, r31

00002a4e <__tablejump__>:
    2a4e:	05 90       	lpm	r0, Z+
    2a50:	f4 91       	lpm	r31, Z
    2a52:	e0 2d       	mov	r30, r0
    2a54:	09 94       	ijmp

00002a56 <atoi>:
    2a56:	fc 01       	movw	r30, r24
    2a58:	88 27       	eor	r24, r24
    2a5a:	99 27       	eor	r25, r25
    2a5c:	e8 94       	clt
    2a5e:	21 91       	ld	r18, Z+
    2a60:	20 32       	cpi	r18, 0x20	; 32
    2a62:	e9 f3       	breq	.-6      	; 0x2a5e <atoi+0x8>
    2a64:	29 30       	cpi	r18, 0x09	; 9
    2a66:	10 f0       	brcs	.+4      	; 0x2a6c <atoi+0x16>
    2a68:	2e 30       	cpi	r18, 0x0E	; 14
    2a6a:	c8 f3       	brcs	.-14     	; 0x2a5e <atoi+0x8>
    2a6c:	2b 32       	cpi	r18, 0x2B	; 43
    2a6e:	41 f0       	breq	.+16     	; 0x2a80 <atoi+0x2a>
    2a70:	2d 32       	cpi	r18, 0x2D	; 45
    2a72:	39 f4       	brne	.+14     	; 0x2a82 <atoi+0x2c>
    2a74:	68 94       	set
    2a76:	04 c0       	rjmp	.+8      	; 0x2a80 <atoi+0x2a>
    2a78:	0e 94 85 15 	call	0x2b0a	; 0x2b0a <__mulhi_const_10>
    2a7c:	82 0f       	add	r24, r18
    2a7e:	91 1d       	adc	r25, r1
    2a80:	21 91       	ld	r18, Z+
    2a82:	20 53       	subi	r18, 0x30	; 48
    2a84:	2a 30       	cpi	r18, 0x0A	; 10
    2a86:	c0 f3       	brcs	.-16     	; 0x2a78 <atoi+0x22>
    2a88:	1e f4       	brtc	.+6      	; 0x2a90 <atoi+0x3a>
    2a8a:	90 95       	com	r25
    2a8c:	81 95       	neg	r24
    2a8e:	9f 4f       	sbci	r25, 0xFF	; 255
    2a90:	08 95       	ret

00002a92 <strcat>:
    2a92:	fb 01       	movw	r30, r22
    2a94:	dc 01       	movw	r26, r24
    2a96:	0d 90       	ld	r0, X+
    2a98:	00 20       	and	r0, r0
    2a9a:	e9 f7       	brne	.-6      	; 0x2a96 <strcat+0x4>
    2a9c:	11 97       	sbiw	r26, 0x01	; 1
    2a9e:	01 90       	ld	r0, Z+
    2aa0:	0d 92       	st	X+, r0
    2aa2:	00 20       	and	r0, r0
    2aa4:	e1 f7       	brne	.-8      	; 0x2a9e <strcat+0xc>
    2aa6:	08 95       	ret

00002aa8 <strcmp>:
    2aa8:	fb 01       	movw	r30, r22
    2aaa:	dc 01       	movw	r26, r24
    2aac:	8d 91       	ld	r24, X+
    2aae:	01 90       	ld	r0, Z+
    2ab0:	80 19       	sub	r24, r0
    2ab2:	01 10       	cpse	r0, r1
    2ab4:	d9 f3       	breq	.-10     	; 0x2aac <strcmp+0x4>
    2ab6:	99 0b       	sbc	r25, r25
    2ab8:	08 95       	ret

00002aba <strcpy>:
    2aba:	fb 01       	movw	r30, r22
    2abc:	dc 01       	movw	r26, r24
    2abe:	01 90       	ld	r0, Z+
    2ac0:	0d 92       	st	X+, r0
    2ac2:	00 20       	and	r0, r0
    2ac4:	e1 f7       	brne	.-8      	; 0x2abe <strcpy+0x4>
    2ac6:	08 95       	ret

00002ac8 <itoa>:
    2ac8:	fb 01       	movw	r30, r22
    2aca:	9f 01       	movw	r18, r30
    2acc:	e8 94       	clt
    2ace:	42 30       	cpi	r20, 0x02	; 2
    2ad0:	c4 f0       	brlt	.+48     	; 0x2b02 <itoa+0x3a>
    2ad2:	45 32       	cpi	r20, 0x25	; 37
    2ad4:	b4 f4       	brge	.+44     	; 0x2b02 <itoa+0x3a>
    2ad6:	4a 30       	cpi	r20, 0x0A	; 10
    2ad8:	29 f4       	brne	.+10     	; 0x2ae4 <itoa+0x1c>
    2ada:	97 fb       	bst	r25, 7
    2adc:	1e f4       	brtc	.+6      	; 0x2ae4 <itoa+0x1c>
    2ade:	90 95       	com	r25
    2ae0:	81 95       	neg	r24
    2ae2:	9f 4f       	sbci	r25, 0xFF	; 255
    2ae4:	64 2f       	mov	r22, r20
    2ae6:	77 27       	eor	r23, r23
    2ae8:	0e 94 11 15 	call	0x2a22	; 0x2a22 <__udivmodhi4>
    2aec:	80 5d       	subi	r24, 0xD0	; 208
    2aee:	8a 33       	cpi	r24, 0x3A	; 58
    2af0:	0c f0       	brlt	.+2      	; 0x2af4 <itoa+0x2c>
    2af2:	89 5d       	subi	r24, 0xD9	; 217
    2af4:	81 93       	st	Z+, r24
    2af6:	cb 01       	movw	r24, r22
    2af8:	00 97       	sbiw	r24, 0x00	; 0
    2afa:	a1 f7       	brne	.-24     	; 0x2ae4 <itoa+0x1c>
    2afc:	16 f4       	brtc	.+4      	; 0x2b02 <itoa+0x3a>
    2afe:	5d e2       	ldi	r21, 0x2D	; 45
    2b00:	51 93       	st	Z+, r21
    2b02:	10 82       	st	Z, r1
    2b04:	c9 01       	movw	r24, r18
    2b06:	0c 94 ae 15 	jmp	0x2b5c	; 0x2b5c <strrev>

00002b0a <__mulhi_const_10>:
    2b0a:	7a e0       	ldi	r23, 0x0A	; 10
    2b0c:	97 9f       	mul	r25, r23
    2b0e:	90 2d       	mov	r25, r0
    2b10:	87 9f       	mul	r24, r23
    2b12:	80 2d       	mov	r24, r0
    2b14:	91 0d       	add	r25, r1
    2b16:	11 24       	eor	r1, r1
    2b18:	08 95       	ret

00002b1a <__eerd_byte_m324pa>:
    2b1a:	f9 99       	sbic	0x1f, 1	; 31
    2b1c:	fe cf       	rjmp	.-4      	; 0x2b1a <__eerd_byte_m324pa>
    2b1e:	92 bd       	out	0x22, r25	; 34
    2b20:	81 bd       	out	0x21, r24	; 33
    2b22:	f8 9a       	sbi	0x1f, 0	; 31
    2b24:	99 27       	eor	r25, r25
    2b26:	80 b5       	in	r24, 0x20	; 32
    2b28:	08 95       	ret

00002b2a <__eerd_word_m324pa>:
    2b2a:	a8 e1       	ldi	r26, 0x18	; 24
    2b2c:	b0 e0       	ldi	r27, 0x00	; 0
    2b2e:	42 e0       	ldi	r20, 0x02	; 2
    2b30:	50 e0       	ldi	r21, 0x00	; 0
    2b32:	0c 94 c0 15 	jmp	0x2b80	; 0x2b80 <__eerd_blraw_m324pa>

00002b36 <__eewr_byte_m324pa>:
    2b36:	26 2f       	mov	r18, r22

00002b38 <__eewr_r18_m324pa>:
    2b38:	f9 99       	sbic	0x1f, 1	; 31
    2b3a:	fe cf       	rjmp	.-4      	; 0x2b38 <__eewr_r18_m324pa>
    2b3c:	1f ba       	out	0x1f, r1	; 31
    2b3e:	92 bd       	out	0x22, r25	; 34
    2b40:	81 bd       	out	0x21, r24	; 33
    2b42:	20 bd       	out	0x20, r18	; 32
    2b44:	0f b6       	in	r0, 0x3f	; 63
    2b46:	f8 94       	cli
    2b48:	fa 9a       	sbi	0x1f, 2	; 31
    2b4a:	f9 9a       	sbi	0x1f, 1	; 31
    2b4c:	0f be       	out	0x3f, r0	; 63
    2b4e:	01 96       	adiw	r24, 0x01	; 1
    2b50:	08 95       	ret

00002b52 <__eewr_word_m324pa>:
    2b52:	0e 94 9b 15 	call	0x2b36	; 0x2b36 <__eewr_byte_m324pa>
    2b56:	27 2f       	mov	r18, r23
    2b58:	0c 94 9c 15 	jmp	0x2b38	; 0x2b38 <__eewr_r18_m324pa>

00002b5c <strrev>:
    2b5c:	dc 01       	movw	r26, r24
    2b5e:	fc 01       	movw	r30, r24
    2b60:	67 2f       	mov	r22, r23
    2b62:	71 91       	ld	r23, Z+
    2b64:	77 23       	and	r23, r23
    2b66:	e1 f7       	brne	.-8      	; 0x2b60 <strrev+0x4>
    2b68:	32 97       	sbiw	r30, 0x02	; 2
    2b6a:	04 c0       	rjmp	.+8      	; 0x2b74 <strrev+0x18>
    2b6c:	7c 91       	ld	r23, X
    2b6e:	6d 93       	st	X+, r22
    2b70:	70 83       	st	Z, r23
    2b72:	62 91       	ld	r22, -Z
    2b74:	ae 17       	cp	r26, r30
    2b76:	bf 07       	cpc	r27, r31
    2b78:	c8 f3       	brcs	.-14     	; 0x2b6c <strrev+0x10>
    2b7a:	08 95       	ret

00002b7c <__eerd_block_m324pa>:
    2b7c:	dc 01       	movw	r26, r24
    2b7e:	cb 01       	movw	r24, r22

00002b80 <__eerd_blraw_m324pa>:
    2b80:	fc 01       	movw	r30, r24
    2b82:	f9 99       	sbic	0x1f, 1	; 31
    2b84:	fe cf       	rjmp	.-4      	; 0x2b82 <__eerd_blraw_m324pa+0x2>
    2b86:	06 c0       	rjmp	.+12     	; 0x2b94 <__eerd_blraw_m324pa+0x14>
    2b88:	f2 bd       	out	0x22, r31	; 34
    2b8a:	e1 bd       	out	0x21, r30	; 33
    2b8c:	f8 9a       	sbi	0x1f, 0	; 31
    2b8e:	31 96       	adiw	r30, 0x01	; 1
    2b90:	00 b4       	in	r0, 0x20	; 32
    2b92:	0d 92       	st	X+, r0
    2b94:	41 50       	subi	r20, 0x01	; 1
    2b96:	50 40       	sbci	r21, 0x00	; 0
    2b98:	b8 f7       	brcc	.-18     	; 0x2b88 <__eerd_blraw_m324pa+0x8>
    2b9a:	08 95       	ret

00002b9c <_exit>:
    2b9c:	f8 94       	cli

00002b9e <__stop_program>:
    2b9e:	ff cf       	rjmp	.-2      	; 0x2b9e <__stop_program>
