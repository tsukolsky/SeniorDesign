
RTC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000050  00800100  0000290e  000029c2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000290e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000003f  00800150  00800150  00002a12  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  00002a12  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00001008  00000000  00000000  00002a1c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00000522  00000000  00000000  00003a24  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  00003f48  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001ece  00000000  00000000  00004068  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000381  00000000  00000000  00005f36  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000ca1  00000000  00000000  000062b7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000768  00000000  00000000  00006f58  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000009b1  00000000  00000000  000076c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00000fa5  00000000  00000000  00008071  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 f0 07 	jmp	0xfe0	; 0xfe0 <__vector_3>
      10:	0c 94 e0 07 	jmp	0xfc0	; 0xfc0 <__vector_4>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 31 08 	jmp	0x1062	; 0x1062 <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 ad 08 	jmp	0x115a	; 0x115a <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	9c 13       	cpse	r25, r28

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d8 e0       	ldi	r29, 0x08	; 8
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	ee e0       	ldi	r30, 0x0E	; 14
      92:	f9 e2       	ldi	r31, 0x29	; 41
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	a0 35       	cpi	r26, 0x50	; 80
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	11 e0       	ldi	r17, 0x01	; 1
      a2:	a0 e5       	ldi	r26, 0x50	; 80
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	af 38       	cpi	r26, 0x8F	; 143
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 de 13 	call	0x27bc	; 0x27bc <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 db 08 	call	0x11b6	; 0x11b6 <main>
      ca:	0c 94 85 14 	jmp	0x290a	; 0x290a <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
	
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	cd b7       	in	r28, 0x3d	; 61
     60a:	de b7       	in	r29, 0x3e	; 62
     60c:	2d 97       	sbiw	r28, 0x0d	; 13
     60e:	0f b6       	in	r0, 0x3f	; 63
     610:	f8 94       	cli
     612:	de bf       	out	0x3e, r29	; 62
     614:	0f be       	out	0x3f, r0	; 63
     616:	cd bf       	out	0x3d, r28	; 61
     618:	9d 87       	std	Y+13, r25	; 0x0d
     61a:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     61c:	8c 85       	ldd	r24, Y+12	; 0x0c
     61e:	9d 85       	ldd	r25, Y+13	; 0x0d
     620:	fc 01       	movw	r30, r24
     622:	80 81       	ld	r24, Z
     624:	91 81       	ldd	r25, Z+1	; 0x01
     626:	9e 01       	movw	r18, r28
     628:	2f 5f       	subi	r18, 0xFF	; 255
     62a:	3f 4f       	sbci	r19, 0xFF	; 255
     62c:	b9 01       	movw	r22, r18
     62e:	4a e0       	ldi	r20, 0x0A	; 10
     630:	50 e0       	ldi	r21, 0x00	; 0
     632:	0e 94 1b 14 	call	0x2836	; 0x2836 <itoa>
	itoa(day,dayString,10);
     636:	8c 85       	ldd	r24, Y+12	; 0x0c
     638:	9d 85       	ldd	r25, Y+13	; 0x0d
     63a:	fc 01       	movw	r30, r24
     63c:	82 81       	ldd	r24, Z+2	; 0x02
     63e:	93 81       	ldd	r25, Z+3	; 0x03
     640:	9e 01       	movw	r18, r28
     642:	2c 5f       	subi	r18, 0xFC	; 252
     644:	3f 4f       	sbci	r19, 0xFF	; 255
     646:	b9 01       	movw	r22, r18
     648:	4a e0       	ldi	r20, 0x0A	; 10
     64a:	50 e0       	ldi	r21, 0x00	; 0
     64c:	0e 94 1b 14 	call	0x2836	; 0x2836 <itoa>
	itoa(year,yearString,10);
     650:	8c 85       	ldd	r24, Y+12	; 0x0c
     652:	9d 85       	ldd	r25, Y+13	; 0x0d
     654:	fc 01       	movw	r30, r24
     656:	84 81       	ldd	r24, Z+4	; 0x04
     658:	95 81       	ldd	r25, Z+5	; 0x05
     65a:	9e 01       	movw	r18, r28
     65c:	29 5f       	subi	r18, 0xF9	; 249
     65e:	3f 4f       	sbci	r19, 0xFF	; 255
     660:	b9 01       	movw	r22, r18
     662:	4a e0       	ldi	r20, 0x0A	; 10
     664:	50 e0       	ldi	r21, 0x00	; 0
     666:	0e 94 1b 14 	call	0x2836	; 0x2836 <itoa>
	strcpy(dateString,monthString);
     66a:	8c 85       	ldd	r24, Y+12	; 0x0c
     66c:	9d 85       	ldd	r25, Y+13	; 0x0d
     66e:	06 96       	adiw	r24, 0x06	; 6
     670:	9e 01       	movw	r18, r28
     672:	2f 5f       	subi	r18, 0xFF	; 255
     674:	3f 4f       	sbci	r19, 0xFF	; 255
     676:	b9 01       	movw	r22, r18
     678:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
	strcat(dateString,",");
     67c:	8c 85       	ldd	r24, Y+12	; 0x0c
     67e:	9d 85       	ldd	r25, Y+13	; 0x0d
     680:	9c 01       	movw	r18, r24
     682:	2a 5f       	subi	r18, 0xFA	; 250
     684:	3f 4f       	sbci	r19, 0xFF	; 255
     686:	c9 01       	movw	r24, r18
     688:	ac 01       	movw	r20, r24
     68a:	fa 01       	movw	r30, r20
     68c:	01 90       	ld	r0, Z+
     68e:	00 20       	and	r0, r0
     690:	e9 f7       	brne	.-6      	; 0x68c <_ZN6myDate7getDateEv+0x88>
     692:	cf 01       	movw	r24, r30
     694:	01 97       	sbiw	r24, 0x01	; 1
     696:	84 1b       	sub	r24, r20
     698:	95 0b       	sbc	r25, r21
     69a:	82 0f       	add	r24, r18
     69c:	93 1f       	adc	r25, r19
     69e:	2c e2       	ldi	r18, 0x2C	; 44
     6a0:	30 e0       	ldi	r19, 0x00	; 0
     6a2:	fc 01       	movw	r30, r24
     6a4:	31 83       	std	Z+1, r19	; 0x01
     6a6:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     6a8:	8c 85       	ldd	r24, Y+12	; 0x0c
     6aa:	9d 85       	ldd	r25, Y+13	; 0x0d
     6ac:	06 96       	adiw	r24, 0x06	; 6
     6ae:	9e 01       	movw	r18, r28
     6b0:	2c 5f       	subi	r18, 0xFC	; 252
     6b2:	3f 4f       	sbci	r19, 0xFF	; 255
     6b4:	b9 01       	movw	r22, r18
     6b6:	0e 94 00 14 	call	0x2800	; 0x2800 <strcat>
	strcat(dateString,",");
     6ba:	8c 85       	ldd	r24, Y+12	; 0x0c
     6bc:	9d 85       	ldd	r25, Y+13	; 0x0d
     6be:	9c 01       	movw	r18, r24
     6c0:	2a 5f       	subi	r18, 0xFA	; 250
     6c2:	3f 4f       	sbci	r19, 0xFF	; 255
     6c4:	c9 01       	movw	r24, r18
     6c6:	ac 01       	movw	r20, r24
     6c8:	fa 01       	movw	r30, r20
     6ca:	01 90       	ld	r0, Z+
     6cc:	00 20       	and	r0, r0
     6ce:	e9 f7       	brne	.-6      	; 0x6ca <_ZN6myDate7getDateEv+0xc6>
     6d0:	cf 01       	movw	r24, r30
     6d2:	01 97       	sbiw	r24, 0x01	; 1
     6d4:	84 1b       	sub	r24, r20
     6d6:	95 0b       	sbc	r25, r21
     6d8:	82 0f       	add	r24, r18
     6da:	93 1f       	adc	r25, r19
     6dc:	2c e2       	ldi	r18, 0x2C	; 44
     6de:	30 e0       	ldi	r19, 0x00	; 0
     6e0:	fc 01       	movw	r30, r24
     6e2:	31 83       	std	Z+1, r19	; 0x01
     6e4:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     6e6:	8c 85       	ldd	r24, Y+12	; 0x0c
     6e8:	9d 85       	ldd	r25, Y+13	; 0x0d
     6ea:	06 96       	adiw	r24, 0x06	; 6
     6ec:	9e 01       	movw	r18, r28
     6ee:	29 5f       	subi	r18, 0xF9	; 249
     6f0:	3f 4f       	sbci	r19, 0xFF	; 255
     6f2:	b9 01       	movw	r22, r18
     6f4:	0e 94 00 14 	call	0x2800	; 0x2800 <strcat>
	dateString[15] = ' ';
     6f8:	8c 85       	ldd	r24, Y+12	; 0x0c
     6fa:	9d 85       	ldd	r25, Y+13	; 0x0d
     6fc:	20 e2       	ldi	r18, 0x20	; 32
     6fe:	fc 01       	movw	r30, r24
     700:	25 8b       	std	Z+21, r18	; 0x15
	dateString[16] = '\0';
     702:	8c 85       	ldd	r24, Y+12	; 0x0c
     704:	9d 85       	ldd	r25, Y+13	; 0x0d
     706:	fc 01       	movw	r30, r24
     708:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     70a:	8c 85       	ldd	r24, Y+12	; 0x0c
     70c:	9d 85       	ldd	r25, Y+13	; 0x0d
     70e:	06 96       	adiw	r24, 0x06	; 6
     710:	2d 96       	adiw	r28, 0x0d	; 13
     712:	0f b6       	in	r0, 0x3f	; 63
     714:	f8 94       	cli
     716:	de bf       	out	0x3e, r29	; 62
     718:	0f be       	out	0x3f, r0	; 63
     71a:	cd bf       	out	0x3d, r28	; 61
     71c:	df 91       	pop	r29
     71e:	cf 91       	pop	r28
     720:	08 95       	ret

00000722 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     722:	cf 93       	push	r28
     724:	df 93       	push	r29
     726:	00 d0       	rcall	.+0      	; 0x728 <_ZN6myTimeC1Ev+0x6>
     728:	cd b7       	in	r28, 0x3d	; 61
     72a:	de b7       	in	r29, 0x3e	; 62
     72c:	9a 83       	std	Y+2, r25	; 0x02
     72e:	89 83       	std	Y+1, r24	; 0x01
     730:	89 81       	ldd	r24, Y+1	; 0x01
     732:	9a 81       	ldd	r25, Y+2	; 0x02
     734:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     738:	89 81       	ldd	r24, Y+1	; 0x01
     73a:	9a 81       	ldd	r25, Y+2	; 0x02
     73c:	60 e0       	ldi	r22, 0x00	; 0
     73e:	70 e0       	ldi	r23, 0x00	; 0
     740:	40 e0       	ldi	r20, 0x00	; 0
     742:	50 e0       	ldi	r21, 0x00	; 0
     744:	20 e0       	ldi	r18, 0x00	; 0
     746:	30 e0       	ldi	r19, 0x00	; 0
     748:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
}
     74c:	0f 90       	pop	r0
     74e:	0f 90       	pop	r0
     750:	df 91       	pop	r29
     752:	cf 91       	pop	r28
     754:	08 95       	ret

00000756 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     756:	cf 93       	push	r28
     758:	df 93       	push	r29
     75a:	cd b7       	in	r28, 0x3d	; 61
     75c:	de b7       	in	r29, 0x3e	; 62
     75e:	28 97       	sbiw	r28, 0x08	; 8
     760:	0f b6       	in	r0, 0x3f	; 63
     762:	f8 94       	cli
     764:	de bf       	out	0x3e, r29	; 62
     766:	0f be       	out	0x3f, r0	; 63
     768:	cd bf       	out	0x3d, r28	; 61
     76a:	9a 83       	std	Y+2, r25	; 0x02
     76c:	89 83       	std	Y+1, r24	; 0x01
     76e:	7c 83       	std	Y+4, r23	; 0x04
     770:	6b 83       	std	Y+3, r22	; 0x03
     772:	5e 83       	std	Y+6, r21	; 0x06
     774:	4d 83       	std	Y+5, r20	; 0x05
     776:	38 87       	std	Y+8, r19	; 0x08
     778:	2f 83       	std	Y+7, r18	; 0x07
     77a:	89 81       	ldd	r24, Y+1	; 0x01
     77c:	9a 81       	ldd	r25, Y+2	; 0x02
     77e:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     782:	89 81       	ldd	r24, Y+1	; 0x01
     784:	9a 81       	ldd	r25, Y+2	; 0x02
     786:	6b 81       	ldd	r22, Y+3	; 0x03
     788:	7c 81       	ldd	r23, Y+4	; 0x04
     78a:	4d 81       	ldd	r20, Y+5	; 0x05
     78c:	5e 81       	ldd	r21, Y+6	; 0x06
     78e:	2f 81       	ldd	r18, Y+7	; 0x07
     790:	38 85       	ldd	r19, Y+8	; 0x08
     792:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
}
     796:	28 96       	adiw	r28, 0x08	; 8
     798:	0f b6       	in	r0, 0x3f	; 63
     79a:	f8 94       	cli
     79c:	de bf       	out	0x3e, r29	; 62
     79e:	0f be       	out	0x3f, r0	; 63
     7a0:	cd bf       	out	0x3d, r28	; 61
     7a2:	df 91       	pop	r29
     7a4:	cf 91       	pop	r28
     7a6:	08 95       	ret

000007a8 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     7a8:	cf 92       	push	r12
     7aa:	df 92       	push	r13
     7ac:	ef 92       	push	r14
     7ae:	ff 92       	push	r15
     7b0:	0f 93       	push	r16
     7b2:	1f 93       	push	r17
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
     7b8:	cd b7       	in	r28, 0x3d	; 61
     7ba:	de b7       	in	r29, 0x3e	; 62
     7bc:	2e 97       	sbiw	r28, 0x0e	; 14
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	f8 94       	cli
     7c2:	de bf       	out	0x3e, r29	; 62
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	cd bf       	out	0x3d, r28	; 61
     7c8:	9a 83       	std	Y+2, r25	; 0x02
     7ca:	89 83       	std	Y+1, r24	; 0x01
     7cc:	7c 83       	std	Y+4, r23	; 0x04
     7ce:	6b 83       	std	Y+3, r22	; 0x03
     7d0:	5e 83       	std	Y+6, r21	; 0x06
     7d2:	4d 83       	std	Y+5, r20	; 0x05
     7d4:	38 87       	std	Y+8, r19	; 0x08
     7d6:	2f 83       	std	Y+7, r18	; 0x07
     7d8:	1a 87       	std	Y+10, r17	; 0x0a
     7da:	09 87       	std	Y+9, r16	; 0x09
     7dc:	fc 86       	std	Y+12, r15	; 0x0c
     7de:	eb 86       	std	Y+11, r14	; 0x0b
     7e0:	de 86       	std	Y+14, r13	; 0x0e
     7e2:	cd 86       	std	Y+13, r12	; 0x0d
     7e4:	89 81       	ldd	r24, Y+1	; 0x01
     7e6:	9a 81       	ldd	r25, Y+2	; 0x02
     7e8:	69 85       	ldd	r22, Y+9	; 0x09
     7ea:	7a 85       	ldd	r23, Y+10	; 0x0a
     7ec:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ee:	5c 85       	ldd	r21, Y+12	; 0x0c
     7f0:	2d 85       	ldd	r18, Y+13	; 0x0d
     7f2:	3e 85       	ldd	r19, Y+14	; 0x0e
     7f4:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     7f8:	89 81       	ldd	r24, Y+1	; 0x01
     7fa:	9a 81       	ldd	r25, Y+2	; 0x02
     7fc:	6b 81       	ldd	r22, Y+3	; 0x03
     7fe:	7c 81       	ldd	r23, Y+4	; 0x04
     800:	4d 81       	ldd	r20, Y+5	; 0x05
     802:	5e 81       	ldd	r21, Y+6	; 0x06
     804:	2f 81       	ldd	r18, Y+7	; 0x07
     806:	38 85       	ldd	r19, Y+8	; 0x08
     808:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
}
     80c:	2e 96       	adiw	r28, 0x0e	; 14
     80e:	0f b6       	in	r0, 0x3f	; 63
     810:	f8 94       	cli
     812:	de bf       	out	0x3e, r29	; 62
     814:	0f be       	out	0x3f, r0	; 63
     816:	cd bf       	out	0x3d, r28	; 61
     818:	df 91       	pop	r29
     81a:	cf 91       	pop	r28
     81c:	1f 91       	pop	r17
     81e:	0f 91       	pop	r16
     820:	ff 90       	pop	r15
     822:	ef 90       	pop	r14
     824:	df 90       	pop	r13
     826:	cf 90       	pop	r12
     828:	08 95       	ret

0000082a <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     82a:	cf 93       	push	r28
     82c:	df 93       	push	r29
     82e:	00 d0       	rcall	.+0      	; 0x830 <_ZN6myTime10getSecondsEv+0x6>
     830:	cd b7       	in	r28, 0x3d	; 61
     832:	de b7       	in	r29, 0x3e	; 62
     834:	9a 83       	std	Y+2, r25	; 0x02
     836:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     838:	89 81       	ldd	r24, Y+1	; 0x01
     83a:	9a 81       	ldd	r25, Y+2	; 0x02
     83c:	fc 01       	movw	r30, r24
     83e:	83 8d       	ldd	r24, Z+27	; 0x1b
     840:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     842:	0f 90       	pop	r0
     844:	0f 90       	pop	r0
     846:	df 91       	pop	r29
     848:	cf 91       	pop	r28
     84a:	08 95       	ret

0000084c <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     84c:	cf 93       	push	r28
     84e:	df 93       	push	r29
     850:	00 d0       	rcall	.+0      	; 0x852 <_ZN6myTime10getMinutesEv+0x6>
     852:	cd b7       	in	r28, 0x3d	; 61
     854:	de b7       	in	r29, 0x3e	; 62
     856:	9a 83       	std	Y+2, r25	; 0x02
     858:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     85a:	89 81       	ldd	r24, Y+1	; 0x01
     85c:	9a 81       	ldd	r25, Y+2	; 0x02
     85e:	fc 01       	movw	r30, r24
     860:	81 8d       	ldd	r24, Z+25	; 0x19
     862:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     864:	0f 90       	pop	r0
     866:	0f 90       	pop	r0
     868:	df 91       	pop	r29
     86a:	cf 91       	pop	r28
     86c:	08 95       	ret

0000086e <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     86e:	cf 93       	push	r28
     870:	df 93       	push	r29
     872:	00 d0       	rcall	.+0      	; 0x874 <_ZN6myTime8getHoursEv+0x6>
     874:	cd b7       	in	r28, 0x3d	; 61
     876:	de b7       	in	r29, 0x3e	; 62
     878:	9a 83       	std	Y+2, r25	; 0x02
     87a:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     87c:	89 81       	ldd	r24, Y+1	; 0x01
     87e:	9a 81       	ldd	r25, Y+2	; 0x02
     880:	fc 01       	movw	r30, r24
     882:	87 89       	ldd	r24, Z+23	; 0x17
     884:	90 8d       	ldd	r25, Z+24	; 0x18
}
     886:	0f 90       	pop	r0
     888:	0f 90       	pop	r0
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	08 95       	ret

00000890 <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     890:	cf 93       	push	r28
     892:	df 93       	push	r29
     894:	cd b7       	in	r28, 0x3d	; 61
     896:	de b7       	in	r29, 0x3e	; 62
     898:	a2 97       	sbiw	r28, 0x22	; 34
     89a:	0f b6       	in	r0, 0x3f	; 63
     89c:	f8 94       	cli
     89e:	de bf       	out	0x3e, r29	; 62
     8a0:	0f be       	out	0x3f, r0	; 63
     8a2:	cd bf       	out	0x3d, r28	; 61
     8a4:	98 a3       	lds	r25, 0x58
     8a6:	8f 8f       	std	Y+31, r24	; 0x1f
     8a8:	7a a3       	lds	r23, 0x5a
     8aa:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     8ac:	ce 01       	movw	r24, r28
     8ae:	0b 96       	adiw	r24, 0x0b	; 11
     8b0:	29 a1       	lds	r18, 0x49
     8b2:	3a a1       	lds	r19, 0x4a
     8b4:	b9 01       	movw	r22, r18
     8b6:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
	for (int j=0; j<3; j++){
     8ba:	1a 82       	std	Y+2, r1	; 0x02
     8bc:	19 82       	std	Y+1, r1	; 0x01
     8be:	43 c0       	rjmp	.+134    	; 0x946 <__stack+0x47>
		for (int i=0; i<2; i++){
     8c0:	1c 82       	std	Y+4, r1	; 0x04
     8c2:	1b 82       	std	Y+3, r1	; 0x03
     8c4:	20 c0       	rjmp	.+64     	; 0x906 <__stack+0x7>
				tempString[i]=currentString[i+j*3];
     8c6:	29 81       	ldd	r18, Y+1	; 0x01
     8c8:	3a 81       	ldd	r19, Y+2	; 0x02
     8ca:	c9 01       	movw	r24, r18
     8cc:	88 0f       	add	r24, r24
     8ce:	99 1f       	adc	r25, r25
     8d0:	28 0f       	add	r18, r24
     8d2:	39 1f       	adc	r19, r25
     8d4:	8b 81       	ldd	r24, Y+3	; 0x03
     8d6:	9c 81       	ldd	r25, Y+4	; 0x04
     8d8:	82 0f       	add	r24, r18
     8da:	93 1f       	adc	r25, r19
     8dc:	9e 01       	movw	r18, r28
     8de:	25 5f       	subi	r18, 0xF5	; 245
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	82 0f       	add	r24, r18
     8e4:	93 1f       	adc	r25, r19
     8e6:	fc 01       	movw	r30, r24
     8e8:	40 81       	ld	r20, Z
     8ea:	9e 01       	movw	r18, r28
     8ec:	2b 5e       	subi	r18, 0xEB	; 235
     8ee:	3f 4f       	sbci	r19, 0xFF	; 255
     8f0:	8b 81       	ldd	r24, Y+3	; 0x03
     8f2:	9c 81       	ldd	r25, Y+4	; 0x04
     8f4:	82 0f       	add	r24, r18
     8f6:	93 1f       	adc	r25, r19
     8f8:	fc 01       	movw	r30, r24
     8fa:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     8fc:	8b 81       	ldd	r24, Y+3	; 0x03
     8fe:	9c 81       	ldd	r25, Y+4	; 0x04
     900:	01 96       	adiw	r24, 0x01	; 1
     902:	9c 83       	std	Y+4, r25	; 0x04
     904:	8b 83       	std	Y+3, r24	; 0x03
     906:	21 e0       	ldi	r18, 0x01	; 1
     908:	8b 81       	ldd	r24, Y+3	; 0x03
     90a:	9c 81       	ldd	r25, Y+4	; 0x04
     90c:	82 30       	cpi	r24, 0x02	; 2
     90e:	91 05       	cpc	r25, r1
     910:	0c f0       	brlt	.+2      	; 0x914 <__stack+0x15>
     912:	20 e0       	ldi	r18, 0x00	; 0
     914:	22 23       	and	r18, r18
     916:	b9 f6       	brne	.-82     	; 0x8c6 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     918:	ce 01       	movw	r24, r28
     91a:	45 96       	adiw	r24, 0x15	; 21
     91c:	0e 94 e2 13 	call	0x27c4	; 0x27c4 <atoi>
     920:	9c 01       	movw	r18, r24
     922:	89 81       	ldd	r24, Y+1	; 0x01
     924:	9a 81       	ldd	r25, Y+2	; 0x02
     926:	88 0f       	add	r24, r24
     928:	99 1f       	adc	r25, r25
     92a:	ae 01       	movw	r20, r28
     92c:	4f 5f       	subi	r20, 0xFF	; 255
     92e:	5f 4f       	sbci	r21, 0xFF	; 255
     930:	84 0f       	add	r24, r20
     932:	95 1f       	adc	r25, r21
     934:	04 96       	adiw	r24, 0x04	; 4
     936:	fc 01       	movw	r30, r24
     938:	31 83       	std	Z+1, r19	; 0x01
     93a:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     93c:	89 81       	ldd	r24, Y+1	; 0x01
     93e:	9a 81       	ldd	r25, Y+2	; 0x02
     940:	01 96       	adiw	r24, 0x01	; 1
     942:	9a 83       	std	Y+2, r25	; 0x02
     944:	89 83       	std	Y+1, r24	; 0x01
     946:	21 e0       	ldi	r18, 0x01	; 1
     948:	89 81       	ldd	r24, Y+1	; 0x01
     94a:	9a 81       	ldd	r25, Y+2	; 0x02
     94c:	83 30       	cpi	r24, 0x03	; 3
     94e:	91 05       	cpc	r25, r1
     950:	0c f0       	brlt	.+2      	; 0x954 <__stack+0x55>
     952:	20 e0       	ldi	r18, 0x00	; 0
     954:	22 23       	and	r18, r18
     956:	09 f0       	breq	.+2      	; 0x95a <__stack+0x5b>
     958:	b3 cf       	rjmp	.-154    	; 0x8c0 <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     95a:	8d 81       	ldd	r24, Y+5	; 0x05
     95c:	9e 81       	ldd	r25, Y+6	; 0x06
     95e:	47 96       	adiw	r24, 0x17	; 23
     960:	8f 32       	cpi	r24, 0x2F	; 47
     962:	91 05       	cpc	r25, r1
     964:	c0 f4       	brcc	.+48     	; 0x996 <__stack+0x97>
     966:	8f 81       	ldd	r24, Y+7	; 0x07
     968:	98 85       	ldd	r25, Y+8	; 0x08
     96a:	cb 96       	adiw	r24, 0x3b	; 59
     96c:	87 37       	cpi	r24, 0x77	; 119
     96e:	91 05       	cpc	r25, r1
     970:	90 f4       	brcc	.+36     	; 0x996 <__stack+0x97>
     972:	89 85       	ldd	r24, Y+9	; 0x09
     974:	9a 85       	ldd	r25, Y+10	; 0x0a
     976:	cb 96       	adiw	r24, 0x3b	; 59
     978:	87 37       	cpi	r24, 0x77	; 119
     97a:	91 05       	cpc	r25, r1
     97c:	60 f4       	brcc	.+24     	; 0x996 <__stack+0x97>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     97e:	6d 81       	ldd	r22, Y+5	; 0x05
     980:	7e 81       	ldd	r23, Y+6	; 0x06
     982:	4f 81       	ldd	r20, Y+7	; 0x07
     984:	58 85       	ldd	r21, Y+8	; 0x08
     986:	29 85       	ldd	r18, Y+9	; 0x09
     988:	3a 85       	ldd	r19, Y+10	; 0x0a
     98a:	8f 8d       	ldd	r24, Y+31	; 0x1f
     98c:	98 a1       	lds	r25, 0x48
     98e:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
		return fTrue;
     992:	81 e0       	ldi	r24, 0x01	; 1
     994:	01 c0       	rjmp	.+2      	; 0x998 <__stack+0x99>
	} 
	return fFalse;
     996:	80 e0       	ldi	r24, 0x00	; 0
}
     998:	a2 96       	adiw	r28, 0x22	; 34
     99a:	0f b6       	in	r0, 0x3f	; 63
     99c:	f8 94       	cli
     99e:	de bf       	out	0x3e, r29	; 62
     9a0:	0f be       	out	0x3f, r0	; 63
     9a2:	cd bf       	out	0x3d, r28	; 61
     9a4:	df 91       	pop	r29
     9a6:	cf 91       	pop	r28
     9a8:	08 95       	ret

000009aa <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     9aa:	cf 93       	push	r28
     9ac:	df 93       	push	r29
     9ae:	cd b7       	in	r28, 0x3d	; 61
     9b0:	de b7       	in	r29, 0x3e	; 62
     9b2:	28 97       	sbiw	r28, 0x08	; 8
     9b4:	0f b6       	in	r0, 0x3f	; 63
     9b6:	f8 94       	cli
     9b8:	de bf       	out	0x3e, r29	; 62
     9ba:	0f be       	out	0x3f, r0	; 63
     9bc:	cd bf       	out	0x3d, r28	; 61
     9be:	9a 83       	std	Y+2, r25	; 0x02
     9c0:	89 83       	std	Y+1, r24	; 0x01
     9c2:	7c 83       	std	Y+4, r23	; 0x04
     9c4:	6b 83       	std	Y+3, r22	; 0x03
     9c6:	5e 83       	std	Y+6, r21	; 0x06
     9c8:	4d 83       	std	Y+5, r20	; 0x05
     9ca:	38 87       	std	Y+8, r19	; 0x08
     9cc:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     9ce:	89 81       	ldd	r24, Y+1	; 0x01
     9d0:	9a 81       	ldd	r25, Y+2	; 0x02
     9d2:	2b 81       	ldd	r18, Y+3	; 0x03
     9d4:	3c 81       	ldd	r19, Y+4	; 0x04
     9d6:	b9 01       	movw	r22, r18
     9d8:	0e 94 05 05 	call	0xa0a	; 0xa0a <_ZN6myTime7setHourEi>
	setMinute(minute);
     9dc:	89 81       	ldd	r24, Y+1	; 0x01
     9de:	9a 81       	ldd	r25, Y+2	; 0x02
     9e0:	2d 81       	ldd	r18, Y+5	; 0x05
     9e2:	3e 81       	ldd	r19, Y+6	; 0x06
     9e4:	b9 01       	movw	r22, r18
     9e6:	0e 94 23 05 	call	0xa46	; 0xa46 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     9ea:	89 81       	ldd	r24, Y+1	; 0x01
     9ec:	9a 81       	ldd	r25, Y+2	; 0x02
     9ee:	2f 81       	ldd	r18, Y+7	; 0x07
     9f0:	38 85       	ldd	r19, Y+8	; 0x08
     9f2:	b9 01       	movw	r22, r18
     9f4:	0e 94 41 05 	call	0xa82	; 0xa82 <_ZN6myTime9setSecondEi>
}
     9f8:	28 96       	adiw	r28, 0x08	; 8
     9fa:	0f b6       	in	r0, 0x3f	; 63
     9fc:	f8 94       	cli
     9fe:	de bf       	out	0x3e, r29	; 62
     a00:	0f be       	out	0x3f, r0	; 63
     a02:	cd bf       	out	0x3d, r28	; 61
     a04:	df 91       	pop	r29
     a06:	cf 91       	pop	r28
     a08:	08 95       	ret

00000a0a <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     a0a:	cf 93       	push	r28
     a0c:	df 93       	push	r29
     a0e:	00 d0       	rcall	.+0      	; 0xa10 <_ZN6myTime7setHourEi+0x6>
     a10:	00 d0       	rcall	.+0      	; 0xa12 <_ZN6myTime7setHourEi+0x8>
     a12:	cd b7       	in	r28, 0x3d	; 61
     a14:	de b7       	in	r29, 0x3e	; 62
     a16:	9a 83       	std	Y+2, r25	; 0x02
     a18:	89 83       	std	Y+1, r24	; 0x01
     a1a:	7c 83       	std	Y+4, r23	; 0x04
     a1c:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     a1e:	8b 81       	ldd	r24, Y+3	; 0x03
     a20:	9c 81       	ldd	r25, Y+4	; 0x04
     a22:	47 96       	adiw	r24, 0x17	; 23
     a24:	8f 32       	cpi	r24, 0x2F	; 47
     a26:	91 05       	cpc	r25, r1
     a28:	38 f4       	brcc	.+14     	; 0xa38 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     a2a:	89 81       	ldd	r24, Y+1	; 0x01
     a2c:	9a 81       	ldd	r25, Y+2	; 0x02
     a2e:	2b 81       	ldd	r18, Y+3	; 0x03
     a30:	3c 81       	ldd	r19, Y+4	; 0x04
     a32:	fc 01       	movw	r30, r24
     a34:	30 8f       	std	Z+24, r19	; 0x18
     a36:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     a38:	0f 90       	pop	r0
     a3a:	0f 90       	pop	r0
     a3c:	0f 90       	pop	r0
     a3e:	0f 90       	pop	r0
     a40:	df 91       	pop	r29
     a42:	cf 91       	pop	r28
     a44:	08 95       	ret

00000a46 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     a46:	cf 93       	push	r28
     a48:	df 93       	push	r29
     a4a:	00 d0       	rcall	.+0      	; 0xa4c <_ZN6myTime9setMinuteEi+0x6>
     a4c:	00 d0       	rcall	.+0      	; 0xa4e <_ZN6myTime9setMinuteEi+0x8>
     a4e:	cd b7       	in	r28, 0x3d	; 61
     a50:	de b7       	in	r29, 0x3e	; 62
     a52:	9a 83       	std	Y+2, r25	; 0x02
     a54:	89 83       	std	Y+1, r24	; 0x01
     a56:	7c 83       	std	Y+4, r23	; 0x04
     a58:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     a5a:	8b 81       	ldd	r24, Y+3	; 0x03
     a5c:	9c 81       	ldd	r25, Y+4	; 0x04
     a5e:	cb 96       	adiw	r24, 0x3b	; 59
     a60:	87 37       	cpi	r24, 0x77	; 119
     a62:	91 05       	cpc	r25, r1
     a64:	38 f4       	brcc	.+14     	; 0xa74 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     a66:	89 81       	ldd	r24, Y+1	; 0x01
     a68:	9a 81       	ldd	r25, Y+2	; 0x02
     a6a:	2b 81       	ldd	r18, Y+3	; 0x03
     a6c:	3c 81       	ldd	r19, Y+4	; 0x04
     a6e:	fc 01       	movw	r30, r24
     a70:	32 8f       	std	Z+26, r19	; 0x1a
     a72:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     a74:	0f 90       	pop	r0
     a76:	0f 90       	pop	r0
     a78:	0f 90       	pop	r0
     a7a:	0f 90       	pop	r0
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	08 95       	ret

00000a82 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     a82:	cf 93       	push	r28
     a84:	df 93       	push	r29
     a86:	00 d0       	rcall	.+0      	; 0xa88 <_ZN6myTime9setSecondEi+0x6>
     a88:	00 d0       	rcall	.+0      	; 0xa8a <_ZN6myTime9setSecondEi+0x8>
     a8a:	cd b7       	in	r28, 0x3d	; 61
     a8c:	de b7       	in	r29, 0x3e	; 62
     a8e:	9a 83       	std	Y+2, r25	; 0x02
     a90:	89 83       	std	Y+1, r24	; 0x01
     a92:	7c 83       	std	Y+4, r23	; 0x04
     a94:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     a96:	8b 81       	ldd	r24, Y+3	; 0x03
     a98:	9c 81       	ldd	r25, Y+4	; 0x04
     a9a:	cb 96       	adiw	r24, 0x3b	; 59
     a9c:	87 37       	cpi	r24, 0x77	; 119
     a9e:	91 05       	cpc	r25, r1
     aa0:	38 f4       	brcc	.+14     	; 0xab0 <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     aa2:	89 81       	ldd	r24, Y+1	; 0x01
     aa4:	9a 81       	ldd	r25, Y+2	; 0x02
     aa6:	2b 81       	ldd	r18, Y+3	; 0x03
     aa8:	3c 81       	ldd	r19, Y+4	; 0x04
     aaa:	fc 01       	movw	r30, r24
     aac:	34 8f       	std	Z+28, r19	; 0x1c
     aae:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     ab0:	0f 90       	pop	r0
     ab2:	0f 90       	pop	r0
     ab4:	0f 90       	pop	r0
     ab6:	0f 90       	pop	r0
     ab8:	df 91       	pop	r29
     aba:	cf 91       	pop	r28
     abc:	08 95       	ret

00000abe <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29
     ac2:	cd b7       	in	r28, 0x3d	; 61
     ac4:	de b7       	in	r29, 0x3e	; 62
     ac6:	28 97       	sbiw	r28, 0x08	; 8
     ac8:	0f b6       	in	r0, 0x3f	; 63
     aca:	f8 94       	cli
     acc:	de bf       	out	0x3e, r29	; 62
     ace:	0f be       	out	0x3f, r0	; 63
     ad0:	cd bf       	out	0x3d, r28	; 61
     ad2:	9e 83       	std	Y+6, r25	; 0x06
     ad4:	8d 83       	std	Y+5, r24	; 0x05
     ad6:	78 87       	std	Y+8, r23	; 0x08
     ad8:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     ada:	8d 81       	ldd	r24, Y+5	; 0x05
     adc:	9e 81       	ldd	r25, Y+6	; 0x06
     ade:	fc 01       	movw	r30, r24
     ae0:	27 89       	ldd	r18, Z+23	; 0x17
     ae2:	30 8d       	ldd	r19, Z+24	; 0x18
     ae4:	8f 81       	ldd	r24, Y+7	; 0x07
     ae6:	98 85       	ldd	r25, Y+8	; 0x08
     ae8:	82 0f       	add	r24, r18
     aea:	93 1f       	adc	r25, r19
     aec:	9a 83       	std	Y+2, r25	; 0x02
     aee:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     af0:	89 81       	ldd	r24, Y+1	; 0x01
     af2:	9a 81       	ldd	r25, Y+2	; 0x02
     af4:	28 e1       	ldi	r18, 0x18	; 24
     af6:	30 e0       	ldi	r19, 0x00	; 0
     af8:	b9 01       	movw	r22, r18
     afa:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     afe:	9c 01       	movw	r18, r24
     b00:	8d 81       	ldd	r24, Y+5	; 0x05
     b02:	9e 81       	ldd	r25, Y+6	; 0x06
     b04:	fc 01       	movw	r30, r24
     b06:	30 8f       	std	Z+24, r19	; 0x18
     b08:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     b0a:	89 81       	ldd	r24, Y+1	; 0x01
     b0c:	9a 81       	ldd	r25, Y+2	; 0x02
     b0e:	21 e0       	ldi	r18, 0x01	; 1
     b10:	88 31       	cpi	r24, 0x18	; 24
     b12:	91 05       	cpc	r25, r1
     b14:	0c f4       	brge	.+2      	; 0xb18 <_ZN6myTime8addHoursEi+0x5a>
     b16:	20 e0       	ldi	r18, 0x00	; 0
     b18:	22 23       	and	r18, r18
     b1a:	91 f0       	breq	.+36     	; 0xb40 <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     b1c:	89 81       	ldd	r24, Y+1	; 0x01
     b1e:	9a 81       	ldd	r25, Y+2	; 0x02
     b20:	28 e1       	ldi	r18, 0x18	; 24
     b22:	30 e0       	ldi	r19, 0x00	; 0
     b24:	b9 01       	movw	r22, r18
     b26:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     b2a:	9b 01       	movw	r18, r22
     b2c:	c9 01       	movw	r24, r18
     b2e:	9c 83       	std	Y+4, r25	; 0x04
     b30:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     b32:	8d 81       	ldd	r24, Y+5	; 0x05
     b34:	9e 81       	ldd	r25, Y+6	; 0x06
     b36:	2b 81       	ldd	r18, Y+3	; 0x03
     b38:	3c 81       	ldd	r19, Y+4	; 0x04
     b3a:	b9 01       	movw	r22, r18
     b3c:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     b40:	28 96       	adiw	r28, 0x08	; 8
     b42:	0f b6       	in	r0, 0x3f	; 63
     b44:	f8 94       	cli
     b46:	de bf       	out	0x3e, r29	; 62
     b48:	0f be       	out	0x3f, r0	; 63
     b4a:	cd bf       	out	0x3d, r28	; 61
     b4c:	df 91       	pop	r29
     b4e:	cf 91       	pop	r28
     b50:	08 95       	ret

00000b52 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	cd b7       	in	r28, 0x3d	; 61
     b58:	de b7       	in	r29, 0x3e	; 62
     b5a:	28 97       	sbiw	r28, 0x08	; 8
     b5c:	0f b6       	in	r0, 0x3f	; 63
     b5e:	f8 94       	cli
     b60:	de bf       	out	0x3e, r29	; 62
     b62:	0f be       	out	0x3f, r0	; 63
     b64:	cd bf       	out	0x3d, r28	; 61
     b66:	9e 83       	std	Y+6, r25	; 0x06
     b68:	8d 83       	std	Y+5, r24	; 0x05
     b6a:	78 87       	std	Y+8, r23	; 0x08
     b6c:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     b6e:	8d 81       	ldd	r24, Y+5	; 0x05
     b70:	9e 81       	ldd	r25, Y+6	; 0x06
     b72:	fc 01       	movw	r30, r24
     b74:	21 8d       	ldd	r18, Z+25	; 0x19
     b76:	32 8d       	ldd	r19, Z+26	; 0x1a
     b78:	8f 81       	ldd	r24, Y+7	; 0x07
     b7a:	98 85       	ldd	r25, Y+8	; 0x08
     b7c:	82 0f       	add	r24, r18
     b7e:	93 1f       	adc	r25, r19
     b80:	9a 83       	std	Y+2, r25	; 0x02
     b82:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     b84:	89 81       	ldd	r24, Y+1	; 0x01
     b86:	9a 81       	ldd	r25, Y+2	; 0x02
     b88:	2c e3       	ldi	r18, 0x3C	; 60
     b8a:	30 e0       	ldi	r19, 0x00	; 0
     b8c:	b9 01       	movw	r22, r18
     b8e:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     b92:	9c 01       	movw	r18, r24
     b94:	8d 81       	ldd	r24, Y+5	; 0x05
     b96:	9e 81       	ldd	r25, Y+6	; 0x06
     b98:	fc 01       	movw	r30, r24
     b9a:	32 8f       	std	Z+26, r19	; 0x1a
     b9c:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     b9e:	89 81       	ldd	r24, Y+1	; 0x01
     ba0:	9a 81       	ldd	r25, Y+2	; 0x02
     ba2:	21 e0       	ldi	r18, 0x01	; 1
     ba4:	8c 33       	cpi	r24, 0x3C	; 60
     ba6:	91 05       	cpc	r25, r1
     ba8:	0c f4       	brge	.+2      	; 0xbac <_ZN6myTime10addMinutesEi+0x5a>
     baa:	20 e0       	ldi	r18, 0x00	; 0
     bac:	22 23       	and	r18, r18
     bae:	91 f0       	breq	.+36     	; 0xbd4 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     bb0:	89 81       	ldd	r24, Y+1	; 0x01
     bb2:	9a 81       	ldd	r25, Y+2	; 0x02
     bb4:	2c e3       	ldi	r18, 0x3C	; 60
     bb6:	30 e0       	ldi	r19, 0x00	; 0
     bb8:	b9 01       	movw	r22, r18
     bba:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     bbe:	9b 01       	movw	r18, r22
     bc0:	c9 01       	movw	r24, r18
     bc2:	9c 83       	std	Y+4, r25	; 0x04
     bc4:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     bc6:	2b 81       	ldd	r18, Y+3	; 0x03
     bc8:	3c 81       	ldd	r19, Y+4	; 0x04
     bca:	8d 81       	ldd	r24, Y+5	; 0x05
     bcc:	9e 81       	ldd	r25, Y+6	; 0x06
     bce:	b9 01       	movw	r22, r18
     bd0:	0e 94 5f 05 	call	0xabe	; 0xabe <_ZN6myTime8addHoursEi>
	}
}
     bd4:	28 96       	adiw	r28, 0x08	; 8
     bd6:	0f b6       	in	r0, 0x3f	; 63
     bd8:	f8 94       	cli
     bda:	de bf       	out	0x3e, r29	; 62
     bdc:	0f be       	out	0x3f, r0	; 63
     bde:	cd bf       	out	0x3d, r28	; 61
     be0:	df 91       	pop	r29
     be2:	cf 91       	pop	r28
     be4:	08 95       	ret

00000be6 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	cd b7       	in	r28, 0x3d	; 61
     bec:	de b7       	in	r29, 0x3e	; 62
     bee:	28 97       	sbiw	r28, 0x08	; 8
     bf0:	0f b6       	in	r0, 0x3f	; 63
     bf2:	f8 94       	cli
     bf4:	de bf       	out	0x3e, r29	; 62
     bf6:	0f be       	out	0x3f, r0	; 63
     bf8:	cd bf       	out	0x3d, r28	; 61
     bfa:	9e 83       	std	Y+6, r25	; 0x06
     bfc:	8d 83       	std	Y+5, r24	; 0x05
     bfe:	78 87       	std	Y+8, r23	; 0x08
     c00:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     c02:	8d 81       	ldd	r24, Y+5	; 0x05
     c04:	9e 81       	ldd	r25, Y+6	; 0x06
     c06:	fc 01       	movw	r30, r24
     c08:	23 8d       	ldd	r18, Z+27	; 0x1b
     c0a:	34 8d       	ldd	r19, Z+28	; 0x1c
     c0c:	8f 81       	ldd	r24, Y+7	; 0x07
     c0e:	98 85       	ldd	r25, Y+8	; 0x08
     c10:	82 0f       	add	r24, r18
     c12:	93 1f       	adc	r25, r19
     c14:	9a 83       	std	Y+2, r25	; 0x02
     c16:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     c18:	89 81       	ldd	r24, Y+1	; 0x01
     c1a:	9a 81       	ldd	r25, Y+2	; 0x02
     c1c:	2c e3       	ldi	r18, 0x3C	; 60
     c1e:	30 e0       	ldi	r19, 0x00	; 0
     c20:	b9 01       	movw	r22, r18
     c22:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     c26:	9c 01       	movw	r18, r24
     c28:	8d 81       	ldd	r24, Y+5	; 0x05
     c2a:	9e 81       	ldd	r25, Y+6	; 0x06
     c2c:	fc 01       	movw	r30, r24
     c2e:	34 8f       	std	Z+28, r19	; 0x1c
     c30:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     c32:	89 81       	ldd	r24, Y+1	; 0x01
     c34:	9a 81       	ldd	r25, Y+2	; 0x02
     c36:	21 e0       	ldi	r18, 0x01	; 1
     c38:	8c 33       	cpi	r24, 0x3C	; 60
     c3a:	91 05       	cpc	r25, r1
     c3c:	0c f4       	brge	.+2      	; 0xc40 <_ZN6myTime10addSecondsEi+0x5a>
     c3e:	20 e0       	ldi	r18, 0x00	; 0
     c40:	22 23       	and	r18, r18
     c42:	91 f0       	breq	.+36     	; 0xc68 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     c44:	89 81       	ldd	r24, Y+1	; 0x01
     c46:	9a 81       	ldd	r25, Y+2	; 0x02
     c48:	2c e3       	ldi	r18, 0x3C	; 60
     c4a:	30 e0       	ldi	r19, 0x00	; 0
     c4c:	b9 01       	movw	r22, r18
     c4e:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
     c52:	9b 01       	movw	r18, r22
     c54:	c9 01       	movw	r24, r18
     c56:	9c 83       	std	Y+4, r25	; 0x04
     c58:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     c5a:	2b 81       	ldd	r18, Y+3	; 0x03
     c5c:	3c 81       	ldd	r19, Y+4	; 0x04
     c5e:	8d 81       	ldd	r24, Y+5	; 0x05
     c60:	9e 81       	ldd	r25, Y+6	; 0x06
     c62:	b9 01       	movw	r22, r18
     c64:	0e 94 a9 05 	call	0xb52	; 0xb52 <_ZN6myTime10addMinutesEi>
	}
}
     c68:	28 96       	adiw	r28, 0x08	; 8
     c6a:	0f b6       	in	r0, 0x3f	; 63
     c6c:	f8 94       	cli
     c6e:	de bf       	out	0x3e, r29	; 62
     c70:	0f be       	out	0x3f, r0	; 63
     c72:	cd bf       	out	0x3d, r28	; 61
     c74:	df 91       	pop	r29
     c76:	cf 91       	pop	r28
     c78:	08 95       	ret

00000c7a <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     c7a:	cf 93       	push	r28
     c7c:	df 93       	push	r29
     c7e:	cd b7       	in	r28, 0x3d	; 61
     c80:	de b7       	in	r29, 0x3e	; 62
     c82:	2b 97       	sbiw	r28, 0x0b	; 11
     c84:	0f b6       	in	r0, 0x3f	; 63
     c86:	f8 94       	cli
     c88:	de bf       	out	0x3e, r29	; 62
     c8a:	0f be       	out	0x3f, r0	; 63
     c8c:	cd bf       	out	0x3d, r28	; 61
     c8e:	9b 87       	std	Y+11, r25	; 0x0b
     c90:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     c92:	8a 85       	ldd	r24, Y+10	; 0x0a
     c94:	9b 85       	ldd	r25, Y+11	; 0x0b
     c96:	fc 01       	movw	r30, r24
     c98:	87 89       	ldd	r24, Z+23	; 0x17
     c9a:	90 8d       	ldd	r25, Z+24	; 0x18
     c9c:	9e 01       	movw	r18, r28
     c9e:	2f 5f       	subi	r18, 0xFF	; 255
     ca0:	3f 4f       	sbci	r19, 0xFF	; 255
     ca2:	b9 01       	movw	r22, r18
     ca4:	4a e0       	ldi	r20, 0x0A	; 10
     ca6:	50 e0       	ldi	r21, 0x00	; 0
     ca8:	0e 94 1b 14 	call	0x2836	; 0x2836 <itoa>
	itoa(minute,minuteString,10);
     cac:	8a 85       	ldd	r24, Y+10	; 0x0a
     cae:	9b 85       	ldd	r25, Y+11	; 0x0b
     cb0:	fc 01       	movw	r30, r24
     cb2:	81 8d       	ldd	r24, Z+25	; 0x19
     cb4:	92 8d       	ldd	r25, Z+26	; 0x1a
     cb6:	9e 01       	movw	r18, r28
     cb8:	2c 5f       	subi	r18, 0xFC	; 252
     cba:	3f 4f       	sbci	r19, 0xFF	; 255
     cbc:	b9 01       	movw	r22, r18
     cbe:	4a e0       	ldi	r20, 0x0A	; 10
     cc0:	50 e0       	ldi	r21, 0x00	; 0
     cc2:	0e 94 1b 14 	call	0x2836	; 0x2836 <itoa>
	itoa(second,secondString,10);
     cc6:	8a 85       	ldd	r24, Y+10	; 0x0a
     cc8:	9b 85       	ldd	r25, Y+11	; 0x0b
     cca:	fc 01       	movw	r30, r24
     ccc:	83 8d       	ldd	r24, Z+27	; 0x1b
     cce:	94 8d       	ldd	r25, Z+28	; 0x1c
     cd0:	9e 01       	movw	r18, r28
     cd2:	29 5f       	subi	r18, 0xF9	; 249
     cd4:	3f 4f       	sbci	r19, 0xFF	; 255
     cd6:	b9 01       	movw	r22, r18
     cd8:	4a e0       	ldi	r20, 0x0A	; 10
     cda:	50 e0       	ldi	r21, 0x00	; 0
     cdc:	0e 94 1b 14 	call	0x2836	; 0x2836 <itoa>
	strcpy(timeString,hourString);
     ce0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ce2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ce4:	4d 96       	adiw	r24, 0x1d	; 29
     ce6:	9e 01       	movw	r18, r28
     ce8:	2f 5f       	subi	r18, 0xFF	; 255
     cea:	3f 4f       	sbci	r19, 0xFF	; 255
     cec:	b9 01       	movw	r22, r18
     cee:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
	strcat(timeString,":");
     cf2:	8a 85       	ldd	r24, Y+10	; 0x0a
     cf4:	9b 85       	ldd	r25, Y+11	; 0x0b
     cf6:	9c 01       	movw	r18, r24
     cf8:	23 5e       	subi	r18, 0xE3	; 227
     cfa:	3f 4f       	sbci	r19, 0xFF	; 255
     cfc:	c9 01       	movw	r24, r18
     cfe:	ac 01       	movw	r20, r24
     d00:	fa 01       	movw	r30, r20
     d02:	01 90       	ld	r0, Z+
     d04:	00 20       	and	r0, r0
     d06:	e9 f7       	brne	.-6      	; 0xd02 <_ZN6myTime7getTimeEv+0x88>
     d08:	cf 01       	movw	r24, r30
     d0a:	01 97       	sbiw	r24, 0x01	; 1
     d0c:	84 1b       	sub	r24, r20
     d0e:	95 0b       	sbc	r25, r21
     d10:	82 0f       	add	r24, r18
     d12:	93 1f       	adc	r25, r19
     d14:	2a e3       	ldi	r18, 0x3A	; 58
     d16:	30 e0       	ldi	r19, 0x00	; 0
     d18:	fc 01       	movw	r30, r24
     d1a:	31 83       	std	Z+1, r19	; 0x01
     d1c:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     d1e:	8a 85       	ldd	r24, Y+10	; 0x0a
     d20:	9b 85       	ldd	r25, Y+11	; 0x0b
     d22:	4d 96       	adiw	r24, 0x1d	; 29
     d24:	9e 01       	movw	r18, r28
     d26:	2c 5f       	subi	r18, 0xFC	; 252
     d28:	3f 4f       	sbci	r19, 0xFF	; 255
     d2a:	b9 01       	movw	r22, r18
     d2c:	0e 94 00 14 	call	0x2800	; 0x2800 <strcat>
	strcat(timeString,":");
     d30:	8a 85       	ldd	r24, Y+10	; 0x0a
     d32:	9b 85       	ldd	r25, Y+11	; 0x0b
     d34:	9c 01       	movw	r18, r24
     d36:	23 5e       	subi	r18, 0xE3	; 227
     d38:	3f 4f       	sbci	r19, 0xFF	; 255
     d3a:	c9 01       	movw	r24, r18
     d3c:	ac 01       	movw	r20, r24
     d3e:	fa 01       	movw	r30, r20
     d40:	01 90       	ld	r0, Z+
     d42:	00 20       	and	r0, r0
     d44:	e9 f7       	brne	.-6      	; 0xd40 <_ZN6myTime7getTimeEv+0xc6>
     d46:	cf 01       	movw	r24, r30
     d48:	01 97       	sbiw	r24, 0x01	; 1
     d4a:	84 1b       	sub	r24, r20
     d4c:	95 0b       	sbc	r25, r21
     d4e:	82 0f       	add	r24, r18
     d50:	93 1f       	adc	r25, r19
     d52:	2a e3       	ldi	r18, 0x3A	; 58
     d54:	30 e0       	ldi	r19, 0x00	; 0
     d56:	fc 01       	movw	r30, r24
     d58:	31 83       	std	Z+1, r19	; 0x01
     d5a:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     d5c:	8a 85       	ldd	r24, Y+10	; 0x0a
     d5e:	9b 85       	ldd	r25, Y+11	; 0x0b
     d60:	4d 96       	adiw	r24, 0x1d	; 29
     d62:	9e 01       	movw	r18, r28
     d64:	29 5f       	subi	r18, 0xF9	; 249
     d66:	3f 4f       	sbci	r19, 0xFF	; 255
     d68:	b9 01       	movw	r22, r18
     d6a:	0e 94 00 14 	call	0x2800	; 0x2800 <strcat>
	timeString[10] = ' ';
     d6e:	8a 85       	ldd	r24, Y+10	; 0x0a
     d70:	9b 85       	ldd	r25, Y+11	; 0x0b
     d72:	20 e2       	ldi	r18, 0x20	; 32
     d74:	fc 01       	movw	r30, r24
     d76:	27 a3       	lds	r18, 0x57
	timeString[11] = '\0';
     d78:	8a 85       	ldd	r24, Y+10	; 0x0a
     d7a:	9b 85       	ldd	r25, Y+11	; 0x0b
     d7c:	fc 01       	movw	r30, r24
     d7e:	10 a6       	lds	r17, 0xb0
	return timeString;
     d80:	8a 85       	ldd	r24, Y+10	; 0x0a
     d82:	9b 85       	ldd	r25, Y+11	; 0x0b
     d84:	4d 96       	adiw	r24, 0x1d	; 29
     d86:	2b 96       	adiw	r28, 0x0b	; 11
     d88:	0f b6       	in	r0, 0x3f	; 63
     d8a:	f8 94       	cli
     d8c:	de bf       	out	0x3e, r29	; 62
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	cd bf       	out	0x3d, r28	; 61
     d92:	df 91       	pop	r29
     d94:	cf 91       	pop	r28
     d96:	08 95       	ret

00000d98 <_Z18getDateTime_eepromhh>:
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/

void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     d98:	cf 93       	push	r28
     d9a:	df 93       	push	r29
     d9c:	cd b7       	in	r28, 0x3d	; 61
     d9e:	de b7       	in	r29, 0x3e	; 62
     da0:	2f 97       	sbiw	r28, 0x0f	; 15
     da2:	0f b6       	in	r0, 0x3f	; 63
     da4:	f8 94       	cli
     da6:	de bf       	out	0x3e, r29	; 62
     da8:	0f be       	out	0x3f, r0	; 63
     daa:	cd bf       	out	0x3d, r28	; 61
     dac:	8e 87       	std	Y+14, r24	; 0x0e
     dae:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     db0:	f8 94       	cli
	if (gTime){
     db2:	8e 85       	ldd	r24, Y+14	; 0x0e
     db4:	88 23       	and	r24, r24
     db6:	09 f4       	brne	.+2      	; 0xdba <_Z18getDateTime_eepromhh+0x22>
     db8:	4b c0       	rjmp	.+150    	; 0xe50 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     dba:	1a 82       	std	Y+2, r1	; 0x02
     dbc:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     dbe:	81 e0       	ldi	r24, 0x01	; 1
     dc0:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     dc2:	2c c0       	rjmp	.+88     	; 0xe1c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     dc4:	82 e0       	ldi	r24, 0x02	; 2
     dc6:	90 e0       	ldi	r25, 0x00	; 0
     dc8:	0e 94 44 14 	call	0x2888	; 0x2888 <__eerd_byte_m324pa>
     dcc:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     dce:	81 e0       	ldi	r24, 0x01	; 1
     dd0:	90 e0       	ldi	r25, 0x00	; 0
     dd2:	0e 94 44 14 	call	0x2888	; 0x2888 <__eerd_byte_m324pa>
     dd6:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     dd8:	80 e0       	ldi	r24, 0x00	; 0
     dda:	90 e0       	ldi	r25, 0x00	; 0
     ddc:	0e 94 44 14 	call	0x2888	; 0x2888 <__eerd_byte_m324pa>
     de0:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     de2:	8f 81       	ldd	r24, Y+7	; 0x07
     de4:	8c 33       	cpi	r24, 0x3C	; 60
     de6:	a8 f4       	brcc	.+42     	; 0xe12 <_Z18getDateTime_eepromhh+0x7a>
     de8:	88 85       	ldd	r24, Y+8	; 0x08
     dea:	8c 33       	cpi	r24, 0x3C	; 60
     dec:	90 f4       	brcc	.+36     	; 0xe12 <_Z18getDateTime_eepromhh+0x7a>
     dee:	89 85       	ldd	r24, Y+9	; 0x09
     df0:	88 31       	cpi	r24, 0x18	; 24
     df2:	78 f4       	brcc	.+30     	; 0xe12 <_Z18getDateTime_eepromhh+0x7a>
     df4:	89 85       	ldd	r24, Y+9	; 0x09
     df6:	68 2f       	mov	r22, r24
     df8:	70 e0       	ldi	r23, 0x00	; 0
     dfa:	88 85       	ldd	r24, Y+8	; 0x08
     dfc:	48 2f       	mov	r20, r24
     dfe:	50 e0       	ldi	r21, 0x00	; 0
     e00:	8f 81       	ldd	r24, Y+7	; 0x07
     e02:	28 2f       	mov	r18, r24
     e04:	30 e0       	ldi	r19, 0x00	; 0
     e06:	83 e6       	ldi	r24, 0x63	; 99
     e08:	91 e0       	ldi	r25, 0x01	; 1
     e0a:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
     e0e:	1b 82       	std	Y+3, r1	; 0x03
     e10:	05 c0       	rjmp	.+10     	; 0xe1c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     e12:	89 81       	ldd	r24, Y+1	; 0x01
     e14:	9a 81       	ldd	r25, Y+2	; 0x02
     e16:	01 96       	adiw	r24, 0x01	; 1
     e18:	9a 83       	std	Y+2, r25	; 0x02
     e1a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     e1c:	8b 81       	ldd	r24, Y+3	; 0x03
     e1e:	88 23       	and	r24, r24
     e20:	39 f0       	breq	.+14     	; 0xe30 <_Z18getDateTime_eepromhh+0x98>
     e22:	89 81       	ldd	r24, Y+1	; 0x01
     e24:	9a 81       	ldd	r25, Y+2	; 0x02
     e26:	83 30       	cpi	r24, 0x03	; 3
     e28:	91 05       	cpc	r25, r1
     e2a:	14 f4       	brge	.+4      	; 0xe30 <_Z18getDateTime_eepromhh+0x98>
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	01 c0       	rjmp	.+2      	; 0xe32 <_Z18getDateTime_eepromhh+0x9a>
     e30:	80 e0       	ldi	r24, 0x00	; 0
     e32:	88 23       	and	r24, r24
     e34:	39 f6       	brne	.-114    	; 0xdc4 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     e36:	8b 81       	ldd	r24, Y+3	; 0x03
     e38:	88 23       	and	r24, r24
     e3a:	51 f0       	breq	.+20     	; 0xe50 <_Z18getDateTime_eepromhh+0xb8>
     e3c:	83 e6       	ldi	r24, 0x63	; 99
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	61 e0       	ldi	r22, 0x01	; 1
     e42:	70 e0       	ldi	r23, 0x00	; 0
     e44:	41 e0       	ldi	r20, 0x01	; 1
     e46:	50 e0       	ldi	r21, 0x00	; 0
     e48:	21 e0       	ldi	r18, 0x01	; 1
     e4a:	30 e0       	ldi	r19, 0x00	; 0
     e4c:	0e 94 d5 04 	call	0x9aa	; 0x9aa <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     e50:	8f 85       	ldd	r24, Y+15	; 0x0f
     e52:	88 23       	and	r24, r24
     e54:	09 f4       	brne	.+2      	; 0xe58 <_Z18getDateTime_eepromhh+0xc0>
     e56:	4e c0       	rjmp	.+156    	; 0xef4 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     e58:	1d 82       	std	Y+5, r1	; 0x05
     e5a:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     e60:	2f c0       	rjmp	.+94     	; 0xec0 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     e62:	84 e0       	ldi	r24, 0x04	; 4
     e64:	90 e0       	ldi	r25, 0x00	; 0
     e66:	0e 94 44 14 	call	0x2888	; 0x2888 <__eerd_byte_m324pa>
     e6a:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     e6c:	83 e0       	ldi	r24, 0x03	; 3
     e6e:	90 e0       	ldi	r25, 0x00	; 0
     e70:	0e 94 44 14 	call	0x2888	; 0x2888 <__eerd_byte_m324pa>
     e74:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     e76:	85 e0       	ldi	r24, 0x05	; 5
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	0e 94 4c 14 	call	0x2898	; 0x2898 <__eerd_word_m324pa>
     e7e:	9d 87       	std	Y+13, r25	; 0x0d
     e80:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     e82:	8a 85       	ldd	r24, Y+10	; 0x0a
     e84:	8f 31       	cpi	r24, 0x1F	; 31
     e86:	b8 f4       	brcc	.+46     	; 0xeb6 <_Z18getDateTime_eepromhh+0x11e>
     e88:	8b 85       	ldd	r24, Y+11	; 0x0b
     e8a:	8d 30       	cpi	r24, 0x0D	; 13
     e8c:	a0 f4       	brcc	.+40     	; 0xeb6 <_Z18getDateTime_eepromhh+0x11e>
     e8e:	8c 85       	ldd	r24, Y+12	; 0x0c
     e90:	9d 85       	ldd	r25, Y+13	; 0x0d
     e92:	27 e2       	ldi	r18, 0x27	; 39
     e94:	80 31       	cpi	r24, 0x10	; 16
     e96:	92 07       	cpc	r25, r18
     e98:	70 f4       	brcc	.+28     	; 0xeb6 <_Z18getDateTime_eepromhh+0x11e>
     e9a:	8b 85       	ldd	r24, Y+11	; 0x0b
     e9c:	68 2f       	mov	r22, r24
     e9e:	70 e0       	ldi	r23, 0x00	; 0
     ea0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ea2:	48 2f       	mov	r20, r24
     ea4:	50 e0       	ldi	r21, 0x00	; 0
     ea6:	2c 85       	ldd	r18, Y+12	; 0x0c
     ea8:	3d 85       	ldd	r19, Y+13	; 0x0d
     eaa:	83 e6       	ldi	r24, 0x63	; 99
     eac:	91 e0       	ldi	r25, 0x01	; 1
     eae:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
     eb2:	1e 82       	std	Y+6, r1	; 0x06
     eb4:	05 c0       	rjmp	.+10     	; 0xec0 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
     eb6:	8c 81       	ldd	r24, Y+4	; 0x04
     eb8:	9d 81       	ldd	r25, Y+5	; 0x05
     eba:	01 96       	adiw	r24, 0x01	; 1
     ebc:	9d 83       	std	Y+5, r25	; 0x05
     ebe:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
     ec0:	8e 81       	ldd	r24, Y+6	; 0x06
     ec2:	88 23       	and	r24, r24
     ec4:	39 f0       	breq	.+14     	; 0xed4 <_Z18getDateTime_eepromhh+0x13c>
     ec6:	8c 81       	ldd	r24, Y+4	; 0x04
     ec8:	9d 81       	ldd	r25, Y+5	; 0x05
     eca:	83 30       	cpi	r24, 0x03	; 3
     ecc:	91 05       	cpc	r25, r1
     ece:	14 f4       	brge	.+4      	; 0xed4 <_Z18getDateTime_eepromhh+0x13c>
     ed0:	81 e0       	ldi	r24, 0x01	; 1
     ed2:	01 c0       	rjmp	.+2      	; 0xed6 <_Z18getDateTime_eepromhh+0x13e>
     ed4:	80 e0       	ldi	r24, 0x00	; 0
     ed6:	88 23       	and	r24, r24
     ed8:	21 f6       	brne	.-120    	; 0xe62 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
     eda:	8e 81       	ldd	r24, Y+6	; 0x06
     edc:	88 23       	and	r24, r24
     ede:	51 f0       	breq	.+20     	; 0xef4 <_Z18getDateTime_eepromhh+0x15c>
     ee0:	83 e6       	ldi	r24, 0x63	; 99
     ee2:	91 e0       	ldi	r25, 0x01	; 1
     ee4:	61 e0       	ldi	r22, 0x01	; 1
     ee6:	70 e0       	ldi	r23, 0x00	; 0
     ee8:	41 e0       	ldi	r20, 0x01	; 1
     eea:	50 e0       	ldi	r21, 0x00	; 0
     eec:	21 ed       	ldi	r18, 0xD1	; 209
     eee:	37 e0       	ldi	r19, 0x07	; 7
     ef0:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
     ef4:	78 94       	sei
}
     ef6:	2f 96       	adiw	r28, 0x0f	; 15
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	29 97       	sbiw	r28, 0x09	; 9
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	88 87       	std	Y+8, r24	; 0x08
     f1e:	69 87       	std	Y+9, r22	; 0x09
	cli();
     f20:	f8 94       	cli
	if (sTime){
     f22:	88 85       	ldd	r24, Y+8	; 0x08
     f24:	88 23       	and	r24, r24
     f26:	f1 f0       	breq	.+60     	; 0xf64 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
     f28:	83 e6       	ldi	r24, 0x63	; 99
     f2a:	91 e0       	ldi	r25, 0x01	; 1
     f2c:	0e 94 37 04 	call	0x86e	; 0x86e <_ZN6myTime8getHoursEv>
     f30:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
     f32:	83 e6       	ldi	r24, 0x63	; 99
     f34:	91 e0       	ldi	r25, 0x01	; 1
     f36:	0e 94 26 04 	call	0x84c	; 0x84c <_ZN6myTime10getMinutesEv>
     f3a:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
     f3c:	83 e6       	ldi	r24, 0x63	; 99
     f3e:	91 e0       	ldi	r25, 0x01	; 1
     f40:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTime10getSecondsEv>
     f44:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
     f46:	82 e0       	ldi	r24, 0x02	; 2
     f48:	90 e0       	ldi	r25, 0x00	; 0
     f4a:	6b 81       	ldd	r22, Y+3	; 0x03
     f4c:	0e 94 52 14 	call	0x28a4	; 0x28a4 <__eewr_byte_m324pa>
		eeprom_write_byte(&eeMinute,tempMin);
     f50:	81 e0       	ldi	r24, 0x01	; 1
     f52:	90 e0       	ldi	r25, 0x00	; 0
     f54:	6a 81       	ldd	r22, Y+2	; 0x02
     f56:	0e 94 52 14 	call	0x28a4	; 0x28a4 <__eewr_byte_m324pa>
		eeprom_write_byte(&eeHour,tempHour);
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	69 81       	ldd	r22, Y+1	; 0x01
     f60:	0e 94 52 14 	call	0x28a4	; 0x28a4 <__eewr_byte_m324pa>
	}
	if (sDate){
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	88 23       	and	r24, r24
     f68:	09 f1       	breq	.+66     	; 0xfac <_Z19saveDateTime_eepromhh+0xa4>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
     f6a:	83 e6       	ldi	r24, 0x63	; 99
     f6c:	91 e0       	ldi	r25, 0x01	; 1
     f6e:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
     f72:	9d 83       	std	Y+5, r25	; 0x05
     f74:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
     f76:	83 e6       	ldi	r24, 0x63	; 99
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
     f7e:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
     f80:	83 e6       	ldi	r24, 0x63	; 99
     f82:	91 e0       	ldi	r25, 0x01	; 1
     f84:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
     f88:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
     f8a:	85 e0       	ldi	r24, 0x05	; 5
     f8c:	90 e0       	ldi	r25, 0x00	; 0
     f8e:	2c 81       	ldd	r18, Y+4	; 0x04
     f90:	3d 81       	ldd	r19, Y+5	; 0x05
     f92:	b9 01       	movw	r22, r18
     f94:	0e 94 60 14 	call	0x28c0	; 0x28c0 <__eewr_word_m324pa>
		eeprom_write_byte(&eeMonth,tempMonth);
     f98:	83 e0       	ldi	r24, 0x03	; 3
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	6e 81       	ldd	r22, Y+6	; 0x06
     f9e:	0e 94 52 14 	call	0x28a4	; 0x28a4 <__eewr_byte_m324pa>
		eeprom_write_byte(&eeDay,tempDay);
     fa2:	84 e0       	ldi	r24, 0x04	; 4
     fa4:	90 e0       	ldi	r25, 0x00	; 0
     fa6:	6f 81       	ldd	r22, Y+7	; 0x07
     fa8:	0e 94 52 14 	call	0x28a4	; 0x28a4 <__eewr_byte_m324pa>
	}
	sei();
     fac:	78 94       	sei
}
     fae:	29 96       	adiw	r28, 0x09	; 9
     fb0:	0f b6       	in	r0, 0x3f	; 63
     fb2:	f8 94       	cli
     fb4:	de bf       	out	0x3e, r29	; 62
     fb6:	0f be       	out	0x3f, r0	; 63
     fb8:	cd bf       	out	0x3d, r28	; 61
     fba:	df 91       	pop	r29
     fbc:	cf 91       	pop	r28
     fbe:	08 95       	ret

00000fc0 <__vector_4>:
volatile WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.

/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
ISR(PCINT0_vect){
     fc0:	1f 92       	push	r1
     fc2:	0f 92       	push	r0
     fc4:	0f b6       	in	r0, 0x3f	; 63
     fc6:	0f 92       	push	r0
     fc8:	11 24       	eor	r1, r1
     fca:	cf 93       	push	r28
     fcc:	df 93       	push	r29
     fce:	cd b7       	in	r28, 0x3d	; 61
     fd0:	de b7       	in	r29, 0x3e	; 62
	
	
}	
     fd2:	df 91       	pop	r29
     fd4:	cf 91       	pop	r28
     fd6:	0f 90       	pop	r0
     fd8:	0f be       	out	0x3f, r0	; 63
     fda:	0f 90       	pop	r0
     fdc:	1f 90       	pop	r1
     fde:	18 95       	reti

00000fe0 <__vector_3>:


ISR(INT2_vect){	//about to get time, get things ready
     fe0:	1f 92       	push	r1
     fe2:	0f 92       	push	r0
     fe4:	0f b6       	in	r0, 0x3f	; 63
     fe6:	0f 92       	push	r0
     fe8:	11 24       	eor	r1, r1
     fea:	2f 93       	push	r18
     fec:	3f 93       	push	r19
     fee:	4f 93       	push	r20
     ff0:	5f 93       	push	r21
     ff2:	6f 93       	push	r22
     ff4:	7f 93       	push	r23
     ff6:	8f 93       	push	r24
     ff8:	9f 93       	push	r25
     ffa:	af 93       	push	r26
     ffc:	bf 93       	push	r27
     ffe:	ef 93       	push	r30
    1000:	ff 93       	push	r31
    1002:	cf 93       	push	r28
    1004:	df 93       	push	r29
    1006:	cd b7       	in	r28, 0x3d	; 61
    1008:	de b7       	in	r29, 0x3e	; 62
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    100a:	90 91 5a 01 	lds	r25, 0x015A
    100e:	81 e0       	ldi	r24, 0x01	; 1
    1010:	99 23       	and	r25, r25
    1012:	09 f0       	breq	.+2      	; 0x1016 <__vector_3+0x36>
    1014:	80 e0       	ldi	r24, 0x00	; 0
    1016:	88 23       	and	r24, r24
    1018:	89 f0       	breq	.+34     	; 0x103c <__vector_3+0x5c>
		UCSR0B |= (1 << RXCIE0);
    101a:	81 ec       	ldi	r24, 0xC1	; 193
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	21 ec       	ldi	r18, 0xC1	; 193
    1020:	30 e0       	ldi	r19, 0x00	; 0
    1022:	f9 01       	movw	r30, r18
    1024:	20 81       	ld	r18, Z
    1026:	20 68       	ori	r18, 0x80	; 128
    1028:	fc 01       	movw	r30, r24
    102a:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    102c:	10 92 50 01 	sts	0x0150, r1
		flagNormalMode=fFalse;
    1030:	10 92 52 01 	sts	0x0152, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("ACKT");
    1034:	80 e0       	ldi	r24, 0x00	; 0
    1036:	91 e0       	ldi	r25, 0x01	; 1
    1038:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
	}	
}
    103c:	df 91       	pop	r29
    103e:	cf 91       	pop	r28
    1040:	ff 91       	pop	r31
    1042:	ef 91       	pop	r30
    1044:	bf 91       	pop	r27
    1046:	af 91       	pop	r26
    1048:	9f 91       	pop	r25
    104a:	8f 91       	pop	r24
    104c:	7f 91       	pop	r23
    104e:	6f 91       	pop	r22
    1050:	5f 91       	pop	r21
    1052:	4f 91       	pop	r20
    1054:	3f 91       	pop	r19
    1056:	2f 91       	pop	r18
    1058:	0f 90       	pop	r0
    105a:	0f be       	out	0x3f, r0	; 63
    105c:	0f 90       	pop	r0
    105e:	1f 90       	pop	r1
    1060:	18 95       	reti

00001062 <__vector_11>:

ISR(TIMER2_OVF_vect){
    1062:	1f 92       	push	r1
    1064:	0f 92       	push	r0
    1066:	0f b6       	in	r0, 0x3f	; 63
    1068:	0f 92       	push	r0
    106a:	11 24       	eor	r1, r1
    106c:	2f 93       	push	r18
    106e:	3f 93       	push	r19
    1070:	4f 93       	push	r20
    1072:	5f 93       	push	r21
    1074:	6f 93       	push	r22
    1076:	7f 93       	push	r23
    1078:	8f 93       	push	r24
    107a:	9f 93       	push	r25
    107c:	af 93       	push	r26
    107e:	bf 93       	push	r27
    1080:	ef 93       	push	r30
    1082:	ff 93       	push	r31
    1084:	cf 93       	push	r28
    1086:	df 93       	push	r29
    1088:	cd b7       	in	r28, 0x3d	; 61
    108a:	de b7       	in	r29, 0x3e	; 62
	volatile static int timeOut = 0;
	volatile static int gavrTimeout=0;
	
	currentTime.addSeconds(1);
    108c:	83 e6       	ldi	r24, 0x63	; 99
    108e:	91 e0       	ldi	r25, 0x01	; 1
    1090:	61 e0       	ldi	r22, 0x01	; 1
    1092:	70 e0       	ldi	r23, 0x00	; 0
    1094:	0e 94 f3 05 	call	0xbe6	; 0xbe6 <_ZN6myTime10addSecondsEi>
	if ((flagUARTbone == fTrue || flagGoToSleep == fFalse) && !flagNewShutdown && !restart){ //if waiting for a character in Receive0() or in main program without sleep
    1098:	80 91 51 01 	lds	r24, 0x0151
    109c:	81 30       	cpi	r24, 0x01	; 1
    109e:	21 f0       	breq	.+8      	; 0x10a8 <__vector_11+0x46>
    10a0:	80 91 50 01 	lds	r24, 0x0150
    10a4:	88 23       	and	r24, r24
    10a6:	51 f4       	brne	.+20     	; 0x10bc <__vector_11+0x5a>
    10a8:	80 91 59 01 	lds	r24, 0x0159
    10ac:	88 23       	and	r24, r24
    10ae:	31 f4       	brne	.+12     	; 0x10bc <__vector_11+0x5a>
    10b0:	80 91 5d 01 	lds	r24, 0x015D
    10b4:	88 23       	and	r24, r24
    10b6:	11 f4       	brne	.+4      	; 0x10bc <__vector_11+0x5a>
    10b8:	81 e0       	ldi	r24, 0x01	; 1
    10ba:	01 c0       	rjmp	.+2      	; 0x10be <__vector_11+0x5c>
    10bc:	80 e0       	ldi	r24, 0x00	; 0
    10be:	88 23       	and	r24, r24
    10c0:	51 f1       	breq	.+84     	; 0x1116 <__vector_11+0xb4>
		timeOut++;
    10c2:	80 91 8b 01 	lds	r24, 0x018B
    10c6:	90 91 8c 01 	lds	r25, 0x018C
    10ca:	01 96       	adiw	r24, 0x01	; 1
    10cc:	90 93 8c 01 	sts	0x018C, r25
    10d0:	80 93 8b 01 	sts	0x018B, r24
		if (timeOut >= 6){
    10d4:	80 91 8b 01 	lds	r24, 0x018B
    10d8:	90 91 8c 01 	lds	r25, 0x018C
    10dc:	21 e0       	ldi	r18, 0x01	; 1
    10de:	86 30       	cpi	r24, 0x06	; 6
    10e0:	91 05       	cpc	r25, r1
    10e2:	0c f4       	brge	.+2      	; 0x10e6 <__vector_11+0x84>
    10e4:	20 e0       	ldi	r18, 0x00	; 0
    10e6:	22 23       	and	r18, r18
    10e8:	29 f1       	breq	.+74     	; 0x1134 <__vector_11+0xd2>
			EIMSK |= (1 << INT2);		//re-enable INT2
    10ea:	8d e3       	ldi	r24, 0x3D	; 61
    10ec:	90 e0       	ldi	r25, 0x00	; 0
    10ee:	2d e3       	ldi	r18, 0x3D	; 61
    10f0:	30 e0       	ldi	r19, 0x00	; 0
    10f2:	f9 01       	movw	r30, r18
    10f4:	20 81       	ld	r18, Z
    10f6:	24 60       	ori	r18, 0x04	; 4
    10f8:	fc 01       	movw	r30, r24
    10fa:	20 83       	st	Z, r18
			flagUARTbone = fFalse;
    10fc:	10 92 51 01 	sts	0x0151, r1
			flagGoToSleep = fTrue;
    1100:	81 e0       	ldi	r24, 0x01	; 1
    1102:	80 93 50 01 	sts	0x0150, r24
			flagNormalMode=fTrue;
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	80 93 52 01 	sts	0x0152, r24
			timeOut = 0;
    110c:	10 92 8c 01 	sts	0x018C, r1
    1110:	10 92 8b 01 	sts	0x018B, r1
    1114:	0f c0       	rjmp	.+30     	; 0x1134 <__vector_11+0xd2>
		}
	} else if (timeOut > 0){
    1116:	80 91 8b 01 	lds	r24, 0x018B
    111a:	90 91 8c 01 	lds	r25, 0x018C
    111e:	21 e0       	ldi	r18, 0x01	; 1
    1120:	18 16       	cp	r1, r24
    1122:	19 06       	cpc	r1, r25
    1124:	0c f0       	brlt	.+2      	; 0x1128 <__vector_11+0xc6>
    1126:	20 e0       	ldi	r18, 0x00	; 0
    1128:	22 23       	and	r18, r18
    112a:	21 f0       	breq	.+8      	; 0x1134 <__vector_11+0xd2>
		timeOut = 0;
    112c:	10 92 8c 01 	sts	0x018C, r1
    1130:	10 92 8b 01 	sts	0x018B, r1
	} else;
	/* This doesnt work
	if (flagSendingGAVR){gavrTimeout++;}
	if (gavrTimeout>10 && flagSendingGAVR){noTimeout=fFalse; flagSendingGAVR=fFalse;gavrTimeout=0;}
	else; 	*/
}
    1134:	df 91       	pop	r29
    1136:	cf 91       	pop	r28
    1138:	ff 91       	pop	r31
    113a:	ef 91       	pop	r30
    113c:	bf 91       	pop	r27
    113e:	af 91       	pop	r26
    1140:	9f 91       	pop	r25
    1142:	8f 91       	pop	r24
    1144:	7f 91       	pop	r23
    1146:	6f 91       	pop	r22
    1148:	5f 91       	pop	r21
    114a:	4f 91       	pop	r20
    114c:	3f 91       	pop	r19
    114e:	2f 91       	pop	r18
    1150:	0f 90       	pop	r0
    1152:	0f be       	out	0x3f, r0	; 63
    1154:	0f 90       	pop	r0
    1156:	1f 90       	pop	r1
    1158:	18 95       	reti

0000115a <__vector_20>:

ISR(USART0_RX_vect){
    115a:	1f 92       	push	r1
    115c:	0f 92       	push	r0
    115e:	0f b6       	in	r0, 0x3f	; 63
    1160:	0f 92       	push	r0
    1162:	11 24       	eor	r1, r1
    1164:	2f 93       	push	r18
    1166:	3f 93       	push	r19
    1168:	8f 93       	push	r24
    116a:	9f 93       	push	r25
    116c:	ef 93       	push	r30
    116e:	ff 93       	push	r31
    1170:	cf 93       	push	r28
    1172:	df 93       	push	r29
    1174:	cd b7       	in	r28, 0x3d	; 61
    1176:	de b7       	in	r29, 0x3e	; 62
	UCSR0B &= ~(1 << RXCIE0);
    1178:	81 ec       	ldi	r24, 0xC1	; 193
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	21 ec       	ldi	r18, 0xC1	; 193
    117e:	30 e0       	ldi	r19, 0x00	; 0
    1180:	f9 01       	movw	r30, r18
    1182:	20 81       	ld	r18, Z
    1184:	2f 77       	andi	r18, 0x7F	; 127
    1186:	fc 01       	movw	r30, r24
    1188:	20 83       	st	Z, r18
	EIMSK=0x00;
    118a:	8d e3       	ldi	r24, 0x3D	; 61
    118c:	90 e0       	ldi	r25, 0x00	; 0
    118e:	fc 01       	movw	r30, r24
    1190:	10 82       	st	Z, r1
	flagUARTbone=fTrue;
    1192:	81 e0       	ldi	r24, 0x01	; 1
    1194:	80 93 51 01 	sts	0x0151, r24
	flagNormalMode=fFalse;
    1198:	10 92 52 01 	sts	0x0152, r1
}
    119c:	df 91       	pop	r29
    119e:	cf 91       	pop	r28
    11a0:	ff 91       	pop	r31
    11a2:	ef 91       	pop	r30
    11a4:	9f 91       	pop	r25
    11a6:	8f 91       	pop	r24
    11a8:	3f 91       	pop	r19
    11aa:	2f 91       	pop	r18
    11ac:	0f 90       	pop	r0
    11ae:	0f be       	out	0x3f, r0	; 63
    11b0:	0f 90       	pop	r0
    11b2:	1f 90       	pop	r1
    11b4:	18 95       	reti

000011b6 <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    11b6:	cf 93       	push	r28
    11b8:	df 93       	push	r29
    11ba:	00 d0       	rcall	.+0      	; 0x11bc <main+0x6>
    11bc:	cd b7       	in	r28, 0x3d	; 61
    11be:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    11c0:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <_Z10DeviceInitv>
	AppInit(MYUBRR);
    11c4:	81 e8       	ldi	r24, 0x81	; 129
    11c6:	90 e0       	ldi	r25, 0x00	; 0
    11c8:	0e 94 a5 0a 	call	0x154a	; 0x154a <_Z7AppInitj>
	EnableRTCTimer();
    11cc:	0e 94 7e 0b 	call	0x16fc	; 0x16fc <_Z14EnableRTCTimerv>
	getDateTime_eeprom(fTrue,fTrue);
    11d0:	81 e0       	ldi	r24, 0x01	; 1
    11d2:	61 e0       	ldi	r22, 0x01	; 1
    11d4:	0e 94 cc 06 	call	0xd98	; 0xd98 <_Z18getDateTime_eepromhh>
	sei();
    11d8:	78 94       	sei
	//Prep/make sure power/temp is good
	GetTemp();
    11da:	0e 94 4b 10 	call	0x2096	; 0x2096 <_Z7GetTempv>
	//flagGoodTemp=fTrue;
	TakeADC();
    11de:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <_Z7TakeADCv>
	if (flagGoodVolts && flagGoodTemp){__powPeriph();flagFreshStart=fTrue;}
    11e2:	80 91 5c 01 	lds	r24, 0x015C
    11e6:	88 23       	and	r24, r24
    11e8:	31 f0       	breq	.+12     	; 0x11f6 <main+0x40>
    11ea:	80 91 5b 01 	lds	r24, 0x015B
    11ee:	88 23       	and	r24, r24
    11f0:	11 f0       	breq	.+4      	; 0x11f6 <main+0x40>
    11f2:	81 e0       	ldi	r24, 0x01	; 1
    11f4:	01 c0       	rjmp	.+2      	; 0x11f8 <main+0x42>
    11f6:	80 e0       	ldi	r24, 0x00	; 0
    11f8:	88 23       	and	r24, r24
    11fa:	b1 f0       	breq	.+44     	; 0x1228 <main+0x72>
    11fc:	82 e2       	ldi	r24, 0x22	; 34
    11fe:	90 e0       	ldi	r25, 0x00	; 0
    1200:	22 e2       	ldi	r18, 0x22	; 34
    1202:	30 e0       	ldi	r19, 0x00	; 0
    1204:	f9 01       	movw	r30, r18
    1206:	20 81       	ld	r18, Z
    1208:	20 6e       	ori	r18, 0xE0	; 224
    120a:	fc 01       	movw	r30, r24
    120c:	20 83       	st	Z, r18
    120e:	85 e2       	ldi	r24, 0x25	; 37
    1210:	90 e0       	ldi	r25, 0x00	; 0
    1212:	25 e2       	ldi	r18, 0x25	; 37
    1214:	30 e0       	ldi	r19, 0x00	; 0
    1216:	f9 01       	movw	r30, r18
    1218:	20 81       	ld	r18, Z
    121a:	21 60       	ori	r18, 0x01	; 1
    121c:	fc 01       	movw	r30, r24
    121e:	20 83       	st	Z, r18
    1220:	81 e0       	ldi	r24, 0x01	; 1
    1222:	80 93 5e 01 	sts	0x015E, r24
    1226:	07 c0       	rjmp	.+14     	; 0x1236 <main+0x80>
	else {flagNormalMode=fTrue;flagFreshStart=fFalse;}
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	80 93 52 01 	sts	0x0152, r24
    122e:	10 92 5e 01 	sts	0x015E, r1
    1232:	01 c0       	rjmp	.+2      	; 0x1236 <main+0x80>
	//main programming loop
	while(fTrue)
    1234:	00 00       	nop
	{				
		//If receiving UART string, go get rest of it.
		if (flagUARTbone){
    1236:	90 91 51 01 	lds	r25, 0x0151
    123a:	81 e0       	ldi	r24, 0x01	; 1
    123c:	99 23       	and	r25, r25
    123e:	09 f4       	brne	.+2      	; 0x1242 <main+0x8c>
    1240:	80 e0       	ldi	r24, 0x00	; 0
    1242:	88 23       	and	r24, r24
    1244:	99 f0       	breq	.+38     	; 0x126c <main+0xb6>
			EIMSK=0;
    1246:	8d e3       	ldi	r24, 0x3D	; 61
    1248:	90 e0       	ldi	r25, 0x00	; 0
    124a:	fc 01       	movw	r30, r24
    124c:	10 82       	st	Z, r1
			ReceiveBone();
    124e:	0e 94 c8 0c 	call	0x1990	; 0x1990 <_Z11ReceiveBonev>
			flagUARTbone = fFalse; 
    1252:	10 92 51 01 	sts	0x0151, r1
			//PCIMSK |= (1 << PCINT0);
			EIMSK = (1 << INT2);											//enable INT2 interrupt vector again.
    1256:	8d e3       	ldi	r24, 0x3D	; 61
    1258:	90 e0       	ldi	r25, 0x00	; 0
    125a:	24 e0       	ldi	r18, 0x04	; 4
    125c:	fc 01       	movw	r30, r24
    125e:	20 83       	st	Z, r18
			flagGoToSleep = fTrue;
    1260:	81 e0       	ldi	r24, 0x01	; 1
    1262:	80 93 50 01 	sts	0x0150, r24
			flagNormalMode=fTrue;
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	80 93 52 01 	sts	0x0152, r24
		}
	
		if (flagUpdateGAVRTime || flagUpdateGAVRDate){
    126c:	80 91 55 01 	lds	r24, 0x0155
    1270:	88 23       	and	r24, r24
    1272:	21 f4       	brne	.+8      	; 0x127c <main+0xc6>
    1274:	80 91 56 01 	lds	r24, 0x0156
    1278:	88 23       	and	r24, r24
    127a:	11 f0       	breq	.+4      	; 0x1280 <main+0xca>
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	01 c0       	rjmp	.+2      	; 0x1282 <main+0xcc>
    1280:	80 e0       	ldi	r24, 0x00	; 0
    1282:	88 23       	and	r24, r24
    1284:	49 f0       	breq	.+18     	; 0x1298 <main+0xe2>
			//kill INT2, updating GAVR
			EIMSK=0x00;
    1286:	8d e3       	ldi	r24, 0x3D	; 61
    1288:	90 e0       	ldi	r25, 0x00	; 0
    128a:	fc 01       	movw	r30, r24
    128c:	10 82       	st	Z, r1
			//SendTimeDateGAVR(flagUpdateGAVRTime,flagUpdateGAVRDate);
			EIMSK = (1 << INT2);
    128e:	8d e3       	ldi	r24, 0x3D	; 61
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	24 e0       	ldi	r18, 0x04	; 4
    1294:	fc 01       	movw	r30, r24
    1296:	20 83       	st	Z, r18
		}

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    1298:	90 91 52 01 	lds	r25, 0x0152
    129c:	81 e0       	ldi	r24, 0x01	; 1
    129e:	99 23       	and	r25, r25
    12a0:	09 f4       	brne	.+2      	; 0x12a4 <main+0xee>
    12a2:	80 e0       	ldi	r24, 0x00	; 0
    12a4:	88 23       	and	r24, r24
    12a6:	49 f1       	breq	.+82     	; 0x12fa <main+0x144>
			if (currentTime.getMinutes()%30 == 0){
    12a8:	83 e6       	ldi	r24, 0x63	; 99
    12aa:	91 e0       	ldi	r25, 0x01	; 1
    12ac:	0e 94 26 04 	call	0x84c	; 0x84c <_ZN6myTime10getMinutesEv>
    12b0:	9e e1       	ldi	r25, 0x1E	; 30
    12b2:	69 2f       	mov	r22, r25
    12b4:	0e 94 a9 13 	call	0x2752	; 0x2752 <__udivmodqi4>
    12b8:	89 2f       	mov	r24, r25
    12ba:	98 2f       	mov	r25, r24
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	99 23       	and	r25, r25
    12c0:	09 f0       	breq	.+2      	; 0x12c4 <main+0x10e>
    12c2:	80 e0       	ldi	r24, 0x00	; 0
    12c4:	88 23       	and	r24, r24
    12c6:	c9 f0       	breq	.+50     	; 0x12fa <main+0x144>
				if (currentTime.getHours()%12 == 0){
    12c8:	83 e6       	ldi	r24, 0x63	; 99
    12ca:	91 e0       	ldi	r25, 0x01	; 1
    12cc:	0e 94 37 04 	call	0x86e	; 0x86e <_ZN6myTime8getHoursEv>
    12d0:	9c e0       	ldi	r25, 0x0C	; 12
    12d2:	69 2f       	mov	r22, r25
    12d4:	0e 94 a9 13 	call	0x2752	; 0x2752 <__udivmodqi4>
    12d8:	89 2f       	mov	r24, r25
    12da:	98 2f       	mov	r25, r24
    12dc:	81 e0       	ldi	r24, 0x01	; 1
    12de:	99 23       	and	r25, r25
    12e0:	09 f0       	breq	.+2      	; 0x12e4 <main+0x12e>
    12e2:	80 e0       	ldi	r24, 0x00	; 0
    12e4:	88 23       	and	r24, r24
    12e6:	29 f0       	breq	.+10     	; 0x12f2 <main+0x13c>
					saveDateTime_eeprom(fTrue,fTrue);
    12e8:	81 e0       	ldi	r24, 0x01	; 1
    12ea:	61 e0       	ldi	r22, 0x01	; 1
    12ec:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    12f0:	04 c0       	rjmp	.+8      	; 0x12fa <main+0x144>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	60 e0       	ldi	r22, 0x00	; 0
    12f6:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}
		
		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    12fa:	90 91 52 01 	lds	r25, 0x0152
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	99 23       	and	r25, r25
    1302:	09 f4       	brne	.+2      	; 0x1306 <main+0x150>
    1304:	80 e0       	ldi	r24, 0x00	; 0
    1306:	88 23       	and	r24, r24
    1308:	09 f4       	brne	.+2      	; 0x130c <main+0x156>
    130a:	3f c0       	rjmp	.+126    	; 0x138a <main+0x1d4>
			TakeADC();
    130c:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <_Z7TakeADCv>
			GetTemp();
    1310:	0e 94 4b 10 	call	0x2096	; 0x2096 <_Z7GetTempv>
			//If both are good & shutodwn is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    1314:	80 91 5c 01 	lds	r24, 0x015C
    1318:	88 23       	and	r24, r24
    131a:	31 f0       	breq	.+12     	; 0x1328 <main+0x172>
    131c:	80 91 5b 01 	lds	r24, 0x015B
    1320:	88 23       	and	r24, r24
    1322:	11 f0       	breq	.+4      	; 0x1328 <main+0x172>
    1324:	81 e0       	ldi	r24, 0x01	; 1
    1326:	01 c0       	rjmp	.+2      	; 0x132a <main+0x174>
    1328:	80 e0       	ldi	r24, 0x00	; 0
    132a:	88 23       	and	r24, r24
    132c:	01 f1       	breq	.+64     	; 0x136e <main+0x1b8>
				__powPeriph();
    132e:	82 e2       	ldi	r24, 0x22	; 34
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	22 e2       	ldi	r18, 0x22	; 34
    1334:	30 e0       	ldi	r19, 0x00	; 0
    1336:	f9 01       	movw	r30, r18
    1338:	20 81       	ld	r18, Z
    133a:	20 6e       	ori	r18, 0xE0	; 224
    133c:	fc 01       	movw	r30, r24
    133e:	20 83       	st	Z, r18
    1340:	85 e2       	ldi	r24, 0x25	; 37
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	25 e2       	ldi	r18, 0x25	; 37
    1346:	30 e0       	ldi	r19, 0x00	; 0
    1348:	f9 01       	movw	r30, r18
    134a:	20 81       	ld	r18, Z
    134c:	21 60       	ori	r18, 0x01	; 1
    134e:	fc 01       	movw	r30, r24
    1350:	20 83       	st	Z, r18
				if( flagShutdown == fTrue){restart = fTrue;}
    1352:	90 91 5a 01 	lds	r25, 0x015A
    1356:	81 e0       	ldi	r24, 0x01	; 1
    1358:	91 30       	cpi	r25, 0x01	; 1
    135a:	09 f0       	breq	.+2      	; 0x135e <main+0x1a8>
    135c:	80 e0       	ldi	r24, 0x00	; 0
    135e:	88 23       	and	r24, r24
    1360:	19 f0       	breq	.+6      	; 0x1368 <main+0x1b2>
    1362:	81 e0       	ldi	r24, 0x01	; 1
    1364:	80 93 5d 01 	sts	0x015D, r24
				flagShutdown = fFalse;
    1368:	10 92 5a 01 	sts	0x015A, r1
    136c:	0e c0       	rjmp	.+28     	; 0x138a <main+0x1d4>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (flagShutdown == fFalse){
    136e:	90 91 5a 01 	lds	r25, 0x015A
    1372:	81 e0       	ldi	r24, 0x01	; 1
    1374:	99 23       	and	r25, r25
    1376:	09 f0       	breq	.+2      	; 0x137a <main+0x1c4>
    1378:	80 e0       	ldi	r24, 0x00	; 0
    137a:	88 23       	and	r24, r24
    137c:	19 f0       	breq	.+6      	; 0x1384 <main+0x1ce>
					flagNewShutdown = fTrue;
    137e:	81 e0       	ldi	r24, 0x01	; 1
    1380:	80 93 59 01 	sts	0x0159, r24
				}
				flagShutdown = fTrue;
    1384:	81 e0       	ldi	r24, 0x01	; 1
    1386:	80 93 5a 01 	sts	0x015A, r24
			}
		}			
		
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    138a:	90 91 59 01 	lds	r25, 0x0159
    138e:	81 e0       	ldi	r24, 0x01	; 1
    1390:	99 23       	and	r25, r25
    1392:	09 f4       	brne	.+2      	; 0x1396 <main+0x1e0>
    1394:	80 e0       	ldi	r24, 0x00	; 0
    1396:	88 23       	and	r24, r24
    1398:	09 f4       	brne	.+2      	; 0x139c <main+0x1e6>
    139a:	63 c0       	rjmp	.+198    	; 0x1462 <main+0x2ac>
			//Make sure nothing messes with the routine that we care about
			EIMSK = 0;
    139c:	8d e3       	ldi	r24, 0x3D	; 61
    139e:	90 e0       	ldi	r25, 0x00	; 0
    13a0:	fc 01       	movw	r30, r24
    13a2:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    13a4:	81 e0       	ldi	r24, 0x01	; 1
    13a6:	80 93 50 01 	sts	0x0150, r24
			flagUARTbone = fFalse;
    13aa:	10 92 51 01 	sts	0x0151, r1
			saveDateTime_eeprom(fTrue,fTrue);
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	61 e0       	ldi	r22, 0x01	; 1
    13b2:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
			
			//Alert BeagleBone and Graphics AVR that powerdown is imminent=> raise SHUTDOWN PINS for 3 clk cycles
			prtBBleds |= (1 << bnBBint);
    13b6:	82 e2       	ldi	r24, 0x22	; 34
    13b8:	90 e0       	ldi	r25, 0x00	; 0
    13ba:	22 e2       	ldi	r18, 0x22	; 34
    13bc:	30 e0       	ldi	r19, 0x00	; 0
    13be:	f9 01       	movw	r30, r18
    13c0:	20 81       	ld	r18, Z
    13c2:	22 60       	ori	r18, 0x02	; 2
    13c4:	fc 01       	movw	r30, r24
    13c6:	20 83       	st	Z, r18
			prtGAVRleds |= (1 << bnGAVRint);
    13c8:	82 e2       	ldi	r24, 0x22	; 34
    13ca:	90 e0       	ldi	r25, 0x00	; 0
    13cc:	22 e2       	ldi	r18, 0x22	; 34
    13ce:	30 e0       	ldi	r19, 0x00	; 0
    13d0:	f9 01       	movw	r30, r18
    13d2:	20 81       	ld	r18, Z
    13d4:	28 60       	ori	r18, 0x08	; 8
    13d6:	fc 01       	movw	r30, r24
    13d8:	20 83       	st	Z, r18
			if (!flagGoodTemp){
    13da:	90 91 5b 01 	lds	r25, 0x015B
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	99 23       	and	r25, r25
    13e2:	09 f0       	breq	.+2      	; 0x13e6 <main+0x230>
    13e4:	80 e0       	ldi	r24, 0x00	; 0
    13e6:	88 23       	and	r24, r24
    13e8:	91 f0       	breq	.+36     	; 0x140e <main+0x258>
				prtBBleds |= (1 << bnBBtemp);
    13ea:	82 e2       	ldi	r24, 0x22	; 34
    13ec:	90 e0       	ldi	r25, 0x00	; 0
    13ee:	22 e2       	ldi	r18, 0x22	; 34
    13f0:	30 e0       	ldi	r19, 0x00	; 0
    13f2:	f9 01       	movw	r30, r18
    13f4:	20 81       	ld	r18, Z
    13f6:	24 60       	ori	r18, 0x04	; 4
    13f8:	fc 01       	movw	r30, r24
    13fa:	20 83       	st	Z, r18
				prtGAVRleds |= (1 << bnGAVRtemp);
    13fc:	82 e2       	ldi	r24, 0x22	; 34
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	22 e2       	ldi	r18, 0x22	; 34
    1402:	30 e0       	ldi	r19, 0x00	; 0
    1404:	f9 01       	movw	r30, r18
    1406:	20 81       	ld	r18, Z
    1408:	20 61       	ori	r18, 0x10	; 16
    140a:	fc 01       	movw	r30, r24
    140c:	20 83       	st	Z, r18
			}
			
			//Five seconds for processing to finish on other chips
			Wait_sec(6);	
    140e:	86 e0       	ldi	r24, 0x06	; 6
    1410:	90 e0       	ldi	r25, 0x00	; 0
    1412:	0e 94 ed 0b 	call	0x17da	; 0x17da <_Z8Wait_seci>
			
			prtBBleds &= ~((1 << bnBBint)|(1 << bnBBtemp));
    1416:	82 e2       	ldi	r24, 0x22	; 34
    1418:	90 e0       	ldi	r25, 0x00	; 0
    141a:	22 e2       	ldi	r18, 0x22	; 34
    141c:	30 e0       	ldi	r19, 0x00	; 0
    141e:	f9 01       	movw	r30, r18
    1420:	20 81       	ld	r18, Z
    1422:	29 7f       	andi	r18, 0xF9	; 249
    1424:	fc 01       	movw	r30, r24
    1426:	20 83       	st	Z, r18
			prtGAVRleds &= ~((1 << bnGAVRint)|(1 << bnGAVRtemp));
    1428:	82 e2       	ldi	r24, 0x22	; 34
    142a:	90 e0       	ldi	r25, 0x00	; 0
    142c:	22 e2       	ldi	r18, 0x22	; 34
    142e:	30 e0       	ldi	r19, 0x00	; 0
    1430:	f9 01       	movw	r30, r18
    1432:	20 81       	ld	r18, Z
    1434:	27 7e       	andi	r18, 0xE7	; 231
    1436:	fc 01       	movw	r30, r24
    1438:	20 83       	st	Z, r18
			
			//Kill power
			__killPeriphPow();
    143a:	82 e2       	ldi	r24, 0x22	; 34
    143c:	90 e0       	ldi	r25, 0x00	; 0
    143e:	22 e2       	ldi	r18, 0x22	; 34
    1440:	30 e0       	ldi	r19, 0x00	; 0
    1442:	f9 01       	movw	r30, r18
    1444:	20 81       	ld	r18, Z
    1446:	2f 71       	andi	r18, 0x1F	; 31
    1448:	fc 01       	movw	r30, r24
    144a:	20 83       	st	Z, r18
    144c:	85 e2       	ldi	r24, 0x25	; 37
    144e:	90 e0       	ldi	r25, 0x00	; 0
    1450:	25 e2       	ldi	r18, 0x25	; 37
    1452:	30 e0       	ldi	r19, 0x00	; 0
    1454:	f9 01       	movw	r30, r18
    1456:	20 81       	ld	r18, Z
    1458:	2e 7f       	andi	r18, 0xFE	; 254
    145a:	fc 01       	movw	r30, r24
    145c:	20 83       	st	Z, r18
			flagNewShutdown = fFalse;
    145e:	10 92 59 01 	sts	0x0159, r1
		}
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    1462:	90 91 5d 01 	lds	r25, 0x015D
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	99 23       	and	r25, r25
    146a:	09 f4       	brne	.+2      	; 0x146e <main+0x2b8>
    146c:	80 e0       	ldi	r24, 0x00	; 0
    146e:	88 23       	and	r24, r24
    1470:	b9 f1       	breq	.+110    	; 0x14e0 <main+0x32a>
			EIMSK = (1 << INT2);	//enable BONE interrupt. Will come out with newest time. Give it 10 seconds to kill
    1472:	8d e3       	ldi	r24, 0x3D	; 61
    1474:	90 e0       	ldi	r25, 0x00	; 0
    1476:	24 e0       	ldi	r18, 0x04	; 4
    1478:	fc 01       	movw	r30, r24
    147a:	20 83       	st	Z, r18
			__powPeriph();
    147c:	82 e2       	ldi	r24, 0x22	; 34
    147e:	90 e0       	ldi	r25, 0x00	; 0
    1480:	22 e2       	ldi	r18, 0x22	; 34
    1482:	30 e0       	ldi	r19, 0x00	; 0
    1484:	f9 01       	movw	r30, r18
    1486:	20 81       	ld	r18, Z
    1488:	20 6e       	ori	r18, 0xE0	; 224
    148a:	fc 01       	movw	r30, r24
    148c:	20 83       	st	Z, r18
    148e:	85 e2       	ldi	r24, 0x25	; 37
    1490:	90 e0       	ldi	r25, 0x00	; 0
    1492:	25 e2       	ldi	r18, 0x25	; 37
    1494:	30 e0       	ldi	r19, 0x00	; 0
    1496:	f9 01       	movw	r30, r18
    1498:	20 81       	ld	r18, Z
    149a:	21 60       	ori	r18, 0x01	; 1
    149c:	fc 01       	movw	r30, r24
    149e:	20 83       	st	Z, r18
			//Check to see if pins are ready. Use timeout of 10 seconds for pins to come high.
			int waitTime = 0;
    14a0:	1a 82       	std	Y+2, r1	; 0x02
    14a2:	19 82       	std	Y+1, r1	; 0x01
			while (waitTime < 3 && restart){waitTime++; Wait_sec(1);}
    14a4:	09 c0       	rjmp	.+18     	; 0x14b8 <main+0x302>
    14a6:	89 81       	ldd	r24, Y+1	; 0x01
    14a8:	9a 81       	ldd	r25, Y+2	; 0x02
    14aa:	01 96       	adiw	r24, 0x01	; 1
    14ac:	9a 83       	std	Y+2, r25	; 0x02
    14ae:	89 83       	std	Y+1, r24	; 0x01
    14b0:	81 e0       	ldi	r24, 0x01	; 1
    14b2:	90 e0       	ldi	r25, 0x00	; 0
    14b4:	0e 94 ed 0b 	call	0x17da	; 0x17da <_Z8Wait_seci>
    14b8:	89 81       	ldd	r24, Y+1	; 0x01
    14ba:	9a 81       	ldd	r25, Y+2	; 0x02
    14bc:	83 30       	cpi	r24, 0x03	; 3
    14be:	91 05       	cpc	r25, r1
    14c0:	34 f4       	brge	.+12     	; 0x14ce <main+0x318>
    14c2:	80 91 5d 01 	lds	r24, 0x015D
    14c6:	88 23       	and	r24, r24
    14c8:	11 f0       	breq	.+4      	; 0x14ce <main+0x318>
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	01 c0       	rjmp	.+2      	; 0x14d0 <main+0x31a>
    14ce:	80 e0       	ldi	r24, 0x00	; 0
    14d0:	88 23       	and	r24, r24
    14d2:	49 f7       	brne	.-46     	; 0x14a6 <main+0x2f0>
			flagUpdateGAVRDate=fTrue;
    14d4:	81 e0       	ldi	r24, 0x01	; 1
    14d6:	80 93 56 01 	sts	0x0156, r24
			flagUpdateGAVRTime=fTrue;
    14da:	81 e0       	ldi	r24, 0x01	; 1
    14dc:	80 93 55 01 	sts	0x0155, r24
			//get an updated date and time from the BeagleBone. Always update GAVR.			
		}		
		
			
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep){GoToSleep(flagShutdown);}
    14e0:	90 91 50 01 	lds	r25, 0x0150
    14e4:	81 e0       	ldi	r24, 0x01	; 1
    14e6:	99 23       	and	r25, r25
    14e8:	09 f4       	brne	.+2      	; 0x14ec <main+0x336>
    14ea:	80 e0       	ldi	r24, 0x00	; 0
    14ec:	88 23       	and	r24, r24
    14ee:	09 f4       	brne	.+2      	; 0x14f2 <main+0x33c>
    14f0:	a1 ce       	rjmp	.-702    	; 0x1234 <main+0x7e>
    14f2:	80 91 5a 01 	lds	r24, 0x015A
    14f6:	0e 94 2d 0f 	call	0x1e5a	; 0x1e5a <_Z9GoToSleeph>
	//flagGoodTemp=fTrue;
	TakeADC();
	if (flagGoodVolts && flagGoodTemp){__powPeriph();flagFreshStart=fTrue;}
	else {flagNormalMode=fTrue;flagFreshStart=fFalse;}
	//main programming loop
	while(fTrue)
    14fa:	9c ce       	rjmp	.-712    	; 0x1234 <main+0x7e>

000014fc <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    14fc:	cf 93       	push	r28
    14fe:	df 93       	push	r29
    1500:	cd b7       	in	r28, 0x3d	; 61
    1502:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    1504:	81 e2       	ldi	r24, 0x21	; 33
    1506:	90 e0       	ldi	r25, 0x00	; 0
    1508:	fc 01       	movw	r30, r24
    150a:	10 82       	st	Z, r1
	DDRB = 0;
    150c:	84 e2       	ldi	r24, 0x24	; 36
    150e:	90 e0       	ldi	r25, 0x00	; 0
    1510:	fc 01       	movw	r30, r24
    1512:	10 82       	st	Z, r1
	DDRC = 0;
    1514:	87 e2       	ldi	r24, 0x27	; 39
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	fc 01       	movw	r30, r24
    151a:	10 82       	st	Z, r1
	DDRD = 0;
    151c:	8a e2       	ldi	r24, 0x2A	; 42
    151e:	90 e0       	ldi	r25, 0x00	; 0
    1520:	fc 01       	movw	r30, r24
    1522:	10 82       	st	Z, r1
	
	PORTA = 0;
    1524:	82 e2       	ldi	r24, 0x22	; 34
    1526:	90 e0       	ldi	r25, 0x00	; 0
    1528:	fc 01       	movw	r30, r24
    152a:	10 82       	st	Z, r1
	PORTB = 0;
    152c:	85 e2       	ldi	r24, 0x25	; 37
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	fc 01       	movw	r30, r24
    1532:	10 82       	st	Z, r1
	PORTC = 0;
    1534:	88 e2       	ldi	r24, 0x28	; 40
    1536:	90 e0       	ldi	r25, 0x00	; 0
    1538:	fc 01       	movw	r30, r24
    153a:	10 82       	st	Z, r1
	PORTD = 0;
    153c:	8b e2       	ldi	r24, 0x2B	; 43
    153e:	90 e0       	ldi	r25, 0x00	; 0
    1540:	fc 01       	movw	r30, r24
    1542:	10 82       	st	Z, r1
}
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	08 95       	ret

0000154a <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    154a:	cf 93       	push	r28
    154c:	df 93       	push	r29
    154e:	00 d0       	rcall	.+0      	; 0x1550 <_Z7AppInitj+0x6>
    1550:	cd b7       	in	r28, 0x3d	; 61
    1552:	de b7       	in	r29, 0x3e	; 62
    1554:	9a 83       	std	Y+2, r25	; 0x02
    1556:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    1558:	84 ec       	ldi	r24, 0xC4	; 196
    155a:	90 e0       	ldi	r25, 0x00	; 0
    155c:	29 81       	ldd	r18, Y+1	; 0x01
    155e:	fc 01       	movw	r30, r24
    1560:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    1562:	85 ec       	ldi	r24, 0xC5	; 197
    1564:	90 e0       	ldi	r25, 0x00	; 0
    1566:	29 81       	ldd	r18, Y+1	; 0x01
    1568:	3a 81       	ldd	r19, Y+2	; 0x02
    156a:	23 2f       	mov	r18, r19
    156c:	33 27       	eor	r19, r19
    156e:	fc 01       	movw	r30, r24
    1570:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    1572:	81 ec       	ldi	r24, 0xC1	; 193
    1574:	90 e0       	ldi	r25, 0x00	; 0
    1576:	28 e1       	ldi	r18, 0x18	; 24
    1578:	fc 01       	movw	r30, r24
    157a:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    157c:	82 ec       	ldi	r24, 0xC2	; 194
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	26 e0       	ldi	r18, 0x06	; 6
    1582:	fc 01       	movw	r30, r24
    1584:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM2)|(1 << PRTIM0)|(1 << PRUSART1)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    1586:	84 e6       	ldi	r24, 0x64	; 100
    1588:	90 e0       	ldi	r25, 0x00	; 0
    158a:	24 e6       	ldi	r18, 0x64	; 100
    158c:	30 e0       	ldi	r19, 0x00	; 0
    158e:	f9 01       	movw	r30, r18
    1590:	20 81       	ld	r18, Z
    1592:	2d 6f       	ori	r18, 0xFD	; 253
    1594:	fc 01       	movw	r30, r24
    1596:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    1598:	8a e2       	ldi	r24, 0x2A	; 42
    159a:	90 e0       	ldi	r25, 0x00	; 0
    159c:	2a e2       	ldi	r18, 0x2A	; 42
    159e:	30 e0       	ldi	r19, 0x00	; 0
    15a0:	f9 01       	movw	r30, r18
    15a2:	20 81       	ld	r18, Z
    15a4:	20 68       	ori	r18, 0x80	; 128
    15a6:	fc 01       	movw	r30, r24
    15a8:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    15aa:	87 e2       	ldi	r24, 0x27	; 39
    15ac:	90 e0       	ldi	r25, 0x00	; 0
    15ae:	27 e2       	ldi	r18, 0x27	; 39
    15b0:	30 e0       	ldi	r19, 0x00	; 0
    15b2:	f9 01       	movw	r30, r18
    15b4:	20 81       	ld	r18, Z
    15b6:	24 60       	ori	r18, 0x04	; 4
    15b8:	fc 01       	movw	r30, r24
    15ba:	20 83       	st	Z, r18
	prtSLEEPled &= ~(1 << bnSLEEPled);	//turn off initially
    15bc:	8b e2       	ldi	r24, 0x2B	; 43
    15be:	90 e0       	ldi	r25, 0x00	; 0
    15c0:	2b e2       	ldi	r18, 0x2B	; 43
    15c2:	30 e0       	ldi	r19, 0x00	; 0
    15c4:	f9 01       	movw	r30, r18
    15c6:	20 81       	ld	r18, Z
    15c8:	2f 77       	andi	r18, 0x7F	; 127
    15ca:	fc 01       	movw	r30, r24
    15cc:	20 83       	st	Z, r18
	prtSTATUSled |= (1 << bnSTATUSled);	//turn on initially
    15ce:	88 e2       	ldi	r24, 0x28	; 40
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	28 e2       	ldi	r18, 0x28	; 40
    15d4:	30 e0       	ldi	r19, 0x00	; 0
    15d6:	f9 01       	movw	r30, r18
    15d8:	20 81       	ld	r18, Z
    15da:	24 60       	ori	r18, 0x04	; 4
    15dc:	fc 01       	movw	r30, r24
    15de:	20 83       	st	Z, r18
	
	//Enable BB and GAVR alert pins...outputs, no pull by default.
	ddrBBleds |= (1 << bnBBint)|(1 << bnBBtemp);
    15e0:	81 e2       	ldi	r24, 0x21	; 33
    15e2:	90 e0       	ldi	r25, 0x00	; 0
    15e4:	21 e2       	ldi	r18, 0x21	; 33
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	f9 01       	movw	r30, r18
    15ea:	20 81       	ld	r18, Z
    15ec:	26 60       	ori	r18, 0x06	; 6
    15ee:	fc 01       	movw	r30, r24
    15f0:	20 83       	st	Z, r18
	ddrGAVRleds |= (1 << bnGAVRint)|(1 << bnGAVRtemp);
    15f2:	81 e2       	ldi	r24, 0x21	; 33
    15f4:	90 e0       	ldi	r25, 0x00	; 0
    15f6:	21 e2       	ldi	r18, 0x21	; 33
    15f8:	30 e0       	ldi	r19, 0x00	; 0
    15fa:	f9 01       	movw	r30, r18
    15fc:	20 81       	ld	r18, Z
    15fe:	28 61       	ori	r18, 0x18	; 24
    1600:	fc 01       	movw	r30, r24
    1602:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrGAVRINT |= (1 << bnGAVRINT);
    1604:	84 e2       	ldi	r24, 0x24	; 36
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	24 e2       	ldi	r18, 0x24	; 36
    160a:	30 e0       	ldi	r19, 0x00	; 0
    160c:	f9 01       	movw	r30, r18
    160e:	20 81       	ld	r18, Z
    1610:	28 60       	ori	r18, 0x08	; 8
    1612:	fc 01       	movw	r30, r24
    1614:	20 83       	st	Z, r18
	prtGAVRINT &=  ~(1 << bnGAVRINT);	//set low at first
    1616:	85 e2       	ldi	r24, 0x25	; 37
    1618:	90 e0       	ldi	r25, 0x00	; 0
    161a:	25 e2       	ldi	r18, 0x25	; 37
    161c:	30 e0       	ldi	r19, 0x00	; 0
    161e:	f9 01       	movw	r30, r18
    1620:	20 81       	ld	r18, Z
    1622:	27 7f       	andi	r18, 0xF7	; 247
    1624:	fc 01       	movw	r30, r24
    1626:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen);
    1628:	81 e2       	ldi	r24, 0x21	; 33
    162a:	90 e0       	ldi	r25, 0x00	; 0
    162c:	21 e2       	ldi	r18, 0x21	; 33
    162e:	30 e0       	ldi	r19, 0x00	; 0
    1630:	f9 01       	movw	r30, r18
    1632:	20 81       	ld	r18, Z
    1634:	20 6e       	ori	r18, 0xE0	; 224
    1636:	fc 01       	movw	r30, r24
    1638:	20 83       	st	Z, r18
	ddrBBen |= (1 << bnBBen);
    163a:	84 e2       	ldi	r24, 0x24	; 36
    163c:	90 e0       	ldi	r25, 0x00	; 0
    163e:	24 e2       	ldi	r18, 0x24	; 36
    1640:	30 e0       	ldi	r19, 0x00	; 0
    1642:	f9 01       	movw	r30, r18
    1644:	20 81       	ld	r18, Z
    1646:	21 60       	ori	r18, 0x01	; 1
    1648:	fc 01       	movw	r30, r24
    164a:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    164c:	84 e2       	ldi	r24, 0x24	; 36
    164e:	90 e0       	ldi	r25, 0x00	; 0
    1650:	24 e2       	ldi	r18, 0x24	; 36
    1652:	30 e0       	ldi	r19, 0x00	; 0
    1654:	f9 01       	movw	r30, r18
    1656:	20 81       	ld	r18, Z
    1658:	22 60       	ori	r18, 0x02	; 2
    165a:	fc 01       	movw	r30, r24
    165c:	20 83       	st	Z, r18
	prtTEMPen |= (1 << bnTEMPen);
    165e:	85 e2       	ldi	r24, 0x25	; 37
    1660:	90 e0       	ldi	r25, 0x00	; 0
    1662:	25 e2       	ldi	r18, 0x25	; 37
    1664:	30 e0       	ldi	r19, 0x00	; 0
    1666:	f9 01       	movw	r30, r18
    1668:	20 81       	ld	r18, Z
    166a:	22 60       	ori	r18, 0x02	; 2
    166c:	fc 01       	movw	r30, r24
    166e:	20 83       	st	Z, r18
	

	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    1670:	89 e6       	ldi	r24, 0x69	; 105
    1672:	90 e0       	ldi	r25, 0x00	; 0
    1674:	20 e3       	ldi	r18, 0x30	; 48
    1676:	fc 01       	movw	r30, r24
    1678:	20 83       	st	Z, r18
	EIMSK = (1 << INT2);			//enable INT2 global interrupt
    167a:	8d e3       	ldi	r24, 0x3D	; 61
    167c:	90 e0       	ldi	r25, 0x00	; 0
    167e:	24 e0       	ldi	r18, 0x04	; 4
    1680:	fc 01       	movw	r30, r24
    1682:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    1684:	84 e2       	ldi	r24, 0x24	; 36
    1686:	90 e0       	ldi	r25, 0x00	; 0
    1688:	24 e2       	ldi	r18, 0x24	; 36
    168a:	30 e0       	ldi	r19, 0x00	; 0
    168c:	f9 01       	movw	r30, r18
    168e:	20 81       	ld	r18, Z
    1690:	20 6b       	ori	r18, 0xB0	; 176
    1692:	fc 01       	movw	r30, r24
    1694:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    1696:	84 e2       	ldi	r24, 0x24	; 36
    1698:	90 e0       	ldi	r25, 0x00	; 0
    169a:	24 e2       	ldi	r18, 0x24	; 36
    169c:	30 e0       	ldi	r19, 0x00	; 0
    169e:	f9 01       	movw	r30, r18
    16a0:	20 81       	ld	r18, Z
    16a2:	2f 7b       	andi	r18, 0xBF	; 191
    16a4:	fc 01       	movw	r30, r24
    16a6:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    16a8:	85 e2       	ldi	r24, 0x25	; 37
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	25 e2       	ldi	r18, 0x25	; 37
    16ae:	30 e0       	ldi	r19, 0x00	; 0
    16b0:	f9 01       	movw	r30, r18
    16b2:	20 81       	ld	r18, Z
    16b4:	20 69       	ori	r18, 0x90	; 144
    16b6:	fc 01       	movw	r30, r24
    16b8:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    16ba:	85 e2       	ldi	r24, 0x25	; 37
    16bc:	90 e0       	ldi	r25, 0x00	; 0
    16be:	25 e2       	ldi	r18, 0x25	; 37
    16c0:	30 e0       	ldi	r19, 0x00	; 0
    16c2:	f9 01       	movw	r30, r18
    16c4:	20 81       	ld	r18, Z
    16c6:	2f 7d       	andi	r18, 0xDF	; 223
    16c8:	fc 01       	movw	r30, r24
    16ca:	20 83       	st	Z, r18
	
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    16cc:	81 e0       	ldi	r24, 0x01	; 1
    16ce:	80 93 50 01 	sts	0x0150, r24
	flagShutdown  = fFalse;
    16d2:	10 92 5a 01 	sts	0x015A, r1
	flagUARTbone = fFalse;
    16d6:	10 92 51 01 	sts	0x0151, r1
	flagNormalMode=fTrue;
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	80 93 52 01 	sts	0x0152, r24
	restart=fFalse;
    16e0:	10 92 5d 01 	sts	0x015D, r1
	flagNewShutdown=fFalse;
    16e4:	10 92 59 01 	sts	0x0159, r1
	flagSendingGAVR=fFalse;
    16e8:	10 92 57 01 	sts	0x0157, r1
	noTimeout=fTrue;
    16ec:	81 e0       	ldi	r24, 0x01	; 1
    16ee:	80 93 58 01 	sts	0x0158, r24
}
    16f2:	0f 90       	pop	r0
    16f4:	0f 90       	pop	r0
    16f6:	df 91       	pop	r29
    16f8:	cf 91       	pop	r28
    16fa:	08 95       	ret

000016fc <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    16fc:	cf 93       	push	r28
    16fe:	df 93       	push	r29
    1700:	cd b7       	in	r28, 0x3d	; 61
    1702:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    1704:	84 e6       	ldi	r24, 0x64	; 100
    1706:	90 e0       	ldi	r25, 0x00	; 0
    1708:	24 e6       	ldi	r18, 0x64	; 100
    170a:	30 e0       	ldi	r19, 0x00	; 0
    170c:	f9 01       	movw	r30, r18
    170e:	20 81       	ld	r18, Z
    1710:	2f 7b       	andi	r18, 0xBF	; 191
    1712:	fc 01       	movw	r30, r24
    1714:	20 83       	st	Z, r18
	Wait_ms(1);	//give it time to power on
    1716:	81 e0       	ldi	r24, 0x01	; 1
    1718:	90 e0       	ldi	r25, 0x00	; 0
    171a:	0e 94 bc 0b 	call	0x1778	; 0x1778 <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    171e:	86 eb       	ldi	r24, 0xB6	; 182
    1720:	90 e0       	ldi	r25, 0x00	; 0
    1722:	26 eb       	ldi	r18, 0xB6	; 182
    1724:	30 e0       	ldi	r19, 0x00	; 0
    1726:	f9 01       	movw	r30, r18
    1728:	20 81       	ld	r18, Z
    172a:	20 62       	ori	r18, 0x20	; 32
    172c:	fc 01       	movw	r30, r24
    172e:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    1730:	81 eb       	ldi	r24, 0xB1	; 177
    1732:	90 e0       	ldi	r25, 0x00	; 0
    1734:	21 eb       	ldi	r18, 0xB1	; 177
    1736:	30 e0       	ldi	r19, 0x00	; 0
    1738:	f9 01       	movw	r30, r18
    173a:	20 81       	ld	r18, Z
    173c:	25 60       	ori	r18, 0x05	; 5
    173e:	fc 01       	movw	r30, r24
    1740:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    1742:	86 eb       	ldi	r24, 0xB6	; 182
    1744:	90 e0       	ldi	r25, 0x00	; 0
    1746:	fc 01       	movw	r30, r24
    1748:	80 81       	ld	r24, Z
    174a:	88 2f       	mov	r24, r24
    174c:	90 e0       	ldi	r25, 0x00	; 0
    174e:	81 71       	andi	r24, 0x11	; 17
    1750:	90 70       	andi	r25, 0x00	; 0
    1752:	21 e0       	ldi	r18, 0x01	; 1
    1754:	00 97       	sbiw	r24, 0x00	; 0
    1756:	09 f4       	brne	.+2      	; 0x175a <_Z14EnableRTCTimerv+0x5e>
    1758:	20 e0       	ldi	r18, 0x00	; 0
    175a:	22 23       	and	r18, r18
    175c:	91 f7       	brne	.-28     	; 0x1742 <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    175e:	87 e3       	ldi	r24, 0x37	; 55
    1760:	90 e0       	ldi	r25, 0x00	; 0
    1762:	21 e0       	ldi	r18, 0x01	; 1
    1764:	fc 01       	movw	r30, r24
    1766:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    1768:	80 e7       	ldi	r24, 0x70	; 112
    176a:	90 e0       	ldi	r25, 0x00	; 0
    176c:	21 e0       	ldi	r18, 0x01	; 1
    176e:	fc 01       	movw	r30, r24
    1770:	20 83       	st	Z, r18
	
	//Away we go
}
    1772:	df 91       	pop	r29
    1774:	cf 91       	pop	r28
    1776:	08 95       	ret

00001778 <_Z7Wait_msi>:
/*************************************************************************************************************/
void Wait_ms(volatile int delay)
{
    1778:	cf 93       	push	r28
    177a:	df 93       	push	r29
    177c:	00 d0       	rcall	.+0      	; 0x177e <_Z7Wait_msi+0x6>
    177e:	00 d0       	rcall	.+0      	; 0x1780 <_Z7Wait_msi+0x8>
    1780:	cd b7       	in	r28, 0x3d	; 61
    1782:	de b7       	in	r29, 0x3e	; 62
    1784:	9c 83       	std	Y+4, r25	; 0x04
    1786:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    1788:	18 c0       	rjmp	.+48     	; 0x17ba <_Z7Wait_msi+0x42>
		for(i = 0; i < 800; i++){
    178a:	1a 82       	std	Y+2, r1	; 0x02
    178c:	19 82       	std	Y+1, r1	; 0x01
    178e:	06 c0       	rjmp	.+12     	; 0x179c <_Z7Wait_msi+0x24>
			asm volatile("nop");
    1790:	00 00       	nop
void Wait_ms(volatile int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 800; i++){
    1792:	89 81       	ldd	r24, Y+1	; 0x01
    1794:	9a 81       	ldd	r25, Y+2	; 0x02
    1796:	01 96       	adiw	r24, 0x01	; 1
    1798:	9a 83       	std	Y+2, r25	; 0x02
    179a:	89 83       	std	Y+1, r24	; 0x01
    179c:	89 81       	ldd	r24, Y+1	; 0x01
    179e:	9a 81       	ldd	r25, Y+2	; 0x02
    17a0:	21 e0       	ldi	r18, 0x01	; 1
    17a2:	33 e0       	ldi	r19, 0x03	; 3
    17a4:	80 32       	cpi	r24, 0x20	; 32
    17a6:	93 07       	cpc	r25, r19
    17a8:	0c f0       	brlt	.+2      	; 0x17ac <_Z7Wait_msi+0x34>
    17aa:	20 e0       	ldi	r18, 0x00	; 0
    17ac:	22 23       	and	r18, r18
    17ae:	81 f7       	brne	.-32     	; 0x1790 <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    17b0:	8b 81       	ldd	r24, Y+3	; 0x03
    17b2:	9c 81       	ldd	r25, Y+4	; 0x04
    17b4:	01 97       	sbiw	r24, 0x01	; 1
    17b6:	9c 83       	std	Y+4, r25	; 0x04
    17b8:	8b 83       	std	Y+3, r24	; 0x03
/*************************************************************************************************************/
void Wait_ms(volatile int delay)
{
	volatile int i;

	while(delay > 0){
    17ba:	8b 81       	ldd	r24, Y+3	; 0x03
    17bc:	9c 81       	ldd	r25, Y+4	; 0x04
    17be:	21 e0       	ldi	r18, 0x01	; 1
    17c0:	18 16       	cp	r1, r24
    17c2:	19 06       	cpc	r1, r25
    17c4:	0c f0       	brlt	.+2      	; 0x17c8 <_Z7Wait_msi+0x50>
    17c6:	20 e0       	ldi	r18, 0x00	; 0
    17c8:	22 23       	and	r18, r18
    17ca:	f9 f6       	brne	.-66     	; 0x178a <_Z7Wait_msi+0x12>
		for(i = 0; i < 800; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    17cc:	0f 90       	pop	r0
    17ce:	0f 90       	pop	r0
    17d0:	0f 90       	pop	r0
    17d2:	0f 90       	pop	r0
    17d4:	df 91       	pop	r29
    17d6:	cf 91       	pop	r28
    17d8:	08 95       	ret

000017da <_Z8Wait_seci>:
/*************************************************************************************************************/
void Wait_sec(volatile int sec){
    17da:	cf 93       	push	r28
    17dc:	df 93       	push	r29
    17de:	00 d0       	rcall	.+0      	; 0x17e0 <_Z8Wait_seci+0x6>
    17e0:	00 d0       	rcall	.+0      	; 0x17e2 <_Z8Wait_seci+0x8>
    17e2:	00 d0       	rcall	.+0      	; 0x17e4 <_Z8Wait_seci+0xa>
    17e4:	cd b7       	in	r28, 0x3d	; 61
    17e6:	de b7       	in	r29, 0x3e	; 62
    17e8:	9e 83       	std	Y+6, r25	; 0x06
    17ea:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    17ec:	83 e6       	ldi	r24, 0x63	; 99
    17ee:	91 e0       	ldi	r25, 0x01	; 1
    17f0:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTime10getSecondsEv>
    17f4:	88 2f       	mov	r24, r24
    17f6:	90 e0       	ldi	r25, 0x00	; 0
    17f8:	9a 83       	std	Y+2, r25	; 0x02
    17fa:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    17fc:	29 81       	ldd	r18, Y+1	; 0x01
    17fe:	3a 81       	ldd	r19, Y+2	; 0x02
    1800:	8d 81       	ldd	r24, Y+5	; 0x05
    1802:	9e 81       	ldd	r25, Y+6	; 0x06
    1804:	82 0f       	add	r24, r18
    1806:	93 1f       	adc	r25, r19
    1808:	2c e3       	ldi	r18, 0x3C	; 60
    180a:	30 e0       	ldi	r19, 0x00	; 0
    180c:	b9 01       	movw	r22, r18
    180e:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
    1812:	9c 83       	std	Y+4, r25	; 0x04
    1814:	8b 83       	std	Y+3, r24	; 0x03
	while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    1816:	01 c0       	rjmp	.+2      	; 0x181a <_Z8Wait_seci+0x40>
    1818:	00 00       	nop
    181a:	83 e6       	ldi	r24, 0x63	; 99
    181c:	91 e0       	ldi	r25, 0x01	; 1
    181e:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTime10getSecondsEv>
    1822:	28 2f       	mov	r18, r24
    1824:	30 e0       	ldi	r19, 0x00	; 0
    1826:	8b 81       	ldd	r24, Y+3	; 0x03
    1828:	9c 81       	ldd	r25, Y+4	; 0x04
    182a:	41 e0       	ldi	r20, 0x01	; 1
    182c:	28 17       	cp	r18, r24
    182e:	39 07       	cpc	r19, r25
    1830:	09 f4       	brne	.+2      	; 0x1834 <_Z8Wait_seci+0x5a>
    1832:	40 e0       	ldi	r20, 0x00	; 0
    1834:	44 23       	and	r20, r20
    1836:	81 f7       	brne	.-32     	; 0x1818 <_Z8Wait_seci+0x3e>
}
    1838:	26 96       	adiw	r28, 0x06	; 6
    183a:	0f b6       	in	r0, 0x3f	; 63
    183c:	f8 94       	cli
    183e:	de bf       	out	0x3e, r29	; 62
    1840:	0f be       	out	0x3f, r0	; 63
    1842:	cd bf       	out	0x3d, r28	; 61
    1844:	df 91       	pop	r29
    1846:	cf 91       	pop	r28
    1848:	08 95       	ret

0000184a <_Z13PutUartChBonec>:

/*************************************************************************************************************/

void PutUartChBone(char ch)
{
    184a:	cf 93       	push	r28
    184c:	df 93       	push	r29
    184e:	0f 92       	push	r0
    1850:	cd b7       	in	r28, 0x3d	; 61
    1852:	de b7       	in	r29, 0x3e	; 62
    1854:	89 83       	std	Y+1, r24	; 0x01
	while (! (UCSR0A & (1 << UDRE0)) ) { asm volatile("nop"); }
    1856:	01 c0       	rjmp	.+2      	; 0x185a <_Z13PutUartChBonec+0x10>
    1858:	00 00       	nop
    185a:	80 ec       	ldi	r24, 0xC0	; 192
    185c:	90 e0       	ldi	r25, 0x00	; 0
    185e:	fc 01       	movw	r30, r24
    1860:	80 81       	ld	r24, Z
    1862:	88 2f       	mov	r24, r24
    1864:	90 e0       	ldi	r25, 0x00	; 0
    1866:	80 72       	andi	r24, 0x20	; 32
    1868:	90 70       	andi	r25, 0x00	; 0
    186a:	21 e0       	ldi	r18, 0x01	; 1
    186c:	00 97       	sbiw	r24, 0x00	; 0
    186e:	09 f0       	breq	.+2      	; 0x1872 <_Z13PutUartChBonec+0x28>
    1870:	20 e0       	ldi	r18, 0x00	; 0
    1872:	22 23       	and	r18, r18
    1874:	89 f7       	brne	.-30     	; 0x1858 <_Z13PutUartChBonec+0xe>
	UDR0 = ch;
    1876:	86 ec       	ldi	r24, 0xC6	; 198
    1878:	90 e0       	ldi	r25, 0x00	; 0
    187a:	29 81       	ldd	r18, Y+1	; 0x01
    187c:	fc 01       	movw	r30, r24
    187e:	20 83       	st	Z, r18
}
    1880:	0f 90       	pop	r0
    1882:	df 91       	pop	r29
    1884:	cf 91       	pop	r28
    1886:	08 95       	ret

00001888 <_Z9PrintBonePc>:

/*************************************************************************************************************/
void PrintBone(char string[])
{	
    1888:	cf 93       	push	r28
    188a:	df 93       	push	r29
    188c:	00 d0       	rcall	.+0      	; 0x188e <_Z9PrintBonePc+0x6>
    188e:	0f 92       	push	r0
    1890:	cd b7       	in	r28, 0x3d	; 61
    1892:	de b7       	in	r29, 0x3e	; 62
    1894:	9b 83       	std	Y+3, r25	; 0x03
    1896:	8a 83       	std	Y+2, r24	; 0x02
	volatile BYTE i;
	i = 0;
    1898:	19 82       	std	Y+1, r1	; 0x01

	while (string[i]) {
    189a:	0e c0       	rjmp	.+28     	; 0x18b8 <_Z9PrintBonePc+0x30>
		PutUartChBone(string[i]);  //send byte		
    189c:	89 81       	ldd	r24, Y+1	; 0x01
    189e:	88 2f       	mov	r24, r24
    18a0:	90 e0       	ldi	r25, 0x00	; 0
    18a2:	2a 81       	ldd	r18, Y+2	; 0x02
    18a4:	3b 81       	ldd	r19, Y+3	; 0x03
    18a6:	82 0f       	add	r24, r18
    18a8:	93 1f       	adc	r25, r19
    18aa:	fc 01       	movw	r30, r24
    18ac:	80 81       	ld	r24, Z
    18ae:	0e 94 25 0c 	call	0x184a	; 0x184a <_Z13PutUartChBonec>
		i += 1;
    18b2:	89 81       	ldd	r24, Y+1	; 0x01
    18b4:	8f 5f       	subi	r24, 0xFF	; 255
    18b6:	89 83       	std	Y+1, r24	; 0x01
void PrintBone(char string[])
{	
	volatile BYTE i;
	i = 0;

	while (string[i]) {
    18b8:	89 81       	ldd	r24, Y+1	; 0x01
    18ba:	88 2f       	mov	r24, r24
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	2a 81       	ldd	r18, Y+2	; 0x02
    18c0:	3b 81       	ldd	r19, Y+3	; 0x03
    18c2:	82 0f       	add	r24, r18
    18c4:	93 1f       	adc	r25, r19
    18c6:	fc 01       	movw	r30, r24
    18c8:	90 81       	ld	r25, Z
    18ca:	81 e0       	ldi	r24, 0x01	; 1
    18cc:	99 23       	and	r25, r25
    18ce:	09 f4       	brne	.+2      	; 0x18d2 <_Z9PrintBonePc+0x4a>
    18d0:	80 e0       	ldi	r24, 0x00	; 0
    18d2:	88 23       	and	r24, r24
    18d4:	19 f7       	brne	.-58     	; 0x189c <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i]);  //send byte		
		i += 1;
	}
}
    18d6:	0f 90       	pop	r0
    18d8:	0f 90       	pop	r0
    18da:	0f 90       	pop	r0
    18dc:	df 91       	pop	r29
    18de:	cf 91       	pop	r28
    18e0:	08 95       	ret

000018e2 <_Z13PutUartChGAVRc>:

/*************************************************************************************************************/

void PutUartChGAVR(char ch)
{
    18e2:	cf 93       	push	r28
    18e4:	df 93       	push	r29
    18e6:	0f 92       	push	r0
    18e8:	cd b7       	in	r28, 0x3d	; 61
    18ea:	de b7       	in	r29, 0x3e	; 62
    18ec:	89 83       	std	Y+1, r24	; 0x01
while (! (UCSR1A & (1 << UDR1)) ) { asm volatile("nop"); }
    18ee:	01 c0       	rjmp	.+2      	; 0x18f2 <_Z13PutUartChGAVRc+0x10>
    18f0:	00 00       	nop
    18f2:	88 ec       	ldi	r24, 0xC8	; 200
    18f4:	90 e0       	ldi	r25, 0x00	; 0
    18f6:	fc 01       	movw	r30, r24
    18f8:	80 81       	ld	r24, Z
    18fa:	88 2f       	mov	r24, r24
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	2e ec       	ldi	r18, 0xCE	; 206
    1900:	30 e0       	ldi	r19, 0x00	; 0
    1902:	f9 01       	movw	r30, r18
    1904:	20 81       	ld	r18, Z
    1906:	22 2f       	mov	r18, r18
    1908:	30 e0       	ldi	r19, 0x00	; 0
    190a:	02 2e       	mov	r0, r18
    190c:	02 c0       	rjmp	.+4      	; 0x1912 <_Z13PutUartChGAVRc+0x30>
    190e:	95 95       	asr	r25
    1910:	87 95       	ror	r24
    1912:	0a 94       	dec	r0
    1914:	e2 f7       	brpl	.-8      	; 0x190e <_Z13PutUartChGAVRc+0x2c>
    1916:	81 70       	andi	r24, 0x01	; 1
    1918:	90 70       	andi	r25, 0x00	; 0
    191a:	98 2f       	mov	r25, r24
    191c:	81 e0       	ldi	r24, 0x01	; 1
    191e:	89 27       	eor	r24, r25
    1920:	88 23       	and	r24, r24
    1922:	31 f7       	brne	.-52     	; 0x18f0 <_Z13PutUartChGAVRc+0xe>
UDR1 = ch;
    1924:	8e ec       	ldi	r24, 0xCE	; 206
    1926:	90 e0       	ldi	r25, 0x00	; 0
    1928:	29 81       	ldd	r18, Y+1	; 0x01
    192a:	fc 01       	movw	r30, r24
    192c:	20 83       	st	Z, r18
}
    192e:	0f 90       	pop	r0
    1930:	df 91       	pop	r29
    1932:	cf 91       	pop	r28
    1934:	08 95       	ret

00001936 <_Z9PrintGAVRPc>:

/*************************************************************************************************************/
void PrintGAVR(char string[])
{	
    1936:	cf 93       	push	r28
    1938:	df 93       	push	r29
    193a:	00 d0       	rcall	.+0      	; 0x193c <_Z9PrintGAVRPc+0x6>
    193c:	0f 92       	push	r0
    193e:	cd b7       	in	r28, 0x3d	; 61
    1940:	de b7       	in	r29, 0x3e	; 62
    1942:	9b 83       	std	Y+3, r25	; 0x03
    1944:	8a 83       	std	Y+2, r24	; 0x02
	volatile BYTE i;
	i = 0;
    1946:	19 82       	std	Y+1, r1	; 0x01

	while (string[i]) {
    1948:	0e c0       	rjmp	.+28     	; 0x1966 <_Z9PrintGAVRPc+0x30>
		PutUartChGAVR(string[i]);  //send byte		
    194a:	89 81       	ldd	r24, Y+1	; 0x01
    194c:	88 2f       	mov	r24, r24
    194e:	90 e0       	ldi	r25, 0x00	; 0
    1950:	2a 81       	ldd	r18, Y+2	; 0x02
    1952:	3b 81       	ldd	r19, Y+3	; 0x03
    1954:	82 0f       	add	r24, r18
    1956:	93 1f       	adc	r25, r19
    1958:	fc 01       	movw	r30, r24
    195a:	80 81       	ld	r24, Z
    195c:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <_Z13PutUartChGAVRc>
		i += 1;
    1960:	89 81       	ldd	r24, Y+1	; 0x01
    1962:	8f 5f       	subi	r24, 0xFF	; 255
    1964:	89 83       	std	Y+1, r24	; 0x01
void PrintGAVR(char string[])
{	
	volatile BYTE i;
	i = 0;

	while (string[i]) {
    1966:	89 81       	ldd	r24, Y+1	; 0x01
    1968:	88 2f       	mov	r24, r24
    196a:	90 e0       	ldi	r25, 0x00	; 0
    196c:	2a 81       	ldd	r18, Y+2	; 0x02
    196e:	3b 81       	ldd	r19, Y+3	; 0x03
    1970:	82 0f       	add	r24, r18
    1972:	93 1f       	adc	r25, r19
    1974:	fc 01       	movw	r30, r24
    1976:	90 81       	ld	r25, Z
    1978:	81 e0       	ldi	r24, 0x01	; 1
    197a:	99 23       	and	r25, r25
    197c:	09 f4       	brne	.+2      	; 0x1980 <_Z9PrintGAVRPc+0x4a>
    197e:	80 e0       	ldi	r24, 0x00	; 0
    1980:	88 23       	and	r24, r24
    1982:	19 f7       	brne	.-58     	; 0x194a <_Z9PrintGAVRPc+0x14>
		PutUartChGAVR(string[i]);  //send byte		
		i += 1;
	}
}
    1984:	0f 90       	pop	r0
    1986:	0f 90       	pop	r0
    1988:	0f 90       	pop	r0
    198a:	df 91       	pop	r29
    198c:	cf 91       	pop	r28
    198e:	08 95       	ret

00001990 <_Z11ReceiveBonev>:

/*************************************************************************************************************/
void ReceiveBone(){
    1990:	cf 93       	push	r28
    1992:	df 93       	push	r29
    1994:	cd b7       	in	r28, 0x3d	; 61
    1996:	de b7       	in	r29, 0x3e	; 62
    1998:	a7 97       	sbiw	r28, 0x27	; 39
    199a:	0f b6       	in	r0, 0x3f	; 63
    199c:	f8 94       	cli
    199e:	de bf       	out	0x3e, r29	; 62
    19a0:	0f be       	out	0x3f, r0	; 63
    19a2:	cd bf       	out	0x3d, r28	; 61
	//Declare variables
	BOOL noCarriage = fTrue;
    19a4:	81 e0       	ldi	r24, 0x01	; 1
    19a6:	89 83       	std	Y+1, r24	; 0x01
	char recString[20];
	char recChar;
	volatile int strLoc = 0;
    19a8:	19 8e       	std	Y+25, r1	; 0x19
    19aa:	18 8e       	std	Y+24, r1	; 0x18
	
	recChar = UDR0;
    19ac:	86 ec       	ldi	r24, 0xC6	; 198
    19ae:	90 e0       	ldi	r25, 0x00	; 0
    19b0:	fc 01       	movw	r30, r24
    19b2:	80 81       	ld	r24, Z
    19b4:	8a 83       	std	Y+2, r24	; 0x02
	if (recChar=='.'){
    19b6:	8a 81       	ldd	r24, Y+2	; 0x02
    19b8:	8e 32       	cpi	r24, 0x2E	; 46
    19ba:	29 f4       	brne	.+10     	; 0x19c6 <_Z11ReceiveBonev+0x36>
		PutUartChBone(recChar);
    19bc:	8a 81       	ldd	r24, Y+2	; 0x02
    19be:	0e 94 25 0c 	call	0x184a	; 0x184a <_Z13PutUartChBonec>
		noCarriage=fFalse;
    19c2:	19 82       	std	Y+1, r1	; 0x01
	} else {
		recString[strLoc]=recChar;
		strLoc++;
	}
	while (noCarriage && flagUARTbone){ //flag goes down if a timeout occurs.
    19c4:	d0 c1       	rjmp	.+928    	; 0x1d66 <_Z11ReceiveBonev+0x3d6>
	recChar = UDR0;
	if (recChar=='.'){
		PutUartChBone(recChar);
		noCarriage=fFalse;
	} else {
		recString[strLoc]=recChar;
    19c6:	88 8d       	ldd	r24, Y+24	; 0x18
    19c8:	99 8d       	ldd	r25, Y+25	; 0x19
    19ca:	9e 01       	movw	r18, r28
    19cc:	2c 5f       	subi	r18, 0xFC	; 252
    19ce:	3f 4f       	sbci	r19, 0xFF	; 255
    19d0:	82 0f       	add	r24, r18
    19d2:	93 1f       	adc	r25, r19
    19d4:	2a 81       	ldd	r18, Y+2	; 0x02
    19d6:	fc 01       	movw	r30, r24
    19d8:	20 83       	st	Z, r18
		strLoc++;
    19da:	88 8d       	ldd	r24, Y+24	; 0x18
    19dc:	99 8d       	ldd	r25, Y+25	; 0x19
    19de:	01 96       	adiw	r24, 0x01	; 1
    19e0:	99 8f       	std	Y+25, r25	; 0x19
    19e2:	88 8f       	std	Y+24, r24	; 0x18
	}
	while (noCarriage && flagUARTbone){ //flag goes down if a timeout occurs.
    19e4:	c0 c1       	rjmp	.+896    	; 0x1d66 <_Z11ReceiveBonev+0x3d6>
		recChar=UDR0; //dump, don't needit. wait for nextone
    19e6:	86 ec       	ldi	r24, 0xC6	; 198
    19e8:	90 e0       	ldi	r25, 0x00	; 0
    19ea:	fc 01       	movw	r30, r24
    19ec:	80 81       	ld	r24, Z
    19ee:	8a 83       	std	Y+2, r24	; 0x02
		while (!(UCSR0A & (1 << RXC0)) && flagUARTbone);
    19f0:	00 00       	nop
    19f2:	80 ec       	ldi	r24, 0xC0	; 192
    19f4:	90 e0       	ldi	r25, 0x00	; 0
    19f6:	fc 01       	movw	r30, r24
    19f8:	80 81       	ld	r24, Z
    19fa:	88 23       	and	r24, r24
    19fc:	34 f0       	brlt	.+12     	; 0x1a0a <_Z11ReceiveBonev+0x7a>
    19fe:	80 91 51 01 	lds	r24, 0x0151
    1a02:	88 23       	and	r24, r24
    1a04:	11 f0       	breq	.+4      	; 0x1a0a <_Z11ReceiveBonev+0x7a>
    1a06:	81 e0       	ldi	r24, 0x01	; 1
    1a08:	01 c0       	rjmp	.+2      	; 0x1a0c <_Z11ReceiveBonev+0x7c>
    1a0a:	80 e0       	ldi	r24, 0x00	; 0
    1a0c:	88 23       	and	r24, r24
    1a0e:	89 f7       	brne	.-30     	; 0x19f2 <_Z11ReceiveBonev+0x62>
		recChar = UDR0;
    1a10:	86 ec       	ldi	r24, 0xC6	; 198
    1a12:	90 e0       	ldi	r25, 0x00	; 0
    1a14:	fc 01       	movw	r30, r24
    1a16:	80 81       	ld	r24, Z
    1a18:	8a 83       	std	Y+2, r24	; 0x02
		//Put string together. Carriage return is dunzo.
		if (recChar == '.'){
    1a1a:	8a 81       	ldd	r24, Y+2	; 0x02
    1a1c:	8e 32       	cpi	r24, 0x2E	; 46
    1a1e:	09 f0       	breq	.+2      	; 0x1a22 <_Z11ReceiveBonev+0x92>
    1a20:	85 c1       	rjmp	.+778    	; 0x1d2c <_Z11ReceiveBonev+0x39c>
			recString[strLoc] = '\0';
    1a22:	88 8d       	ldd	r24, Y+24	; 0x18
    1a24:	99 8d       	ldd	r25, Y+25	; 0x19
    1a26:	9e 01       	movw	r18, r28
    1a28:	2c 5f       	subi	r18, 0xFC	; 252
    1a2a:	3f 4f       	sbci	r19, 0xFF	; 255
    1a2c:	82 0f       	add	r24, r18
    1a2e:	93 1f       	adc	r25, r19
    1a30:	fc 01       	movw	r30, r24
    1a32:	10 82       	st	Z, r1
			//See what it's asking for
			if (!strcmp(recString,"date")){printTimeDate(fTrue,fFalse,fTrue);}
    1a34:	ce 01       	movw	r24, r28
    1a36:	04 96       	adiw	r24, 0x04	; 4
    1a38:	25 e0       	ldi	r18, 0x05	; 5
    1a3a:	31 e0       	ldi	r19, 0x01	; 1
    1a3c:	b9 01       	movw	r22, r18
    1a3e:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    1a42:	00 97       	sbiw	r24, 0x00	; 0
    1a44:	31 f4       	brne	.+12     	; 0x1a52 <_Z11ReceiveBonev+0xc2>
    1a46:	81 e0       	ldi	r24, 0x01	; 1
    1a48:	60 e0       	ldi	r22, 0x00	; 0
    1a4a:	41 e0       	ldi	r20, 0x01	; 1
    1a4c:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <_Z13printTimeDatehhh>
    1a50:	6b c1       	rjmp	.+726    	; 0x1d28 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"time")){printTimeDate(fTrue,fTrue,fFalse);}
    1a52:	ce 01       	movw	r24, r28
    1a54:	04 96       	adiw	r24, 0x04	; 4
    1a56:	2a e0       	ldi	r18, 0x0A	; 10
    1a58:	31 e0       	ldi	r19, 0x01	; 1
    1a5a:	b9 01       	movw	r22, r18
    1a5c:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    1a60:	00 97       	sbiw	r24, 0x00	; 0
    1a62:	31 f4       	brne	.+12     	; 0x1a70 <_Z11ReceiveBonev+0xe0>
    1a64:	81 e0       	ldi	r24, 0x01	; 1
    1a66:	61 e0       	ldi	r22, 0x01	; 1
    1a68:	40 e0       	ldi	r20, 0x00	; 0
    1a6a:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <_Z13printTimeDatehhh>
    1a6e:	5c c1       	rjmp	.+696    	; 0x1d28 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"both")){printTimeDate(fTrue,fTrue,fTrue);}
    1a70:	ce 01       	movw	r24, r28
    1a72:	04 96       	adiw	r24, 0x04	; 4
    1a74:	2f e0       	ldi	r18, 0x0F	; 15
    1a76:	31 e0       	ldi	r19, 0x01	; 1
    1a78:	b9 01       	movw	r22, r18
    1a7a:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    1a7e:	00 97       	sbiw	r24, 0x00	; 0
    1a80:	31 f4       	brne	.+12     	; 0x1a8e <_Z11ReceiveBonev+0xfe>
    1a82:	81 e0       	ldi	r24, 0x01	; 1
    1a84:	61 e0       	ldi	r22, 0x01	; 1
    1a86:	41 e0       	ldi	r20, 0x01	; 1
    1a88:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <_Z13printTimeDatehhh>
    1a8c:	4d c1       	rjmp	.+666    	; 0x1d28 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"save")){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);}
    1a8e:	ce 01       	movw	r24, r28
    1a90:	04 96       	adiw	r24, 0x04	; 4
    1a92:	24 e1       	ldi	r18, 0x14	; 20
    1a94:	31 e0       	ldi	r19, 0x01	; 1
    1a96:	b9 01       	movw	r22, r18
    1a98:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    1a9c:	00 97       	sbiw	r24, 0x00	; 0
    1a9e:	49 f4       	brne	.+18     	; 0x1ab2 <_Z11ReceiveBonev+0x122>
    1aa0:	81 e0       	ldi	r24, 0x01	; 1
    1aa2:	60 e0       	ldi	r22, 0x00	; 0
    1aa4:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1aa8:	ce 01       	movw	r24, r28
    1aaa:	04 96       	adiw	r24, 0x04	; 4
    1aac:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1ab0:	3b c1       	rjmp	.+630    	; 0x1d28 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"adc")){char tempChar[7]; itoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);}
    1ab2:	ce 01       	movw	r24, r28
    1ab4:	04 96       	adiw	r24, 0x04	; 4
    1ab6:	29 e1       	ldi	r18, 0x19	; 25
    1ab8:	31 e0       	ldi	r19, 0x01	; 1
    1aba:	b9 01       	movw	r22, r18
    1abc:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    1ac0:	00 97       	sbiw	r24, 0x00	; 0
    1ac2:	91 f4       	brne	.+36     	; 0x1ae8 <_Z11ReceiveBonev+0x158>
    1ac4:	80 91 5f 01 	lds	r24, 0x015F
    1ac8:	90 91 60 01 	lds	r25, 0x0160
    1acc:	9e 01       	movw	r18, r28
    1ace:	26 5e       	subi	r18, 0xE6	; 230
    1ad0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ad2:	b9 01       	movw	r22, r18
    1ad4:	4a e0       	ldi	r20, 0x0A	; 10
    1ad6:	50 e0       	ldi	r21, 0x00	; 0
    1ad8:	0e 94 1b 14 	call	0x2836	; 0x2836 <itoa>
    1adc:	18 a2       	lds	r17, 0x98
    1ade:	ce 01       	movw	r24, r28
    1ae0:	4a 96       	adiw	r24, 0x1a	; 26
    1ae2:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1ae6:	20 c1       	rjmp	.+576    	; 0x1d28 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"temp")){char tempChar[7]; itoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);}
    1ae8:	ce 01       	movw	r24, r28
    1aea:	04 96       	adiw	r24, 0x04	; 4
    1aec:	2d e1       	ldi	r18, 0x1D	; 29
    1aee:	31 e0       	ldi	r19, 0x01	; 1
    1af0:	b9 01       	movw	r22, r18
    1af2:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    1af6:	00 97       	sbiw	r24, 0x00	; 0
    1af8:	91 f4       	brne	.+36     	; 0x1b1e <_Z11ReceiveBonev+0x18e>
    1afa:	80 91 61 01 	lds	r24, 0x0161
    1afe:	90 91 62 01 	lds	r25, 0x0162
    1b02:	9e 01       	movw	r18, r28
    1b04:	2f 5d       	subi	r18, 0xDF	; 223
    1b06:	3f 4f       	sbci	r19, 0xFF	; 255
    1b08:	b9 01       	movw	r22, r18
    1b0a:	4a e0       	ldi	r20, 0x0A	; 10
    1b0c:	50 e0       	ldi	r21, 0x00	; 0
    1b0e:	0e 94 1b 14 	call	0x2836	; 0x2836 <itoa>
    1b12:	1f a2       	lds	r17, 0x9f
    1b14:	ce 01       	movw	r24, r28
    1b16:	81 96       	adiw	r24, 0x21	; 33
    1b18:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1b1c:	05 c1       	rjmp	.+522    	; 0x1d28 <_Z11ReceiveBonev+0x398>
			else if (!strcmp(recString,"NONE") && (restart || flagFreshStart)){ //If we are starting up again, we need to alert GAVR and clear the flags
    1b1e:	ce 01       	movw	r24, r28
    1b20:	04 96       	adiw	r24, 0x04	; 4
    1b22:	22 e2       	ldi	r18, 0x22	; 34
    1b24:	31 e0       	ldi	r19, 0x01	; 1
    1b26:	b9 01       	movw	r22, r18
    1b28:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    1b2c:	00 97       	sbiw	r24, 0x00	; 0
    1b2e:	51 f4       	brne	.+20     	; 0x1b44 <_Z11ReceiveBonev+0x1b4>
    1b30:	80 91 5d 01 	lds	r24, 0x015D
    1b34:	88 23       	and	r24, r24
    1b36:	21 f4       	brne	.+8      	; 0x1b40 <_Z11ReceiveBonev+0x1b0>
    1b38:	80 91 5e 01 	lds	r24, 0x015E
    1b3c:	88 23       	and	r24, r24
    1b3e:	11 f0       	breq	.+4      	; 0x1b44 <_Z11ReceiveBonev+0x1b4>
    1b40:	81 e0       	ldi	r24, 0x01	; 1
    1b42:	01 c0       	rjmp	.+2      	; 0x1b46 <_Z11ReceiveBonev+0x1b6>
    1b44:	80 e0       	ldi	r24, 0x00	; 0
    1b46:	88 23       	and	r24, r24
    1b48:	f9 f0       	breq	.+62     	; 0x1b88 <_Z11ReceiveBonev+0x1f8>
				PrintBone("ACKNONE");
    1b4a:	87 e2       	ldi	r24, 0x27	; 39
    1b4c:	91 e0       	ldi	r25, 0x01	; 1
    1b4e:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
				if (flagFreshStart){flagFreshStart=fFalse;}
    1b52:	90 91 5e 01 	lds	r25, 0x015E
    1b56:	81 e0       	ldi	r24, 0x01	; 1
    1b58:	99 23       	and	r25, r25
    1b5a:	09 f4       	brne	.+2      	; 0x1b5e <_Z11ReceiveBonev+0x1ce>
    1b5c:	80 e0       	ldi	r24, 0x00	; 0
    1b5e:	88 23       	and	r24, r24
    1b60:	11 f0       	breq	.+4      	; 0x1b66 <_Z11ReceiveBonev+0x1d6>
    1b62:	10 92 5e 01 	sts	0x015E, r1
				if (restart){restart=fFalse;}
    1b66:	90 91 5d 01 	lds	r25, 0x015D
    1b6a:	81 e0       	ldi	r24, 0x01	; 1
    1b6c:	99 23       	and	r25, r25
    1b6e:	09 f4       	brne	.+2      	; 0x1b72 <_Z11ReceiveBonev+0x1e2>
    1b70:	80 e0       	ldi	r24, 0x00	; 0
    1b72:	88 23       	and	r24, r24
    1b74:	11 f0       	breq	.+4      	; 0x1b7a <_Z11ReceiveBonev+0x1ea>
    1b76:	10 92 5d 01 	sts	0x015D, r1
				flagUserTime=fTrue;
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	80 93 53 01 	sts	0x0153, r24
				flagUserDate=fTrue;
    1b80:	81 e0       	ldi	r24, 0x01	; 1
    1b82:	80 93 54 01 	sts	0x0154, r24
    1b86:	d0 c0       	rjmp	.+416    	; 0x1d28 <_Z11ReceiveBonev+0x398>
			} else if (recString[2] == ':'){//valid string. Update the time anyways. Comes in every 20 minutes or so...
    1b88:	8e 81       	ldd	r24, Y+6	; 0x06
    1b8a:	8a 33       	cpi	r24, 0x3A	; 58
    1b8c:	09 f0       	breq	.+2      	; 0x1b90 <_Z11ReceiveBonev+0x200>
    1b8e:	c4 c0       	rjmp	.+392    	; 0x1d18 <_Z11ReceiveBonev+0x388>
				cli();
    1b90:	f8 94       	cli
				BOOL success=currentTime.setTime(recString);
    1b92:	83 e6       	ldi	r24, 0x63	; 99
    1b94:	91 e0       	ldi	r25, 0x01	; 1
    1b96:	9e 01       	movw	r18, r28
    1b98:	2c 5f       	subi	r18, 0xFC	; 252
    1b9a:	3f 4f       	sbci	r19, 0xFF	; 255
    1b9c:	b9 01       	movw	r22, r18
    1b9e:	0e 94 48 04 	call	0x890	; 0x890 <_ZN6myTime7setTimeEPc>
    1ba2:	8b 83       	std	Y+3, r24	; 0x03
				sei();
    1ba4:	78 94       	sei
				if (restart){restart=fFalse;} 
    1ba6:	90 91 5d 01 	lds	r25, 0x015D
    1baa:	81 e0       	ldi	r24, 0x01	; 1
    1bac:	99 23       	and	r25, r25
    1bae:	09 f4       	brne	.+2      	; 0x1bb2 <_Z11ReceiveBonev+0x222>
    1bb0:	80 e0       	ldi	r24, 0x00	; 0
    1bb2:	88 23       	and	r24, r24
    1bb4:	11 f0       	breq	.+4      	; 0x1bba <_Z11ReceiveBonev+0x22a>
    1bb6:	10 92 5d 01 	sts	0x015D, r1
				if (flagFreshStart){flagFreshStart=fFalse;}
    1bba:	90 91 5e 01 	lds	r25, 0x015E
    1bbe:	81 e0       	ldi	r24, 0x01	; 1
    1bc0:	99 23       	and	r25, r25
    1bc2:	09 f4       	brne	.+2      	; 0x1bc6 <_Z11ReceiveBonev+0x236>
    1bc4:	80 e0       	ldi	r24, 0x00	; 0
    1bc6:	88 23       	and	r24, r24
    1bc8:	11 f0       	breq	.+4      	; 0x1bce <_Z11ReceiveBonev+0x23e>
    1bca:	10 92 5e 01 	sts	0x015E, r1
				PrintBone("ACK");
    1bce:	8f e2       	ldi	r24, 0x2F	; 47
    1bd0:	91 e0       	ldi	r25, 0x01	; 1
    1bd2:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
				if (success && !restart && !flagFreshStart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRTime=fTrue; PrintBone(recString);}
    1bd6:	8b 81       	ldd	r24, Y+3	; 0x03
    1bd8:	88 23       	and	r24, r24
    1bda:	51 f0       	breq	.+20     	; 0x1bf0 <_Z11ReceiveBonev+0x260>
    1bdc:	80 91 5d 01 	lds	r24, 0x015D
    1be0:	88 23       	and	r24, r24
    1be2:	31 f4       	brne	.+12     	; 0x1bf0 <_Z11ReceiveBonev+0x260>
    1be4:	80 91 5e 01 	lds	r24, 0x015E
    1be8:	88 23       	and	r24, r24
    1bea:	11 f4       	brne	.+4      	; 0x1bf0 <_Z11ReceiveBonev+0x260>
    1bec:	81 e0       	ldi	r24, 0x01	; 1
    1bee:	01 c0       	rjmp	.+2      	; 0x1bf2 <_Z11ReceiveBonev+0x262>
    1bf0:	80 e0       	ldi	r24, 0x00	; 0
    1bf2:	88 23       	and	r24, r24
    1bf4:	61 f0       	breq	.+24     	; 0x1c0e <_Z11ReceiveBonev+0x27e>
    1bf6:	81 e0       	ldi	r24, 0x01	; 1
    1bf8:	60 e0       	ldi	r22, 0x00	; 0
    1bfa:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1bfe:	81 e0       	ldi	r24, 0x01	; 1
    1c00:	80 93 55 01 	sts	0x0155, r24
    1c04:	ce 01       	movw	r24, r28
    1c06:	04 96       	adiw	r24, 0x04	; 4
    1c08:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1c0c:	70 c0       	rjmp	.+224    	; 0x1cee <_Z11ReceiveBonev+0x35e>
				else if (success && !restart && flagFreshStart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRTime=fTrue; flagUserDate=fTrue; PrintBone(recString);}
    1c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c10:	88 23       	and	r24, r24
    1c12:	51 f0       	breq	.+20     	; 0x1c28 <_Z11ReceiveBonev+0x298>
    1c14:	80 91 5d 01 	lds	r24, 0x015D
    1c18:	88 23       	and	r24, r24
    1c1a:	31 f4       	brne	.+12     	; 0x1c28 <_Z11ReceiveBonev+0x298>
    1c1c:	80 91 5e 01 	lds	r24, 0x015E
    1c20:	88 23       	and	r24, r24
    1c22:	11 f0       	breq	.+4      	; 0x1c28 <_Z11ReceiveBonev+0x298>
    1c24:	81 e0       	ldi	r24, 0x01	; 1
    1c26:	01 c0       	rjmp	.+2      	; 0x1c2a <_Z11ReceiveBonev+0x29a>
    1c28:	80 e0       	ldi	r24, 0x00	; 0
    1c2a:	88 23       	and	r24, r24
    1c2c:	79 f0       	breq	.+30     	; 0x1c4c <_Z11ReceiveBonev+0x2bc>
    1c2e:	81 e0       	ldi	r24, 0x01	; 1
    1c30:	60 e0       	ldi	r22, 0x00	; 0
    1c32:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1c36:	81 e0       	ldi	r24, 0x01	; 1
    1c38:	80 93 55 01 	sts	0x0155, r24
    1c3c:	81 e0       	ldi	r24, 0x01	; 1
    1c3e:	80 93 54 01 	sts	0x0154, r24
    1c42:	ce 01       	movw	r24, r28
    1c44:	04 96       	adiw	r24, 0x04	; 4
    1c46:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1c4a:	51 c0       	rjmp	.+162    	; 0x1cee <_Z11ReceiveBonev+0x35e>
				else if (success && restart && !flagFreshStart){saveDateTime_eeprom(fTrue,fFalse); flagUpdateGAVRDate=fTrue; flagUpdateGAVRTime=fTrue; PrintBone(recString);}
    1c4c:	8b 81       	ldd	r24, Y+3	; 0x03
    1c4e:	88 23       	and	r24, r24
    1c50:	51 f0       	breq	.+20     	; 0x1c66 <_Z11ReceiveBonev+0x2d6>
    1c52:	80 91 5d 01 	lds	r24, 0x015D
    1c56:	88 23       	and	r24, r24
    1c58:	31 f0       	breq	.+12     	; 0x1c66 <_Z11ReceiveBonev+0x2d6>
    1c5a:	80 91 5e 01 	lds	r24, 0x015E
    1c5e:	88 23       	and	r24, r24
    1c60:	11 f4       	brne	.+4      	; 0x1c66 <_Z11ReceiveBonev+0x2d6>
    1c62:	81 e0       	ldi	r24, 0x01	; 1
    1c64:	01 c0       	rjmp	.+2      	; 0x1c68 <_Z11ReceiveBonev+0x2d8>
    1c66:	80 e0       	ldi	r24, 0x00	; 0
    1c68:	88 23       	and	r24, r24
    1c6a:	79 f0       	breq	.+30     	; 0x1c8a <_Z11ReceiveBonev+0x2fa>
    1c6c:	81 e0       	ldi	r24, 0x01	; 1
    1c6e:	60 e0       	ldi	r22, 0x00	; 0
    1c70:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z19saveDateTime_eepromhh>
    1c74:	81 e0       	ldi	r24, 0x01	; 1
    1c76:	80 93 56 01 	sts	0x0156, r24
    1c7a:	81 e0       	ldi	r24, 0x01	; 1
    1c7c:	80 93 55 01 	sts	0x0155, r24
    1c80:	ce 01       	movw	r24, r28
    1c82:	04 96       	adiw	r24, 0x04	; 4
    1c84:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1c88:	32 c0       	rjmp	.+100    	; 0x1cee <_Z11ReceiveBonev+0x35e>
				else if (!success && restart){flagUpdateGAVRTime=fTrue; flagUpdateGAVRDate=fTrue; PrintBone("bad");}	//sends eeprom time and date
    1c8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c8c:	88 23       	and	r24, r24
    1c8e:	31 f4       	brne	.+12     	; 0x1c9c <_Z11ReceiveBonev+0x30c>
    1c90:	80 91 5d 01 	lds	r24, 0x015D
    1c94:	88 23       	and	r24, r24
    1c96:	11 f0       	breq	.+4      	; 0x1c9c <_Z11ReceiveBonev+0x30c>
    1c98:	81 e0       	ldi	r24, 0x01	; 1
    1c9a:	01 c0       	rjmp	.+2      	; 0x1c9e <_Z11ReceiveBonev+0x30e>
    1c9c:	80 e0       	ldi	r24, 0x00	; 0
    1c9e:	88 23       	and	r24, r24
    1ca0:	59 f0       	breq	.+22     	; 0x1cb8 <_Z11ReceiveBonev+0x328>
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	80 93 55 01 	sts	0x0155, r24
    1ca8:	81 e0       	ldi	r24, 0x01	; 1
    1caa:	80 93 56 01 	sts	0x0156, r24
    1cae:	83 e3       	ldi	r24, 0x33	; 51
    1cb0:	91 e0       	ldi	r25, 0x01	; 1
    1cb2:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1cb6:	1b c0       	rjmp	.+54     	; 0x1cee <_Z11ReceiveBonev+0x35e>
				else if (!success && flagFreshStart){flagUserTime=fTrue; flagUserDate=fTrue; PrintBone("bad");} //need to get user time and date
    1cb8:	8b 81       	ldd	r24, Y+3	; 0x03
    1cba:	88 23       	and	r24, r24
    1cbc:	31 f4       	brne	.+12     	; 0x1cca <_Z11ReceiveBonev+0x33a>
    1cbe:	80 91 5e 01 	lds	r24, 0x015E
    1cc2:	88 23       	and	r24, r24
    1cc4:	11 f0       	breq	.+4      	; 0x1cca <_Z11ReceiveBonev+0x33a>
    1cc6:	81 e0       	ldi	r24, 0x01	; 1
    1cc8:	01 c0       	rjmp	.+2      	; 0x1ccc <_Z11ReceiveBonev+0x33c>
    1cca:	80 e0       	ldi	r24, 0x00	; 0
    1ccc:	88 23       	and	r24, r24
    1cce:	59 f0       	breq	.+22     	; 0x1ce6 <_Z11ReceiveBonev+0x356>
    1cd0:	81 e0       	ldi	r24, 0x01	; 1
    1cd2:	80 93 53 01 	sts	0x0153, r24
    1cd6:	81 e0       	ldi	r24, 0x01	; 1
    1cd8:	80 93 54 01 	sts	0x0154, r24
    1cdc:	83 e3       	ldi	r24, 0x33	; 51
    1cde:	91 e0       	ldi	r25, 0x01	; 1
    1ce0:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1ce4:	04 c0       	rjmp	.+8      	; 0x1cee <_Z11ReceiveBonev+0x35e>
				else {PrintBone("bad");}
    1ce6:	83 e3       	ldi	r24, 0x33	; 51
    1ce8:	91 e0       	ldi	r25, 0x01	; 1
    1cea:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
				//Reset flags for startup
				if (restart){restart=fFalse;}
    1cee:	90 91 5d 01 	lds	r25, 0x015D
    1cf2:	81 e0       	ldi	r24, 0x01	; 1
    1cf4:	99 23       	and	r25, r25
    1cf6:	09 f4       	brne	.+2      	; 0x1cfa <_Z11ReceiveBonev+0x36a>
    1cf8:	80 e0       	ldi	r24, 0x00	; 0
    1cfa:	88 23       	and	r24, r24
    1cfc:	11 f0       	breq	.+4      	; 0x1d02 <_Z11ReceiveBonev+0x372>
    1cfe:	10 92 5d 01 	sts	0x015D, r1
				if (flagFreshStart){flagFreshStart=fFalse;}		
    1d02:	90 91 5e 01 	lds	r25, 0x015E
    1d06:	81 e0       	ldi	r24, 0x01	; 1
    1d08:	99 23       	and	r25, r25
    1d0a:	09 f4       	brne	.+2      	; 0x1d0e <_Z11ReceiveBonev+0x37e>
    1d0c:	80 e0       	ldi	r24, 0x00	; 0
    1d0e:	88 23       	and	r24, r24
    1d10:	59 f0       	breq	.+22     	; 0x1d28 <_Z11ReceiveBonev+0x398>
    1d12:	10 92 5e 01 	sts	0x015E, r1
    1d16:	08 c0       	rjmp	.+16     	; 0x1d28 <_Z11ReceiveBonev+0x398>
			} else {
				PrintBone("ACK"); 
    1d18:	8f e2       	ldi	r24, 0x2F	; 47
    1d1a:	91 e0       	ldi	r25, 0x01	; 1
    1d1c:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
				PrintBone(recString);
    1d20:	ce 01       	movw	r24, r28
    1d22:	04 96       	adiw	r24, 0x04	; 4
    1d24:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
			}
			noCarriage = fFalse;
    1d28:	19 82       	std	Y+1, r1	; 0x01
    1d2a:	1d c0       	rjmp	.+58     	; 0x1d66 <_Z11ReceiveBonev+0x3d6>
		} else {
			recString[strLoc++] = recChar;
    1d2c:	88 8d       	ldd	r24, Y+24	; 0x18
    1d2e:	99 8d       	ldd	r25, Y+25	; 0x19
    1d30:	9e 01       	movw	r18, r28
    1d32:	2c 5f       	subi	r18, 0xFC	; 252
    1d34:	3f 4f       	sbci	r19, 0xFF	; 255
    1d36:	28 0f       	add	r18, r24
    1d38:	39 1f       	adc	r19, r25
    1d3a:	4a 81       	ldd	r20, Y+2	; 0x02
    1d3c:	f9 01       	movw	r30, r18
    1d3e:	40 83       	st	Z, r20
    1d40:	01 96       	adiw	r24, 0x01	; 1
    1d42:	99 8f       	std	Y+25, r25	; 0x19
    1d44:	88 8f       	std	Y+24, r24	; 0x18
			if (strLoc >= 19){strLoc = 0; noCarriage = fFalse; PrintBone("ACKERROR");}
    1d46:	88 8d       	ldd	r24, Y+24	; 0x18
    1d48:	99 8d       	ldd	r25, Y+25	; 0x19
    1d4a:	21 e0       	ldi	r18, 0x01	; 1
    1d4c:	83 31       	cpi	r24, 0x13	; 19
    1d4e:	91 05       	cpc	r25, r1
    1d50:	0c f4       	brge	.+2      	; 0x1d54 <_Z11ReceiveBonev+0x3c4>
    1d52:	20 e0       	ldi	r18, 0x00	; 0
    1d54:	22 23       	and	r18, r18
    1d56:	39 f0       	breq	.+14     	; 0x1d66 <_Z11ReceiveBonev+0x3d6>
    1d58:	19 8e       	std	Y+25, r1	; 0x19
    1d5a:	18 8e       	std	Y+24, r1	; 0x18
    1d5c:	19 82       	std	Y+1, r1	; 0x01
    1d5e:	87 e3       	ldi	r24, 0x37	; 55
    1d60:	91 e0       	ldi	r25, 0x01	; 1
    1d62:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
		noCarriage=fFalse;
	} else {
		recString[strLoc]=recChar;
		strLoc++;
	}
	while (noCarriage && flagUARTbone){ //flag goes down if a timeout occurs.
    1d66:	89 81       	ldd	r24, Y+1	; 0x01
    1d68:	88 23       	and	r24, r24
    1d6a:	31 f0       	breq	.+12     	; 0x1d78 <_Z11ReceiveBonev+0x3e8>
    1d6c:	80 91 51 01 	lds	r24, 0x0151
    1d70:	88 23       	and	r24, r24
    1d72:	11 f0       	breq	.+4      	; 0x1d78 <_Z11ReceiveBonev+0x3e8>
    1d74:	81 e0       	ldi	r24, 0x01	; 1
    1d76:	01 c0       	rjmp	.+2      	; 0x1d7a <_Z11ReceiveBonev+0x3ea>
    1d78:	80 e0       	ldi	r24, 0x00	; 0
    1d7a:	88 23       	and	r24, r24
    1d7c:	09 f0       	breq	.+2      	; 0x1d80 <_Z11ReceiveBonev+0x3f0>
    1d7e:	33 ce       	rjmp	.-922    	; 0x19e6 <_Z11ReceiveBonev+0x56>
		} else {
			recString[strLoc++] = recChar;
			if (strLoc >= 19){strLoc = 0; noCarriage = fFalse; PrintBone("ACKERROR");}
		}	
	}	
}
    1d80:	a7 96       	adiw	r28, 0x27	; 39
    1d82:	0f b6       	in	r0, 0x3f	; 63
    1d84:	f8 94       	cli
    1d86:	de bf       	out	0x3e, r29	; 62
    1d88:	0f be       	out	0x3f, r0	; 63
    1d8a:	cd bf       	out	0x3d, r28	; 61
    1d8c:	df 91       	pop	r29
    1d8e:	cf 91       	pop	r28
    1d90:	08 95       	ret

00001d92 <_Z13printTimeDatehhh>:

/*************************************************************************************************************/

void printTimeDate(BOOL GAVRorBONE, BOOL pTime,BOOL pDate){
    1d92:	cf 93       	push	r28
    1d94:	df 93       	push	r29
    1d96:	cd b7       	in	r28, 0x3d	; 61
    1d98:	de b7       	in	r29, 0x3e	; 62
    1d9a:	eb 97       	sbiw	r28, 0x3b	; 59
    1d9c:	0f b6       	in	r0, 0x3f	; 63
    1d9e:	f8 94       	cli
    1da0:	de bf       	out	0x3e, r29	; 62
    1da2:	0f be       	out	0x3f, r0	; 63
    1da4:	cd bf       	out	0x3d, r28	; 61
    1da6:	89 af       	sts	0x79, r24
    1da8:	6a af       	sts	0x7a, r22
    1daa:	4b af       	sts	0x7b, r20
	if (GAVRorBONE){ //Printing to BeagleBone
    1dac:	89 ad       	sts	0x69, r24
    1dae:	88 23       	and	r24, r24
    1db0:	31 f1       	breq	.+76     	; 0x1dfe <_Z13printTimeDatehhh+0x6c>
		if (pTime){
    1db2:	8a ad       	sts	0x6a, r24
    1db4:	88 23       	and	r24, r24
    1db6:	89 f0       	breq	.+34     	; 0x1dda <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    1db8:	83 e6       	ldi	r24, 0x63	; 99
    1dba:	91 e0       	ldi	r25, 0x01	; 1
    1dbc:	0e 94 3d 06 	call	0xc7a	; 0xc7a <_ZN6myTime7getTimeEv>
    1dc0:	9c 01       	movw	r18, r24
    1dc2:	ce 01       	movw	r24, r28
    1dc4:	01 96       	adiw	r24, 0x01	; 1
    1dc6:	b9 01       	movw	r22, r18
    1dc8:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
			PrintBone(tempTime);
    1dcc:	ce 01       	movw	r24, r28
    1dce:	01 96       	adiw	r24, 0x01	; 1
    1dd0:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
			PutUartChBone('/');
    1dd4:	8f e2       	ldi	r24, 0x2F	; 47
    1dd6:	0e 94 25 0c 	call	0x184a	; 0x184a <_Z13PutUartChBonec>
		}
		if (pDate){	
    1dda:	8b ad       	sts	0x6b, r24
    1ddc:	88 23       	and	r24, r24
    1dde:	a1 f1       	breq	.+104    	; 0x1e48 <_Z13printTimeDatehhh+0xb6>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    1de0:	83 e6       	ldi	r24, 0x63	; 99
    1de2:	91 e0       	ldi	r25, 0x01	; 1
    1de4:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate7getDateEv>
    1de8:	9c 01       	movw	r18, r24
    1dea:	ce 01       	movw	r24, r28
    1dec:	0c 96       	adiw	r24, 0x0c	; 12
    1dee:	b9 01       	movw	r22, r18
    1df0:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
			PrintBone(tempDate);
    1df4:	ce 01       	movw	r24, r28
    1df6:	0c 96       	adiw	r24, 0x0c	; 12
    1df8:	0e 94 44 0c 	call	0x1888	; 0x1888 <_Z9PrintBonePc>
    1dfc:	25 c0       	rjmp	.+74     	; 0x1e48 <_Z13printTimeDatehhh+0xb6>
		}
	} else { //Printing to GAVR
		if (pTime){
    1dfe:	8a ad       	sts	0x6a, r24
    1e00:	88 23       	and	r24, r24
    1e02:	89 f0       	breq	.+34     	; 0x1e26 <_Z13printTimeDatehhh+0x94>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    1e04:	83 e6       	ldi	r24, 0x63	; 99
    1e06:	91 e0       	ldi	r25, 0x01	; 1
    1e08:	0e 94 3d 06 	call	0xc7a	; 0xc7a <_ZN6myTime7getTimeEv>
    1e0c:	9c 01       	movw	r18, r24
    1e0e:	ce 01       	movw	r24, r28
    1e10:	4d 96       	adiw	r24, 0x1d	; 29
    1e12:	b9 01       	movw	r22, r18
    1e14:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
			PrintGAVR(tempTime);
    1e18:	ce 01       	movw	r24, r28
    1e1a:	4d 96       	adiw	r24, 0x1d	; 29
    1e1c:	0e 94 9b 0c 	call	0x1936	; 0x1936 <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    1e20:	8f e2       	ldi	r24, 0x2F	; 47
    1e22:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <_Z13PutUartChGAVRc>
		}
		if (pDate){
    1e26:	8b ad       	sts	0x6b, r24
    1e28:	88 23       	and	r24, r24
    1e2a:	71 f0       	breq	.+28     	; 0x1e48 <_Z13printTimeDatehhh+0xb6>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    1e2c:	83 e6       	ldi	r24, 0x63	; 99
    1e2e:	91 e0       	ldi	r25, 0x01	; 1
    1e30:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate7getDateEv>
    1e34:	9c 01       	movw	r18, r24
    1e36:	ce 01       	movw	r24, r28
    1e38:	88 96       	adiw	r24, 0x28	; 40
    1e3a:	b9 01       	movw	r22, r18
    1e3c:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
			PrintGAVR(tempDate);
    1e40:	ce 01       	movw	r24, r28
    1e42:	88 96       	adiw	r24, 0x28	; 40
    1e44:	0e 94 9b 0c 	call	0x1936	; 0x1936 <_Z9PrintGAVRPc>
		}		
	}
}
    1e48:	eb 96       	adiw	r28, 0x3b	; 59
    1e4a:	0f b6       	in	r0, 0x3f	; 63
    1e4c:	f8 94       	cli
    1e4e:	de bf       	out	0x3e, r29	; 62
    1e50:	0f be       	out	0x3f, r0	; 63
    1e52:	cd bf       	out	0x3d, r28	; 61
    1e54:	df 91       	pop	r29
    1e56:	cf 91       	pop	r28
    1e58:	08 95       	ret

00001e5a <_Z9GoToSleeph>:
/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    1e5a:	cf 93       	push	r28
    1e5c:	df 93       	push	r29
    1e5e:	00 d0       	rcall	.+0      	; 0x1e60 <_Z9GoToSleeph+0x6>
    1e60:	00 d0       	rcall	.+0      	; 0x1e62 <_Z9GoToSleeph+0x8>
    1e62:	0f 92       	push	r0
    1e64:	cd b7       	in	r28, 0x3d	; 61
    1e66:	de b7       	in	r29, 0x3e	; 62
    1e68:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    1e6a:	78 94       	sei
		volatile int sleepTime, sleepTicks = 0;
    1e6c:	1c 82       	std	Y+4, r1	; 0x04
    1e6e:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong == fTrue){
    1e70:	8d 81       	ldd	r24, Y+5	; 0x05
    1e72:	81 30       	cpi	r24, 0x01	; 1
    1e74:	49 f4       	brne	.+18     	; 0x1e88 <_Z9GoToSleeph+0x2e>
			sleepTime = SLEEP_TICKS_LOWV;
    1e76:	8c e0       	ldi	r24, 0x0C	; 12
    1e78:	90 e0       	ldi	r25, 0x00	; 0
    1e7a:	9a 83       	std	Y+2, r25	; 0x02
    1e7c:	89 83       	std	Y+1, r24	; 0x01
			EIMSK = 0;						//no int2
    1e7e:	8d e3       	ldi	r24, 0x3D	; 61
    1e80:	90 e0       	ldi	r25, 0x00	; 0
    1e82:	fc 01       	movw	r30, r24
    1e84:	10 82       	st	Z, r1
    1e86:	0d c0       	rjmp	.+26     	; 0x1ea2 <_Z9GoToSleeph+0x48>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    1e88:	8a e0       	ldi	r24, 0x0A	; 10
    1e8a:	90 e0       	ldi	r25, 0x00	; 0
    1e8c:	9a 83       	std	Y+2, r25	; 0x02
    1e8e:	89 83       	std	Y+1, r24	; 0x01
			EIMSK |= (1 << INT2);			//int2 is allowed.
    1e90:	8d e3       	ldi	r24, 0x3D	; 61
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	2d e3       	ldi	r18, 0x3D	; 61
    1e96:	30 e0       	ldi	r19, 0x00	; 0
    1e98:	f9 01       	movw	r30, r18
    1e9a:	20 81       	ld	r18, Z
    1e9c:	24 60       	ori	r18, 0x04	; 4
    1e9e:	fc 01       	movw	r30, r24
    1ea0:	20 83       	st	Z, r18
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    1ea2:	88 e2       	ldi	r24, 0x28	; 40
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	28 e2       	ldi	r18, 0x28	; 40
    1ea8:	30 e0       	ldi	r19, 0x00	; 0
    1eaa:	f9 01       	movw	r30, r18
    1eac:	20 81       	ld	r18, Z
    1eae:	2b 7f       	andi	r18, 0xFB	; 251
    1eb0:	fc 01       	movw	r30, r24
    1eb2:	20 83       	st	Z, r18
		prtSLEEPled |= (1 << bnSLEEPled);
    1eb4:	8b e2       	ldi	r24, 0x2B	; 43
    1eb6:	90 e0       	ldi	r25, 0x00	; 0
    1eb8:	2b e2       	ldi	r18, 0x2B	; 43
    1eba:	30 e0       	ldi	r19, 0x00	; 0
    1ebc:	f9 01       	movw	r30, r18
    1ebe:	20 81       	ld	r18, Z
    1ec0:	20 68       	ori	r18, 0x80	; 128
    1ec2:	fc 01       	movw	r30, r24
    1ec4:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    1ec6:	83 e5       	ldi	r24, 0x53	; 83
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	26 e0       	ldi	r18, 0x06	; 6
    1ecc:	fc 01       	movw	r30, r24
    1ece:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    1ed0:	83 e5       	ldi	r24, 0x53	; 83
    1ed2:	90 e0       	ldi	r25, 0x00	; 0
    1ed4:	23 e5       	ldi	r18, 0x53	; 83
    1ed6:	30 e0       	ldi	r19, 0x00	; 0
    1ed8:	f9 01       	movw	r30, r18
    1eda:	20 81       	ld	r18, Z
    1edc:	21 60       	ori	r18, 0x01	; 1
    1ede:	fc 01       	movw	r30, r24
    1ee0:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    1ee2:	81 e0       	ldi	r24, 0x01	; 1
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	0e 94 bc 0b 	call	0x1778	; 0x1778 <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    1eea:	06 c0       	rjmp	.+12     	; 0x1ef8 <_Z9GoToSleeph+0x9e>
			asm volatile("SLEEP");
    1eec:	88 95       	sleep
			sleepTicks++;
    1eee:	8b 81       	ldd	r24, Y+3	; 0x03
    1ef0:	9c 81       	ldd	r25, Y+4	; 0x04
    1ef2:	01 96       	adiw	r24, 0x01	; 1
    1ef4:	9c 83       	std	Y+4, r25	; 0x04
    1ef6:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    1ef8:	2b 81       	ldd	r18, Y+3	; 0x03
    1efa:	3c 81       	ldd	r19, Y+4	; 0x04
    1efc:	89 81       	ldd	r24, Y+1	; 0x01
    1efe:	9a 81       	ldd	r25, Y+2	; 0x02
    1f00:	28 17       	cp	r18, r24
    1f02:	39 07       	cpc	r19, r25
    1f04:	34 f4       	brge	.+12     	; 0x1f12 <_Z9GoToSleeph+0xb8>
    1f06:	80 91 50 01 	lds	r24, 0x0150
    1f0a:	88 23       	and	r24, r24
    1f0c:	11 f0       	breq	.+4      	; 0x1f12 <_Z9GoToSleeph+0xb8>
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	01 c0       	rjmp	.+2      	; 0x1f14 <_Z9GoToSleeph+0xba>
    1f12:	80 e0       	ldi	r24, 0x00	; 0
    1f14:	88 23       	and	r24, r24
    1f16:	51 f7       	brne	.-44     	; 0x1eec <_Z9GoToSleeph+0x92>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(10);
    1f18:	8a e0       	ldi	r24, 0x0A	; 10
    1f1a:	90 e0       	ldi	r25, 0x00	; 0
    1f1c:	0e 94 bc 0b 	call	0x1778	; 0x1778 <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSLEEPled &= ~(1 << bnSLEEPled);
    1f20:	8b e2       	ldi	r24, 0x2B	; 43
    1f22:	90 e0       	ldi	r25, 0x00	; 0
    1f24:	2b e2       	ldi	r18, 0x2B	; 43
    1f26:	30 e0       	ldi	r19, 0x00	; 0
    1f28:	f9 01       	movw	r30, r18
    1f2a:	20 81       	ld	r18, Z
    1f2c:	2f 77       	andi	r18, 0x7F	; 127
    1f2e:	fc 01       	movw	r30, r24
    1f30:	20 83       	st	Z, r18
		prtSTATUSled |= (1 << bnSTATUSled);
    1f32:	88 e2       	ldi	r24, 0x28	; 40
    1f34:	90 e0       	ldi	r25, 0x00	; 0
    1f36:	28 e2       	ldi	r18, 0x28	; 40
    1f38:	30 e0       	ldi	r19, 0x00	; 0
    1f3a:	f9 01       	movw	r30, r18
    1f3c:	20 81       	ld	r18, Z
    1f3e:	24 60       	ori	r18, 0x04	; 4
    1f40:	fc 01       	movw	r30, r24
    1f42:	20 83       	st	Z, r18
}
    1f44:	0f 90       	pop	r0
    1f46:	0f 90       	pop	r0
    1f48:	0f 90       	pop	r0
    1f4a:	0f 90       	pop	r0
    1f4c:	0f 90       	pop	r0
    1f4e:	df 91       	pop	r29
    1f50:	cf 91       	pop	r28
    1f52:	08 95       	ret

00001f54 <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    1f54:	cf 93       	push	r28
    1f56:	df 93       	push	r29
    1f58:	00 d0       	rcall	.+0      	; 0x1f5a <_Z7TakeADCv+0x6>
    1f5a:	00 d0       	rcall	.+0      	; 0x1f5c <_Z7TakeADCv+0x8>
    1f5c:	cd b7       	in	r28, 0x3d	; 61
    1f5e:	de b7       	in	r29, 0x3e	; 62
	WORD adcReading = 0;
    1f60:	1c 82       	std	Y+4, r1	; 0x04
    1f62:	1b 82       	std	Y+3, r1	; 0x03
	
	cli();
    1f64:	f8 94       	cli
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    1f66:	84 e6       	ldi	r24, 0x64	; 100
    1f68:	90 e0       	ldi	r25, 0x00	; 0
    1f6a:	24 e6       	ldi	r18, 0x64	; 100
    1f6c:	30 e0       	ldi	r19, 0x00	; 0
    1f6e:	f9 01       	movw	r30, r18
    1f70:	20 81       	ld	r18, Z
    1f72:	2e 7f       	andi	r18, 0xFE	; 254
    1f74:	fc 01       	movw	r30, r24
    1f76:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    1f78:	8c e7       	ldi	r24, 0x7C	; 124
    1f7a:	90 e0       	ldi	r25, 0x00	; 0
    1f7c:	2c e7       	ldi	r18, 0x7C	; 124
    1f7e:	30 e0       	ldi	r19, 0x00	; 0
    1f80:	f9 01       	movw	r30, r18
    1f82:	20 81       	ld	r18, Z
    1f84:	20 68       	ori	r18, 0x80	; 128
    1f86:	fc 01       	movw	r30, r24
    1f88:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    1f8a:	8a e7       	ldi	r24, 0x7A	; 122
    1f8c:	90 e0       	ldi	r25, 0x00	; 0
    1f8e:	2a e7       	ldi	r18, 0x7A	; 122
    1f90:	30 e0       	ldi	r19, 0x00	; 0
    1f92:	f9 01       	movw	r30, r18
    1f94:	20 81       	ld	r18, Z
    1f96:	24 68       	ori	r18, 0x84	; 132
    1f98:	fc 01       	movw	r30, r24
    1f9a:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    1f9c:	8e e7       	ldi	r24, 0x7E	; 126
    1f9e:	90 e0       	ldi	r25, 0x00	; 0
    1fa0:	2e ef       	ldi	r18, 0xFE	; 254
    1fa2:	fc 01       	movw	r30, r24
    1fa4:	20 83       	st	Z, r18
	Wait_ms(5);									//Tim for registers to setup
    1fa6:	85 e0       	ldi	r24, 0x05	; 5
    1fa8:	90 e0       	ldi	r25, 0x00	; 0
    1faa:	0e 94 bc 0b 	call	0x1778	; 0x1778 <_Z7Wait_msi>
	
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    1fae:	1a 82       	std	Y+2, r1	; 0x02
    1fb0:	19 82       	std	Y+1, r1	; 0x01
    1fb2:	1c c0       	rjmp	.+56     	; 0x1fec <_Z7TakeADCv+0x98>
    1fb4:	8a e7       	ldi	r24, 0x7A	; 122
    1fb6:	90 e0       	ldi	r25, 0x00	; 0
    1fb8:	2a e7       	ldi	r18, 0x7A	; 122
    1fba:	30 e0       	ldi	r19, 0x00	; 0
    1fbc:	f9 01       	movw	r30, r18
    1fbe:	20 81       	ld	r18, Z
    1fc0:	20 64       	ori	r18, 0x40	; 64
    1fc2:	fc 01       	movw	r30, r24
    1fc4:	20 83       	st	Z, r18
    1fc6:	8a e7       	ldi	r24, 0x7A	; 122
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
    1fca:	fc 01       	movw	r30, r24
    1fcc:	80 81       	ld	r24, Z
    1fce:	88 2f       	mov	r24, r24
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
    1fd2:	80 74       	andi	r24, 0x40	; 64
    1fd4:	90 70       	andi	r25, 0x00	; 0
    1fd6:	21 e0       	ldi	r18, 0x01	; 1
    1fd8:	00 97       	sbiw	r24, 0x00	; 0
    1fda:	09 f4       	brne	.+2      	; 0x1fde <_Z7TakeADCv+0x8a>
    1fdc:	20 e0       	ldi	r18, 0x00	; 0
    1fde:	22 23       	and	r18, r18
    1fe0:	91 f7       	brne	.-28     	; 0x1fc6 <_Z7TakeADCv+0x72>
    1fe2:	89 81       	ldd	r24, Y+1	; 0x01
    1fe4:	9a 81       	ldd	r25, Y+2	; 0x02
    1fe6:	01 96       	adiw	r24, 0x01	; 1
    1fe8:	9a 83       	std	Y+2, r25	; 0x02
    1fea:	89 83       	std	Y+1, r24	; 0x01
    1fec:	21 e0       	ldi	r18, 0x01	; 1
    1fee:	89 81       	ldd	r24, Y+1	; 0x01
    1ff0:	9a 81       	ldd	r25, Y+2	; 0x02
    1ff2:	82 30       	cpi	r24, 0x02	; 2
    1ff4:	91 05       	cpc	r25, r1
    1ff6:	0c f0       	brlt	.+2      	; 0x1ffa <_Z7TakeADCv+0xa6>
    1ff8:	20 e0       	ldi	r18, 0x00	; 0
    1ffa:	22 23       	and	r18, r18
    1ffc:	d9 f6       	brne	.-74     	; 0x1fb4 <_Z7TakeADCv+0x60>
	
	//Put conversion into buffer
	adcReading = ADCL;
    1ffe:	88 e7       	ldi	r24, 0x78	; 120
    2000:	90 e0       	ldi	r25, 0x00	; 0
    2002:	fc 01       	movw	r30, r24
    2004:	80 81       	ld	r24, Z
    2006:	88 2f       	mov	r24, r24
    2008:	90 e0       	ldi	r25, 0x00	; 0
    200a:	9c 83       	std	Y+4, r25	; 0x04
    200c:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    200e:	89 e7       	ldi	r24, 0x79	; 121
    2010:	90 e0       	ldi	r25, 0x00	; 0
    2012:	fc 01       	movw	r30, r24
    2014:	80 81       	ld	r24, Z
    2016:	88 2f       	mov	r24, r24
    2018:	90 e0       	ldi	r25, 0x00	; 0
    201a:	98 2f       	mov	r25, r24
    201c:	88 27       	eor	r24, r24
    201e:	2b 81       	ldd	r18, Y+3	; 0x03
    2020:	3c 81       	ldd	r19, Y+4	; 0x04
    2022:	82 2b       	or	r24, r18
    2024:	93 2b       	or	r25, r19
    2026:	9c 83       	std	Y+4, r25	; 0x04
    2028:	8b 83       	std	Y+3, r24	; 0x03
	
	//Re-enable interrupts
	sei();
    202a:	78 94       	sei
	
	//Disable ADC hardware/registers
	ADCSRA = 0;
    202c:	8a e7       	ldi	r24, 0x7A	; 122
    202e:	90 e0       	ldi	r25, 0x00	; 0
    2030:	fc 01       	movw	r30, r24
    2032:	10 82       	st	Z, r1
	ADMUX = 0;
    2034:	8c e7       	ldi	r24, 0x7C	; 124
    2036:	90 e0       	ldi	r25, 0x00	; 0
    2038:	fc 01       	movw	r30, r24
    203a:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    203c:	8e e7       	ldi	r24, 0x7E	; 126
    203e:	90 e0       	ldi	r25, 0x00	; 0
    2040:	2e e7       	ldi	r18, 0x7E	; 126
    2042:	30 e0       	ldi	r19, 0x00	; 0
    2044:	f9 01       	movw	r30, r18
    2046:	20 81       	ld	r18, Z
    2048:	21 60       	ori	r18, 0x01	; 1
    204a:	fc 01       	movw	r30, r24
    204c:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    204e:	84 e6       	ldi	r24, 0x64	; 100
    2050:	90 e0       	ldi	r25, 0x00	; 0
    2052:	24 e6       	ldi	r18, 0x64	; 100
    2054:	30 e0       	ldi	r19, 0x00	; 0
    2056:	f9 01       	movw	r30, r18
    2058:	20 81       	ld	r18, Z
    205a:	21 60       	ori	r18, 0x01	; 1
    205c:	fc 01       	movw	r30, r24
    205e:	20 83       	st	Z, r18
	
	//Do work
	Wait_ms(5);
    2060:	85 e0       	ldi	r24, 0x05	; 5
    2062:	90 e0       	ldi	r25, 0x00	; 0
    2064:	0e 94 bc 0b 	call	0x1778	; 0x1778 <_Z7Wait_msi>

	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    2068:	21 e0       	ldi	r18, 0x01	; 1
    206a:	8b 81       	ldd	r24, Y+3	; 0x03
    206c:	9c 81       	ldd	r25, Y+4	; 0x04
    206e:	f1 e0       	ldi	r31, 0x01	; 1
    2070:	8c 32       	cpi	r24, 0x2C	; 44
    2072:	9f 07       	cpc	r25, r31
    2074:	08 f4       	brcc	.+2      	; 0x2078 <_Z7TakeADCv+0x124>
    2076:	20 e0       	ldi	r18, 0x00	; 0
    2078:	20 93 5c 01 	sts	0x015C, r18
	
	globalADC=adcReading;
    207c:	8b 81       	ldd	r24, Y+3	; 0x03
    207e:	9c 81       	ldd	r25, Y+4	; 0x04
    2080:	90 93 60 01 	sts	0x0160, r25
    2084:	80 93 5f 01 	sts	0x015F, r24
}
    2088:	0f 90       	pop	r0
    208a:	0f 90       	pop	r0
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	df 91       	pop	r29
    2092:	cf 91       	pop	r28
    2094:	08 95       	ret

00002096 <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    2096:	cf 93       	push	r28
    2098:	df 93       	push	r29
    209a:	00 d0       	rcall	.+0      	; 0x209c <_Z7GetTempv+0x6>
    209c:	cd b7       	in	r28, 0x3d	; 61
    209e:	de b7       	in	r29, 0x3e	; 62
	WORD rawTemp = 0;
    20a0:	1a 82       	std	Y+2, r1	; 0x02
    20a2:	19 82       	std	Y+1, r1	; 0x01
	
	//Power on temp monitor, let it settle
	//prtTEMPen |= (1 << bnTEMPen);
	PRR0 &= ~(1 << PRSPI);	
    20a4:	84 e6       	ldi	r24, 0x64	; 100
    20a6:	90 e0       	ldi	r25, 0x00	; 0
    20a8:	24 e6       	ldi	r18, 0x64	; 100
    20aa:	30 e0       	ldi	r19, 0x00	; 0
    20ac:	f9 01       	movw	r30, r18
    20ae:	20 81       	ld	r18, Z
    20b0:	2b 7f       	andi	r18, 0xFB	; 251
    20b2:	fc 01       	movw	r30, r24
    20b4:	20 83       	st	Z, r18
	SPCR0 |= (1 << MSTR0)|(1 << SPE0)|(1 << SPR00);			//enables SPI, master, fck/64
    20b6:	8c e4       	ldi	r24, 0x4C	; 76
    20b8:	90 e0       	ldi	r25, 0x00	; 0
    20ba:	2c e4       	ldi	r18, 0x4C	; 76
    20bc:	30 e0       	ldi	r19, 0x00	; 0
    20be:	f9 01       	movw	r30, r18
    20c0:	20 81       	ld	r18, Z
    20c2:	21 65       	ori	r18, 0x51	; 81
    20c4:	fc 01       	movw	r30, r24
    20c6:	20 83       	st	Z, r18
	Wait_ms(200);
    20c8:	88 ec       	ldi	r24, 0xC8	; 200
    20ca:	90 e0       	ldi	r25, 0x00	; 0
    20cc:	0e 94 bc 0b 	call	0x1778	; 0x1778 <_Z7Wait_msi>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    20d0:	85 e2       	ldi	r24, 0x25	; 37
    20d2:	90 e0       	ldi	r25, 0x00	; 0
    20d4:	25 e2       	ldi	r18, 0x25	; 37
    20d6:	30 e0       	ldi	r19, 0x00	; 0
    20d8:	f9 01       	movw	r30, r18
    20da:	20 81       	ld	r18, Z
    20dc:	2f 76       	andi	r18, 0x6F	; 111
    20de:	fc 01       	movw	r30, r24
    20e0:	20 83       	st	Z, r18
	
	cli();
    20e2:	f8 94       	cli
	//Write to buffer to start transmission
	SPDR0 = 0x00;
    20e4:	8e e4       	ldi	r24, 0x4E	; 78
    20e6:	90 e0       	ldi	r25, 0x00	; 0
    20e8:	fc 01       	movw	r30, r24
    20ea:	10 82       	st	Z, r1
	//Wait for data to be receieved.
	while (!(SPSR0 & (1 << SPIF0)));
    20ec:	00 00       	nop
    20ee:	8d e4       	ldi	r24, 0x4D	; 77
    20f0:	90 e0       	ldi	r25, 0x00	; 0
    20f2:	fc 01       	movw	r30, r24
    20f4:	80 81       	ld	r24, Z
    20f6:	80 95       	com	r24
    20f8:	88 1f       	adc	r24, r24
    20fa:	88 27       	eor	r24, r24
    20fc:	88 1f       	adc	r24, r24
    20fe:	88 23       	and	r24, r24
    2100:	b1 f7       	brne	.-20     	; 0x20ee <_Z7GetTempv+0x58>
	rawTemp = (SPDR0 << 8);
    2102:	8e e4       	ldi	r24, 0x4E	; 78
    2104:	90 e0       	ldi	r25, 0x00	; 0
    2106:	fc 01       	movw	r30, r24
    2108:	80 81       	ld	r24, Z
    210a:	88 2f       	mov	r24, r24
    210c:	90 e0       	ldi	r25, 0x00	; 0
    210e:	98 2f       	mov	r25, r24
    2110:	88 27       	eor	r24, r24
    2112:	9a 83       	std	Y+2, r25	; 0x02
    2114:	89 83       	std	Y+1, r24	; 0x01
	SPDR0 = 0x00;
    2116:	8e e4       	ldi	r24, 0x4E	; 78
    2118:	90 e0       	ldi	r25, 0x00	; 0
    211a:	fc 01       	movw	r30, r24
    211c:	10 82       	st	Z, r1
	while (!(SPSR0 & (1 << SPIF0)));
    211e:	00 00       	nop
    2120:	8d e4       	ldi	r24, 0x4D	; 77
    2122:	90 e0       	ldi	r25, 0x00	; 0
    2124:	fc 01       	movw	r30, r24
    2126:	80 81       	ld	r24, Z
    2128:	80 95       	com	r24
    212a:	88 1f       	adc	r24, r24
    212c:	88 27       	eor	r24, r24
    212e:	88 1f       	adc	r24, r24
    2130:	88 23       	and	r24, r24
    2132:	b1 f7       	brne	.-20     	; 0x2120 <_Z7GetTempv+0x8a>
	rawTemp |= SPDR0;
    2134:	8e e4       	ldi	r24, 0x4E	; 78
    2136:	90 e0       	ldi	r25, 0x00	; 0
    2138:	fc 01       	movw	r30, r24
    213a:	80 81       	ld	r24, Z
    213c:	88 2f       	mov	r24, r24
    213e:	90 e0       	ldi	r25, 0x00	; 0
    2140:	29 81       	ldd	r18, Y+1	; 0x01
    2142:	3a 81       	ldd	r19, Y+2	; 0x02
    2144:	82 2b       	or	r24, r18
    2146:	93 2b       	or	r25, r19
    2148:	9a 83       	std	Y+2, r25	; 0x02
    214a:	89 83       	std	Y+1, r24	; 0x01
	//Set flag to correct value.
	flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
    214c:	89 81       	ldd	r24, Y+1	; 0x01
    214e:	9a 81       	ldd	r25, Y+2	; 0x02
    2150:	f2 e3       	ldi	r31, 0x32	; 50
    2152:	84 36       	cpi	r24, 0x64	; 100
    2154:	9f 07       	cpc	r25, r31
    2156:	10 f4       	brcc	.+4      	; 0x215c <_Z7GetTempv+0xc6>
    2158:	81 e0       	ldi	r24, 0x01	; 1
    215a:	01 c0       	rjmp	.+2      	; 0x215e <_Z7GetTempv+0xc8>
    215c:	80 e0       	ldi	r24, 0x00	; 0
    215e:	80 93 5b 01 	sts	0x015B, r24
	//re enable interrupts
	sei();
    2162:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    2164:	85 e2       	ldi	r24, 0x25	; 37
    2166:	90 e0       	ldi	r25, 0x00	; 0
    2168:	25 e2       	ldi	r18, 0x25	; 37
    216a:	30 e0       	ldi	r19, 0x00	; 0
    216c:	f9 01       	movw	r30, r18
    216e:	20 81       	ld	r18, Z
    2170:	20 69       	ori	r18, 0x90	; 144
    2172:	fc 01       	movw	r30, r24
    2174:	20 83       	st	Z, r18
	SPCR0=0x00;	
    2176:	8c e4       	ldi	r24, 0x4C	; 76
    2178:	90 e0       	ldi	r25, 0x00	; 0
    217a:	fc 01       	movw	r30, r24
    217c:	10 82       	st	Z, r1
	//prtTEMPen &= ~(1 << bnTEMPen);
	PRR0 |= (1 << PRSPI);
    217e:	84 e6       	ldi	r24, 0x64	; 100
    2180:	90 e0       	ldi	r25, 0x00	; 0
    2182:	24 e6       	ldi	r18, 0x64	; 100
    2184:	30 e0       	ldi	r19, 0x00	; 0
    2186:	f9 01       	movw	r30, r18
    2188:	20 81       	ld	r18, Z
    218a:	24 60       	ori	r18, 0x04	; 4
    218c:	fc 01       	movw	r30, r24
    218e:	20 83       	st	Z, r18

	globalTemp=rawTemp;
    2190:	89 81       	ldd	r24, Y+1	; 0x01
    2192:	9a 81       	ldd	r25, Y+2	; 0x02
    2194:	90 93 62 01 	sts	0x0162, r25
    2198:	80 93 61 01 	sts	0x0161, r24
}
    219c:	0f 90       	pop	r0
    219e:	0f 90       	pop	r0
    21a0:	df 91       	pop	r29
    21a2:	cf 91       	pop	r28
    21a4:	08 95       	ret

000021a6 <_Z16SendTimeDateGAVRhh>:
/*************************************************************************************************************/
//10 second timeout for this.
void SendTimeDateGAVR(BOOL sTime, BOOL sDate){
    21a6:	cf 93       	push	r28
    21a8:	df 93       	push	r29
    21aa:	cd b7       	in	r28, 0x3d	; 61
    21ac:	de b7       	in	r29, 0x3e	; 62
    21ae:	cb 58       	subi	r28, 0x8B	; 139
    21b0:	d0 40       	sbci	r29, 0x00	; 0
    21b2:	0f b6       	in	r0, 0x3f	; 63
    21b4:	f8 94       	cli
    21b6:	de bf       	out	0x3e, r29	; 62
    21b8:	0f be       	out	0x3f, r0	; 63
    21ba:	cd bf       	out	0x3d, r28	; 61
    21bc:	9e 01       	movw	r18, r28
    21be:	26 57       	subi	r18, 0x76	; 118
    21c0:	3f 4f       	sbci	r19, 0xFF	; 255
    21c2:	f9 01       	movw	r30, r18
    21c4:	80 83       	st	Z, r24
    21c6:	ce 01       	movw	r24, r28
    21c8:	85 57       	subi	r24, 0x75	; 117
    21ca:	9f 4f       	sbci	r25, 0xFF	; 255
    21cc:	fc 01       	movw	r30, r24
    21ce:	60 83       	st	Z, r22
	flagSendingGAVR=fTrue;
    21d0:	81 e0       	ldi	r24, 0x01	; 1
    21d2:	80 93 57 01 	sts	0x0157, r24
	prtSLEEPled |= (1 << bnSLEEPled);
    21d6:	8b e2       	ldi	r24, 0x2B	; 43
    21d8:	90 e0       	ldi	r25, 0x00	; 0
    21da:	2b e2       	ldi	r18, 0x2B	; 43
    21dc:	30 e0       	ldi	r19, 0x00	; 0
    21de:	f9 01       	movw	r30, r18
    21e0:	20 81       	ld	r18, Z
    21e2:	20 68       	ori	r18, 0x80	; 128
    21e4:	fc 01       	movw	r30, r24
    21e6:	20 83       	st	Z, r18
	volatile int state=0;
    21e8:	1f 82       	std	Y+7, r1	; 0x07
    21ea:	1e 82       	std	Y+6, r1	; 0x06
	BOOL communicating=fTrue;
    21ec:	81 e0       	ldi	r24, 0x01	; 1
    21ee:	89 83       	std	Y+1, r24	; 0x01
	noTimeout=fTrue;
    21f0:	81 e0       	ldi	r24, 0x01	; 1
    21f2:	80 93 58 01 	sts	0x0158, r24
	volatile int beginningSecond=currentTime.getSeconds();
    21f6:	83 e6       	ldi	r24, 0x63	; 99
    21f8:	91 e0       	ldi	r25, 0x01	; 1
    21fa:	0e 94 15 04 	call	0x82a	; 0x82a <_ZN6myTime10getSecondsEv>
    21fe:	88 2f       	mov	r24, r24
    2200:	90 e0       	ldi	r25, 0x00	; 0
    2202:	99 87       	std	Y+9, r25	; 0x09
    2204:	88 87       	std	Y+8, r24	; 0x08
	volatile int endingSecond=(10+beginningSecond)%60;
    2206:	88 85       	ldd	r24, Y+8	; 0x08
    2208:	99 85       	ldd	r25, Y+9	; 0x09
    220a:	0a 96       	adiw	r24, 0x0a	; 10
    220c:	2c e3       	ldi	r18, 0x3C	; 60
    220e:	30 e0       	ldi	r19, 0x00	; 0
    2210:	b9 01       	movw	r22, r18
    2212:	0e 94 b5 13 	call	0x276a	; 0x276a <__divmodhi4>
    2216:	9b 87       	std	Y+11, r25	; 0x0b
    2218:	8a 87       	std	Y+10, r24	; 0x0a
	char sentString[30];	//string that was sent, need it for error checking
	//Make sure we should be sending something
	if (sTime || sDate){communicating=fTrue;}
    221a:	ce 01       	movw	r24, r28
    221c:	86 57       	subi	r24, 0x76	; 118
    221e:	9f 4f       	sbci	r25, 0xFF	; 255
    2220:	fc 01       	movw	r30, r24
    2222:	80 81       	ld	r24, Z
    2224:	88 23       	and	r24, r24
    2226:	39 f4       	brne	.+14     	; 0x2236 <_Z16SendTimeDateGAVRhh+0x90>
    2228:	ce 01       	movw	r24, r28
    222a:	85 57       	subi	r24, 0x75	; 117
    222c:	9f 4f       	sbci	r25, 0xFF	; 255
    222e:	fc 01       	movw	r30, r24
    2230:	80 81       	ld	r24, Z
    2232:	88 23       	and	r24, r24
    2234:	19 f0       	breq	.+6      	; 0x223c <_Z16SendTimeDateGAVRhh+0x96>
    2236:	81 e0       	ldi	r24, 0x01	; 1
    2238:	89 83       	std	Y+1, r24	; 0x01
	else {communicating=fFalse;}
	//Main sending  loop
	while(communicating && noTimeout){
    223a:	00 c2       	rjmp	.+1024   	; 0x263c <_Z16SendTimeDateGAVRhh+0x496>
	volatile int beginningSecond=currentTime.getSeconds();
	volatile int endingSecond=(10+beginningSecond)%60;
	char sentString[30];	//string that was sent, need it for error checking
	//Make sure we should be sending something
	if (sTime || sDate){communicating=fTrue;}
	else {communicating=fFalse;}
    223c:	19 82       	std	Y+1, r1	; 0x01
	//Main sending  loop
	while(communicating && noTimeout){
    223e:	fe c1       	rjmp	.+1020   	; 0x263c <_Z16SendTimeDateGAVRhh+0x496>
		switch(state){
    2240:	8e 81       	ldd	r24, Y+6	; 0x06
    2242:	9f 81       	ldd	r25, Y+7	; 0x07
    2244:	81 30       	cpi	r24, 0x01	; 1
    2246:	91 05       	cpc	r25, r1
    2248:	79 f1       	breq	.+94     	; 0x22a8 <_Z16SendTimeDateGAVRhh+0x102>
    224a:	82 30       	cpi	r24, 0x02	; 2
    224c:	91 05       	cpc	r25, r1
    224e:	09 f4       	brne	.+2      	; 0x2252 <_Z16SendTimeDateGAVRhh+0xac>
    2250:	30 c1       	rjmp	.+608    	; 0x24b2 <_Z16SendTimeDateGAVRhh+0x30c>
    2252:	00 97       	sbiw	r24, 0x00	; 0
    2254:	09 f0       	breq	.+2      	; 0x2258 <_Z16SendTimeDateGAVRhh+0xb2>
    2256:	de c1       	rjmp	.+956    	; 0x2614 <_Z16SendTimeDateGAVRhh+0x46e>
			case 0:{
				//Send interrupt to GAVR, wait for  ACKW
				prtGAVRINT |= (1 << bnGAVRINT);
    2258:	85 e2       	ldi	r24, 0x25	; 37
    225a:	90 e0       	ldi	r25, 0x00	; 0
    225c:	25 e2       	ldi	r18, 0x25	; 37
    225e:	30 e0       	ldi	r19, 0x00	; 0
    2260:	f9 01       	movw	r30, r18
    2262:	20 81       	ld	r18, Z
    2264:	28 60       	ori	r18, 0x08	; 8
    2266:	fc 01       	movw	r30, r24
    2268:	20 83       	st	Z, r18
				for (volatile int i=0; i<2;i++){asm volatile("nop");}	
    226a:	1b a6       	lds	r17, 0xbb
    226c:	1a a6       	lds	r17, 0xba
    226e:	06 c0       	rjmp	.+12     	; 0x227c <_Z16SendTimeDateGAVRhh+0xd6>
    2270:	00 00       	nop
    2272:	8a a5       	lds	r24, 0x6a
    2274:	9b a5       	lds	r25, 0x6b
    2276:	01 96       	adiw	r24, 0x01	; 1
    2278:	9b a7       	lds	r25, 0x7b
    227a:	8a a7       	lds	r24, 0x7a
    227c:	8a a5       	lds	r24, 0x6a
    227e:	9b a5       	lds	r25, 0x6b
    2280:	21 e0       	ldi	r18, 0x01	; 1
    2282:	82 30       	cpi	r24, 0x02	; 2
    2284:	91 05       	cpc	r25, r1
    2286:	0c f0       	brlt	.+2      	; 0x228a <_Z16SendTimeDateGAVRhh+0xe4>
    2288:	20 e0       	ldi	r18, 0x00	; 0
    228a:	22 23       	and	r18, r18
    228c:	89 f7       	brne	.-30     	; 0x2270 <_Z16SendTimeDateGAVRhh+0xca>
				prtGAVRINT &= ~(1 << bnGAVRINT);
    228e:	85 e2       	ldi	r24, 0x25	; 37
    2290:	90 e0       	ldi	r25, 0x00	; 0
    2292:	25 e2       	ldi	r18, 0x25	; 37
    2294:	30 e0       	ldi	r19, 0x00	; 0
    2296:	f9 01       	movw	r30, r18
    2298:	20 81       	ld	r18, Z
    229a:	27 7f       	andi	r18, 0xF7	; 247
    229c:	fc 01       	movw	r30, r24
    229e:	20 83       	st	Z, r18
				//Wait for ACK now
				state=1;
    22a0:	81 e0       	ldi	r24, 0x01	; 1
    22a2:	90 e0       	ldi	r25, 0x00	; 0
    22a4:	9f 83       	std	Y+7, r25	; 0x07
    22a6:	8e 83       	std	Y+6, r24	; 0x06
			} case 1: {
				char recChar, recString[30];
				volatile int strLoc=0;
    22a8:	ce 01       	movw	r24, r28
    22aa:	86 5b       	subi	r24, 0xB6	; 182
    22ac:	9f 4f       	sbci	r25, 0xFF	; 255
    22ae:	fc 01       	movw	r30, r24
    22b0:	11 82       	std	Z+1, r1	; 0x01
    22b2:	10 82       	st	Z, r1
				BOOL noCarriage=fTrue;
    22b4:	81 e0       	ldi	r24, 0x01	; 1
    22b6:	8a 83       	std	Y+2, r24	; 0x02
				//We sent an interrupt, need to get an ACKW back now.
				while (noCarriage && noTimeout){
    22b8:	ee c0       	rjmp	.+476    	; 0x2496 <_Z16SendTimeDateGAVRhh+0x2f0>
					while (!(UCSR1A & (1 << RXC1)) && noTimeout);
    22ba:	00 00       	nop
    22bc:	88 ec       	ldi	r24, 0xC8	; 200
    22be:	90 e0       	ldi	r25, 0x00	; 0
    22c0:	fc 01       	movw	r30, r24
    22c2:	80 81       	ld	r24, Z
    22c4:	88 23       	and	r24, r24
    22c6:	34 f0       	brlt	.+12     	; 0x22d4 <_Z16SendTimeDateGAVRhh+0x12e>
    22c8:	80 91 58 01 	lds	r24, 0x0158
    22cc:	88 23       	and	r24, r24
    22ce:	11 f0       	breq	.+4      	; 0x22d4 <_Z16SendTimeDateGAVRhh+0x12e>
    22d0:	81 e0       	ldi	r24, 0x01	; 1
    22d2:	01 c0       	rjmp	.+2      	; 0x22d6 <_Z16SendTimeDateGAVRhh+0x130>
    22d4:	80 e0       	ldi	r24, 0x00	; 0
    22d6:	88 23       	and	r24, r24
    22d8:	89 f7       	brne	.-30     	; 0x22bc <_Z16SendTimeDateGAVRhh+0x116>
					recChar=UDR1;
    22da:	8e ec       	ldi	r24, 0xCE	; 206
    22dc:	90 e0       	ldi	r25, 0x00	; 0
    22de:	fc 01       	movw	r30, r24
    22e0:	80 81       	ld	r24, Z
    22e2:	8c 83       	std	Y+4, r24	; 0x04
					if (recChar=='.'){
    22e4:	8c 81       	ldd	r24, Y+4	; 0x04
    22e6:	8e 32       	cpi	r24, 0x2E	; 46
    22e8:	09 f0       	breq	.+2      	; 0x22ec <_Z16SendTimeDateGAVRhh+0x146>
    22ea:	a8 c0       	rjmp	.+336    	; 0x243c <_Z16SendTimeDateGAVRhh+0x296>
						recString[strLoc]='\0';
    22ec:	ce 01       	movw	r24, r28
    22ee:	86 5b       	subi	r24, 0xB6	; 182
    22f0:	9f 4f       	sbci	r25, 0xFF	; 255
    22f2:	fc 01       	movw	r30, r24
    22f4:	80 81       	ld	r24, Z
    22f6:	91 81       	ldd	r25, Z+1	; 0x01
    22f8:	9e 01       	movw	r18, r28
    22fa:	24 5d       	subi	r18, 0xD4	; 212
    22fc:	3f 4f       	sbci	r19, 0xFF	; 255
    22fe:	82 0f       	add	r24, r18
    2300:	93 1f       	adc	r25, r19
    2302:	fc 01       	movw	r30, r24
    2304:	10 82       	st	Z, r1
						noCarriage=fFalse; //get out of loop
    2306:	1a 82       	std	Y+2, r1	; 0x02
						if (!strcmp(recString,"ACKW")){//Good to send time and/or date. send and go to next state.
    2308:	ce 01       	movw	r24, r28
    230a:	8c 96       	adiw	r24, 0x2c	; 44
    230c:	20 e4       	ldi	r18, 0x40	; 64
    230e:	31 e0       	ldi	r19, 0x01	; 1
    2310:	b9 01       	movw	r22, r18
    2312:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    2316:	00 97       	sbiw	r24, 0x00	; 0
    2318:	09 f0       	breq	.+2      	; 0x231c <_Z16SendTimeDateGAVRhh+0x176>
    231a:	8d c0       	rjmp	.+282    	; 0x2436 <_Z16SendTimeDateGAVRhh+0x290>
							state=2;
    231c:	82 e0       	ldi	r24, 0x02	; 2
    231e:	90 e0       	ldi	r25, 0x00	; 0
    2320:	9f 83       	std	Y+7, r25	; 0x07
    2322:	8e 83       	std	Y+6, r24	; 0x06
							if (sTime && sDate){
    2324:	ce 01       	movw	r24, r28
    2326:	86 57       	subi	r24, 0x76	; 118
    2328:	9f 4f       	sbci	r25, 0xFF	; 255
    232a:	fc 01       	movw	r30, r24
    232c:	80 81       	ld	r24, Z
    232e:	88 23       	and	r24, r24
    2330:	c9 f1       	breq	.+114    	; 0x23a4 <_Z16SendTimeDateGAVRhh+0x1fe>
    2332:	ce 01       	movw	r24, r28
    2334:	85 57       	subi	r24, 0x75	; 117
    2336:	9f 4f       	sbci	r25, 0xFF	; 255
    2338:	fc 01       	movw	r30, r24
    233a:	80 81       	ld	r24, Z
    233c:	88 23       	and	r24, r24
    233e:	91 f1       	breq	.+100    	; 0x23a4 <_Z16SendTimeDateGAVRhh+0x1fe>
								printTimeDate(fFalse,fTrue,fTrue);
    2340:	80 e0       	ldi	r24, 0x00	; 0
    2342:	61 e0       	ldi	r22, 0x01	; 1
    2344:	41 e0       	ldi	r20, 0x01	; 1
    2346:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <_Z13printTimeDatehhh>
								PutUartChGAVR('.');
    234a:	8e e2       	ldi	r24, 0x2E	; 46
    234c:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <_Z13PutUartChGAVRc>
								strcpy(sentString,currentTime.getTime());
    2350:	83 e6       	ldi	r24, 0x63	; 99
    2352:	91 e0       	ldi	r25, 0x01	; 1
    2354:	0e 94 3d 06 	call	0xc7a	; 0xc7a <_ZN6myTime7getTimeEv>
    2358:	9c 01       	movw	r18, r24
    235a:	ce 01       	movw	r24, r28
    235c:	0c 96       	adiw	r24, 0x0c	; 12
    235e:	b9 01       	movw	r22, r18
    2360:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
								strcat(sentString,"/");
    2364:	ce 01       	movw	r24, r28
    2366:	0c 96       	adiw	r24, 0x0c	; 12
    2368:	9c 01       	movw	r18, r24
    236a:	f9 01       	movw	r30, r18
    236c:	01 90       	ld	r0, Z+
    236e:	00 20       	and	r0, r0
    2370:	e9 f7       	brne	.-6      	; 0x236c <_Z16SendTimeDateGAVRhh+0x1c6>
    2372:	cf 01       	movw	r24, r30
    2374:	01 97       	sbiw	r24, 0x01	; 1
    2376:	82 1b       	sub	r24, r18
    2378:	93 0b       	sbc	r25, r19
    237a:	9e 01       	movw	r18, r28
    237c:	24 5f       	subi	r18, 0xF4	; 244
    237e:	3f 4f       	sbci	r19, 0xFF	; 255
    2380:	82 0f       	add	r24, r18
    2382:	93 1f       	adc	r25, r19
    2384:	2f e2       	ldi	r18, 0x2F	; 47
    2386:	30 e0       	ldi	r19, 0x00	; 0
    2388:	fc 01       	movw	r30, r24
    238a:	31 83       	std	Z+1, r19	; 0x01
    238c:	20 83       	st	Z, r18
								strcat(sentString,currentTime.getDate());
    238e:	83 e6       	ldi	r24, 0x63	; 99
    2390:	91 e0       	ldi	r25, 0x01	; 1
    2392:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate7getDateEv>
    2396:	9c 01       	movw	r18, r24
    2398:	ce 01       	movw	r24, r28
    239a:	0c 96       	adiw	r24, 0x0c	; 12
    239c:	b9 01       	movw	r22, r18
    239e:	0e 94 00 14 	call	0x2800	; 0x2800 <strcat>
    23a2:	79 c0       	rjmp	.+242    	; 0x2496 <_Z16SendTimeDateGAVRhh+0x2f0>
							} else if (sTime && !sDate){
    23a4:	ce 01       	movw	r24, r28
    23a6:	86 57       	subi	r24, 0x76	; 118
    23a8:	9f 4f       	sbci	r25, 0xFF	; 255
    23aa:	fc 01       	movw	r30, r24
    23ac:	80 81       	ld	r24, Z
    23ae:	88 23       	and	r24, r24
    23b0:	79 f1       	breq	.+94     	; 0x2410 <_Z16SendTimeDateGAVRhh+0x26a>
    23b2:	ce 01       	movw	r24, r28
    23b4:	85 57       	subi	r24, 0x75	; 117
    23b6:	9f 4f       	sbci	r25, 0xFF	; 255
    23b8:	fc 01       	movw	r30, r24
    23ba:	80 81       	ld	r24, Z
    23bc:	88 23       	and	r24, r24
    23be:	41 f5       	brne	.+80     	; 0x2410 <_Z16SendTimeDateGAVRhh+0x26a>
								printTimeDate(fFalse,fTrue,fFalse);
    23c0:	80 e0       	ldi	r24, 0x00	; 0
    23c2:	61 e0       	ldi	r22, 0x01	; 1
    23c4:	40 e0       	ldi	r20, 0x00	; 0
    23c6:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <_Z13printTimeDatehhh>
								PutUartChGAVR('.');
    23ca:	8e e2       	ldi	r24, 0x2E	; 46
    23cc:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <_Z13PutUartChGAVRc>
								strcpy(sentString,currentTime.getTime());
    23d0:	83 e6       	ldi	r24, 0x63	; 99
    23d2:	91 e0       	ldi	r25, 0x01	; 1
    23d4:	0e 94 3d 06 	call	0xc7a	; 0xc7a <_ZN6myTime7getTimeEv>
    23d8:	9c 01       	movw	r18, r24
    23da:	ce 01       	movw	r24, r28
    23dc:	0c 96       	adiw	r24, 0x0c	; 12
    23de:	b9 01       	movw	r22, r18
    23e0:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
								strcat(sentString,"/");
    23e4:	ce 01       	movw	r24, r28
    23e6:	0c 96       	adiw	r24, 0x0c	; 12
    23e8:	9c 01       	movw	r18, r24
    23ea:	f9 01       	movw	r30, r18
    23ec:	01 90       	ld	r0, Z+
    23ee:	00 20       	and	r0, r0
    23f0:	e9 f7       	brne	.-6      	; 0x23ec <_Z16SendTimeDateGAVRhh+0x246>
    23f2:	cf 01       	movw	r24, r30
    23f4:	01 97       	sbiw	r24, 0x01	; 1
    23f6:	82 1b       	sub	r24, r18
    23f8:	93 0b       	sbc	r25, r19
    23fa:	9e 01       	movw	r18, r28
    23fc:	24 5f       	subi	r18, 0xF4	; 244
    23fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2400:	82 0f       	add	r24, r18
    2402:	93 1f       	adc	r25, r19
    2404:	2f e2       	ldi	r18, 0x2F	; 47
    2406:	30 e0       	ldi	r19, 0x00	; 0
    2408:	fc 01       	movw	r30, r24
    240a:	31 83       	std	Z+1, r19	; 0x01
    240c:	20 83       	st	Z, r18
    240e:	43 c0       	rjmp	.+134    	; 0x2496 <_Z16SendTimeDateGAVRhh+0x2f0>
							} else {
								printTimeDate(fFalse,fFalse,fTrue);
    2410:	80 e0       	ldi	r24, 0x00	; 0
    2412:	60 e0       	ldi	r22, 0x00	; 0
    2414:	41 e0       	ldi	r20, 0x01	; 1
    2416:	0e 94 c9 0e 	call	0x1d92	; 0x1d92 <_Z13printTimeDatehhh>
								PutUartChGAVR('.');
    241a:	8e e2       	ldi	r24, 0x2E	; 46
    241c:	0e 94 71 0c 	call	0x18e2	; 0x18e2 <_Z13PutUartChGAVRc>
								strcpy(sentString,currentTime.getDate());
    2420:	83 e6       	ldi	r24, 0x63	; 99
    2422:	91 e0       	ldi	r25, 0x01	; 1
    2424:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate7getDateEv>
    2428:	9c 01       	movw	r18, r24
    242a:	ce 01       	movw	r24, r28
    242c:	0c 96       	adiw	r24, 0x0c	; 12
    242e:	b9 01       	movw	r22, r18
    2430:	0e 94 14 14 	call	0x2828	; 0x2828 <strcpy>
    2434:	30 c0       	rjmp	.+96     	; 0x2496 <_Z16SendTimeDateGAVRhh+0x2f0>
							}													
						} else {state=0;}
    2436:	1f 82       	std	Y+7, r1	; 0x07
    2438:	1e 82       	std	Y+6, r1	; 0x06
    243a:	2d c0       	rjmp	.+90     	; 0x2496 <_Z16SendTimeDateGAVRhh+0x2f0>
					} //endif carriage
					else {
						recString[strLoc++]=recChar;
    243c:	ce 01       	movw	r24, r28
    243e:	86 5b       	subi	r24, 0xB6	; 182
    2440:	9f 4f       	sbci	r25, 0xFF	; 255
    2442:	fc 01       	movw	r30, r24
    2444:	80 81       	ld	r24, Z
    2446:	91 81       	ldd	r25, Z+1	; 0x01
    2448:	9e 01       	movw	r18, r28
    244a:	24 5d       	subi	r18, 0xD4	; 212
    244c:	3f 4f       	sbci	r19, 0xFF	; 255
    244e:	28 0f       	add	r18, r24
    2450:	39 1f       	adc	r19, r25
    2452:	4c 81       	ldd	r20, Y+4	; 0x04
    2454:	f9 01       	movw	r30, r18
    2456:	40 83       	st	Z, r20
    2458:	9c 01       	movw	r18, r24
    245a:	2f 5f       	subi	r18, 0xFF	; 255
    245c:	3f 4f       	sbci	r19, 0xFF	; 255
    245e:	ce 01       	movw	r24, r28
    2460:	86 5b       	subi	r24, 0xB6	; 182
    2462:	9f 4f       	sbci	r25, 0xFF	; 255
    2464:	fc 01       	movw	r30, r24
    2466:	31 83       	std	Z+1, r19	; 0x01
    2468:	20 83       	st	Z, r18
						if (strLoc >= 30){strLoc=0; noCarriage=fFalse; state=0;}
    246a:	ce 01       	movw	r24, r28
    246c:	86 5b       	subi	r24, 0xB6	; 182
    246e:	9f 4f       	sbci	r25, 0xFF	; 255
    2470:	fc 01       	movw	r30, r24
    2472:	80 81       	ld	r24, Z
    2474:	91 81       	ldd	r25, Z+1	; 0x01
    2476:	21 e0       	ldi	r18, 0x01	; 1
    2478:	8e 31       	cpi	r24, 0x1E	; 30
    247a:	91 05       	cpc	r25, r1
    247c:	0c f4       	brge	.+2      	; 0x2480 <_Z16SendTimeDateGAVRhh+0x2da>
    247e:	20 e0       	ldi	r18, 0x00	; 0
    2480:	22 23       	and	r18, r18
    2482:	49 f0       	breq	.+18     	; 0x2496 <_Z16SendTimeDateGAVRhh+0x2f0>
    2484:	ce 01       	movw	r24, r28
    2486:	86 5b       	subi	r24, 0xB6	; 182
    2488:	9f 4f       	sbci	r25, 0xFF	; 255
    248a:	fc 01       	movw	r30, r24
    248c:	11 82       	std	Z+1, r1	; 0x01
    248e:	10 82       	st	Z, r1
    2490:	1a 82       	std	Y+2, r1	; 0x02
    2492:	1f 82       	std	Y+7, r1	; 0x07
    2494:	1e 82       	std	Y+6, r1	; 0x06
			} case 1: {
				char recChar, recString[30];
				volatile int strLoc=0;
				BOOL noCarriage=fTrue;
				//We sent an interrupt, need to get an ACKW back now.
				while (noCarriage && noTimeout){
    2496:	8a 81       	ldd	r24, Y+2	; 0x02
    2498:	88 23       	and	r24, r24
    249a:	31 f0       	breq	.+12     	; 0x24a8 <_Z16SendTimeDateGAVRhh+0x302>
    249c:	80 91 58 01 	lds	r24, 0x0158
    24a0:	88 23       	and	r24, r24
    24a2:	11 f0       	breq	.+4      	; 0x24a8 <_Z16SendTimeDateGAVRhh+0x302>
    24a4:	81 e0       	ldi	r24, 0x01	; 1
    24a6:	01 c0       	rjmp	.+2      	; 0x24aa <_Z16SendTimeDateGAVRhh+0x304>
    24a8:	80 e0       	ldi	r24, 0x00	; 0
    24aa:	88 23       	and	r24, r24
    24ac:	09 f0       	breq	.+2      	; 0x24b0 <_Z16SendTimeDateGAVRhh+0x30a>
    24ae:	05 cf       	rjmp	.-502    	; 0x22ba <_Z16SendTimeDateGAVRhh+0x114>
					else {
						recString[strLoc++]=recChar;
						if (strLoc >= 30){strLoc=0; noCarriage=fFalse; state=0;}
					} //end normal char else
				} //end receiving part
				break;//end case 1
    24b0:	b4 c0       	rjmp	.+360    	; 0x261a <_Z16SendTimeDateGAVRhh+0x474>
			} case 2: { //Need to get ACK with the date and/or time.
				char recString[30];
				char recChar;
				volatile int strLoc=0;
    24b2:	ce 01       	movw	r24, r28
    24b4:	86 59       	subi	r24, 0x96	; 150
    24b6:	9f 4f       	sbci	r25, 0xFF	; 255
    24b8:	fc 01       	movw	r30, r24
    24ba:	11 82       	std	Z+1, r1	; 0x01
    24bc:	10 82       	st	Z, r1
				BOOL noCarriage=fTrue;
    24be:	81 e0       	ldi	r24, 0x01	; 1
    24c0:	8b 83       	std	Y+3, r24	; 0x03
				char noGoodString[30];
				strcpy(noGoodString,"ACKnogood");
    24c2:	ce 01       	movw	r24, r28
    24c4:	84 59       	subi	r24, 0x94	; 148
    24c6:	9f 4f       	sbci	r25, 0xFF	; 255
    24c8:	25 e4       	ldi	r18, 0x45	; 69
    24ca:	31 e0       	ldi	r19, 0x01	; 1
    24cc:	4a e0       	ldi	r20, 0x0A	; 10
    24ce:	f9 01       	movw	r30, r18
    24d0:	00 80       	ld	r0, Z
    24d2:	2f 5f       	subi	r18, 0xFF	; 255
    24d4:	3f 4f       	sbci	r19, 0xFF	; 255
    24d6:	fc 01       	movw	r30, r24
    24d8:	00 82       	st	Z, r0
    24da:	01 96       	adiw	r24, 0x01	; 1
    24dc:	41 50       	subi	r20, 0x01	; 1
    24de:	44 23       	and	r20, r20
    24e0:	b1 f7       	brne	.-20     	; 0x24ce <_Z16SendTimeDateGAVRhh+0x328>
				strcat(noGoodString,sentString);
    24e2:	ce 01       	movw	r24, r28
    24e4:	84 59       	subi	r24, 0x94	; 148
    24e6:	9f 4f       	sbci	r25, 0xFF	; 255
    24e8:	9e 01       	movw	r18, r28
    24ea:	24 5f       	subi	r18, 0xF4	; 244
    24ec:	3f 4f       	sbci	r19, 0xFF	; 255
    24ee:	b9 01       	movw	r22, r18
    24f0:	0e 94 00 14 	call	0x2800	; 0x2800 <strcat>
				//get the ack
				while (noCarriage && noTimeout){
    24f4:	81 c0       	rjmp	.+258    	; 0x25f8 <_Z16SendTimeDateGAVRhh+0x452>
					while (!(UCSR1A & (1 << RXC1)) && noTimeout);
    24f6:	00 00       	nop
    24f8:	88 ec       	ldi	r24, 0xC8	; 200
    24fa:	90 e0       	ldi	r25, 0x00	; 0
    24fc:	fc 01       	movw	r30, r24
    24fe:	80 81       	ld	r24, Z
    2500:	88 23       	and	r24, r24
    2502:	34 f0       	brlt	.+12     	; 0x2510 <_Z16SendTimeDateGAVRhh+0x36a>
    2504:	80 91 58 01 	lds	r24, 0x0158
    2508:	88 23       	and	r24, r24
    250a:	11 f0       	breq	.+4      	; 0x2510 <_Z16SendTimeDateGAVRhh+0x36a>
    250c:	81 e0       	ldi	r24, 0x01	; 1
    250e:	01 c0       	rjmp	.+2      	; 0x2512 <_Z16SendTimeDateGAVRhh+0x36c>
    2510:	80 e0       	ldi	r24, 0x00	; 0
    2512:	88 23       	and	r24, r24
    2514:	89 f7       	brne	.-30     	; 0x24f8 <_Z16SendTimeDateGAVRhh+0x352>
					recChar=UDR1;
    2516:	8e ec       	ldi	r24, 0xCE	; 206
    2518:	90 e0       	ldi	r25, 0x00	; 0
    251a:	fc 01       	movw	r30, r24
    251c:	80 81       	ld	r24, Z
    251e:	8d 83       	std	Y+5, r24	; 0x05
					if (recChar=='.'){
    2520:	8d 81       	ldd	r24, Y+5	; 0x05
    2522:	8e 32       	cpi	r24, 0x2E	; 46
    2524:	e1 f5       	brne	.+120    	; 0x259e <_Z16SendTimeDateGAVRhh+0x3f8>
						recString[strLoc]='\0';
    2526:	ce 01       	movw	r24, r28
    2528:	86 59       	subi	r24, 0x96	; 150
    252a:	9f 4f       	sbci	r25, 0xFF	; 255
    252c:	fc 01       	movw	r30, r24
    252e:	80 81       	ld	r24, Z
    2530:	91 81       	ldd	r25, Z+1	; 0x01
    2532:	9e 01       	movw	r18, r28
    2534:	24 5b       	subi	r18, 0xB4	; 180
    2536:	3f 4f       	sbci	r19, 0xFF	; 255
    2538:	82 0f       	add	r24, r18
    253a:	93 1f       	adc	r25, r19
    253c:	fc 01       	movw	r30, r24
    253e:	10 82       	st	Z, r1
						noCarriage=fFalse;
    2540:	1b 82       	std	Y+3, r1	; 0x03
						if (!strcmp(recString,sentString)){communicating=fFalse;}
    2542:	ce 01       	movw	r24, r28
    2544:	84 5b       	subi	r24, 0xB4	; 180
    2546:	9f 4f       	sbci	r25, 0xFF	; 255
    2548:	9e 01       	movw	r18, r28
    254a:	24 5f       	subi	r18, 0xF4	; 244
    254c:	3f 4f       	sbci	r19, 0xFF	; 255
    254e:	b9 01       	movw	r22, r18
    2550:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    2554:	00 97       	sbiw	r24, 0x00	; 0
    2556:	11 f4       	brne	.+4      	; 0x255c <_Z16SendTimeDateGAVRhh+0x3b6>
    2558:	19 82       	std	Y+1, r1	; 0x01
    255a:	4e c0       	rjmp	.+156    	; 0x25f8 <_Z16SendTimeDateGAVRhh+0x452>
						else if (!strcmp(recString,noGoodString)){state=0;} //retry the send
    255c:	ce 01       	movw	r24, r28
    255e:	84 5b       	subi	r24, 0xB4	; 180
    2560:	9f 4f       	sbci	r25, 0xFF	; 255
    2562:	9e 01       	movw	r18, r28
    2564:	24 59       	subi	r18, 0x94	; 148
    2566:	3f 4f       	sbci	r19, 0xFF	; 255
    2568:	b9 01       	movw	r22, r18
    256a:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    256e:	00 97       	sbiw	r24, 0x00	; 0
    2570:	19 f4       	brne	.+6      	; 0x2578 <_Z16SendTimeDateGAVRhh+0x3d2>
    2572:	1f 82       	std	Y+7, r1	; 0x07
    2574:	1e 82       	std	Y+6, r1	; 0x06
    2576:	40 c0       	rjmp	.+128    	; 0x25f8 <_Z16SendTimeDateGAVRhh+0x452>
						else if (!strcmp(recString,"ACKERROR")){communicating=fFalse; flagUpdateGAVRDate=fFalse; flagUpdateGAVRTime=fFalse;} //major error, User is going to get date and time and then send it back to this WAVR												 
    2578:	ce 01       	movw	r24, r28
    257a:	84 5b       	subi	r24, 0xB4	; 180
    257c:	9f 4f       	sbci	r25, 0xFF	; 255
    257e:	27 e3       	ldi	r18, 0x37	; 55
    2580:	31 e0       	ldi	r19, 0x01	; 1
    2582:	b9 01       	movw	r22, r18
    2584:	0e 94 0b 14 	call	0x2816	; 0x2816 <strcmp>
    2588:	00 97       	sbiw	r24, 0x00	; 0
    258a:	31 f4       	brne	.+12     	; 0x2598 <_Z16SendTimeDateGAVRhh+0x3f2>
    258c:	19 82       	std	Y+1, r1	; 0x01
    258e:	10 92 56 01 	sts	0x0156, r1
    2592:	10 92 55 01 	sts	0x0155, r1
    2596:	30 c0       	rjmp	.+96     	; 0x25f8 <_Z16SendTimeDateGAVRhh+0x452>
						
						else {state=0;}
    2598:	1f 82       	std	Y+7, r1	; 0x07
    259a:	1e 82       	std	Y+6, r1	; 0x06
    259c:	2d c0       	rjmp	.+90     	; 0x25f8 <_Z16SendTimeDateGAVRhh+0x452>
					} else {
						recString[strLoc++]=recChar;
    259e:	ce 01       	movw	r24, r28
    25a0:	86 59       	subi	r24, 0x96	; 150
    25a2:	9f 4f       	sbci	r25, 0xFF	; 255
    25a4:	fc 01       	movw	r30, r24
    25a6:	80 81       	ld	r24, Z
    25a8:	91 81       	ldd	r25, Z+1	; 0x01
    25aa:	9e 01       	movw	r18, r28
    25ac:	24 5b       	subi	r18, 0xB4	; 180
    25ae:	3f 4f       	sbci	r19, 0xFF	; 255
    25b0:	28 0f       	add	r18, r24
    25b2:	39 1f       	adc	r19, r25
    25b4:	4d 81       	ldd	r20, Y+5	; 0x05
    25b6:	f9 01       	movw	r30, r18
    25b8:	40 83       	st	Z, r20
    25ba:	9c 01       	movw	r18, r24
    25bc:	2f 5f       	subi	r18, 0xFF	; 255
    25be:	3f 4f       	sbci	r19, 0xFF	; 255
    25c0:	ce 01       	movw	r24, r28
    25c2:	86 59       	subi	r24, 0x96	; 150
    25c4:	9f 4f       	sbci	r25, 0xFF	; 255
    25c6:	fc 01       	movw	r30, r24
    25c8:	31 83       	std	Z+1, r19	; 0x01
    25ca:	20 83       	st	Z, r18
						if (strLoc > 30){strLoc=0; state=0; noCarriage=fFalse;}
    25cc:	ce 01       	movw	r24, r28
    25ce:	86 59       	subi	r24, 0x96	; 150
    25d0:	9f 4f       	sbci	r25, 0xFF	; 255
    25d2:	fc 01       	movw	r30, r24
    25d4:	80 81       	ld	r24, Z
    25d6:	91 81       	ldd	r25, Z+1	; 0x01
    25d8:	21 e0       	ldi	r18, 0x01	; 1
    25da:	8f 31       	cpi	r24, 0x1F	; 31
    25dc:	91 05       	cpc	r25, r1
    25de:	0c f4       	brge	.+2      	; 0x25e2 <_Z16SendTimeDateGAVRhh+0x43c>
    25e0:	20 e0       	ldi	r18, 0x00	; 0
    25e2:	22 23       	and	r18, r18
    25e4:	49 f0       	breq	.+18     	; 0x25f8 <_Z16SendTimeDateGAVRhh+0x452>
    25e6:	ce 01       	movw	r24, r28
    25e8:	86 59       	subi	r24, 0x96	; 150
    25ea:	9f 4f       	sbci	r25, 0xFF	; 255
    25ec:	fc 01       	movw	r30, r24
    25ee:	11 82       	std	Z+1, r1	; 0x01
    25f0:	10 82       	st	Z, r1
    25f2:	1f 82       	std	Y+7, r1	; 0x07
    25f4:	1e 82       	std	Y+6, r1	; 0x06
    25f6:	1b 82       	std	Y+3, r1	; 0x03
				BOOL noCarriage=fTrue;
				char noGoodString[30];
				strcpy(noGoodString,"ACKnogood");
				strcat(noGoodString,sentString);
				//get the ack
				while (noCarriage && noTimeout){
    25f8:	8b 81       	ldd	r24, Y+3	; 0x03
    25fa:	88 23       	and	r24, r24
    25fc:	31 f0       	breq	.+12     	; 0x260a <_Z16SendTimeDateGAVRhh+0x464>
    25fe:	80 91 58 01 	lds	r24, 0x0158
    2602:	88 23       	and	r24, r24
    2604:	11 f0       	breq	.+4      	; 0x260a <_Z16SendTimeDateGAVRhh+0x464>
    2606:	81 e0       	ldi	r24, 0x01	; 1
    2608:	01 c0       	rjmp	.+2      	; 0x260c <_Z16SendTimeDateGAVRhh+0x466>
    260a:	80 e0       	ldi	r24, 0x00	; 0
    260c:	88 23       	and	r24, r24
    260e:	09 f0       	breq	.+2      	; 0x2612 <_Z16SendTimeDateGAVRhh+0x46c>
    2610:	72 cf       	rjmp	.-284    	; 0x24f6 <_Z16SendTimeDateGAVRhh+0x350>
					} else {
						recString[strLoc++]=recChar;
						if (strLoc > 30){strLoc=0; state=0; noCarriage=fFalse;}
					}
				}
				break;
    2612:	03 c0       	rjmp	.+6      	; 0x261a <_Z16SendTimeDateGAVRhh+0x474>
			} //end case 2
			default: {state=0; break;}
    2614:	1f 82       	std	Y+7, r1	; 0x07
    2616:	1e 82       	std	Y+6, r1	; 0x06
    2618:	00 00       	nop
		} //end switch
	if (beginningSecond != endingSecond){noTimeout=fTrue;}
    261a:	28 85       	ldd	r18, Y+8	; 0x08
    261c:	39 85       	ldd	r19, Y+9	; 0x09
    261e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2620:	9b 85       	ldd	r25, Y+11	; 0x0b
    2622:	41 e0       	ldi	r20, 0x01	; 1
    2624:	28 17       	cp	r18, r24
    2626:	39 07       	cpc	r19, r25
    2628:	09 f4       	brne	.+2      	; 0x262c <_Z16SendTimeDateGAVRhh+0x486>
    262a:	40 e0       	ldi	r20, 0x00	; 0
    262c:	44 23       	and	r20, r20
    262e:	21 f0       	breq	.+8      	; 0x2638 <_Z16SendTimeDateGAVRhh+0x492>
    2630:	81 e0       	ldi	r24, 0x01	; 1
    2632:	80 93 58 01 	sts	0x0158, r24
    2636:	02 c0       	rjmp	.+4      	; 0x263c <_Z16SendTimeDateGAVRhh+0x496>
	else {noTimeout=fFalse;}
    2638:	10 92 58 01 	sts	0x0158, r1
	char sentString[30];	//string that was sent, need it for error checking
	//Make sure we should be sending something
	if (sTime || sDate){communicating=fTrue;}
	else {communicating=fFalse;}
	//Main sending  loop
	while(communicating && noTimeout){
    263c:	89 81       	ldd	r24, Y+1	; 0x01
    263e:	88 23       	and	r24, r24
    2640:	31 f0       	breq	.+12     	; 0x264e <_Z16SendTimeDateGAVRhh+0x4a8>
    2642:	80 91 58 01 	lds	r24, 0x0158
    2646:	88 23       	and	r24, r24
    2648:	11 f0       	breq	.+4      	; 0x264e <_Z16SendTimeDateGAVRhh+0x4a8>
    264a:	81 e0       	ldi	r24, 0x01	; 1
    264c:	01 c0       	rjmp	.+2      	; 0x2650 <_Z16SendTimeDateGAVRhh+0x4aa>
    264e:	80 e0       	ldi	r24, 0x00	; 0
    2650:	88 23       	and	r24, r24
    2652:	09 f0       	breq	.+2      	; 0x2656 <_Z16SendTimeDateGAVRhh+0x4b0>
    2654:	f5 cd       	rjmp	.-1046   	; 0x2240 <_Z16SendTimeDateGAVRhh+0x9a>
			default: {state=0; break;}
		} //end switch
	if (beginningSecond != endingSecond){noTimeout=fTrue;}
	else {noTimeout=fFalse;}
	}//end communicationg	
	if (noTimeout){
    2656:	90 91 58 01 	lds	r25, 0x0158
    265a:	81 e0       	ldi	r24, 0x01	; 1
    265c:	99 23       	and	r25, r25
    265e:	09 f4       	brne	.+2      	; 0x2662 <_Z16SendTimeDateGAVRhh+0x4bc>
    2660:	80 e0       	ldi	r24, 0x00	; 0
    2662:	88 23       	and	r24, r24
    2664:	a1 f1       	breq	.+104    	; 0x26ce <_Z16SendTimeDateGAVRhh+0x528>
		if (sDate && sTime){flagUpdateGAVRDate=fFalse; flagUpdateGAVRTime=fFalse;}
    2666:	ce 01       	movw	r24, r28
    2668:	85 57       	subi	r24, 0x75	; 117
    266a:	9f 4f       	sbci	r25, 0xFF	; 255
    266c:	fc 01       	movw	r30, r24
    266e:	80 81       	ld	r24, Z
    2670:	88 23       	and	r24, r24
    2672:	61 f0       	breq	.+24     	; 0x268c <_Z16SendTimeDateGAVRhh+0x4e6>
    2674:	ce 01       	movw	r24, r28
    2676:	86 57       	subi	r24, 0x76	; 118
    2678:	9f 4f       	sbci	r25, 0xFF	; 255
    267a:	fc 01       	movw	r30, r24
    267c:	80 81       	ld	r24, Z
    267e:	88 23       	and	r24, r24
    2680:	29 f0       	breq	.+10     	; 0x268c <_Z16SendTimeDateGAVRhh+0x4e6>
    2682:	10 92 56 01 	sts	0x0156, r1
    2686:	10 92 55 01 	sts	0x0155, r1
    268a:	21 c0       	rjmp	.+66     	; 0x26ce <_Z16SendTimeDateGAVRhh+0x528>
		else if (sDate && !sTime){flagUpdateGAVRDate=fFalse;}
    268c:	ce 01       	movw	r24, r28
    268e:	85 57       	subi	r24, 0x75	; 117
    2690:	9f 4f       	sbci	r25, 0xFF	; 255
    2692:	fc 01       	movw	r30, r24
    2694:	80 81       	ld	r24, Z
    2696:	88 23       	and	r24, r24
    2698:	51 f0       	breq	.+20     	; 0x26ae <_Z16SendTimeDateGAVRhh+0x508>
    269a:	ce 01       	movw	r24, r28
    269c:	86 57       	subi	r24, 0x76	; 118
    269e:	9f 4f       	sbci	r25, 0xFF	; 255
    26a0:	fc 01       	movw	r30, r24
    26a2:	80 81       	ld	r24, Z
    26a4:	88 23       	and	r24, r24
    26a6:	19 f4       	brne	.+6      	; 0x26ae <_Z16SendTimeDateGAVRhh+0x508>
    26a8:	10 92 56 01 	sts	0x0156, r1
    26ac:	10 c0       	rjmp	.+32     	; 0x26ce <_Z16SendTimeDateGAVRhh+0x528>
		else if (sTime && !sDate){flagUpdateGAVRTime=fFalse;}
    26ae:	ce 01       	movw	r24, r28
    26b0:	86 57       	subi	r24, 0x76	; 118
    26b2:	9f 4f       	sbci	r25, 0xFF	; 255
    26b4:	fc 01       	movw	r30, r24
    26b6:	80 81       	ld	r24, Z
    26b8:	88 23       	and	r24, r24
    26ba:	49 f0       	breq	.+18     	; 0x26ce <_Z16SendTimeDateGAVRhh+0x528>
    26bc:	ce 01       	movw	r24, r28
    26be:	85 57       	subi	r24, 0x75	; 117
    26c0:	9f 4f       	sbci	r25, 0xFF	; 255
    26c2:	fc 01       	movw	r30, r24
    26c4:	80 81       	ld	r24, Z
    26c6:	88 23       	and	r24, r24
    26c8:	11 f4       	brne	.+4      	; 0x26ce <_Z16SendTimeDateGAVRhh+0x528>
    26ca:	10 92 55 01 	sts	0x0155, r1
		else;
	} else;
	prtSLEEPled &= ~(1 << bnSLEEPled);
    26ce:	8b e2       	ldi	r24, 0x2B	; 43
    26d0:	90 e0       	ldi	r25, 0x00	; 0
    26d2:	2b e2       	ldi	r18, 0x2B	; 43
    26d4:	30 e0       	ldi	r19, 0x00	; 0
    26d6:	f9 01       	movw	r30, r18
    26d8:	20 81       	ld	r18, Z
    26da:	2f 77       	andi	r18, 0x7F	; 127
    26dc:	fc 01       	movw	r30, r24
    26de:	20 83       	st	Z, r18
	flagSendingGAVR=fFalse;			
    26e0:	10 92 57 01 	sts	0x0157, r1
} //end function
    26e4:	c5 57       	subi	r28, 0x75	; 117
    26e6:	df 4f       	sbci	r29, 0xFF	; 255
    26e8:	0f b6       	in	r0, 0x3f	; 63
    26ea:	f8 94       	cli
    26ec:	de bf       	out	0x3e, r29	; 62
    26ee:	0f be       	out	0x3f, r0	; 63
    26f0:	cd bf       	out	0x3d, r28	; 61
    26f2:	df 91       	pop	r29
    26f4:	cf 91       	pop	r28
    26f6:	08 95       	ret

000026f8 <_Z41__static_initialization_and_destruction_0ii>:
    26f8:	cf 93       	push	r28
    26fa:	df 93       	push	r29
    26fc:	00 d0       	rcall	.+0      	; 0x26fe <_Z41__static_initialization_and_destruction_0ii+0x6>
    26fe:	00 d0       	rcall	.+0      	; 0x2700 <_Z41__static_initialization_and_destruction_0ii+0x8>
    2700:	cd b7       	in	r28, 0x3d	; 61
    2702:	de b7       	in	r29, 0x3e	; 62
    2704:	9a 83       	std	Y+2, r25	; 0x02
    2706:	89 83       	std	Y+1, r24	; 0x01
    2708:	7c 83       	std	Y+4, r23	; 0x04
    270a:	6b 83       	std	Y+3, r22	; 0x03
    270c:	89 81       	ldd	r24, Y+1	; 0x01
    270e:	9a 81       	ldd	r25, Y+2	; 0x02
    2710:	81 30       	cpi	r24, 0x01	; 1
    2712:	91 05       	cpc	r25, r1
    2714:	51 f4       	brne	.+20     	; 0x272a <_Z41__static_initialization_and_destruction_0ii+0x32>
    2716:	8b 81       	ldd	r24, Y+3	; 0x03
    2718:	9c 81       	ldd	r25, Y+4	; 0x04
    271a:	2f ef       	ldi	r18, 0xFF	; 255
    271c:	8f 3f       	cpi	r24, 0xFF	; 255
    271e:	92 07       	cpc	r25, r18
    2720:	21 f4       	brne	.+8      	; 0x272a <_Z41__static_initialization_and_destruction_0ii+0x32>
volatile BOOL flagGoToSleep, flagUARTbone,flagNormalMode,flagUserTime, flagUserDate;
volatile BOOL flagUpdateGAVRTime, flagUpdateGAVRDate, flagSendingGAVR, noTimeout;
volatile BOOL flagNewShutdown, flagShutdown,flagGoodTemp, flagGoodVolts, restart,flagFreshStart;
volatile WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    2722:	83 e6       	ldi	r24, 0x63	; 99
    2724:	91 e0       	ldi	r25, 0x01	; 1
    2726:	0e 94 91 03 	call	0x722	; 0x722 <_ZN6myTimeC1Ev>
		else if (sTime && !sDate){flagUpdateGAVRTime=fFalse;}
		else;
	} else;
	prtSLEEPled &= ~(1 << bnSLEEPled);
	flagSendingGAVR=fFalse;			
} //end function
    272a:	0f 90       	pop	r0
    272c:	0f 90       	pop	r0
    272e:	0f 90       	pop	r0
    2730:	0f 90       	pop	r0
    2732:	df 91       	pop	r29
    2734:	cf 91       	pop	r28
    2736:	08 95       	ret

00002738 <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    2738:	cf 93       	push	r28
    273a:	df 93       	push	r29
    273c:	cd b7       	in	r28, 0x3d	; 61
    273e:	de b7       	in	r29, 0x3e	; 62
    2740:	81 e0       	ldi	r24, 0x01	; 1
    2742:	90 e0       	ldi	r25, 0x00	; 0
    2744:	6f ef       	ldi	r22, 0xFF	; 255
    2746:	7f ef       	ldi	r23, 0xFF	; 255
    2748:	0e 94 7c 13 	call	0x26f8	; 0x26f8 <_Z41__static_initialization_and_destruction_0ii>
    274c:	df 91       	pop	r29
    274e:	cf 91       	pop	r28
    2750:	08 95       	ret

00002752 <__udivmodqi4>:
    2752:	99 1b       	sub	r25, r25
    2754:	79 e0       	ldi	r23, 0x09	; 9
    2756:	04 c0       	rjmp	.+8      	; 0x2760 <__udivmodqi4_ep>

00002758 <__udivmodqi4_loop>:
    2758:	99 1f       	adc	r25, r25
    275a:	96 17       	cp	r25, r22
    275c:	08 f0       	brcs	.+2      	; 0x2760 <__udivmodqi4_ep>
    275e:	96 1b       	sub	r25, r22

00002760 <__udivmodqi4_ep>:
    2760:	88 1f       	adc	r24, r24
    2762:	7a 95       	dec	r23
    2764:	c9 f7       	brne	.-14     	; 0x2758 <__udivmodqi4_loop>
    2766:	80 95       	com	r24
    2768:	08 95       	ret

0000276a <__divmodhi4>:
    276a:	97 fb       	bst	r25, 7
    276c:	09 2e       	mov	r0, r25
    276e:	07 26       	eor	r0, r23
    2770:	0a d0       	rcall	.+20     	; 0x2786 <__divmodhi4_neg1>
    2772:	77 fd       	sbrc	r23, 7
    2774:	04 d0       	rcall	.+8      	; 0x277e <__divmodhi4_neg2>
    2776:	0c d0       	rcall	.+24     	; 0x2790 <__udivmodhi4>
    2778:	06 d0       	rcall	.+12     	; 0x2786 <__divmodhi4_neg1>
    277a:	00 20       	and	r0, r0
    277c:	1a f4       	brpl	.+6      	; 0x2784 <__divmodhi4_exit>

0000277e <__divmodhi4_neg2>:
    277e:	70 95       	com	r23
    2780:	61 95       	neg	r22
    2782:	7f 4f       	sbci	r23, 0xFF	; 255

00002784 <__divmodhi4_exit>:
    2784:	08 95       	ret

00002786 <__divmodhi4_neg1>:
    2786:	f6 f7       	brtc	.-4      	; 0x2784 <__divmodhi4_exit>
    2788:	90 95       	com	r25
    278a:	81 95       	neg	r24
    278c:	9f 4f       	sbci	r25, 0xFF	; 255
    278e:	08 95       	ret

00002790 <__udivmodhi4>:
    2790:	aa 1b       	sub	r26, r26
    2792:	bb 1b       	sub	r27, r27
    2794:	51 e1       	ldi	r21, 0x11	; 17
    2796:	07 c0       	rjmp	.+14     	; 0x27a6 <__udivmodhi4_ep>

00002798 <__udivmodhi4_loop>:
    2798:	aa 1f       	adc	r26, r26
    279a:	bb 1f       	adc	r27, r27
    279c:	a6 17       	cp	r26, r22
    279e:	b7 07       	cpc	r27, r23
    27a0:	10 f0       	brcs	.+4      	; 0x27a6 <__udivmodhi4_ep>
    27a2:	a6 1b       	sub	r26, r22
    27a4:	b7 0b       	sbc	r27, r23

000027a6 <__udivmodhi4_ep>:
    27a6:	88 1f       	adc	r24, r24
    27a8:	99 1f       	adc	r25, r25
    27aa:	5a 95       	dec	r21
    27ac:	a9 f7       	brne	.-22     	; 0x2798 <__udivmodhi4_loop>
    27ae:	80 95       	com	r24
    27b0:	90 95       	com	r25
    27b2:	bc 01       	movw	r22, r24
    27b4:	cd 01       	movw	r24, r26
    27b6:	08 95       	ret

000027b8 <__tablejump2__>:
    27b8:	ee 0f       	add	r30, r30
    27ba:	ff 1f       	adc	r31, r31

000027bc <__tablejump__>:
    27bc:	05 90       	lpm	r0, Z+
    27be:	f4 91       	lpm	r31, Z
    27c0:	e0 2d       	mov	r30, r0
    27c2:	09 94       	ijmp

000027c4 <atoi>:
    27c4:	fc 01       	movw	r30, r24
    27c6:	88 27       	eor	r24, r24
    27c8:	99 27       	eor	r25, r25
    27ca:	e8 94       	clt
    27cc:	21 91       	ld	r18, Z+
    27ce:	20 32       	cpi	r18, 0x20	; 32
    27d0:	e9 f3       	breq	.-6      	; 0x27cc <atoi+0x8>
    27d2:	29 30       	cpi	r18, 0x09	; 9
    27d4:	10 f0       	brcs	.+4      	; 0x27da <atoi+0x16>
    27d6:	2e 30       	cpi	r18, 0x0E	; 14
    27d8:	c8 f3       	brcs	.-14     	; 0x27cc <atoi+0x8>
    27da:	2b 32       	cpi	r18, 0x2B	; 43
    27dc:	41 f0       	breq	.+16     	; 0x27ee <atoi+0x2a>
    27de:	2d 32       	cpi	r18, 0x2D	; 45
    27e0:	39 f4       	brne	.+14     	; 0x27f0 <atoi+0x2c>
    27e2:	68 94       	set
    27e4:	04 c0       	rjmp	.+8      	; 0x27ee <atoi+0x2a>
    27e6:	0e 94 3c 14 	call	0x2878	; 0x2878 <__mulhi_const_10>
    27ea:	82 0f       	add	r24, r18
    27ec:	91 1d       	adc	r25, r1
    27ee:	21 91       	ld	r18, Z+
    27f0:	20 53       	subi	r18, 0x30	; 48
    27f2:	2a 30       	cpi	r18, 0x0A	; 10
    27f4:	c0 f3       	brcs	.-16     	; 0x27e6 <atoi+0x22>
    27f6:	1e f4       	brtc	.+6      	; 0x27fe <atoi+0x3a>
    27f8:	90 95       	com	r25
    27fa:	81 95       	neg	r24
    27fc:	9f 4f       	sbci	r25, 0xFF	; 255
    27fe:	08 95       	ret

00002800 <strcat>:
    2800:	fb 01       	movw	r30, r22
    2802:	dc 01       	movw	r26, r24
    2804:	0d 90       	ld	r0, X+
    2806:	00 20       	and	r0, r0
    2808:	e9 f7       	brne	.-6      	; 0x2804 <strcat+0x4>
    280a:	11 97       	sbiw	r26, 0x01	; 1
    280c:	01 90       	ld	r0, Z+
    280e:	0d 92       	st	X+, r0
    2810:	00 20       	and	r0, r0
    2812:	e1 f7       	brne	.-8      	; 0x280c <strcat+0xc>
    2814:	08 95       	ret

00002816 <strcmp>:
    2816:	fb 01       	movw	r30, r22
    2818:	dc 01       	movw	r26, r24
    281a:	8d 91       	ld	r24, X+
    281c:	01 90       	ld	r0, Z+
    281e:	80 19       	sub	r24, r0
    2820:	01 10       	cpse	r0, r1
    2822:	d9 f3       	breq	.-10     	; 0x281a <strcmp+0x4>
    2824:	99 0b       	sbc	r25, r25
    2826:	08 95       	ret

00002828 <strcpy>:
    2828:	fb 01       	movw	r30, r22
    282a:	dc 01       	movw	r26, r24
    282c:	01 90       	ld	r0, Z+
    282e:	0d 92       	st	X+, r0
    2830:	00 20       	and	r0, r0
    2832:	e1 f7       	brne	.-8      	; 0x282c <strcpy+0x4>
    2834:	08 95       	ret

00002836 <itoa>:
    2836:	fb 01       	movw	r30, r22
    2838:	9f 01       	movw	r18, r30
    283a:	e8 94       	clt
    283c:	42 30       	cpi	r20, 0x02	; 2
    283e:	c4 f0       	brlt	.+48     	; 0x2870 <itoa+0x3a>
    2840:	45 32       	cpi	r20, 0x25	; 37
    2842:	b4 f4       	brge	.+44     	; 0x2870 <itoa+0x3a>
    2844:	4a 30       	cpi	r20, 0x0A	; 10
    2846:	29 f4       	brne	.+10     	; 0x2852 <itoa+0x1c>
    2848:	97 fb       	bst	r25, 7
    284a:	1e f4       	brtc	.+6      	; 0x2852 <itoa+0x1c>
    284c:	90 95       	com	r25
    284e:	81 95       	neg	r24
    2850:	9f 4f       	sbci	r25, 0xFF	; 255
    2852:	64 2f       	mov	r22, r20
    2854:	77 27       	eor	r23, r23
    2856:	0e 94 c8 13 	call	0x2790	; 0x2790 <__udivmodhi4>
    285a:	80 5d       	subi	r24, 0xD0	; 208
    285c:	8a 33       	cpi	r24, 0x3A	; 58
    285e:	0c f0       	brlt	.+2      	; 0x2862 <itoa+0x2c>
    2860:	89 5d       	subi	r24, 0xD9	; 217
    2862:	81 93       	st	Z+, r24
    2864:	cb 01       	movw	r24, r22
    2866:	00 97       	sbiw	r24, 0x00	; 0
    2868:	a1 f7       	brne	.-24     	; 0x2852 <itoa+0x1c>
    286a:	16 f4       	brtc	.+4      	; 0x2870 <itoa+0x3a>
    286c:	5d e2       	ldi	r21, 0x2D	; 45
    286e:	51 93       	st	Z+, r21
    2870:	10 82       	st	Z, r1
    2872:	c9 01       	movw	r24, r18
    2874:	0c 94 65 14 	jmp	0x28ca	; 0x28ca <strrev>

00002878 <__mulhi_const_10>:
    2878:	7a e0       	ldi	r23, 0x0A	; 10
    287a:	97 9f       	mul	r25, r23
    287c:	90 2d       	mov	r25, r0
    287e:	87 9f       	mul	r24, r23
    2880:	80 2d       	mov	r24, r0
    2882:	91 0d       	add	r25, r1
    2884:	11 24       	eor	r1, r1
    2886:	08 95       	ret

00002888 <__eerd_byte_m324pa>:
    2888:	f9 99       	sbic	0x1f, 1	; 31
    288a:	fe cf       	rjmp	.-4      	; 0x2888 <__eerd_byte_m324pa>
    288c:	92 bd       	out	0x22, r25	; 34
    288e:	81 bd       	out	0x21, r24	; 33
    2890:	f8 9a       	sbi	0x1f, 0	; 31
    2892:	99 27       	eor	r25, r25
    2894:	80 b5       	in	r24, 0x20	; 32
    2896:	08 95       	ret

00002898 <__eerd_word_m324pa>:
    2898:	a8 e1       	ldi	r26, 0x18	; 24
    289a:	b0 e0       	ldi	r27, 0x00	; 0
    289c:	42 e0       	ldi	r20, 0x02	; 2
    289e:	50 e0       	ldi	r21, 0x00	; 0
    28a0:	0c 94 77 14 	jmp	0x28ee	; 0x28ee <__eerd_blraw_m324pa>

000028a4 <__eewr_byte_m324pa>:
    28a4:	26 2f       	mov	r18, r22

000028a6 <__eewr_r18_m324pa>:
    28a6:	f9 99       	sbic	0x1f, 1	; 31
    28a8:	fe cf       	rjmp	.-4      	; 0x28a6 <__eewr_r18_m324pa>
    28aa:	1f ba       	out	0x1f, r1	; 31
    28ac:	92 bd       	out	0x22, r25	; 34
    28ae:	81 bd       	out	0x21, r24	; 33
    28b0:	20 bd       	out	0x20, r18	; 32
    28b2:	0f b6       	in	r0, 0x3f	; 63
    28b4:	f8 94       	cli
    28b6:	fa 9a       	sbi	0x1f, 2	; 31
    28b8:	f9 9a       	sbi	0x1f, 1	; 31
    28ba:	0f be       	out	0x3f, r0	; 63
    28bc:	01 96       	adiw	r24, 0x01	; 1
    28be:	08 95       	ret

000028c0 <__eewr_word_m324pa>:
    28c0:	0e 94 52 14 	call	0x28a4	; 0x28a4 <__eewr_byte_m324pa>
    28c4:	27 2f       	mov	r18, r23
    28c6:	0c 94 53 14 	jmp	0x28a6	; 0x28a6 <__eewr_r18_m324pa>

000028ca <strrev>:
    28ca:	dc 01       	movw	r26, r24
    28cc:	fc 01       	movw	r30, r24
    28ce:	67 2f       	mov	r22, r23
    28d0:	71 91       	ld	r23, Z+
    28d2:	77 23       	and	r23, r23
    28d4:	e1 f7       	brne	.-8      	; 0x28ce <strrev+0x4>
    28d6:	32 97       	sbiw	r30, 0x02	; 2
    28d8:	04 c0       	rjmp	.+8      	; 0x28e2 <strrev+0x18>
    28da:	7c 91       	ld	r23, X
    28dc:	6d 93       	st	X+, r22
    28de:	70 83       	st	Z, r23
    28e0:	62 91       	ld	r22, -Z
    28e2:	ae 17       	cp	r26, r30
    28e4:	bf 07       	cpc	r27, r31
    28e6:	c8 f3       	brcs	.-14     	; 0x28da <strrev+0x10>
    28e8:	08 95       	ret

000028ea <__eerd_block_m324pa>:
    28ea:	dc 01       	movw	r26, r24
    28ec:	cb 01       	movw	r24, r22

000028ee <__eerd_blraw_m324pa>:
    28ee:	fc 01       	movw	r30, r24
    28f0:	f9 99       	sbic	0x1f, 1	; 31
    28f2:	fe cf       	rjmp	.-4      	; 0x28f0 <__eerd_blraw_m324pa+0x2>
    28f4:	06 c0       	rjmp	.+12     	; 0x2902 <__eerd_blraw_m324pa+0x14>
    28f6:	f2 bd       	out	0x22, r31	; 34
    28f8:	e1 bd       	out	0x21, r30	; 33
    28fa:	f8 9a       	sbi	0x1f, 0	; 31
    28fc:	31 96       	adiw	r30, 0x01	; 1
    28fe:	00 b4       	in	r0, 0x20	; 32
    2900:	0d 92       	st	X+, r0
    2902:	41 50       	subi	r20, 0x01	; 1
    2904:	50 40       	sbci	r21, 0x00	; 0
    2906:	b8 f7       	brcc	.-18     	; 0x28f6 <__eerd_blraw_m324pa+0x8>
    2908:	08 95       	ret

0000290a <_exit>:
    290a:	f8 94       	cli

0000290c <__stop_program>:
    290c:	ff cf       	rjmp	.-2      	; 0x290c <__stop_program>
