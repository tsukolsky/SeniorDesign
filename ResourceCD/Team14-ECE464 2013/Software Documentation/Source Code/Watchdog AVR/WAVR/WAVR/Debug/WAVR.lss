
WAVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000e0  00800100  00003bb6  00003c6a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00003bb6  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000049  008001e0  008001e0  00003d4a  2**0
                  ALLOC
  3 .eeprom       00000007  00810000  00810000  00003d4a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         000011f4  00000000  00000000  00003d54  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000005eb  00000000  00000000  00004f48  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_aranges 00000120  00000000  00000000  00005538  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000022c6  00000000  00000000  00005658  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000393  00000000  00000000  0000791e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000fda  00000000  00000000  00007cb1  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008cc  00000000  00000000  00008c8c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000b4b  00000000  00000000  00009558  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001290  00000000  00000000  0000a0a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000030  00000000  00000000  0000b333  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3f 00 	jmp	0x7e	; 0x7e <__ctors_end>
       4:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       8:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
       c:	0c 94 5d 14 	jmp	0x28ba	; 0x28ba <__vector_3>
      10:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      14:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      18:	0c 94 09 14 	jmp	0x2812	; 0x2812 <__vector_6>
      1c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      20:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      24:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      28:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      2c:	0c 94 0d 15 	jmp	0x2a1a	; 0x2a1a <__vector_11>
      30:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      34:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      38:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      3c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      40:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      44:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      48:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      4c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      50:	0c 94 a7 14 	jmp	0x294e	; 0x294e <__vector_20>
      54:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      58:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      5c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      60:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      64:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      68:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      6c:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      70:	0c 94 da 14 	jmp	0x29b4	; 0x29b4 <__vector_28>
      74:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>
      78:	0c 94 67 00 	jmp	0xce	; 0xce <__bad_interrupt>

0000007c <__ctors_start>:
      7c:	cc 1c       	adc	r12, r12

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf ef       	ldi	r28, 0xFF	; 255
      84:	d0 e1       	ldi	r29, 0x10	; 16
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e0       	ldi	r26, 0x00	; 0
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	e6 eb       	ldi	r30, 0xB6	; 182
      92:	fb e3       	ldi	r31, 0x3B	; 59
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	a0 3e       	cpi	r26, 0xE0	; 224
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	12 e0       	ldi	r17, 0x02	; 2
      a2:	a0 ee       	ldi	r26, 0xE0	; 224
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	a9 32       	cpi	r26, 0x29	; 41
      ac:	b1 07       	cpc	r27, r17
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>

000000b0 <__do_global_ctors>:
      b0:	10 e0       	ldi	r17, 0x00	; 0
      b2:	ce e7       	ldi	r28, 0x7E	; 126
      b4:	d0 e0       	ldi	r29, 0x00	; 0
      b6:	04 c0       	rjmp	.+8      	; 0xc0 <__do_global_ctors+0x10>
      b8:	22 97       	sbiw	r28, 0x02	; 2
      ba:	fe 01       	movw	r30, r28
      bc:	0e 94 0e 1d 	call	0x3a1c	; 0x3a1c <__tablejump__>
      c0:	cc 37       	cpi	r28, 0x7C	; 124
      c2:	d1 07       	cpc	r29, r17
      c4:	c9 f7       	brne	.-14     	; 0xb8 <__do_global_ctors+0x8>
      c6:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <main>
      ca:	0c 94 d9 1d 	jmp	0x3bb2	; 0x3bb2 <_exit>

000000ce <__bad_interrupt>:
      ce:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d2 <_ZN6myDateC1Ev>:
		void setYear(int year);
		void addMonths(int months);
		void addYears(int years);
};

myDate::myDate(){
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <_ZN6myDateC1Ev+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
      dc:	9a 83       	std	Y+2, r25	; 0x02
      de:	89 83       	std	Y+1, r24	; 0x01
	month = 0;
      e0:	89 81       	ldd	r24, Y+1	; 0x01
      e2:	9a 81       	ldd	r25, Y+2	; 0x02
      e4:	fc 01       	movw	r30, r24
      e6:	11 82       	std	Z+1, r1	; 0x01
      e8:	10 82       	st	Z, r1
	day = 0;
      ea:	89 81       	ldd	r24, Y+1	; 0x01
      ec:	9a 81       	ldd	r25, Y+2	; 0x02
      ee:	fc 01       	movw	r30, r24
      f0:	13 82       	std	Z+3, r1	; 0x03
      f2:	12 82       	std	Z+2, r1	; 0x02
	year = 0;
      f4:	89 81       	ldd	r24, Y+1	; 0x01
      f6:	9a 81       	ldd	r25, Y+2	; 0x02
      f8:	fc 01       	movw	r30, r24
      fa:	15 82       	std	Z+5, r1	; 0x05
      fc:	14 82       	std	Z+4, r1	; 0x04
}
      fe:	0f 90       	pop	r0
     100:	0f 90       	pop	r0
     102:	df 91       	pop	r29
     104:	cf 91       	pop	r28
     106:	08 95       	ret

00000108 <_ZN6myDateC1Eiii>:

myDate::myDate(int month,int day,int year){
     108:	cf 93       	push	r28
     10a:	df 93       	push	r29
     10c:	cd b7       	in	r28, 0x3d	; 61
     10e:	de b7       	in	r29, 0x3e	; 62
     110:	28 97       	sbiw	r28, 0x08	; 8
     112:	0f b6       	in	r0, 0x3f	; 63
     114:	f8 94       	cli
     116:	de bf       	out	0x3e, r29	; 62
     118:	0f be       	out	0x3f, r0	; 63
     11a:	cd bf       	out	0x3d, r28	; 61
     11c:	9a 83       	std	Y+2, r25	; 0x02
     11e:	89 83       	std	Y+1, r24	; 0x01
     120:	7c 83       	std	Y+4, r23	; 0x04
     122:	6b 83       	std	Y+3, r22	; 0x03
     124:	5e 83       	std	Y+6, r21	; 0x06
     126:	4d 83       	std	Y+5, r20	; 0x05
     128:	38 87       	std	Y+8, r19	; 0x08
     12a:	2f 83       	std	Y+7, r18	; 0x07
	setDate(month,day,year);
     12c:	89 81       	ldd	r24, Y+1	; 0x01
     12e:	9a 81       	ldd	r25, Y+2	; 0x02
     130:	6b 81       	ldd	r22, Y+3	; 0x03
     132:	7c 81       	ldd	r23, Y+4	; 0x04
     134:	4d 81       	ldd	r20, Y+5	; 0x05
     136:	5e 81       	ldd	r21, Y+6	; 0x06
     138:	2f 81       	ldd	r18, Y+7	; 0x07
     13a:	38 85       	ldd	r19, Y+8	; 0x08
     13c:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
}
     140:	28 96       	adiw	r28, 0x08	; 8
     142:	0f b6       	in	r0, 0x3f	; 63
     144:	f8 94       	cli
     146:	de bf       	out	0x3e, r29	; 62
     148:	0f be       	out	0x3f, r0	; 63
     14a:	cd bf       	out	0x3d, r28	; 61
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <_ZN6myDate9getMonthsEv>:

BYTE myDate::getMonths(){
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	00 d0       	rcall	.+0      	; 0x158 <_ZN6myDate9getMonthsEv+0x6>
     158:	cd b7       	in	r28, 0x3d	; 61
     15a:	de b7       	in	r29, 0x3e	; 62
     15c:	9a 83       	std	Y+2, r25	; 0x02
     15e:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)month;
     160:	89 81       	ldd	r24, Y+1	; 0x01
     162:	9a 81       	ldd	r25, Y+2	; 0x02
     164:	fc 01       	movw	r30, r24
     166:	80 81       	ld	r24, Z
     168:	91 81       	ldd	r25, Z+1	; 0x01
}
     16a:	0f 90       	pop	r0
     16c:	0f 90       	pop	r0
     16e:	df 91       	pop	r29
     170:	cf 91       	pop	r28
     172:	08 95       	ret

00000174 <_ZN6myDate8getYearsEv>:

WORD myDate::getYears(){
     174:	cf 93       	push	r28
     176:	df 93       	push	r29
     178:	00 d0       	rcall	.+0      	; 0x17a <_ZN6myDate8getYearsEv+0x6>
     17a:	cd b7       	in	r28, 0x3d	; 61
     17c:	de b7       	in	r29, 0x3e	; 62
     17e:	9a 83       	std	Y+2, r25	; 0x02
     180:	89 83       	std	Y+1, r24	; 0x01
	return (WORD)year;
     182:	89 81       	ldd	r24, Y+1	; 0x01
     184:	9a 81       	ldd	r25, Y+2	; 0x02
     186:	fc 01       	movw	r30, r24
     188:	84 81       	ldd	r24, Z+4	; 0x04
     18a:	95 81       	ldd	r25, Z+5	; 0x05
}
     18c:	0f 90       	pop	r0
     18e:	0f 90       	pop	r0
     190:	df 91       	pop	r29
     192:	cf 91       	pop	r28
     194:	08 95       	ret

00000196 <_ZN6myDate7getDaysEv>:

BYTE myDate::getDays(){
     196:	cf 93       	push	r28
     198:	df 93       	push	r29
     19a:	00 d0       	rcall	.+0      	; 0x19c <_ZN6myDate7getDaysEv+0x6>
     19c:	cd b7       	in	r28, 0x3d	; 61
     19e:	de b7       	in	r29, 0x3e	; 62
     1a0:	9a 83       	std	Y+2, r25	; 0x02
     1a2:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)day;
     1a4:	89 81       	ldd	r24, Y+1	; 0x01
     1a6:	9a 81       	ldd	r25, Y+2	; 0x02
     1a8:	fc 01       	movw	r30, r24
     1aa:	82 81       	ldd	r24, Z+2	; 0x02
     1ac:	93 81       	ldd	r25, Z+3	; 0x03
}
     1ae:	0f 90       	pop	r0
     1b0:	0f 90       	pop	r0
     1b2:	df 91       	pop	r29
     1b4:	cf 91       	pop	r28
     1b6:	08 95       	ret

000001b8 <_ZN6myDate8setMonthEi>:

void myDate::setMonth(int month){
     1b8:	cf 93       	push	r28
     1ba:	df 93       	push	r29
     1bc:	00 d0       	rcall	.+0      	; 0x1be <_ZN6myDate8setMonthEi+0x6>
     1be:	00 d0       	rcall	.+0      	; 0x1c0 <_ZN6myDate8setMonthEi+0x8>
     1c0:	cd b7       	in	r28, 0x3d	; 61
     1c2:	de b7       	in	r29, 0x3e	; 62
     1c4:	9a 83       	std	Y+2, r25	; 0x02
     1c6:	89 83       	std	Y+1, r24	; 0x01
     1c8:	7c 83       	std	Y+4, r23	; 0x04
     1ca:	6b 83       	std	Y+3, r22	; 0x03
	if (month/13 == 0){
     1cc:	8b 81       	ldd	r24, Y+3	; 0x03
     1ce:	9c 81       	ldd	r25, Y+4	; 0x04
     1d0:	0c 96       	adiw	r24, 0x0c	; 12
     1d2:	89 31       	cpi	r24, 0x19	; 25
     1d4:	91 05       	cpc	r25, r1
     1d6:	38 f4       	brcc	.+14     	; 0x1e6 <_ZN6myDate8setMonthEi+0x2e>
		this->month = month;
     1d8:	89 81       	ldd	r24, Y+1	; 0x01
     1da:	9a 81       	ldd	r25, Y+2	; 0x02
     1dc:	2b 81       	ldd	r18, Y+3	; 0x03
     1de:	3c 81       	ldd	r19, Y+4	; 0x04
     1e0:	fc 01       	movw	r30, r24
     1e2:	31 83       	std	Z+1, r19	; 0x01
     1e4:	20 83       	st	Z, r18
	}
}
     1e6:	0f 90       	pop	r0
     1e8:	0f 90       	pop	r0
     1ea:	0f 90       	pop	r0
     1ec:	0f 90       	pop	r0
     1ee:	df 91       	pop	r29
     1f0:	cf 91       	pop	r28
     1f2:	08 95       	ret

000001f4 <_ZN6myDate6setDayEi>:

void myDate::setDay(int day){
     1f4:	cf 93       	push	r28
     1f6:	df 93       	push	r29
     1f8:	00 d0       	rcall	.+0      	; 0x1fa <_ZN6myDate6setDayEi+0x6>
     1fa:	00 d0       	rcall	.+0      	; 0x1fc <_ZN6myDate6setDayEi+0x8>
     1fc:	cd b7       	in	r28, 0x3d	; 61
     1fe:	de b7       	in	r29, 0x3e	; 62
     200:	9a 83       	std	Y+2, r25	; 0x02
     202:	89 83       	std	Y+1, r24	; 0x01
     204:	7c 83       	std	Y+4, r23	; 0x04
     206:	6b 83       	std	Y+3, r22	; 0x03
	if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     208:	89 81       	ldd	r24, Y+1	; 0x01
     20a:	9a 81       	ldd	r25, Y+2	; 0x02
     20c:	fc 01       	movw	r30, r24
     20e:	80 81       	ld	r24, Z
     210:	91 81       	ldd	r25, Z+1	; 0x01
     212:	89 30       	cpi	r24, 0x09	; 9
     214:	91 05       	cpc	r25, r1
     216:	81 f0       	breq	.+32     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     218:	89 81       	ldd	r24, Y+1	; 0x01
     21a:	9a 81       	ldd	r25, Y+2	; 0x02
     21c:	fc 01       	movw	r30, r24
     21e:	80 81       	ld	r24, Z
     220:	91 81       	ldd	r25, Z+1	; 0x01
     222:	84 30       	cpi	r24, 0x04	; 4
     224:	91 05       	cpc	r25, r1
     226:	41 f0       	breq	.+16     	; 0x238 <_ZN6myDate6setDayEi+0x44>
     228:	89 81       	ldd	r24, Y+1	; 0x01
     22a:	9a 81       	ldd	r25, Y+2	; 0x02
     22c:	fc 01       	movw	r30, r24
     22e:	80 81       	ld	r24, Z
     230:	91 81       	ldd	r25, Z+1	; 0x01
     232:	86 30       	cpi	r24, 0x06	; 6
     234:	91 05       	cpc	r25, r1
     236:	41 f4       	brne	.+16     	; 0x248 <_ZN6myDate6setDayEi+0x54>
     238:	8b 81       	ldd	r24, Y+3	; 0x03
     23a:	9c 81       	ldd	r25, Y+4	; 0x04
     23c:	4e 96       	adiw	r24, 0x1e	; 30
     23e:	8d 33       	cpi	r24, 0x3D	; 61
     240:	91 05       	cpc	r25, r1
     242:	10 f4       	brcc	.+4      	; 0x248 <_ZN6myDate6setDayEi+0x54>
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	01 c0       	rjmp	.+2      	; 0x24a <_ZN6myDate6setDayEi+0x56>
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	88 23       	and	r24, r24
     24c:	41 f0       	breq	.+16     	; 0x25e <_ZN6myDate6setDayEi+0x6a>
		this->day = day;
     24e:	89 81       	ldd	r24, Y+1	; 0x01
     250:	9a 81       	ldd	r25, Y+2	; 0x02
     252:	2b 81       	ldd	r18, Y+3	; 0x03
     254:	3c 81       	ldd	r19, Y+4	; 0x04
     256:	fc 01       	movw	r30, r24
     258:	33 83       	std	Z+3, r19	; 0x03
     25a:	22 83       	std	Z+2, r18	; 0x02
     25c:	28 c0       	rjmp	.+80     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else if (month == 2 && day/29 == 0){
     25e:	89 81       	ldd	r24, Y+1	; 0x01
     260:	9a 81       	ldd	r25, Y+2	; 0x02
     262:	fc 01       	movw	r30, r24
     264:	80 81       	ld	r24, Z
     266:	91 81       	ldd	r25, Z+1	; 0x01
     268:	82 30       	cpi	r24, 0x02	; 2
     26a:	91 05       	cpc	r25, r1
     26c:	41 f4       	brne	.+16     	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     26e:	8b 81       	ldd	r24, Y+3	; 0x03
     270:	9c 81       	ldd	r25, Y+4	; 0x04
     272:	4c 96       	adiw	r24, 0x1c	; 28
     274:	89 33       	cpi	r24, 0x39	; 57
     276:	91 05       	cpc	r25, r1
     278:	10 f4       	brcc	.+4      	; 0x27e <_ZN6myDate6setDayEi+0x8a>
     27a:	81 e0       	ldi	r24, 0x01	; 1
     27c:	01 c0       	rjmp	.+2      	; 0x280 <_ZN6myDate6setDayEi+0x8c>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	88 23       	and	r24, r24
     282:	41 f0       	breq	.+16     	; 0x294 <_ZN6myDate6setDayEi+0xa0>
		this->day = day;
     284:	89 81       	ldd	r24, Y+1	; 0x01
     286:	9a 81       	ldd	r25, Y+2	; 0x02
     288:	2b 81       	ldd	r18, Y+3	; 0x03
     28a:	3c 81       	ldd	r19, Y+4	; 0x04
     28c:	fc 01       	movw	r30, r24
     28e:	33 83       	std	Z+3, r19	; 0x03
     290:	22 83       	std	Z+2, r18	; 0x02
     292:	0d c0       	rjmp	.+26     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
	} else{
		if (day/32 == 0){
     294:	8b 81       	ldd	r24, Y+3	; 0x03
     296:	9c 81       	ldd	r25, Y+4	; 0x04
     298:	4f 96       	adiw	r24, 0x1f	; 31
     29a:	8f 33       	cpi	r24, 0x3F	; 63
     29c:	91 05       	cpc	r25, r1
     29e:	38 f4       	brcc	.+14     	; 0x2ae <_ZN6myDate6setDayEi+0xba>
			this->day = day;
     2a0:	89 81       	ldd	r24, Y+1	; 0x01
     2a2:	9a 81       	ldd	r25, Y+2	; 0x02
     2a4:	2b 81       	ldd	r18, Y+3	; 0x03
     2a6:	3c 81       	ldd	r19, Y+4	; 0x04
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 83       	std	Z+3, r19	; 0x03
     2ac:	22 83       	std	Z+2, r18	; 0x02
		}		
	}
}
     2ae:	0f 90       	pop	r0
     2b0:	0f 90       	pop	r0
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	df 91       	pop	r29
     2b8:	cf 91       	pop	r28
     2ba:	08 95       	ret

000002bc <_ZN6myDate7setYearEi>:

void myDate::setYear(int year){
     2bc:	cf 93       	push	r28
     2be:	df 93       	push	r29
     2c0:	00 d0       	rcall	.+0      	; 0x2c2 <_ZN6myDate7setYearEi+0x6>
     2c2:	00 d0       	rcall	.+0      	; 0x2c4 <_ZN6myDate7setYearEi+0x8>
     2c4:	cd b7       	in	r28, 0x3d	; 61
     2c6:	de b7       	in	r29, 0x3e	; 62
     2c8:	9a 83       	std	Y+2, r25	; 0x02
     2ca:	89 83       	std	Y+1, r24	; 0x01
     2cc:	7c 83       	std	Y+4, r23	; 0x04
     2ce:	6b 83       	std	Y+3, r22	; 0x03
	if (year >= 2000){
     2d0:	8b 81       	ldd	r24, Y+3	; 0x03
     2d2:	9c 81       	ldd	r25, Y+4	; 0x04
     2d4:	27 e0       	ldi	r18, 0x07	; 7
     2d6:	80 3d       	cpi	r24, 0xD0	; 208
     2d8:	92 07       	cpc	r25, r18
     2da:	44 f0       	brlt	.+16     	; 0x2ec <_ZN6myDate7setYearEi+0x30>
		this->year = year;
     2dc:	89 81       	ldd	r24, Y+1	; 0x01
     2de:	9a 81       	ldd	r25, Y+2	; 0x02
     2e0:	2b 81       	ldd	r18, Y+3	; 0x03
     2e2:	3c 81       	ldd	r19, Y+4	; 0x04
     2e4:	fc 01       	movw	r30, r24
     2e6:	35 83       	std	Z+5, r19	; 0x05
     2e8:	24 83       	std	Z+4, r18	; 0x04
     2ea:	07 c0       	rjmp	.+14     	; 0x2fa <_ZN6myDate7setYearEi+0x3e>
	} else {
		this->year = 1010;
     2ec:	89 81       	ldd	r24, Y+1	; 0x01
     2ee:	9a 81       	ldd	r25, Y+2	; 0x02
     2f0:	22 ef       	ldi	r18, 0xF2	; 242
     2f2:	33 e0       	ldi	r19, 0x03	; 3
     2f4:	fc 01       	movw	r30, r24
     2f6:	35 83       	std	Z+5, r19	; 0x05
     2f8:	24 83       	std	Z+4, r18	; 0x04
	}	
}
     2fa:	0f 90       	pop	r0
     2fc:	0f 90       	pop	r0
     2fe:	0f 90       	pop	r0
     300:	0f 90       	pop	r0
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	08 95       	ret

00000308 <_ZN6myDate7setDateEiii>:

void myDate::setDate(int month, int day, int year){
     308:	cf 93       	push	r28
     30a:	df 93       	push	r29
     30c:	cd b7       	in	r28, 0x3d	; 61
     30e:	de b7       	in	r29, 0x3e	; 62
     310:	28 97       	sbiw	r28, 0x08	; 8
     312:	0f b6       	in	r0, 0x3f	; 63
     314:	f8 94       	cli
     316:	de bf       	out	0x3e, r29	; 62
     318:	0f be       	out	0x3f, r0	; 63
     31a:	cd bf       	out	0x3d, r28	; 61
     31c:	9a 83       	std	Y+2, r25	; 0x02
     31e:	89 83       	std	Y+1, r24	; 0x01
     320:	7c 83       	std	Y+4, r23	; 0x04
     322:	6b 83       	std	Y+3, r22	; 0x03
     324:	5e 83       	std	Y+6, r21	; 0x06
     326:	4d 83       	std	Y+5, r20	; 0x05
     328:	38 87       	std	Y+8, r19	; 0x08
     32a:	2f 83       	std	Y+7, r18	; 0x07
	setMonth(month);
     32c:	89 81       	ldd	r24, Y+1	; 0x01
     32e:	9a 81       	ldd	r25, Y+2	; 0x02
     330:	2b 81       	ldd	r18, Y+3	; 0x03
     332:	3c 81       	ldd	r19, Y+4	; 0x04
     334:	b9 01       	movw	r22, r18
     336:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN6myDate8setMonthEi>
	setDay(day);
     33a:	89 81       	ldd	r24, Y+1	; 0x01
     33c:	9a 81       	ldd	r25, Y+2	; 0x02
     33e:	2d 81       	ldd	r18, Y+5	; 0x05
     340:	3e 81       	ldd	r19, Y+6	; 0x06
     342:	b9 01       	movw	r22, r18
     344:	0e 94 fa 00 	call	0x1f4	; 0x1f4 <_ZN6myDate6setDayEi>
	setYear(year);
     348:	89 81       	ldd	r24, Y+1	; 0x01
     34a:	9a 81       	ldd	r25, Y+2	; 0x02
     34c:	2f 81       	ldd	r18, Y+7	; 0x07
     34e:	38 85       	ldd	r19, Y+8	; 0x08
     350:	b9 01       	movw	r22, r18
     352:	0e 94 5e 01 	call	0x2bc	; 0x2bc <_ZN6myDate7setYearEi>
}
     356:	28 96       	adiw	r28, 0x08	; 8
     358:	0f b6       	in	r0, 0x3f	; 63
     35a:	f8 94       	cli
     35c:	de bf       	out	0x3e, r29	; 62
     35e:	0f be       	out	0x3f, r0	; 63
     360:	cd bf       	out	0x3d, r28	; 61
     362:	df 91       	pop	r29
     364:	cf 91       	pop	r28
     366:	08 95       	ret

00000368 <_ZN6myDate8addYearsEi>:


void myDate::addYears(int years){	//allows negative years to come in, therefore subtracting years
     368:	cf 93       	push	r28
     36a:	df 93       	push	r29
     36c:	00 d0       	rcall	.+0      	; 0x36e <_ZN6myDate8addYearsEi+0x6>
     36e:	00 d0       	rcall	.+0      	; 0x370 <_ZN6myDate8addYearsEi+0x8>
     370:	00 d0       	rcall	.+0      	; 0x372 <_ZN6myDate8addYearsEi+0xa>
     372:	cd b7       	in	r28, 0x3d	; 61
     374:	de b7       	in	r29, 0x3e	; 62
     376:	9c 83       	std	Y+4, r25	; 0x04
     378:	8b 83       	std	Y+3, r24	; 0x03
     37a:	7e 83       	std	Y+6, r23	; 0x06
     37c:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempYears = year + years;
     37e:	8b 81       	ldd	r24, Y+3	; 0x03
     380:	9c 81       	ldd	r25, Y+4	; 0x04
     382:	fc 01       	movw	r30, r24
     384:	24 81       	ldd	r18, Z+4	; 0x04
     386:	35 81       	ldd	r19, Z+5	; 0x05
     388:	8d 81       	ldd	r24, Y+5	; 0x05
     38a:	9e 81       	ldd	r25, Y+6	; 0x06
     38c:	82 0f       	add	r24, r18
     38e:	93 1f       	adc	r25, r19
     390:	9a 83       	std	Y+2, r25	; 0x02
     392:	89 83       	std	Y+1, r24	; 0x01
	if (tempYears > 2012){
     394:	89 81       	ldd	r24, Y+1	; 0x01
     396:	9a 81       	ldd	r25, Y+2	; 0x02
     398:	21 e0       	ldi	r18, 0x01	; 1
     39a:	f7 e0       	ldi	r31, 0x07	; 7
     39c:	8d 3d       	cpi	r24, 0xDD	; 221
     39e:	9f 07       	cpc	r25, r31
     3a0:	0c f4       	brge	.+2      	; 0x3a4 <_ZN6myDate8addYearsEi+0x3c>
     3a2:	20 e0       	ldi	r18, 0x00	; 0
     3a4:	22 23       	and	r18, r18
     3a6:	39 f0       	breq	.+14     	; 0x3b6 <_ZN6myDate8addYearsEi+0x4e>
		year = tempYears;
     3a8:	29 81       	ldd	r18, Y+1	; 0x01
     3aa:	3a 81       	ldd	r19, Y+2	; 0x02
     3ac:	8b 81       	ldd	r24, Y+3	; 0x03
     3ae:	9c 81       	ldd	r25, Y+4	; 0x04
     3b0:	fc 01       	movw	r30, r24
     3b2:	35 83       	std	Z+5, r19	; 0x05
     3b4:	24 83       	std	Z+4, r18	; 0x04
	}
}
     3b6:	26 96       	adiw	r28, 0x06	; 6
     3b8:	0f b6       	in	r0, 0x3f	; 63
     3ba:	f8 94       	cli
     3bc:	de bf       	out	0x3e, r29	; 62
     3be:	0f be       	out	0x3f, r0	; 63
     3c0:	cd bf       	out	0x3d, r28	; 61
     3c2:	df 91       	pop	r29
     3c4:	cf 91       	pop	r28
     3c6:	08 95       	ret

000003c8 <_ZN6myDate9addMonthsEi>:

void myDate::addMonths(int months){	//adds months depending on number of months currently on.
     3c8:	cf 93       	push	r28
     3ca:	df 93       	push	r29
     3cc:	cd b7       	in	r28, 0x3d	; 61
     3ce:	de b7       	in	r29, 0x3e	; 62
     3d0:	2a 97       	sbiw	r28, 0x0a	; 10
     3d2:	0f b6       	in	r0, 0x3f	; 63
     3d4:	f8 94       	cli
     3d6:	de bf       	out	0x3e, r29	; 62
     3d8:	0f be       	out	0x3f, r0	; 63
     3da:	cd bf       	out	0x3d, r28	; 61
     3dc:	98 87       	std	Y+8, r25	; 0x08
     3de:	8f 83       	std	Y+7, r24	; 0x07
     3e0:	7a 87       	std	Y+10, r23	; 0x0a
     3e2:	69 87       	std	Y+9, r22	; 0x09
	volatile int tempMonths = month + months;
     3e4:	8f 81       	ldd	r24, Y+7	; 0x07
     3e6:	98 85       	ldd	r25, Y+8	; 0x08
     3e8:	fc 01       	movw	r30, r24
     3ea:	20 81       	ld	r18, Z
     3ec:	31 81       	ldd	r19, Z+1	; 0x01
     3ee:	89 85       	ldd	r24, Y+9	; 0x09
     3f0:	9a 85       	ldd	r25, Y+10	; 0x0a
     3f2:	82 0f       	add	r24, r18
     3f4:	93 1f       	adc	r25, r19
     3f6:	9e 83       	std	Y+6, r25	; 0x06
     3f8:	8d 83       	std	Y+5, r24	; 0x05
	if (tempMonths > 12 && tempMonths < 25){
     3fa:	8d 81       	ldd	r24, Y+5	; 0x05
     3fc:	9e 81       	ldd	r25, Y+6	; 0x06
     3fe:	8d 30       	cpi	r24, 0x0D	; 13
     400:	91 05       	cpc	r25, r1
     402:	3c f0       	brlt	.+14     	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     404:	8d 81       	ldd	r24, Y+5	; 0x05
     406:	9e 81       	ldd	r25, Y+6	; 0x06
     408:	89 31       	cpi	r24, 0x19	; 25
     40a:	91 05       	cpc	r25, r1
     40c:	14 f4       	brge	.+4      	; 0x412 <_ZN6myDate9addMonthsEi+0x4a>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <_ZN6myDate9addMonthsEi+0x4c>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	88 23       	and	r24, r24
     416:	61 f0       	breq	.+24     	; 0x430 <_ZN6myDate9addMonthsEi+0x68>
		int yearsToAdd = 1;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	9a 83       	std	Y+2, r25	; 0x02
     41e:	89 83       	std	Y+1, r24	; 0x01
		addYears(yearsToAdd);
     420:	8f 81       	ldd	r24, Y+7	; 0x07
     422:	98 85       	ldd	r25, Y+8	; 0x08
     424:	29 81       	ldd	r18, Y+1	; 0x01
     426:	3a 81       	ldd	r19, Y+2	; 0x02
     428:	b9 01       	movw	r22, r18
     42a:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     42e:	22 c0       	rjmp	.+68     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else if (tempMonths >= 25){
     430:	8d 81       	ldd	r24, Y+5	; 0x05
     432:	9e 81       	ldd	r25, Y+6	; 0x06
     434:	21 e0       	ldi	r18, 0x01	; 1
     436:	89 31       	cpi	r24, 0x19	; 25
     438:	91 05       	cpc	r25, r1
     43a:	0c f4       	brge	.+2      	; 0x43e <_ZN6myDate9addMonthsEi+0x76>
     43c:	20 e0       	ldi	r18, 0x00	; 0
     43e:	22 23       	and	r18, r18
     440:	91 f0       	breq	.+36     	; 0x466 <_ZN6myDate9addMonthsEi+0x9e>
		int yearsToAdd = tempMonths/12;
     442:	8d 81       	ldd	r24, Y+5	; 0x05
     444:	9e 81       	ldd	r25, Y+6	; 0x06
     446:	2c e0       	ldi	r18, 0x0C	; 12
     448:	30 e0       	ldi	r19, 0x00	; 0
     44a:	b9 01       	movw	r22, r18
     44c:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     450:	9b 01       	movw	r18, r22
     452:	3c 83       	std	Y+4, r19	; 0x04
     454:	2b 83       	std	Y+3, r18	; 0x03
		addYears(yearsToAdd);
     456:	8f 81       	ldd	r24, Y+7	; 0x07
     458:	98 85       	ldd	r25, Y+8	; 0x08
     45a:	2b 81       	ldd	r18, Y+3	; 0x03
     45c:	3c 81       	ldd	r19, Y+4	; 0x04
     45e:	b9 01       	movw	r22, r18
     460:	0e 94 b4 01 	call	0x368	; 0x368 <_ZN6myDate8addYearsEi>
     464:	07 c0       	rjmp	.+14     	; 0x474 <_ZN6myDate9addMonthsEi+0xac>
	} else {
		month = tempMonths;
     466:	2d 81       	ldd	r18, Y+5	; 0x05
     468:	3e 81       	ldd	r19, Y+6	; 0x06
     46a:	8f 81       	ldd	r24, Y+7	; 0x07
     46c:	98 85       	ldd	r25, Y+8	; 0x08
     46e:	fc 01       	movw	r30, r24
     470:	31 83       	std	Z+1, r19	; 0x01
     472:	20 83       	st	Z, r18
	}	
}
     474:	2a 96       	adiw	r28, 0x0a	; 10
     476:	0f b6       	in	r0, 0x3f	; 63
     478:	f8 94       	cli
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	0f be       	out	0x3f, r0	; 63
     47e:	cd bf       	out	0x3d, r28	; 61
     480:	df 91       	pop	r29
     482:	cf 91       	pop	r28
     484:	08 95       	ret

00000486 <_ZN6myDate7addDaysEi>:

void myDate::addDays(int days){
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	00 d0       	rcall	.+0      	; 0x48c <_ZN6myDate7addDaysEi+0x6>
     48c:	00 d0       	rcall	.+0      	; 0x48e <_ZN6myDate7addDaysEi+0x8>
     48e:	00 d0       	rcall	.+0      	; 0x490 <_ZN6myDate7addDaysEi+0xa>
     490:	cd b7       	in	r28, 0x3d	; 61
     492:	de b7       	in	r29, 0x3e	; 62
     494:	9c 83       	std	Y+4, r25	; 0x04
     496:	8b 83       	std	Y+3, r24	; 0x03
     498:	7e 83       	std	Y+6, r23	; 0x06
     49a:	6d 83       	std	Y+5, r22	; 0x05
	volatile int tempDays = days + day;
     49c:	8b 81       	ldd	r24, Y+3	; 0x03
     49e:	9c 81       	ldd	r25, Y+4	; 0x04
     4a0:	fc 01       	movw	r30, r24
     4a2:	22 81       	ldd	r18, Z+2	; 0x02
     4a4:	33 81       	ldd	r19, Z+3	; 0x03
     4a6:	8d 81       	ldd	r24, Y+5	; 0x05
     4a8:	9e 81       	ldd	r25, Y+6	; 0x06
     4aa:	82 0f       	add	r24, r18
     4ac:	93 1f       	adc	r25, r19
     4ae:	9a 83       	std	Y+2, r25	; 0x02
     4b0:	89 83       	std	Y+1, r24	; 0x01
	//Logic for incrementing days the right way. We are assuming no more than one month will be added
	if (month == 9 || month == 4 || month == 6){	//30 days in a month
     4b2:	8b 81       	ldd	r24, Y+3	; 0x03
     4b4:	9c 81       	ldd	r25, Y+4	; 0x04
     4b6:	fc 01       	movw	r30, r24
     4b8:	80 81       	ld	r24, Z
     4ba:	91 81       	ldd	r25, Z+1	; 0x01
     4bc:	89 30       	cpi	r24, 0x09	; 9
     4be:	91 05       	cpc	r25, r1
     4c0:	81 f0       	breq	.+32     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4c2:	8b 81       	ldd	r24, Y+3	; 0x03
     4c4:	9c 81       	ldd	r25, Y+4	; 0x04
     4c6:	fc 01       	movw	r30, r24
     4c8:	80 81       	ld	r24, Z
     4ca:	91 81       	ldd	r25, Z+1	; 0x01
     4cc:	84 30       	cpi	r24, 0x04	; 4
     4ce:	91 05       	cpc	r25, r1
     4d0:	41 f0       	breq	.+16     	; 0x4e2 <_ZN6myDate7addDaysEi+0x5c>
     4d2:	8b 81       	ldd	r24, Y+3	; 0x03
     4d4:	9c 81       	ldd	r25, Y+4	; 0x04
     4d6:	fc 01       	movw	r30, r24
     4d8:	80 81       	ld	r24, Z
     4da:	91 81       	ldd	r25, Z+1	; 0x01
     4dc:	86 30       	cpi	r24, 0x06	; 6
     4de:	91 05       	cpc	r25, r1
     4e0:	11 f4       	brne	.+4      	; 0x4e6 <_ZN6myDate7addDaysEi+0x60>
     4e2:	81 e0       	ldi	r24, 0x01	; 1
     4e4:	01 c0       	rjmp	.+2      	; 0x4e8 <_ZN6myDate7addDaysEi+0x62>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	88 23       	and	r24, r24
     4ea:	31 f1       	breq	.+76     	; 0x538 <_ZN6myDate7addDaysEi+0xb2>
		if (tempDays/31 == 0){	
     4ec:	89 81       	ldd	r24, Y+1	; 0x01
     4ee:	9a 81       	ldd	r25, Y+2	; 0x02
     4f0:	4e 96       	adiw	r24, 0x1e	; 30
     4f2:	21 e0       	ldi	r18, 0x01	; 1
     4f4:	8d 33       	cpi	r24, 0x3D	; 61
     4f6:	91 05       	cpc	r25, r1
     4f8:	08 f0       	brcs	.+2      	; 0x4fc <_ZN6myDate7addDaysEi+0x76>
     4fa:	20 e0       	ldi	r18, 0x00	; 0
     4fc:	22 23       	and	r18, r18
     4fe:	41 f0       	breq	.+16     	; 0x510 <_ZN6myDate7addDaysEi+0x8a>
			day = tempDays;
     500:	29 81       	ldd	r18, Y+1	; 0x01
     502:	3a 81       	ldd	r19, Y+2	; 0x02
     504:	8b 81       	ldd	r24, Y+3	; 0x03
     506:	9c 81       	ldd	r25, Y+4	; 0x04
     508:	fc 01       	movw	r30, r24
     50a:	33 83       	std	Z+3, r19	; 0x03
     50c:	22 83       	std	Z+2, r18	; 0x02
     50e:	71 c0       	rjmp	.+226    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);	//just add 1 month
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	61 e0       	ldi	r22, 0x01	; 1
     516:	70 e0       	ldi	r23, 0x00	; 0
     518:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%31;			
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	9a 81       	ldd	r25, Y+2	; 0x02
     520:	2f e1       	ldi	r18, 0x1F	; 31
     522:	30 e0       	ldi	r19, 0x00	; 0
     524:	b9 01       	movw	r22, r18
     526:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     52a:	9c 01       	movw	r18, r24
     52c:	8b 81       	ldd	r24, Y+3	; 0x03
     52e:	9c 81       	ldd	r25, Y+4	; 0x04
     530:	fc 01       	movw	r30, r24
     532:	33 83       	std	Z+3, r19	; 0x03
     534:	22 83       	std	Z+2, r18	; 0x02
     536:	5d c0       	rjmp	.+186    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}
	} else if (month == 2){
     538:	8b 81       	ldd	r24, Y+3	; 0x03
     53a:	9c 81       	ldd	r25, Y+4	; 0x04
     53c:	fc 01       	movw	r30, r24
     53e:	80 81       	ld	r24, Z
     540:	91 81       	ldd	r25, Z+1	; 0x01
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	82 30       	cpi	r24, 0x02	; 2
     546:	91 05       	cpc	r25, r1
     548:	09 f0       	breq	.+2      	; 0x54c <_ZN6myDate7addDaysEi+0xc6>
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	22 23       	and	r18, r18
     54e:	49 f1       	breq	.+82     	; 0x5a2 <_ZN6myDate7addDaysEi+0x11c>
		if(day/29 == 0){		//Don't take into account LeapYear
     550:	8b 81       	ldd	r24, Y+3	; 0x03
     552:	9c 81       	ldd	r25, Y+4	; 0x04
     554:	fc 01       	movw	r30, r24
     556:	82 81       	ldd	r24, Z+2	; 0x02
     558:	93 81       	ldd	r25, Z+3	; 0x03
     55a:	4c 96       	adiw	r24, 0x1c	; 28
     55c:	21 e0       	ldi	r18, 0x01	; 1
     55e:	89 33       	cpi	r24, 0x39	; 57
     560:	91 05       	cpc	r25, r1
     562:	08 f0       	brcs	.+2      	; 0x566 <_ZN6myDate7addDaysEi+0xe0>
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	22 23       	and	r18, r18
     568:	41 f0       	breq	.+16     	; 0x57a <_ZN6myDate7addDaysEi+0xf4>
			day = tempDays;
     56a:	29 81       	ldd	r18, Y+1	; 0x01
     56c:	3a 81       	ldd	r19, Y+2	; 0x02
     56e:	8b 81       	ldd	r24, Y+3	; 0x03
     570:	9c 81       	ldd	r25, Y+4	; 0x04
     572:	fc 01       	movw	r30, r24
     574:	33 83       	std	Z+3, r19	; 0x03
     576:	22 83       	std	Z+2, r18	; 0x02
     578:	3c c0       	rjmp	.+120    	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     57a:	8b 81       	ldd	r24, Y+3	; 0x03
     57c:	9c 81       	ldd	r25, Y+4	; 0x04
     57e:	61 e0       	ldi	r22, 0x01	; 1
     580:	70 e0       	ldi	r23, 0x00	; 0
     582:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%29;
     586:	89 81       	ldd	r24, Y+1	; 0x01
     588:	9a 81       	ldd	r25, Y+2	; 0x02
     58a:	2d e1       	ldi	r18, 0x1D	; 29
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	b9 01       	movw	r22, r18
     590:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     594:	9c 01       	movw	r18, r24
     596:	8b 81       	ldd	r24, Y+3	; 0x03
     598:	9c 81       	ldd	r25, Y+4	; 0x04
     59a:	fc 01       	movw	r30, r24
     59c:	33 83       	std	Z+3, r19	; 0x03
     59e:	22 83       	std	Z+2, r18	; 0x02
     5a0:	28 c0       	rjmp	.+80     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		}		
	} else {
		if (day/32 == 0){
     5a2:	8b 81       	ldd	r24, Y+3	; 0x03
     5a4:	9c 81       	ldd	r25, Y+4	; 0x04
     5a6:	fc 01       	movw	r30, r24
     5a8:	82 81       	ldd	r24, Z+2	; 0x02
     5aa:	93 81       	ldd	r25, Z+3	; 0x03
     5ac:	4f 96       	adiw	r24, 0x1f	; 31
     5ae:	21 e0       	ldi	r18, 0x01	; 1
     5b0:	8f 33       	cpi	r24, 0x3F	; 63
     5b2:	91 05       	cpc	r25, r1
     5b4:	08 f0       	brcs	.+2      	; 0x5b8 <_ZN6myDate7addDaysEi+0x132>
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	22 23       	and	r18, r18
     5ba:	41 f0       	breq	.+16     	; 0x5cc <_ZN6myDate7addDaysEi+0x146>
			day = tempDays;
     5bc:	29 81       	ldd	r18, Y+1	; 0x01
     5be:	3a 81       	ldd	r19, Y+2	; 0x02
     5c0:	8b 81       	ldd	r24, Y+3	; 0x03
     5c2:	9c 81       	ldd	r25, Y+4	; 0x04
     5c4:	fc 01       	movw	r30, r24
     5c6:	33 83       	std	Z+3, r19	; 0x03
     5c8:	22 83       	std	Z+2, r18	; 0x02
     5ca:	13 c0       	rjmp	.+38     	; 0x5f2 <_ZN6myDate7addDaysEi+0x16c>
		} else {
			addMonths(1);
     5cc:	8b 81       	ldd	r24, Y+3	; 0x03
     5ce:	9c 81       	ldd	r25, Y+4	; 0x04
     5d0:	61 e0       	ldi	r22, 0x01	; 1
     5d2:	70 e0       	ldi	r23, 0x00	; 0
     5d4:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <_ZN6myDate9addMonthsEi>
			day = tempDays%32;
     5d8:	89 81       	ldd	r24, Y+1	; 0x01
     5da:	9a 81       	ldd	r25, Y+2	; 0x02
     5dc:	20 e2       	ldi	r18, 0x20	; 32
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	b9 01       	movw	r22, r18
     5e2:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     5e6:	9c 01       	movw	r18, r24
     5e8:	8b 81       	ldd	r24, Y+3	; 0x03
     5ea:	9c 81       	ldd	r25, Y+4	; 0x04
     5ec:	fc 01       	movw	r30, r24
     5ee:	33 83       	std	Z+3, r19	; 0x03
     5f0:	22 83       	std	Z+2, r18	; 0x02
		}
	}
}
     5f2:	26 96       	adiw	r28, 0x06	; 6
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	df 91       	pop	r29
     600:	cf 91       	pop	r28
     602:	08 95       	ret

00000604 <_ZN6myDate17checkValidityDateEv>:

BOOL myDate::checkValidityDate(){
     604:	cf 93       	push	r28
     606:	df 93       	push	r29
     608:	00 d0       	rcall	.+0      	; 0x60a <_ZN6myDate17checkValidityDateEv+0x6>
     60a:	0f 92       	push	r0
     60c:	cd b7       	in	r28, 0x3d	; 61
     60e:	de b7       	in	r29, 0x3e	; 62
     610:	9b 83       	std	Y+3, r25	; 0x03
     612:	8a 83       	std	Y+2, r24	; 0x02
	BOOL checkYear=fFalse;
     614:	19 82       	std	Y+1, r1	; 0x01
	if (month/13==0){
     616:	8a 81       	ldd	r24, Y+2	; 0x02
     618:	9b 81       	ldd	r25, Y+3	; 0x03
     61a:	fc 01       	movw	r30, r24
     61c:	80 81       	ld	r24, Z
     61e:	91 81       	ldd	r25, Z+1	; 0x01
     620:	0c 96       	adiw	r24, 0x0c	; 12
     622:	21 e0       	ldi	r18, 0x01	; 1
     624:	89 31       	cpi	r24, 0x19	; 25
     626:	91 05       	cpc	r25, r1
     628:	08 f0       	brcs	.+2      	; 0x62c <_ZN6myDate17checkValidityDateEv+0x28>
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	22 23       	and	r18, r18
     62e:	09 f4       	brne	.+2      	; 0x632 <_ZN6myDate17checkValidityDateEv+0x2e>
     630:	66 c0       	rjmp	.+204    	; 0x6fe <_ZN6myDate17checkValidityDateEv+0xfa>
			if ((month == 9 || month == 4 || month == 6) && day/31 == 0){
     632:	8a 81       	ldd	r24, Y+2	; 0x02
     634:	9b 81       	ldd	r25, Y+3	; 0x03
     636:	fc 01       	movw	r30, r24
     638:	80 81       	ld	r24, Z
     63a:	91 81       	ldd	r25, Z+1	; 0x01
     63c:	89 30       	cpi	r24, 0x09	; 9
     63e:	91 05       	cpc	r25, r1
     640:	81 f0       	breq	.+32     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     642:	8a 81       	ldd	r24, Y+2	; 0x02
     644:	9b 81       	ldd	r25, Y+3	; 0x03
     646:	fc 01       	movw	r30, r24
     648:	80 81       	ld	r24, Z
     64a:	91 81       	ldd	r25, Z+1	; 0x01
     64c:	84 30       	cpi	r24, 0x04	; 4
     64e:	91 05       	cpc	r25, r1
     650:	41 f0       	breq	.+16     	; 0x662 <_ZN6myDate17checkValidityDateEv+0x5e>
     652:	8a 81       	ldd	r24, Y+2	; 0x02
     654:	9b 81       	ldd	r25, Y+3	; 0x03
     656:	fc 01       	movw	r30, r24
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	86 30       	cpi	r24, 0x06	; 6
     65e:	91 05       	cpc	r25, r1
     660:	59 f4       	brne	.+22     	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     662:	8a 81       	ldd	r24, Y+2	; 0x02
     664:	9b 81       	ldd	r25, Y+3	; 0x03
     666:	fc 01       	movw	r30, r24
     668:	82 81       	ldd	r24, Z+2	; 0x02
     66a:	93 81       	ldd	r25, Z+3	; 0x03
     66c:	4e 96       	adiw	r24, 0x1e	; 30
     66e:	8d 33       	cpi	r24, 0x3D	; 61
     670:	91 05       	cpc	r25, r1
     672:	10 f4       	brcc	.+4      	; 0x678 <_ZN6myDate17checkValidityDateEv+0x74>
     674:	81 e0       	ldi	r24, 0x01	; 1
     676:	01 c0       	rjmp	.+2      	; 0x67a <_ZN6myDate17checkValidityDateEv+0x76>
     678:	80 e0       	ldi	r24, 0x00	; 0
     67a:	88 23       	and	r24, r24
     67c:	19 f0       	breq	.+6      	; 0x684 <_ZN6myDate17checkValidityDateEv+0x80>
				checkYear=fTrue;
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	89 83       	std	Y+1, r24	; 0x01
     682:	28 c0       	rjmp	.+80     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else if (month == 2 && day/29 == 0){
     684:	8a 81       	ldd	r24, Y+2	; 0x02
     686:	9b 81       	ldd	r25, Y+3	; 0x03
     688:	fc 01       	movw	r30, r24
     68a:	80 81       	ld	r24, Z
     68c:	91 81       	ldd	r25, Z+1	; 0x01
     68e:	82 30       	cpi	r24, 0x02	; 2
     690:	91 05       	cpc	r25, r1
     692:	59 f4       	brne	.+22     	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     694:	8a 81       	ldd	r24, Y+2	; 0x02
     696:	9b 81       	ldd	r25, Y+3	; 0x03
     698:	fc 01       	movw	r30, r24
     69a:	82 81       	ldd	r24, Z+2	; 0x02
     69c:	93 81       	ldd	r25, Z+3	; 0x03
     69e:	4c 96       	adiw	r24, 0x1c	; 28
     6a0:	89 33       	cpi	r24, 0x39	; 57
     6a2:	91 05       	cpc	r25, r1
     6a4:	10 f4       	brcc	.+4      	; 0x6aa <_ZN6myDate17checkValidityDateEv+0xa6>
     6a6:	81 e0       	ldi	r24, 0x01	; 1
     6a8:	01 c0       	rjmp	.+2      	; 0x6ac <_ZN6myDate17checkValidityDateEv+0xa8>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	88 23       	and	r24, r24
     6ae:	19 f0       	breq	.+6      	; 0x6b6 <_ZN6myDate17checkValidityDateEv+0xb2>
				checkYear=fTrue;
     6b0:	81 e0       	ldi	r24, 0x01	; 1
     6b2:	89 83       	std	Y+1, r24	; 0x01
     6b4:	0f c0       	rjmp	.+30     	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
			} else{
				if (day/32 == 0){
     6b6:	8a 81       	ldd	r24, Y+2	; 0x02
     6b8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ba:	fc 01       	movw	r30, r24
     6bc:	82 81       	ldd	r24, Z+2	; 0x02
     6be:	93 81       	ldd	r25, Z+3	; 0x03
     6c0:	4f 96       	adiw	r24, 0x1f	; 31
     6c2:	21 e0       	ldi	r18, 0x01	; 1
     6c4:	8f 33       	cpi	r24, 0x3F	; 63
     6c6:	91 05       	cpc	r25, r1
     6c8:	08 f0       	brcs	.+2      	; 0x6cc <_ZN6myDate17checkValidityDateEv+0xc8>
     6ca:	20 e0       	ldi	r18, 0x00	; 0
     6cc:	22 23       	and	r18, r18
     6ce:	11 f0       	breq	.+4      	; 0x6d4 <_ZN6myDate17checkValidityDateEv+0xd0>
					checkYear=fTrue;
     6d0:	81 e0       	ldi	r24, 0x01	; 1
     6d2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
			
			//Check year
			if (checkYear && year>=2013){return fTrue;}
     6d4:	89 81       	ldd	r24, Y+1	; 0x01
     6d6:	88 23       	and	r24, r24
     6d8:	59 f0       	breq	.+22     	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6da:	8a 81       	ldd	r24, Y+2	; 0x02
     6dc:	9b 81       	ldd	r25, Y+3	; 0x03
     6de:	fc 01       	movw	r30, r24
     6e0:	84 81       	ldd	r24, Z+4	; 0x04
     6e2:	95 81       	ldd	r25, Z+5	; 0x05
     6e4:	f7 e0       	ldi	r31, 0x07	; 7
     6e6:	8d 3d       	cpi	r24, 0xDD	; 221
     6e8:	9f 07       	cpc	r25, r31
     6ea:	14 f0       	brlt	.+4      	; 0x6f0 <_ZN6myDate17checkValidityDateEv+0xec>
     6ec:	81 e0       	ldi	r24, 0x01	; 1
     6ee:	01 c0       	rjmp	.+2      	; 0x6f2 <_ZN6myDate17checkValidityDateEv+0xee>
     6f0:	80 e0       	ldi	r24, 0x00	; 0
     6f2:	88 23       	and	r24, r24
     6f4:	11 f0       	breq	.+4      	; 0x6fa <_ZN6myDate17checkValidityDateEv+0xf6>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	03 c0       	rjmp	.+6      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
			else {return fFalse;}
     6fa:	80 e0       	ldi	r24, 0x00	; 0
     6fc:	01 c0       	rjmp	.+2      	; 0x700 <_ZN6myDate17checkValidityDateEv+0xfc>
	} else {return fFalse;}
     6fe:	80 e0       	ldi	r24, 0x00	; 0
}
     700:	0f 90       	pop	r0
     702:	0f 90       	pop	r0
     704:	0f 90       	pop	r0
     706:	df 91       	pop	r29
     708:	cf 91       	pop	r28
     70a:	08 95       	ret

0000070c <_ZN6myDate7getDateEv>:

const char * myDate::getDate(){
     70c:	cf 93       	push	r28
     70e:	df 93       	push	r29
     710:	cd b7       	in	r28, 0x3d	; 61
     712:	de b7       	in	r29, 0x3e	; 62
     714:	2d 97       	sbiw	r28, 0x0d	; 13
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	f8 94       	cli
     71a:	de bf       	out	0x3e, r29	; 62
     71c:	0f be       	out	0x3f, r0	; 63
     71e:	cd bf       	out	0x3d, r28	; 61
     720:	9d 87       	std	Y+13, r25	; 0x0d
     722:	8c 87       	std	Y+12, r24	; 0x0c
	char monthString[3],dayString[3],yearString[5];
	itoa(month,monthString,10);
     724:	8c 85       	ldd	r24, Y+12	; 0x0c
     726:	9d 85       	ldd	r25, Y+13	; 0x0d
     728:	fc 01       	movw	r30, r24
     72a:	80 81       	ld	r24, Z
     72c:	91 81       	ldd	r25, Z+1	; 0x01
     72e:	9e 01       	movw	r18, r28
     730:	2f 5f       	subi	r18, 0xFF	; 255
     732:	3f 4f       	sbci	r19, 0xFF	; 255
     734:	b9 01       	movw	r22, r18
     736:	4a e0       	ldi	r20, 0x0A	; 10
     738:	50 e0       	ldi	r21, 0x00	; 0
     73a:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <itoa>
	itoa(day,dayString,10);
     73e:	8c 85       	ldd	r24, Y+12	; 0x0c
     740:	9d 85       	ldd	r25, Y+13	; 0x0d
     742:	fc 01       	movw	r30, r24
     744:	82 81       	ldd	r24, Z+2	; 0x02
     746:	93 81       	ldd	r25, Z+3	; 0x03
     748:	9e 01       	movw	r18, r28
     74a:	2c 5f       	subi	r18, 0xFC	; 252
     74c:	3f 4f       	sbci	r19, 0xFF	; 255
     74e:	b9 01       	movw	r22, r18
     750:	4a e0       	ldi	r20, 0x0A	; 10
     752:	50 e0       	ldi	r21, 0x00	; 0
     754:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <itoa>
	itoa(year,yearString,10);
     758:	8c 85       	ldd	r24, Y+12	; 0x0c
     75a:	9d 85       	ldd	r25, Y+13	; 0x0d
     75c:	fc 01       	movw	r30, r24
     75e:	84 81       	ldd	r24, Z+4	; 0x04
     760:	95 81       	ldd	r25, Z+5	; 0x05
     762:	9e 01       	movw	r18, r28
     764:	29 5f       	subi	r18, 0xF9	; 249
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	b9 01       	movw	r22, r18
     76a:	4a e0       	ldi	r20, 0x0A	; 10
     76c:	50 e0       	ldi	r21, 0x00	; 0
     76e:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <itoa>
	strcpy(dateString,monthString);
     772:	8c 85       	ldd	r24, Y+12	; 0x0c
     774:	9d 85       	ldd	r25, Y+13	; 0x0d
     776:	06 96       	adiw	r24, 0x06	; 6
     778:	9e 01       	movw	r18, r28
     77a:	2f 5f       	subi	r18, 0xFF	; 255
     77c:	3f 4f       	sbci	r19, 0xFF	; 255
     77e:	b9 01       	movw	r22, r18
     780:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <strcpy>
	strcat(dateString,",");
     784:	8c 85       	ldd	r24, Y+12	; 0x0c
     786:	9d 85       	ldd	r25, Y+13	; 0x0d
     788:	9c 01       	movw	r18, r24
     78a:	2a 5f       	subi	r18, 0xFA	; 250
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	c9 01       	movw	r24, r18
     790:	ac 01       	movw	r20, r24
     792:	fa 01       	movw	r30, r20
     794:	01 90       	ld	r0, Z+
     796:	00 20       	and	r0, r0
     798:	e9 f7       	brne	.-6      	; 0x794 <_ZN6myDate7getDateEv+0x88>
     79a:	cf 01       	movw	r24, r30
     79c:	01 97       	sbiw	r24, 0x01	; 1
     79e:	84 1b       	sub	r24, r20
     7a0:	95 0b       	sbc	r25, r21
     7a2:	82 0f       	add	r24, r18
     7a4:	93 1f       	adc	r25, r19
     7a6:	2c e2       	ldi	r18, 0x2C	; 44
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	fc 01       	movw	r30, r24
     7ac:	31 83       	std	Z+1, r19	; 0x01
     7ae:	20 83       	st	Z, r18
	strcat(dateString,dayString);
     7b0:	8c 85       	ldd	r24, Y+12	; 0x0c
     7b2:	9d 85       	ldd	r25, Y+13	; 0x0d
     7b4:	06 96       	adiw	r24, 0x06	; 6
     7b6:	9e 01       	movw	r18, r28
     7b8:	2c 5f       	subi	r18, 0xFC	; 252
     7ba:	3f 4f       	sbci	r19, 0xFF	; 255
     7bc:	b9 01       	movw	r22, r18
     7be:	0e 94 30 1d 	call	0x3a60	; 0x3a60 <strcat>
	strcat(dateString,",");
     7c2:	8c 85       	ldd	r24, Y+12	; 0x0c
     7c4:	9d 85       	ldd	r25, Y+13	; 0x0d
     7c6:	9c 01       	movw	r18, r24
     7c8:	2a 5f       	subi	r18, 0xFA	; 250
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	c9 01       	movw	r24, r18
     7ce:	ac 01       	movw	r20, r24
     7d0:	fa 01       	movw	r30, r20
     7d2:	01 90       	ld	r0, Z+
     7d4:	00 20       	and	r0, r0
     7d6:	e9 f7       	brne	.-6      	; 0x7d2 <_ZN6myDate7getDateEv+0xc6>
     7d8:	cf 01       	movw	r24, r30
     7da:	01 97       	sbiw	r24, 0x01	; 1
     7dc:	84 1b       	sub	r24, r20
     7de:	95 0b       	sbc	r25, r21
     7e0:	82 0f       	add	r24, r18
     7e2:	93 1f       	adc	r25, r19
     7e4:	2c e2       	ldi	r18, 0x2C	; 44
     7e6:	30 e0       	ldi	r19, 0x00	; 0
     7e8:	fc 01       	movw	r30, r24
     7ea:	31 83       	std	Z+1, r19	; 0x01
     7ec:	20 83       	st	Z, r18
	strcat(dateString,yearString);
     7ee:	8c 85       	ldd	r24, Y+12	; 0x0c
     7f0:	9d 85       	ldd	r25, Y+13	; 0x0d
     7f2:	06 96       	adiw	r24, 0x06	; 6
     7f4:	9e 01       	movw	r18, r28
     7f6:	29 5f       	subi	r18, 0xF9	; 249
     7f8:	3f 4f       	sbci	r19, 0xFF	; 255
     7fa:	b9 01       	movw	r22, r18
     7fc:	0e 94 30 1d 	call	0x3a60	; 0x3a60 <strcat>
	dateString[16] = '\0';
     800:	8c 85       	ldd	r24, Y+12	; 0x0c
     802:	9d 85       	ldd	r25, Y+13	; 0x0d
     804:	fc 01       	movw	r30, r24
     806:	16 8a       	std	Z+22, r1	; 0x16
	
	return dateString;
     808:	8c 85       	ldd	r24, Y+12	; 0x0c
     80a:	9d 85       	ldd	r25, Y+13	; 0x0d
     80c:	06 96       	adiw	r24, 0x06	; 6
     80e:	2d 96       	adiw	r28, 0x0d	; 13
     810:	0f b6       	in	r0, 0x3f	; 63
     812:	f8 94       	cli
     814:	de bf       	out	0x3e, r29	; 62
     816:	0f be       	out	0x3f, r0	; 63
     818:	cd bf       	out	0x3d, r28	; 61
     81a:	df 91       	pop	r29
     81c:	cf 91       	pop	r28
     81e:	08 95       	ret

00000820 <_ZN6myTimeC1Ev>:
		void addMinutes(int minutes);
		void setHour(int hour);
		void setMinute(int minute);
};

myTime::myTime():myDate(){
     820:	cf 93       	push	r28
     822:	df 93       	push	r29
     824:	00 d0       	rcall	.+0      	; 0x826 <_ZN6myTimeC1Ev+0x6>
     826:	cd b7       	in	r28, 0x3d	; 61
     828:	de b7       	in	r29, 0x3e	; 62
     82a:	9a 83       	std	Y+2, r25	; 0x02
     82c:	89 83       	std	Y+1, r24	; 0x01
     82e:	89 81       	ldd	r24, Y+1	; 0x01
     830:	9a 81       	ldd	r25, Y+2	; 0x02
     832:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(0,0,0);
     836:	89 81       	ldd	r24, Y+1	; 0x01
     838:	9a 81       	ldd	r25, Y+2	; 0x02
     83a:	60 e0       	ldi	r22, 0x00	; 0
     83c:	70 e0       	ldi	r23, 0x00	; 0
     83e:	40 e0       	ldi	r20, 0x00	; 0
     840:	50 e0       	ldi	r21, 0x00	; 0
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     84a:	0f 90       	pop	r0
     84c:	0f 90       	pop	r0
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	08 95       	ret

00000854 <_ZN6myTimeC1Eiii>:

myTime::myTime(int hour, int minute, int second):myDate(){
     854:	cf 93       	push	r28
     856:	df 93       	push	r29
     858:	cd b7       	in	r28, 0x3d	; 61
     85a:	de b7       	in	r29, 0x3e	; 62
     85c:	28 97       	sbiw	r28, 0x08	; 8
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	de bf       	out	0x3e, r29	; 62
     864:	0f be       	out	0x3f, r0	; 63
     866:	cd bf       	out	0x3d, r28	; 61
     868:	9a 83       	std	Y+2, r25	; 0x02
     86a:	89 83       	std	Y+1, r24	; 0x01
     86c:	7c 83       	std	Y+4, r23	; 0x04
     86e:	6b 83       	std	Y+3, r22	; 0x03
     870:	5e 83       	std	Y+6, r21	; 0x06
     872:	4d 83       	std	Y+5, r20	; 0x05
     874:	38 87       	std	Y+8, r19	; 0x08
     876:	2f 83       	std	Y+7, r18	; 0x07
     878:	89 81       	ldd	r24, Y+1	; 0x01
     87a:	9a 81       	ldd	r25, Y+2	; 0x02
     87c:	0e 94 69 00 	call	0xd2	; 0xd2 <_ZN6myDateC1Ev>
	setTime(hour,minute,second);
     880:	89 81       	ldd	r24, Y+1	; 0x01
     882:	9a 81       	ldd	r25, Y+2	; 0x02
     884:	6b 81       	ldd	r22, Y+3	; 0x03
     886:	7c 81       	ldd	r23, Y+4	; 0x04
     888:	4d 81       	ldd	r20, Y+5	; 0x05
     88a:	5e 81       	ldd	r21, Y+6	; 0x06
     88c:	2f 81       	ldd	r18, Y+7	; 0x07
     88e:	38 85       	ldd	r19, Y+8	; 0x08
     890:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     894:	28 96       	adiw	r28, 0x08	; 8
     896:	0f b6       	in	r0, 0x3f	; 63
     898:	f8 94       	cli
     89a:	de bf       	out	0x3e, r29	; 62
     89c:	0f be       	out	0x3f, r0	; 63
     89e:	cd bf       	out	0x3d, r28	; 61
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	08 95       	ret

000008a6 <_ZN6myTimeC1Eiiiiii>:

myTime::myTime(int hour,int minute,int second,int month, int day, int year):myDate(month,day,year){
     8a6:	cf 92       	push	r12
     8a8:	df 92       	push	r13
     8aa:	ef 92       	push	r14
     8ac:	ff 92       	push	r15
     8ae:	0f 93       	push	r16
     8b0:	1f 93       	push	r17
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	cd b7       	in	r28, 0x3d	; 61
     8b8:	de b7       	in	r29, 0x3e	; 62
     8ba:	2e 97       	sbiw	r28, 0x0e	; 14
     8bc:	0f b6       	in	r0, 0x3f	; 63
     8be:	f8 94       	cli
     8c0:	de bf       	out	0x3e, r29	; 62
     8c2:	0f be       	out	0x3f, r0	; 63
     8c4:	cd bf       	out	0x3d, r28	; 61
     8c6:	9a 83       	std	Y+2, r25	; 0x02
     8c8:	89 83       	std	Y+1, r24	; 0x01
     8ca:	7c 83       	std	Y+4, r23	; 0x04
     8cc:	6b 83       	std	Y+3, r22	; 0x03
     8ce:	5e 83       	std	Y+6, r21	; 0x06
     8d0:	4d 83       	std	Y+5, r20	; 0x05
     8d2:	38 87       	std	Y+8, r19	; 0x08
     8d4:	2f 83       	std	Y+7, r18	; 0x07
     8d6:	1a 87       	std	Y+10, r17	; 0x0a
     8d8:	09 87       	std	Y+9, r16	; 0x09
     8da:	fc 86       	std	Y+12, r15	; 0x0c
     8dc:	eb 86       	std	Y+11, r14	; 0x0b
     8de:	de 86       	std	Y+14, r13	; 0x0e
     8e0:	cd 86       	std	Y+13, r12	; 0x0d
     8e2:	89 81       	ldd	r24, Y+1	; 0x01
     8e4:	9a 81       	ldd	r25, Y+2	; 0x02
     8e6:	69 85       	ldd	r22, Y+9	; 0x09
     8e8:	7a 85       	ldd	r23, Y+10	; 0x0a
     8ea:	4b 85       	ldd	r20, Y+11	; 0x0b
     8ec:	5c 85       	ldd	r21, Y+12	; 0x0c
     8ee:	2d 85       	ldd	r18, Y+13	; 0x0d
     8f0:	3e 85       	ldd	r19, Y+14	; 0x0e
     8f2:	0e 94 84 00 	call	0x108	; 0x108 <_ZN6myDateC1Eiii>
	setTime(hour,minute,second);
     8f6:	89 81       	ldd	r24, Y+1	; 0x01
     8f8:	9a 81       	ldd	r25, Y+2	; 0x02
     8fa:	6b 81       	ldd	r22, Y+3	; 0x03
     8fc:	7c 81       	ldd	r23, Y+4	; 0x04
     8fe:	4d 81       	ldd	r20, Y+5	; 0x05
     900:	5e 81       	ldd	r21, Y+6	; 0x06
     902:	2f 81       	ldd	r18, Y+7	; 0x07
     904:	38 85       	ldd	r19, Y+8	; 0x08
     906:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
}
     90a:	2e 96       	adiw	r28, 0x0e	; 14
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	de bf       	out	0x3e, r29	; 62
     912:	0f be       	out	0x3f, r0	; 63
     914:	cd bf       	out	0x3d, r28	; 61
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	08 95       	ret

00000928 <_ZN6myTime10getSecondsEv>:

BYTE myTime::getSeconds(){
     928:	cf 93       	push	r28
     92a:	df 93       	push	r29
     92c:	00 d0       	rcall	.+0      	; 0x92e <_ZN6myTime10getSecondsEv+0x6>
     92e:	cd b7       	in	r28, 0x3d	; 61
     930:	de b7       	in	r29, 0x3e	; 62
     932:	9a 83       	std	Y+2, r25	; 0x02
     934:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)second;
     936:	89 81       	ldd	r24, Y+1	; 0x01
     938:	9a 81       	ldd	r25, Y+2	; 0x02
     93a:	fc 01       	movw	r30, r24
     93c:	83 8d       	ldd	r24, Z+27	; 0x1b
     93e:	94 8d       	ldd	r25, Z+28	; 0x1c
}
     940:	0f 90       	pop	r0
     942:	0f 90       	pop	r0
     944:	df 91       	pop	r29
     946:	cf 91       	pop	r28
     948:	08 95       	ret

0000094a <_ZN6myTime10getMinutesEv>:

BYTE myTime::getMinutes(){
     94a:	cf 93       	push	r28
     94c:	df 93       	push	r29
     94e:	00 d0       	rcall	.+0      	; 0x950 <_ZN6myTime10getMinutesEv+0x6>
     950:	cd b7       	in	r28, 0x3d	; 61
     952:	de b7       	in	r29, 0x3e	; 62
     954:	9a 83       	std	Y+2, r25	; 0x02
     956:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)minute;
     958:	89 81       	ldd	r24, Y+1	; 0x01
     95a:	9a 81       	ldd	r25, Y+2	; 0x02
     95c:	fc 01       	movw	r30, r24
     95e:	81 8d       	ldd	r24, Z+25	; 0x19
     960:	92 8d       	ldd	r25, Z+26	; 0x1a
}
     962:	0f 90       	pop	r0
     964:	0f 90       	pop	r0
     966:	df 91       	pop	r29
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <_ZN6myTime8getHoursEv>:

BYTE myTime::getHours(){
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	00 d0       	rcall	.+0      	; 0x972 <_ZN6myTime8getHoursEv+0x6>
     972:	cd b7       	in	r28, 0x3d	; 61
     974:	de b7       	in	r29, 0x3e	; 62
     976:	9a 83       	std	Y+2, r25	; 0x02
     978:	89 83       	std	Y+1, r24	; 0x01
	return (BYTE)hour;
     97a:	89 81       	ldd	r24, Y+1	; 0x01
     97c:	9a 81       	ldd	r25, Y+2	; 0x02
     97e:	fc 01       	movw	r30, r24
     980:	87 89       	ldd	r24, Z+23	; 0x17
     982:	90 8d       	ldd	r25, Z+24	; 0x18
}
     984:	0f 90       	pop	r0
     986:	0f 90       	pop	r0
     988:	df 91       	pop	r29
     98a:	cf 91       	pop	r28
     98c:	08 95       	ret

0000098e <_ZN6myTime7setTimeEPc>:

BOOL myTime::setTime(char *newTime){
     98e:	cf 93       	push	r28
     990:	df 93       	push	r29
     992:	cd b7       	in	r28, 0x3d	; 61
     994:	de b7       	in	r29, 0x3e	; 62
     996:	a2 97       	sbiw	r28, 0x22	; 34
     998:	0f b6       	in	r0, 0x3f	; 63
     99a:	f8 94       	cli
     99c:	de bf       	out	0x3e, r29	; 62
     99e:	0f be       	out	0x3f, r0	; 63
     9a0:	cd bf       	out	0x3d, r28	; 61
     9a2:	98 a3       	lds	r25, 0x58
     9a4:	8f 8f       	std	Y+31, r24	; 0x1f
     9a6:	7a a3       	lds	r23, 0x5a
     9a8:	69 a3       	lds	r22, 0x59
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
     9aa:	ce 01       	movw	r24, r28
     9ac:	0b 96       	adiw	r24, 0x0b	; 11
     9ae:	29 a1       	lds	r18, 0x49
     9b0:	3a a1       	lds	r19, 0x4a
     9b2:	b9 01       	movw	r22, r18
     9b4:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <strcpy>
	for (int j=0; j<3; j++){
     9b8:	1a 82       	std	Y+2, r1	; 0x02
     9ba:	19 82       	std	Y+1, r1	; 0x01
     9bc:	43 c0       	rjmp	.+134    	; 0xa44 <_ZN6myTime7setTimeEPc+0xb6>
		for (int i=0; i<2; i++){
     9be:	1c 82       	std	Y+4, r1	; 0x04
     9c0:	1b 82       	std	Y+3, r1	; 0x03
     9c2:	20 c0       	rjmp	.+64     	; 0xa04 <_ZN6myTime7setTimeEPc+0x76>
				tempString[i]=currentString[i+j*3];
     9c4:	29 81       	ldd	r18, Y+1	; 0x01
     9c6:	3a 81       	ldd	r19, Y+2	; 0x02
     9c8:	c9 01       	movw	r24, r18
     9ca:	88 0f       	add	r24, r24
     9cc:	99 1f       	adc	r25, r25
     9ce:	28 0f       	add	r18, r24
     9d0:	39 1f       	adc	r19, r25
     9d2:	8b 81       	ldd	r24, Y+3	; 0x03
     9d4:	9c 81       	ldd	r25, Y+4	; 0x04
     9d6:	82 0f       	add	r24, r18
     9d8:	93 1f       	adc	r25, r19
     9da:	9e 01       	movw	r18, r28
     9dc:	25 5f       	subi	r18, 0xF5	; 245
     9de:	3f 4f       	sbci	r19, 0xFF	; 255
     9e0:	82 0f       	add	r24, r18
     9e2:	93 1f       	adc	r25, r19
     9e4:	fc 01       	movw	r30, r24
     9e6:	40 81       	ld	r20, Z
     9e8:	9e 01       	movw	r18, r28
     9ea:	2b 5e       	subi	r18, 0xEB	; 235
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	8b 81       	ldd	r24, Y+3	; 0x03
     9f0:	9c 81       	ldd	r25, Y+4	; 0x04
     9f2:	82 0f       	add	r24, r18
     9f4:	93 1f       	adc	r25, r19
     9f6:	fc 01       	movw	r30, r24
     9f8:	40 83       	st	Z, r20
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
		for (int i=0; i<2; i++){
     9fa:	8b 81       	ldd	r24, Y+3	; 0x03
     9fc:	9c 81       	ldd	r25, Y+4	; 0x04
     9fe:	01 96       	adiw	r24, 0x01	; 1
     a00:	9c 83       	std	Y+4, r25	; 0x04
     a02:	8b 83       	std	Y+3, r24	; 0x03
     a04:	21 e0       	ldi	r18, 0x01	; 1
     a06:	8b 81       	ldd	r24, Y+3	; 0x03
     a08:	9c 81       	ldd	r25, Y+4	; 0x04
     a0a:	82 30       	cpi	r24, 0x02	; 2
     a0c:	91 05       	cpc	r25, r1
     a0e:	0c f0       	brlt	.+2      	; 0xa12 <_ZN6myTime7setTimeEPc+0x84>
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	22 23       	and	r18, r18
     a14:	b9 f6       	brne	.-82     	; 0x9c4 <_ZN6myTime7setTimeEPc+0x36>
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
     a16:	ce 01       	movw	r24, r28
     a18:	45 96       	adiw	r24, 0x15	; 21
     a1a:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
     a1e:	9c 01       	movw	r18, r24
     a20:	89 81       	ldd	r24, Y+1	; 0x01
     a22:	9a 81       	ldd	r25, Y+2	; 0x02
     a24:	88 0f       	add	r24, r24
     a26:	99 1f       	adc	r25, r25
     a28:	ae 01       	movw	r20, r28
     a2a:	4f 5f       	subi	r20, 0xFF	; 255
     a2c:	5f 4f       	sbci	r21, 0xFF	; 255
     a2e:	84 0f       	add	r24, r20
     a30:	95 1f       	adc	r25, r21
     a32:	04 96       	adiw	r24, 0x04	; 4
     a34:	fc 01       	movw	r30, r24
     a36:	31 83       	std	Z+1, r19	; 0x01
     a38:	20 83       	st	Z, r18
BOOL myTime::setTime(char *newTime){
	int tempNum[3];
	char currentString[10];
	char tempString[10];
	strcpy(currentString,newTime);
	for (int j=0; j<3; j++){
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	9a 81       	ldd	r25, Y+2	; 0x02
     a3e:	01 96       	adiw	r24, 0x01	; 1
     a40:	9a 83       	std	Y+2, r25	; 0x02
     a42:	89 83       	std	Y+1, r24	; 0x01
     a44:	21 e0       	ldi	r18, 0x01	; 1
     a46:	89 81       	ldd	r24, Y+1	; 0x01
     a48:	9a 81       	ldd	r25, Y+2	; 0x02
     a4a:	83 30       	cpi	r24, 0x03	; 3
     a4c:	91 05       	cpc	r25, r1
     a4e:	0c f0       	brlt	.+2      	; 0xa52 <_ZN6myTime7setTimeEPc+0xc4>
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	22 23       	and	r18, r18
     a54:	09 f0       	breq	.+2      	; 0xa58 <_ZN6myTime7setTimeEPc+0xca>
     a56:	b3 cf       	rjmp	.-154    	; 0x9be <_ZN6myTime7setTimeEPc+0x30>
		for (int i=0; i<2; i++){
				tempString[i]=currentString[i+j*3];
		}
		tempNum[j]=atoi(tempString);
	}
	if (tempNum[0]/24==0 && tempNum[1]/60==0 && tempNum[2]/60==0){
     a58:	8d 81       	ldd	r24, Y+5	; 0x05
     a5a:	9e 81       	ldd	r25, Y+6	; 0x06
     a5c:	47 96       	adiw	r24, 0x17	; 23
     a5e:	8f 32       	cpi	r24, 0x2F	; 47
     a60:	91 05       	cpc	r25, r1
     a62:	c0 f4       	brcc	.+48     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a64:	8f 81       	ldd	r24, Y+7	; 0x07
     a66:	98 85       	ldd	r25, Y+8	; 0x08
     a68:	cb 96       	adiw	r24, 0x3b	; 59
     a6a:	87 37       	cpi	r24, 0x77	; 119
     a6c:	91 05       	cpc	r25, r1
     a6e:	90 f4       	brcc	.+36     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
     a70:	89 85       	ldd	r24, Y+9	; 0x09
     a72:	9a 85       	ldd	r25, Y+10	; 0x0a
     a74:	cb 96       	adiw	r24, 0x3b	; 59
     a76:	87 37       	cpi	r24, 0x77	; 119
     a78:	91 05       	cpc	r25, r1
     a7a:	60 f4       	brcc	.+24     	; 0xa94 <_ZN6myTime7setTimeEPc+0x106>
		setTime(tempNum[0],tempNum[1],tempNum[2]);
     a7c:	6d 81       	ldd	r22, Y+5	; 0x05
     a7e:	7e 81       	ldd	r23, Y+6	; 0x06
     a80:	4f 81       	ldd	r20, Y+7	; 0x07
     a82:	58 85       	ldd	r21, Y+8	; 0x08
     a84:	29 85       	ldd	r18, Y+9	; 0x09
     a86:	3a 85       	ldd	r19, Y+10	; 0x0a
     a88:	8f 8d       	ldd	r24, Y+31	; 0x1f
     a8a:	98 a1       	lds	r25, 0x48
     a8c:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
		return fTrue;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	01 c0       	rjmp	.+2      	; 0xa96 <_ZN6myTime7setTimeEPc+0x108>
	} 
	return fFalse;
     a94:	80 e0       	ldi	r24, 0x00	; 0
}
     a96:	a2 96       	adiw	r28, 0x22	; 34
     a98:	0f b6       	in	r0, 0x3f	; 63
     a9a:	f8 94       	cli
     a9c:	de bf       	out	0x3e, r29	; 62
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	cd bf       	out	0x3d, r28	; 61
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	08 95       	ret

00000aa8 <_ZN6myTime7setTimeEiii>:

void myTime::setTime(int hour,int minute,int second){
     aa8:	cf 93       	push	r28
     aaa:	df 93       	push	r29
     aac:	cd b7       	in	r28, 0x3d	; 61
     aae:	de b7       	in	r29, 0x3e	; 62
     ab0:	28 97       	sbiw	r28, 0x08	; 8
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	de bf       	out	0x3e, r29	; 62
     ab8:	0f be       	out	0x3f, r0	; 63
     aba:	cd bf       	out	0x3d, r28	; 61
     abc:	9a 83       	std	Y+2, r25	; 0x02
     abe:	89 83       	std	Y+1, r24	; 0x01
     ac0:	7c 83       	std	Y+4, r23	; 0x04
     ac2:	6b 83       	std	Y+3, r22	; 0x03
     ac4:	5e 83       	std	Y+6, r21	; 0x06
     ac6:	4d 83       	std	Y+5, r20	; 0x05
     ac8:	38 87       	std	Y+8, r19	; 0x08
     aca:	2f 83       	std	Y+7, r18	; 0x07
	setHour(hour);
     acc:	89 81       	ldd	r24, Y+1	; 0x01
     ace:	9a 81       	ldd	r25, Y+2	; 0x02
     ad0:	2b 81       	ldd	r18, Y+3	; 0x03
     ad2:	3c 81       	ldd	r19, Y+4	; 0x04
     ad4:	b9 01       	movw	r22, r18
     ad6:	0e 94 84 05 	call	0xb08	; 0xb08 <_ZN6myTime7setHourEi>
	setMinute(minute);
     ada:	89 81       	ldd	r24, Y+1	; 0x01
     adc:	9a 81       	ldd	r25, Y+2	; 0x02
     ade:	2d 81       	ldd	r18, Y+5	; 0x05
     ae0:	3e 81       	ldd	r19, Y+6	; 0x06
     ae2:	b9 01       	movw	r22, r18
     ae4:	0e 94 a2 05 	call	0xb44	; 0xb44 <_ZN6myTime9setMinuteEi>
	setSecond(second);
     ae8:	89 81       	ldd	r24, Y+1	; 0x01
     aea:	9a 81       	ldd	r25, Y+2	; 0x02
     aec:	2f 81       	ldd	r18, Y+7	; 0x07
     aee:	38 85       	ldd	r19, Y+8	; 0x08
     af0:	b9 01       	movw	r22, r18
     af2:	0e 94 c0 05 	call	0xb80	; 0xb80 <_ZN6myTime9setSecondEi>
}
     af6:	28 96       	adiw	r28, 0x08	; 8
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	de bf       	out	0x3e, r29	; 62
     afe:	0f be       	out	0x3f, r0	; 63
     b00:	cd bf       	out	0x3d, r28	; 61
     b02:	df 91       	pop	r29
     b04:	cf 91       	pop	r28
     b06:	08 95       	ret

00000b08 <_ZN6myTime7setHourEi>:

void myTime::setHour(int hour){
     b08:	cf 93       	push	r28
     b0a:	df 93       	push	r29
     b0c:	00 d0       	rcall	.+0      	; 0xb0e <_ZN6myTime7setHourEi+0x6>
     b0e:	00 d0       	rcall	.+0      	; 0xb10 <_ZN6myTime7setHourEi+0x8>
     b10:	cd b7       	in	r28, 0x3d	; 61
     b12:	de b7       	in	r29, 0x3e	; 62
     b14:	9a 83       	std	Y+2, r25	; 0x02
     b16:	89 83       	std	Y+1, r24	; 0x01
     b18:	7c 83       	std	Y+4, r23	; 0x04
     b1a:	6b 83       	std	Y+3, r22	; 0x03
	if (hour/24 == 0){
     b1c:	8b 81       	ldd	r24, Y+3	; 0x03
     b1e:	9c 81       	ldd	r25, Y+4	; 0x04
     b20:	47 96       	adiw	r24, 0x17	; 23
     b22:	8f 32       	cpi	r24, 0x2F	; 47
     b24:	91 05       	cpc	r25, r1
     b26:	38 f4       	brcc	.+14     	; 0xb36 <_ZN6myTime7setHourEi+0x2e>
		this->hour = hour;
     b28:	89 81       	ldd	r24, Y+1	; 0x01
     b2a:	9a 81       	ldd	r25, Y+2	; 0x02
     b2c:	2b 81       	ldd	r18, Y+3	; 0x03
     b2e:	3c 81       	ldd	r19, Y+4	; 0x04
     b30:	fc 01       	movw	r30, r24
     b32:	30 8f       	std	Z+24, r19	; 0x18
     b34:	27 8b       	std	Z+23, r18	; 0x17
	}	
}
     b36:	0f 90       	pop	r0
     b38:	0f 90       	pop	r0
     b3a:	0f 90       	pop	r0
     b3c:	0f 90       	pop	r0
     b3e:	df 91       	pop	r29
     b40:	cf 91       	pop	r28
     b42:	08 95       	ret

00000b44 <_ZN6myTime9setMinuteEi>:

void myTime::setMinute(int minute){
     b44:	cf 93       	push	r28
     b46:	df 93       	push	r29
     b48:	00 d0       	rcall	.+0      	; 0xb4a <_ZN6myTime9setMinuteEi+0x6>
     b4a:	00 d0       	rcall	.+0      	; 0xb4c <_ZN6myTime9setMinuteEi+0x8>
     b4c:	cd b7       	in	r28, 0x3d	; 61
     b4e:	de b7       	in	r29, 0x3e	; 62
     b50:	9a 83       	std	Y+2, r25	; 0x02
     b52:	89 83       	std	Y+1, r24	; 0x01
     b54:	7c 83       	std	Y+4, r23	; 0x04
     b56:	6b 83       	std	Y+3, r22	; 0x03
	if (minute/60 == 0){
     b58:	8b 81       	ldd	r24, Y+3	; 0x03
     b5a:	9c 81       	ldd	r25, Y+4	; 0x04
     b5c:	cb 96       	adiw	r24, 0x3b	; 59
     b5e:	87 37       	cpi	r24, 0x77	; 119
     b60:	91 05       	cpc	r25, r1
     b62:	38 f4       	brcc	.+14     	; 0xb72 <_ZN6myTime9setMinuteEi+0x2e>
		this->minute = minute;
     b64:	89 81       	ldd	r24, Y+1	; 0x01
     b66:	9a 81       	ldd	r25, Y+2	; 0x02
     b68:	2b 81       	ldd	r18, Y+3	; 0x03
     b6a:	3c 81       	ldd	r19, Y+4	; 0x04
     b6c:	fc 01       	movw	r30, r24
     b6e:	32 8f       	std	Z+26, r19	; 0x1a
     b70:	21 8f       	std	Z+25, r18	; 0x19
	}	
}
     b72:	0f 90       	pop	r0
     b74:	0f 90       	pop	r0
     b76:	0f 90       	pop	r0
     b78:	0f 90       	pop	r0
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	08 95       	ret

00000b80 <_ZN6myTime9setSecondEi>:

void myTime::setSecond(int second){
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	00 d0       	rcall	.+0      	; 0xb86 <_ZN6myTime9setSecondEi+0x6>
     b86:	00 d0       	rcall	.+0      	; 0xb88 <_ZN6myTime9setSecondEi+0x8>
     b88:	cd b7       	in	r28, 0x3d	; 61
     b8a:	de b7       	in	r29, 0x3e	; 62
     b8c:	9a 83       	std	Y+2, r25	; 0x02
     b8e:	89 83       	std	Y+1, r24	; 0x01
     b90:	7c 83       	std	Y+4, r23	; 0x04
     b92:	6b 83       	std	Y+3, r22	; 0x03
	if (second/60 == 0){
     b94:	8b 81       	ldd	r24, Y+3	; 0x03
     b96:	9c 81       	ldd	r25, Y+4	; 0x04
     b98:	cb 96       	adiw	r24, 0x3b	; 59
     b9a:	87 37       	cpi	r24, 0x77	; 119
     b9c:	91 05       	cpc	r25, r1
     b9e:	38 f4       	brcc	.+14     	; 0xbae <_ZN6myTime9setSecondEi+0x2e>
		this->second = second;
     ba0:	89 81       	ldd	r24, Y+1	; 0x01
     ba2:	9a 81       	ldd	r25, Y+2	; 0x02
     ba4:	2b 81       	ldd	r18, Y+3	; 0x03
     ba6:	3c 81       	ldd	r19, Y+4	; 0x04
     ba8:	fc 01       	movw	r30, r24
     baa:	34 8f       	std	Z+28, r19	; 0x1c
     bac:	23 8f       	std	Z+27, r18	; 0x1b
	}	
}
     bae:	0f 90       	pop	r0
     bb0:	0f 90       	pop	r0
     bb2:	0f 90       	pop	r0
     bb4:	0f 90       	pop	r0
     bb6:	df 91       	pop	r29
     bb8:	cf 91       	pop	r28
     bba:	08 95       	ret

00000bbc <_ZN6myTime8addHoursEi>:

void myTime::addHours(int hours){
     bbc:	cf 93       	push	r28
     bbe:	df 93       	push	r29
     bc0:	cd b7       	in	r28, 0x3d	; 61
     bc2:	de b7       	in	r29, 0x3e	; 62
     bc4:	28 97       	sbiw	r28, 0x08	; 8
     bc6:	0f b6       	in	r0, 0x3f	; 63
     bc8:	f8 94       	cli
     bca:	de bf       	out	0x3e, r29	; 62
     bcc:	0f be       	out	0x3f, r0	; 63
     bce:	cd bf       	out	0x3d, r28	; 61
     bd0:	9e 83       	std	Y+6, r25	; 0x06
     bd2:	8d 83       	std	Y+5, r24	; 0x05
     bd4:	78 87       	std	Y+8, r23	; 0x08
     bd6:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempHours = hour + hours;
     bd8:	8d 81       	ldd	r24, Y+5	; 0x05
     bda:	9e 81       	ldd	r25, Y+6	; 0x06
     bdc:	fc 01       	movw	r30, r24
     bde:	27 89       	ldd	r18, Z+23	; 0x17
     be0:	30 8d       	ldd	r19, Z+24	; 0x18
     be2:	8f 81       	ldd	r24, Y+7	; 0x07
     be4:	98 85       	ldd	r25, Y+8	; 0x08
     be6:	82 0f       	add	r24, r18
     be8:	93 1f       	adc	r25, r19
     bea:	9a 83       	std	Y+2, r25	; 0x02
     bec:	89 83       	std	Y+1, r24	; 0x01
	hour = tempHours%24;
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	9a 81       	ldd	r25, Y+2	; 0x02
     bf2:	28 e1       	ldi	r18, 0x18	; 24
     bf4:	30 e0       	ldi	r19, 0x00	; 0
     bf6:	b9 01       	movw	r22, r18
     bf8:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     bfc:	9c 01       	movw	r18, r24
     bfe:	8d 81       	ldd	r24, Y+5	; 0x05
     c00:	9e 81       	ldd	r25, Y+6	; 0x06
     c02:	fc 01       	movw	r30, r24
     c04:	30 8f       	std	Z+24, r19	; 0x18
     c06:	27 8b       	std	Z+23, r18	; 0x17
	if (tempHours/24 >= 1){
     c08:	89 81       	ldd	r24, Y+1	; 0x01
     c0a:	9a 81       	ldd	r25, Y+2	; 0x02
     c0c:	21 e0       	ldi	r18, 0x01	; 1
     c0e:	88 31       	cpi	r24, 0x18	; 24
     c10:	91 05       	cpc	r25, r1
     c12:	0c f4       	brge	.+2      	; 0xc16 <_ZN6myTime8addHoursEi+0x5a>
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	22 23       	and	r18, r18
     c18:	91 f0       	breq	.+36     	; 0xc3e <_ZN6myTime8addHoursEi+0x82>
		volatile int daysToAdd = tempHours/24;
     c1a:	89 81       	ldd	r24, Y+1	; 0x01
     c1c:	9a 81       	ldd	r25, Y+2	; 0x02
     c1e:	28 e1       	ldi	r18, 0x18	; 24
     c20:	30 e0       	ldi	r19, 0x00	; 0
     c22:	b9 01       	movw	r22, r18
     c24:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     c28:	9b 01       	movw	r18, r22
     c2a:	c9 01       	movw	r24, r18
     c2c:	9c 83       	std	Y+4, r25	; 0x04
     c2e:	8b 83       	std	Y+3, r24	; 0x03
		addDays(daysToAdd);
     c30:	8d 81       	ldd	r24, Y+5	; 0x05
     c32:	9e 81       	ldd	r25, Y+6	; 0x06
     c34:	2b 81       	ldd	r18, Y+3	; 0x03
     c36:	3c 81       	ldd	r19, Y+4	; 0x04
     c38:	b9 01       	movw	r22, r18
     c3a:	0e 94 43 02 	call	0x486	; 0x486 <_ZN6myDate7addDaysEi>
	}	
}
     c3e:	28 96       	adiw	r28, 0x08	; 8
     c40:	0f b6       	in	r0, 0x3f	; 63
     c42:	f8 94       	cli
     c44:	de bf       	out	0x3e, r29	; 62
     c46:	0f be       	out	0x3f, r0	; 63
     c48:	cd bf       	out	0x3d, r28	; 61
     c4a:	df 91       	pop	r29
     c4c:	cf 91       	pop	r28
     c4e:	08 95       	ret

00000c50 <_ZN6myTime10addMinutesEi>:

void myTime::addMinutes(int minutes){
     c50:	cf 93       	push	r28
     c52:	df 93       	push	r29
     c54:	cd b7       	in	r28, 0x3d	; 61
     c56:	de b7       	in	r29, 0x3e	; 62
     c58:	28 97       	sbiw	r28, 0x08	; 8
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	de bf       	out	0x3e, r29	; 62
     c60:	0f be       	out	0x3f, r0	; 63
     c62:	cd bf       	out	0x3d, r28	; 61
     c64:	9e 83       	std	Y+6, r25	; 0x06
     c66:	8d 83       	std	Y+5, r24	; 0x05
     c68:	78 87       	std	Y+8, r23	; 0x08
     c6a:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempMinutes = minute + minutes;				//what the minutes were + added minutes
     c6c:	8d 81       	ldd	r24, Y+5	; 0x05
     c6e:	9e 81       	ldd	r25, Y+6	; 0x06
     c70:	fc 01       	movw	r30, r24
     c72:	21 8d       	ldd	r18, Z+25	; 0x19
     c74:	32 8d       	ldd	r19, Z+26	; 0x1a
     c76:	8f 81       	ldd	r24, Y+7	; 0x07
     c78:	98 85       	ldd	r25, Y+8	; 0x08
     c7a:	82 0f       	add	r24, r18
     c7c:	93 1f       	adc	r25, r19
     c7e:	9a 83       	std	Y+2, r25	; 0x02
     c80:	89 83       	std	Y+1, r24	; 0x01
	minute = tempMinutes%60;
     c82:	89 81       	ldd	r24, Y+1	; 0x01
     c84:	9a 81       	ldd	r25, Y+2	; 0x02
     c86:	2c e3       	ldi	r18, 0x3C	; 60
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	b9 01       	movw	r22, r18
     c8c:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     c90:	9c 01       	movw	r18, r24
     c92:	8d 81       	ldd	r24, Y+5	; 0x05
     c94:	9e 81       	ldd	r25, Y+6	; 0x06
     c96:	fc 01       	movw	r30, r24
     c98:	32 8f       	std	Z+26, r19	; 0x1a
     c9a:	21 8f       	std	Z+25, r18	; 0x19
	if (tempMinutes/60 >= 1){
     c9c:	89 81       	ldd	r24, Y+1	; 0x01
     c9e:	9a 81       	ldd	r25, Y+2	; 0x02
     ca0:	21 e0       	ldi	r18, 0x01	; 1
     ca2:	8c 33       	cpi	r24, 0x3C	; 60
     ca4:	91 05       	cpc	r25, r1
     ca6:	0c f4       	brge	.+2      	; 0xcaa <_ZN6myTime10addMinutesEi+0x5a>
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	22 23       	and	r18, r18
     cac:	91 f0       	breq	.+36     	; 0xcd2 <_ZN6myTime10addMinutesEi+0x82>
		volatile int hoursToAdd = tempMinutes/60;
     cae:	89 81       	ldd	r24, Y+1	; 0x01
     cb0:	9a 81       	ldd	r25, Y+2	; 0x02
     cb2:	2c e3       	ldi	r18, 0x3C	; 60
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	b9 01       	movw	r22, r18
     cb8:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     cbc:	9b 01       	movw	r18, r22
     cbe:	c9 01       	movw	r24, r18
     cc0:	9c 83       	std	Y+4, r25	; 0x04
     cc2:	8b 83       	std	Y+3, r24	; 0x03
		addHours(hoursToAdd);
     cc4:	2b 81       	ldd	r18, Y+3	; 0x03
     cc6:	3c 81       	ldd	r19, Y+4	; 0x04
     cc8:	8d 81       	ldd	r24, Y+5	; 0x05
     cca:	9e 81       	ldd	r25, Y+6	; 0x06
     ccc:	b9 01       	movw	r22, r18
     cce:	0e 94 de 05 	call	0xbbc	; 0xbbc <_ZN6myTime8addHoursEi>
	}
}
     cd2:	28 96       	adiw	r28, 0x08	; 8
     cd4:	0f b6       	in	r0, 0x3f	; 63
     cd6:	f8 94       	cli
     cd8:	de bf       	out	0x3e, r29	; 62
     cda:	0f be       	out	0x3f, r0	; 63
     cdc:	cd bf       	out	0x3d, r28	; 61
     cde:	df 91       	pop	r29
     ce0:	cf 91       	pop	r28
     ce2:	08 95       	ret

00000ce4 <_ZN6myTime10addSecondsEi>:

void myTime::addSeconds(int seconds){
     ce4:	cf 93       	push	r28
     ce6:	df 93       	push	r29
     ce8:	cd b7       	in	r28, 0x3d	; 61
     cea:	de b7       	in	r29, 0x3e	; 62
     cec:	28 97       	sbiw	r28, 0x08	; 8
     cee:	0f b6       	in	r0, 0x3f	; 63
     cf0:	f8 94       	cli
     cf2:	de bf       	out	0x3e, r29	; 62
     cf4:	0f be       	out	0x3f, r0	; 63
     cf6:	cd bf       	out	0x3d, r28	; 61
     cf8:	9e 83       	std	Y+6, r25	; 0x06
     cfa:	8d 83       	std	Y+5, r24	; 0x05
     cfc:	78 87       	std	Y+8, r23	; 0x08
     cfe:	6f 83       	std	Y+7, r22	; 0x07
	volatile int tempSecond = second + seconds;
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	9e 81       	ldd	r25, Y+6	; 0x06
     d04:	fc 01       	movw	r30, r24
     d06:	23 8d       	ldd	r18, Z+27	; 0x1b
     d08:	34 8d       	ldd	r19, Z+28	; 0x1c
     d0a:	8f 81       	ldd	r24, Y+7	; 0x07
     d0c:	98 85       	ldd	r25, Y+8	; 0x08
     d0e:	82 0f       	add	r24, r18
     d10:	93 1f       	adc	r25, r19
     d12:	9a 83       	std	Y+2, r25	; 0x02
     d14:	89 83       	std	Y+1, r24	; 0x01
	second = (tempSecond)%60;			  //what's left over
     d16:	89 81       	ldd	r24, Y+1	; 0x01
     d18:	9a 81       	ldd	r25, Y+2	; 0x02
     d1a:	2c e3       	ldi	r18, 0x3C	; 60
     d1c:	30 e0       	ldi	r19, 0x00	; 0
     d1e:	b9 01       	movw	r22, r18
     d20:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     d24:	9c 01       	movw	r18, r24
     d26:	8d 81       	ldd	r24, Y+5	; 0x05
     d28:	9e 81       	ldd	r25, Y+6	; 0x06
     d2a:	fc 01       	movw	r30, r24
     d2c:	34 8f       	std	Z+28, r19	; 0x1c
     d2e:	23 8f       	std	Z+27, r18	; 0x1b
	if ((tempSecond)/60 >= 1){
     d30:	89 81       	ldd	r24, Y+1	; 0x01
     d32:	9a 81       	ldd	r25, Y+2	; 0x02
     d34:	21 e0       	ldi	r18, 0x01	; 1
     d36:	8c 33       	cpi	r24, 0x3C	; 60
     d38:	91 05       	cpc	r25, r1
     d3a:	0c f4       	brge	.+2      	; 0xd3e <_ZN6myTime10addSecondsEi+0x5a>
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	22 23       	and	r18, r18
     d40:	91 f0       	breq	.+36     	; 0xd66 <_ZN6myTime10addSecondsEi+0x82>
		//There are more than 60 seconds now, find out how many minutes need to be added
		volatile int minutesToAdd = (tempSecond)/60;		  //if seconds = 120, adds two minutes
     d42:	89 81       	ldd	r24, Y+1	; 0x01
     d44:	9a 81       	ldd	r25, Y+2	; 0x02
     d46:	2c e3       	ldi	r18, 0x3C	; 60
     d48:	30 e0       	ldi	r19, 0x00	; 0
     d4a:	b9 01       	movw	r22, r18
     d4c:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
     d50:	9b 01       	movw	r18, r22
     d52:	c9 01       	movw	r24, r18
     d54:	9c 83       	std	Y+4, r25	; 0x04
     d56:	8b 83       	std	Y+3, r24	; 0x03
		addMinutes(minutesToAdd);					  //add to minutes
     d58:	2b 81       	ldd	r18, Y+3	; 0x03
     d5a:	3c 81       	ldd	r19, Y+4	; 0x04
     d5c:	8d 81       	ldd	r24, Y+5	; 0x05
     d5e:	9e 81       	ldd	r25, Y+6	; 0x06
     d60:	b9 01       	movw	r22, r18
     d62:	0e 94 28 06 	call	0xc50	; 0xc50 <_ZN6myTime10addMinutesEi>
	}
}
     d66:	28 96       	adiw	r28, 0x08	; 8
     d68:	0f b6       	in	r0, 0x3f	; 63
     d6a:	f8 94       	cli
     d6c:	de bf       	out	0x3e, r29	; 62
     d6e:	0f be       	out	0x3f, r0	; 63
     d70:	cd bf       	out	0x3d, r28	; 61
     d72:	df 91       	pop	r29
     d74:	cf 91       	pop	r28
     d76:	08 95       	ret

00000d78 <_ZN6myTime13checkValidityEv>:

BOOL myTime::checkValidity(){
     d78:	cf 93       	push	r28
     d7a:	df 93       	push	r29
     d7c:	00 d0       	rcall	.+0      	; 0xd7e <_ZN6myTime13checkValidityEv+0x6>
     d7e:	0f 92       	push	r0
     d80:	cd b7       	in	r28, 0x3d	; 61
     d82:	de b7       	in	r29, 0x3e	; 62
     d84:	9b 83       	std	Y+3, r25	; 0x03
     d86:	8a 83       	std	Y+2, r24	; 0x02
	BOOL stillValid=fTrue;
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	89 83       	std	Y+1, r24	; 0x01
	if (second/60==0 && minute/60==0 && hour/24==0){
     d8c:	8a 81       	ldd	r24, Y+2	; 0x02
     d8e:	9b 81       	ldd	r25, Y+3	; 0x03
     d90:	fc 01       	movw	r30, r24
     d92:	83 8d       	ldd	r24, Z+27	; 0x1b
     d94:	94 8d       	ldd	r25, Z+28	; 0x1c
     d96:	cb 96       	adiw	r24, 0x3b	; 59
     d98:	87 37       	cpi	r24, 0x77	; 119
     d9a:	91 05       	cpc	r25, r1
     d9c:	a0 f4       	brcc	.+40     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     d9e:	8a 81       	ldd	r24, Y+2	; 0x02
     da0:	9b 81       	ldd	r25, Y+3	; 0x03
     da2:	fc 01       	movw	r30, r24
     da4:	81 8d       	ldd	r24, Z+25	; 0x19
     da6:	92 8d       	ldd	r25, Z+26	; 0x1a
     da8:	cb 96       	adiw	r24, 0x3b	; 59
     daa:	87 37       	cpi	r24, 0x77	; 119
     dac:	91 05       	cpc	r25, r1
     dae:	58 f4       	brcc	.+22     	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     db0:	8a 81       	ldd	r24, Y+2	; 0x02
     db2:	9b 81       	ldd	r25, Y+3	; 0x03
     db4:	fc 01       	movw	r30, r24
     db6:	87 89       	ldd	r24, Z+23	; 0x17
     db8:	90 8d       	ldd	r25, Z+24	; 0x18
     dba:	47 96       	adiw	r24, 0x17	; 23
     dbc:	8f 32       	cpi	r24, 0x2F	; 47
     dbe:	91 05       	cpc	r25, r1
     dc0:	10 f4       	brcc	.+4      	; 0xdc6 <_ZN6myTime13checkValidityEv+0x4e>
     dc2:	81 e0       	ldi	r24, 0x01	; 1
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <_ZN6myTime13checkValidityEv+0x50>
     dc6:	80 e0       	ldi	r24, 0x00	; 0
     dc8:	88 23       	and	r24, r24
     dca:	69 f0       	breq	.+26     	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
		if (checkValidityDate()){return fTrue;}
     dcc:	8a 81       	ldd	r24, Y+2	; 0x02
     dce:	9b 81       	ldd	r25, Y+3	; 0x03
     dd0:	0e 94 02 03 	call	0x604	; 0x604 <_ZN6myDate17checkValidityDateEv>
     dd4:	98 2f       	mov	r25, r24
     dd6:	81 e0       	ldi	r24, 0x01	; 1
     dd8:	99 23       	and	r25, r25
     dda:	09 f4       	brne	.+2      	; 0xdde <_ZN6myTime13checkValidityEv+0x66>
     ddc:	80 e0       	ldi	r24, 0x00	; 0
     dde:	88 23       	and	r24, r24
     de0:	11 f0       	breq	.+4      	; 0xde6 <_ZN6myTime13checkValidityEv+0x6e>
     de2:	81 e0       	ldi	r24, 0x01	; 1
     de4:	01 c0       	rjmp	.+2      	; 0xde8 <_ZN6myTime13checkValidityEv+0x70>
	}
	return fFalse;
     de6:	80 e0       	ldi	r24, 0x00	; 0
}
     de8:	0f 90       	pop	r0
     dea:	0f 90       	pop	r0
     dec:	0f 90       	pop	r0
     dee:	df 91       	pop	r29
     df0:	cf 91       	pop	r28
     df2:	08 95       	ret

00000df4 <_ZN6myTime7getTimeEv>:

const char * myTime::getTime(){
     df4:	cf 93       	push	r28
     df6:	df 93       	push	r29
     df8:	cd b7       	in	r28, 0x3d	; 61
     dfa:	de b7       	in	r29, 0x3e	; 62
     dfc:	2b 97       	sbiw	r28, 0x0b	; 11
     dfe:	0f b6       	in	r0, 0x3f	; 63
     e00:	f8 94       	cli
     e02:	de bf       	out	0x3e, r29	; 62
     e04:	0f be       	out	0x3f, r0	; 63
     e06:	cd bf       	out	0x3d, r28	; 61
     e08:	9b 87       	std	Y+11, r25	; 0x0b
     e0a:	8a 87       	std	Y+10, r24	; 0x0a
	char hourString[3], minuteString[3],secondString[3];
	itoa(hour,hourString,10);
     e0c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e0e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e10:	fc 01       	movw	r30, r24
     e12:	87 89       	ldd	r24, Z+23	; 0x17
     e14:	90 8d       	ldd	r25, Z+24	; 0x18
     e16:	9e 01       	movw	r18, r28
     e18:	2f 5f       	subi	r18, 0xFF	; 255
     e1a:	3f 4f       	sbci	r19, 0xFF	; 255
     e1c:	b9 01       	movw	r22, r18
     e1e:	4a e0       	ldi	r20, 0x0A	; 10
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <itoa>
	itoa(minute,minuteString,10);
     e26:	8a 85       	ldd	r24, Y+10	; 0x0a
     e28:	9b 85       	ldd	r25, Y+11	; 0x0b
     e2a:	fc 01       	movw	r30, r24
     e2c:	81 8d       	ldd	r24, Z+25	; 0x19
     e2e:	92 8d       	ldd	r25, Z+26	; 0x1a
     e30:	9e 01       	movw	r18, r28
     e32:	2c 5f       	subi	r18, 0xFC	; 252
     e34:	3f 4f       	sbci	r19, 0xFF	; 255
     e36:	b9 01       	movw	r22, r18
     e38:	4a e0       	ldi	r20, 0x0A	; 10
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <itoa>
	itoa(second,secondString,10);
     e40:	8a 85       	ldd	r24, Y+10	; 0x0a
     e42:	9b 85       	ldd	r25, Y+11	; 0x0b
     e44:	fc 01       	movw	r30, r24
     e46:	83 8d       	ldd	r24, Z+27	; 0x1b
     e48:	94 8d       	ldd	r25, Z+28	; 0x1c
     e4a:	9e 01       	movw	r18, r28
     e4c:	29 5f       	subi	r18, 0xF9	; 249
     e4e:	3f 4f       	sbci	r19, 0xFF	; 255
     e50:	b9 01       	movw	r22, r18
     e52:	4a e0       	ldi	r20, 0x0A	; 10
     e54:	50 e0       	ldi	r21, 0x00	; 0
     e56:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <itoa>
	strcpy(timeString,hourString);
     e5a:	8a 85       	ldd	r24, Y+10	; 0x0a
     e5c:	9b 85       	ldd	r25, Y+11	; 0x0b
     e5e:	4d 96       	adiw	r24, 0x1d	; 29
     e60:	9e 01       	movw	r18, r28
     e62:	2f 5f       	subi	r18, 0xFF	; 255
     e64:	3f 4f       	sbci	r19, 0xFF	; 255
     e66:	b9 01       	movw	r22, r18
     e68:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <strcpy>
	strcat(timeString,":");
     e6c:	8a 85       	ldd	r24, Y+10	; 0x0a
     e6e:	9b 85       	ldd	r25, Y+11	; 0x0b
     e70:	9c 01       	movw	r18, r24
     e72:	23 5e       	subi	r18, 0xE3	; 227
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	c9 01       	movw	r24, r18
     e78:	ac 01       	movw	r20, r24
     e7a:	fa 01       	movw	r30, r20
     e7c:	01 90       	ld	r0, Z+
     e7e:	00 20       	and	r0, r0
     e80:	e9 f7       	brne	.-6      	; 0xe7c <_ZN6myTime7getTimeEv+0x88>
     e82:	cf 01       	movw	r24, r30
     e84:	01 97       	sbiw	r24, 0x01	; 1
     e86:	84 1b       	sub	r24, r20
     e88:	95 0b       	sbc	r25, r21
     e8a:	82 0f       	add	r24, r18
     e8c:	93 1f       	adc	r25, r19
     e8e:	2a e3       	ldi	r18, 0x3A	; 58
     e90:	30 e0       	ldi	r19, 0x00	; 0
     e92:	fc 01       	movw	r30, r24
     e94:	31 83       	std	Z+1, r19	; 0x01
     e96:	20 83       	st	Z, r18
	strcat(timeString,minuteString);
     e98:	8a 85       	ldd	r24, Y+10	; 0x0a
     e9a:	9b 85       	ldd	r25, Y+11	; 0x0b
     e9c:	4d 96       	adiw	r24, 0x1d	; 29
     e9e:	9e 01       	movw	r18, r28
     ea0:	2c 5f       	subi	r18, 0xFC	; 252
     ea2:	3f 4f       	sbci	r19, 0xFF	; 255
     ea4:	b9 01       	movw	r22, r18
     ea6:	0e 94 30 1d 	call	0x3a60	; 0x3a60 <strcat>
	strcat(timeString,":");
     eaa:	8a 85       	ldd	r24, Y+10	; 0x0a
     eac:	9b 85       	ldd	r25, Y+11	; 0x0b
     eae:	9c 01       	movw	r18, r24
     eb0:	23 5e       	subi	r18, 0xE3	; 227
     eb2:	3f 4f       	sbci	r19, 0xFF	; 255
     eb4:	c9 01       	movw	r24, r18
     eb6:	ac 01       	movw	r20, r24
     eb8:	fa 01       	movw	r30, r20
     eba:	01 90       	ld	r0, Z+
     ebc:	00 20       	and	r0, r0
     ebe:	e9 f7       	brne	.-6      	; 0xeba <_ZN6myTime7getTimeEv+0xc6>
     ec0:	cf 01       	movw	r24, r30
     ec2:	01 97       	sbiw	r24, 0x01	; 1
     ec4:	84 1b       	sub	r24, r20
     ec6:	95 0b       	sbc	r25, r21
     ec8:	82 0f       	add	r24, r18
     eca:	93 1f       	adc	r25, r19
     ecc:	2a e3       	ldi	r18, 0x3A	; 58
     ece:	30 e0       	ldi	r19, 0x00	; 0
     ed0:	fc 01       	movw	r30, r24
     ed2:	31 83       	std	Z+1, r19	; 0x01
     ed4:	20 83       	st	Z, r18
	strcat(timeString,secondString);
     ed6:	8a 85       	ldd	r24, Y+10	; 0x0a
     ed8:	9b 85       	ldd	r25, Y+11	; 0x0b
     eda:	4d 96       	adiw	r24, 0x1d	; 29
     edc:	9e 01       	movw	r18, r28
     ede:	29 5f       	subi	r18, 0xF9	; 249
     ee0:	3f 4f       	sbci	r19, 0xFF	; 255
     ee2:	b9 01       	movw	r22, r18
     ee4:	0e 94 30 1d 	call	0x3a60	; 0x3a60 <strcat>
	timeString[11] = '\0';
     ee8:	8a 85       	ldd	r24, Y+10	; 0x0a
     eea:	9b 85       	ldd	r25, Y+11	; 0x0b
     eec:	fc 01       	movw	r30, r24
     eee:	10 a6       	lds	r17, 0xb0
	return timeString;
     ef0:	8a 85       	ldd	r24, Y+10	; 0x0a
     ef2:	9b 85       	ldd	r25, Y+11	; 0x0b
     ef4:	4d 96       	adiw	r24, 0x1d	; 29
     ef6:	2b 96       	adiw	r28, 0x0b	; 11
     ef8:	0f b6       	in	r0, 0x3f	; 63
     efa:	f8 94       	cli
     efc:	de bf       	out	0x3e, r29	; 62
     efe:	0f be       	out	0x3f, r0	; 63
     f00:	cd bf       	out	0x3d, r28	; 61
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <_Z18getDateTime_eepromhh>:
BYTE EEMEM eeDay = 8;
WORD EEMEM eeYear = 2013;


/*************************************************************************************************************/
void getDateTime_eeprom(BOOL gTime, BOOL gDate){			//get date and time from EEPROM
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	cd b7       	in	r28, 0x3d	; 61
     f0e:	de b7       	in	r29, 0x3e	; 62
     f10:	2f 97       	sbiw	r28, 0x0f	; 15
     f12:	0f b6       	in	r0, 0x3f	; 63
     f14:	f8 94       	cli
     f16:	de bf       	out	0x3e, r29	; 62
     f18:	0f be       	out	0x3f, r0	; 63
     f1a:	cd bf       	out	0x3d, r28	; 61
     f1c:	8e 87       	std	Y+14, r24	; 0x0e
     f1e:	6f 87       	std	Y+15, r22	; 0x0f
	cli();
     f20:	f8 94       	cli
	if (gTime){
     f22:	8e 85       	ldd	r24, Y+14	; 0x0e
     f24:	88 23       	and	r24, r24
     f26:	09 f4       	brne	.+2      	; 0xf2a <_Z18getDateTime_eepromhh+0x22>
     f28:	4b c0       	rjmp	.+150    	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
		BYTE tempMin, tempSec, tempHour;
		int times=0;
     f2a:	1a 82       	std	Y+2, r1	; 0x02
     f2c:	19 82       	std	Y+1, r1	; 0x01
		BOOL notGood=fTrue;
     f2e:	81 e0       	ldi	r24, 0x01	; 1
     f30:	8b 83       	std	Y+3, r24	; 0x03
		while(notGood && times<3){
     f32:	2c c0       	rjmp	.+88     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			tempSec = eeprom_read_byte(&eeSecond);
     f34:	82 e0       	ldi	r24, 0x02	; 2
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <__eerd_byte_m644pa>
     f3c:	8f 83       	std	Y+7, r24	; 0x07
			tempMin = eeprom_read_byte(&eeMinute);
     f3e:	81 e0       	ldi	r24, 0x01	; 1
     f40:	90 e0       	ldi	r25, 0x00	; 0
     f42:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <__eerd_byte_m644pa>
     f46:	88 87       	std	Y+8, r24	; 0x08
			tempHour = eeprom_read_byte(&eeHour);
     f48:	80 e0       	ldi	r24, 0x00	; 0
     f4a:	90 e0       	ldi	r25, 0x00	; 0
     f4c:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <__eerd_byte_m644pa>
     f50:	89 87       	std	Y+9, r24	; 0x09
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
     f52:	8f 81       	ldd	r24, Y+7	; 0x07
     f54:	8c 33       	cpi	r24, 0x3C	; 60
     f56:	a8 f4       	brcc	.+42     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f58:	88 85       	ldd	r24, Y+8	; 0x08
     f5a:	8c 33       	cpi	r24, 0x3C	; 60
     f5c:	90 f4       	brcc	.+36     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f5e:	89 85       	ldd	r24, Y+9	; 0x09
     f60:	88 31       	cpi	r24, 0x18	; 24
     f62:	78 f4       	brcc	.+30     	; 0xf82 <_Z18getDateTime_eepromhh+0x7a>
     f64:	89 85       	ldd	r24, Y+9	; 0x09
     f66:	68 2f       	mov	r22, r24
     f68:	70 e0       	ldi	r23, 0x00	; 0
     f6a:	88 85       	ldd	r24, Y+8	; 0x08
     f6c:	48 2f       	mov	r20, r24
     f6e:	50 e0       	ldi	r21, 0x00	; 0
     f70:	8f 81       	ldd	r24, Y+7	; 0x07
     f72:	28 2f       	mov	r18, r24
     f74:	30 e0       	ldi	r19, 0x00	; 0
     f76:	84 ee       	ldi	r24, 0xE4	; 228
     f78:	91 e0       	ldi	r25, 0x01	; 1
     f7a:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
     f7e:	1b 82       	std	Y+3, r1	; 0x03
     f80:	05 c0       	rjmp	.+10     	; 0xf8c <_Z18getDateTime_eepromhh+0x84>
			else {times++;}
     f82:	89 81       	ldd	r24, Y+1	; 0x01
     f84:	9a 81       	ldd	r25, Y+2	; 0x02
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	9a 83       	std	Y+2, r25	; 0x02
     f8a:	89 83       	std	Y+1, r24	; 0x01
	cli();
	if (gTime){
		BYTE tempMin, tempSec, tempHour;
		int times=0;
		BOOL notGood=fTrue;
		while(notGood && times<3){
     f8c:	8b 81       	ldd	r24, Y+3	; 0x03
     f8e:	88 23       	and	r24, r24
     f90:	39 f0       	breq	.+14     	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f92:	89 81       	ldd	r24, Y+1	; 0x01
     f94:	9a 81       	ldd	r25, Y+2	; 0x02
     f96:	83 30       	cpi	r24, 0x03	; 3
     f98:	91 05       	cpc	r25, r1
     f9a:	14 f4       	brge	.+4      	; 0xfa0 <_Z18getDateTime_eepromhh+0x98>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	01 c0       	rjmp	.+2      	; 0xfa2 <_Z18getDateTime_eepromhh+0x9a>
     fa0:	80 e0       	ldi	r24, 0x00	; 0
     fa2:	88 23       	and	r24, r24
     fa4:	39 f6       	brne	.-114    	; 0xf34 <_Z18getDateTime_eepromhh+0x2c>
			tempMin = eeprom_read_byte(&eeMinute);
			tempHour = eeprom_read_byte(&eeHour);
			if (tempSec/60==0 && tempMin/60==0 && tempHour/24==0){currentTime.setTime((int)tempHour,(int)tempMin,(int)tempSec); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setTime(1,1,1);}
     fa6:	8b 81       	ldd	r24, Y+3	; 0x03
     fa8:	88 23       	and	r24, r24
     faa:	51 f0       	breq	.+20     	; 0xfc0 <_Z18getDateTime_eepromhh+0xb8>
     fac:	84 ee       	ldi	r24, 0xE4	; 228
     fae:	91 e0       	ldi	r25, 0x01	; 1
     fb0:	61 e0       	ldi	r22, 0x01	; 1
     fb2:	70 e0       	ldi	r23, 0x00	; 0
     fb4:	41 e0       	ldi	r20, 0x01	; 1
     fb6:	50 e0       	ldi	r21, 0x00	; 0
     fb8:	21 e0       	ldi	r18, 0x01	; 1
     fba:	30 e0       	ldi	r19, 0x00	; 0
     fbc:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
	}		
	if (gDate){
     fc0:	8f 85       	ldd	r24, Y+15	; 0x0f
     fc2:	88 23       	and	r24, r24
     fc4:	09 f4       	brne	.+2      	; 0xfc8 <_Z18getDateTime_eepromhh+0xc0>
     fc6:	4e c0       	rjmp	.+156    	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
     fc8:	1d 82       	std	Y+5, r1	; 0x05
     fca:	1c 82       	std	Y+4, r1	; 0x04
		BOOL notGood=fTrue;
     fcc:	81 e0       	ldi	r24, 0x01	; 1
     fce:	8e 83       	std	Y+6, r24	; 0x06
		while (notGood && times<3){
     fd0:	2f c0       	rjmp	.+94     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			tempDay = eeprom_read_byte(&eeDay);
     fd2:	84 e0       	ldi	r24, 0x04	; 4
     fd4:	90 e0       	ldi	r25, 0x00	; 0
     fd6:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <__eerd_byte_m644pa>
     fda:	8a 87       	std	Y+10, r24	; 0x0a
			tempMonth = eeprom_read_byte(&eeMonth);
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 98 1d 	call	0x3b30	; 0x3b30 <__eerd_byte_m644pa>
     fe4:	8b 87       	std	Y+11, r24	; 0x0b
			tempYear = eeprom_read_word(&eeYear);
     fe6:	85 e0       	ldi	r24, 0x05	; 5
     fe8:	90 e0       	ldi	r25, 0x00	; 0
     fea:	0e 94 a0 1d 	call	0x3b40	; 0x3b40 <__eerd_word_m644pa>
     fee:	9d 87       	std	Y+13, r25	; 0x0d
     ff0:	8c 87       	std	Y+12, r24	; 0x0c
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
     ff2:	8a 85       	ldd	r24, Y+10	; 0x0a
     ff4:	8f 31       	cpi	r24, 0x1F	; 31
     ff6:	b8 f4       	brcc	.+46     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ff8:	8b 85       	ldd	r24, Y+11	; 0x0b
     ffa:	8d 30       	cpi	r24, 0x0D	; 13
     ffc:	a0 f4       	brcc	.+40     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
     ffe:	8c 85       	ldd	r24, Y+12	; 0x0c
    1000:	9d 85       	ldd	r25, Y+13	; 0x0d
    1002:	27 e2       	ldi	r18, 0x27	; 39
    1004:	80 31       	cpi	r24, 0x10	; 16
    1006:	92 07       	cpc	r25, r18
    1008:	70 f4       	brcc	.+28     	; 0x1026 <_Z18getDateTime_eepromhh+0x11e>
    100a:	8b 85       	ldd	r24, Y+11	; 0x0b
    100c:	68 2f       	mov	r22, r24
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	8a 85       	ldd	r24, Y+10	; 0x0a
    1012:	48 2f       	mov	r20, r24
    1014:	50 e0       	ldi	r21, 0x00	; 0
    1016:	2c 85       	ldd	r18, Y+12	; 0x0c
    1018:	3d 85       	ldd	r19, Y+13	; 0x0d
    101a:	84 ee       	ldi	r24, 0xE4	; 228
    101c:	91 e0       	ldi	r25, 0x01	; 1
    101e:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
    1022:	1e 82       	std	Y+6, r1	; 0x06
    1024:	05 c0       	rjmp	.+10     	; 0x1030 <_Z18getDateTime_eepromhh+0x128>
			else {times++;}
    1026:	8c 81       	ldd	r24, Y+4	; 0x04
    1028:	9d 81       	ldd	r25, Y+5	; 0x05
    102a:	01 96       	adiw	r24, 0x01	; 1
    102c:	9d 83       	std	Y+5, r25	; 0x05
    102e:	8c 83       	std	Y+4, r24	; 0x04
	if (gDate){
		BYTE tempDay,tempMonth;
		WORD tempYear;
		int times=0;
		BOOL notGood=fTrue;
		while (notGood && times<3){
    1030:	8e 81       	ldd	r24, Y+6	; 0x06
    1032:	88 23       	and	r24, r24
    1034:	39 f0       	breq	.+14     	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1036:	8c 81       	ldd	r24, Y+4	; 0x04
    1038:	9d 81       	ldd	r25, Y+5	; 0x05
    103a:	83 30       	cpi	r24, 0x03	; 3
    103c:	91 05       	cpc	r25, r1
    103e:	14 f4       	brge	.+4      	; 0x1044 <_Z18getDateTime_eepromhh+0x13c>
    1040:	81 e0       	ldi	r24, 0x01	; 1
    1042:	01 c0       	rjmp	.+2      	; 0x1046 <_Z18getDateTime_eepromhh+0x13e>
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	88 23       	and	r24, r24
    1048:	21 f6       	brne	.-120    	; 0xfd2 <_Z18getDateTime_eepromhh+0xca>
			tempMonth = eeprom_read_byte(&eeMonth);
			tempYear = eeprom_read_word(&eeYear);
			if (tempDay/31==0 && tempMonth/13==0 && tempYear/10000==0){currentTime.setDate((int)tempMonth,(int)tempDay,(int)tempYear); notGood=fFalse;}
			else {times++;}
		}
		if (notGood){currentTime.setDate(1,1,2001);}	
    104a:	8e 81       	ldd	r24, Y+6	; 0x06
    104c:	88 23       	and	r24, r24
    104e:	51 f0       	breq	.+20     	; 0x1064 <_Z18getDateTime_eepromhh+0x15c>
    1050:	84 ee       	ldi	r24, 0xE4	; 228
    1052:	91 e0       	ldi	r25, 0x01	; 1
    1054:	61 e0       	ldi	r22, 0x01	; 1
    1056:	70 e0       	ldi	r23, 0x00	; 0
    1058:	41 e0       	ldi	r20, 0x01	; 1
    105a:	50 e0       	ldi	r21, 0x00	; 0
    105c:	21 ed       	ldi	r18, 0xD1	; 209
    105e:	37 e0       	ldi	r19, 0x07	; 7
    1060:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
	}
	sei();
    1064:	78 94       	sei
}
    1066:	2f 96       	adiw	r28, 0x0f	; 15
    1068:	0f b6       	in	r0, 0x3f	; 63
    106a:	f8 94       	cli
    106c:	de bf       	out	0x3e, r29	; 62
    106e:	0f be       	out	0x3f, r0	; 63
    1070:	cd bf       	out	0x3d, r28	; 61
    1072:	df 91       	pop	r29
    1074:	cf 91       	pop	r28
    1076:	08 95       	ret

00001078 <_Z19saveDateTime_eepromhh>:
/*************************************************************************************************************/

void saveDateTime_eeprom(BOOL sTime, BOOL sDate){
    1078:	cf 93       	push	r28
    107a:	df 93       	push	r29
    107c:	cd b7       	in	r28, 0x3d	; 61
    107e:	de b7       	in	r29, 0x3e	; 62
    1080:	29 97       	sbiw	r28, 0x09	; 9
    1082:	0f b6       	in	r0, 0x3f	; 63
    1084:	f8 94       	cli
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	0f be       	out	0x3f, r0	; 63
    108a:	cd bf       	out	0x3d, r28	; 61
    108c:	88 87       	std	Y+8, r24	; 0x08
    108e:	69 87       	std	Y+9, r22	; 0x09
	cli();
    1090:	f8 94       	cli
	if (sTime){
    1092:	88 85       	ldd	r24, Y+8	; 0x08
    1094:	88 23       	and	r24, r24
    1096:	f1 f0       	breq	.+60     	; 0x10d4 <_Z19saveDateTime_eepromhh+0x5c>
		BYTE tempSec,tempMin,tempHour;
		tempHour = currentTime.getHours();
    1098:	84 ee       	ldi	r24, 0xE4	; 228
    109a:	91 e0       	ldi	r25, 0x01	; 1
    109c:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    10a0:	89 83       	std	Y+1, r24	; 0x01
		tempMin = currentTime.getMinutes();
    10a2:	84 ee       	ldi	r24, 0xE4	; 228
    10a4:	91 e0       	ldi	r25, 0x01	; 1
    10a6:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    10aa:	8a 83       	std	Y+2, r24	; 0x02
		tempSec = currentTime.getSeconds();
    10ac:	84 ee       	ldi	r24, 0xE4	; 228
    10ae:	91 e0       	ldi	r25, 0x01	; 1
    10b0:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    10b4:	8b 83       	std	Y+3, r24	; 0x03
		eeprom_write_byte(&eeSecond,tempSec);
    10b6:	82 e0       	ldi	r24, 0x02	; 2
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	6b 81       	ldd	r22, Y+3	; 0x03
    10bc:	0e 94 a6 1d 	call	0x3b4c	; 0x3b4c <__eewr_byte_m644pa>
		eeprom_write_byte(&eeMinute,tempMin);
    10c0:	81 e0       	ldi	r24, 0x01	; 1
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	6a 81       	ldd	r22, Y+2	; 0x02
    10c6:	0e 94 a6 1d 	call	0x3b4c	; 0x3b4c <__eewr_byte_m644pa>
		eeprom_write_byte(&eeHour,tempHour);
    10ca:	80 e0       	ldi	r24, 0x00	; 0
    10cc:	90 e0       	ldi	r25, 0x00	; 0
    10ce:	69 81       	ldd	r22, Y+1	; 0x01
    10d0:	0e 94 a6 1d 	call	0x3b4c	; 0x3b4c <__eewr_byte_m644pa>
	}
	if (sDate){
    10d4:	89 85       	ldd	r24, Y+9	; 0x09
    10d6:	88 23       	and	r24, r24
    10d8:	09 f1       	breq	.+66     	; 0x111c <__stack+0x1d>
		BYTE tempDay,tempMonth;
		WORD tempYear;
		tempYear = currentTime.getYears();
    10da:	84 ee       	ldi	r24, 0xE4	; 228
    10dc:	91 e0       	ldi	r25, 0x01	; 1
    10de:	0e 94 ba 00 	call	0x174	; 0x174 <_ZN6myDate8getYearsEv>
    10e2:	9d 83       	std	Y+5, r25	; 0x05
    10e4:	8c 83       	std	Y+4, r24	; 0x04
		tempMonth = currentTime.getMonths();
    10e6:	84 ee       	ldi	r24, 0xE4	; 228
    10e8:	91 e0       	ldi	r25, 0x01	; 1
    10ea:	0e 94 a9 00 	call	0x152	; 0x152 <_ZN6myDate9getMonthsEv>
    10ee:	8e 83       	std	Y+6, r24	; 0x06
		tempDay = currentTime.getDays();
    10f0:	84 ee       	ldi	r24, 0xE4	; 228
    10f2:	91 e0       	ldi	r25, 0x01	; 1
    10f4:	0e 94 cb 00 	call	0x196	; 0x196 <_ZN6myDate7getDaysEv>
    10f8:	8f 83       	std	Y+7, r24	; 0x07
		eeprom_write_word(&eeYear,tempYear);
    10fa:	85 e0       	ldi	r24, 0x05	; 5
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1100:	3d 81       	ldd	r19, Y+5	; 0x05
    1102:	b9 01       	movw	r22, r18
    1104:	0e 94 b4 1d 	call	0x3b68	; 0x3b68 <__eewr_word_m644pa>
		eeprom_write_byte(&eeMonth,tempMonth);
    1108:	83 e0       	ldi	r24, 0x03	; 3
    110a:	90 e0       	ldi	r25, 0x00	; 0
    110c:	6e 81       	ldd	r22, Y+6	; 0x06
    110e:	0e 94 a6 1d 	call	0x3b4c	; 0x3b4c <__eewr_byte_m644pa>
		eeprom_write_byte(&eeDay,tempDay);
    1112:	84 e0       	ldi	r24, 0x04	; 4
    1114:	90 e0       	ldi	r25, 0x00	; 0
    1116:	6f 81       	ldd	r22, Y+7	; 0x07
    1118:	0e 94 a6 1d 	call	0x3b4c	; 0x3b4c <__eewr_byte_m644pa>
	}
	sei();
    111c:	78 94       	sei
}
    111e:	29 96       	adiw	r28, 0x09	; 9
    1120:	0f b6       	in	r0, 0x3f	; 63
    1122:	f8 94       	cli
    1124:	de bf       	out	0x3e, r29	; 62
    1126:	0f be       	out	0x3f, r0	; 63
    1128:	cd bf       	out	0x3d, r28	; 61
    112a:	df 91       	pop	r29
    112c:	cf 91       	pop	r28
    112e:	08 95       	ret

00001130 <_Z8Wait_seci>:
extern WORD globalADC, globalTemp;
extern myTime currentTime;


/************************************************************************************************************/
void Wait_sec(int sec){
    1130:	cf 93       	push	r28
    1132:	df 93       	push	r29
    1134:	00 d0       	rcall	.+0      	; 0x1136 <_Z8Wait_seci+0x6>
    1136:	00 d0       	rcall	.+0      	; 0x1138 <_Z8Wait_seci+0x8>
    1138:	00 d0       	rcall	.+0      	; 0x113a <_Z8Wait_seci+0xa>
    113a:	cd b7       	in	r28, 0x3d	; 61
    113c:	de b7       	in	r29, 0x3e	; 62
    113e:	9e 83       	std	Y+6, r25	; 0x06
    1140:	8d 83       	std	Y+5, r24	; 0x05
	volatile int startingTime = currentTime.getSeconds();
    1142:	84 ee       	ldi	r24, 0xE4	; 228
    1144:	91 e0       	ldi	r25, 0x01	; 1
    1146:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    114a:	88 2f       	mov	r24, r24
    114c:	90 e0       	ldi	r25, 0x00	; 0
    114e:	9a 83       	std	Y+2, r25	; 0x02
    1150:	89 83       	std	Y+1, r24	; 0x01
	volatile int endingTime= (startingTime+sec)%60;
    1152:	29 81       	ldd	r18, Y+1	; 0x01
    1154:	3a 81       	ldd	r19, Y+2	; 0x02
    1156:	8d 81       	ldd	r24, Y+5	; 0x05
    1158:	9e 81       	ldd	r25, Y+6	; 0x06
    115a:	82 0f       	add	r24, r18
    115c:	93 1f       	adc	r25, r19
    115e:	2c e3       	ldi	r18, 0x3C	; 60
    1160:	30 e0       	ldi	r19, 0x00	; 0
    1162:	b9 01       	movw	r22, r18
    1164:	0e 94 e5 1c 	call	0x39ca	; 0x39ca <__divmodhi4>
    1168:	9c 83       	std	Y+4, r25	; 0x04
    116a:	8b 83       	std	Y+3, r24	; 0x03
while (currentTime.getSeconds() != endingTime){asm volatile ("nop");}
    116c:	01 c0       	rjmp	.+2      	; 0x1170 <_Z8Wait_seci+0x40>
    116e:	00 00       	nop
    1170:	84 ee       	ldi	r24, 0xE4	; 228
    1172:	91 e0       	ldi	r25, 0x01	; 1
    1174:	0e 94 94 04 	call	0x928	; 0x928 <_ZN6myTime10getSecondsEv>
    1178:	28 2f       	mov	r18, r24
    117a:	30 e0       	ldi	r19, 0x00	; 0
    117c:	8b 81       	ldd	r24, Y+3	; 0x03
    117e:	9c 81       	ldd	r25, Y+4	; 0x04
    1180:	41 e0       	ldi	r20, 0x01	; 1
    1182:	28 17       	cp	r18, r24
    1184:	39 07       	cpc	r19, r25
    1186:	09 f4       	brne	.+2      	; 0x118a <_Z8Wait_seci+0x5a>
    1188:	40 e0       	ldi	r20, 0x00	; 0
    118a:	44 23       	and	r20, r20
    118c:	81 f7       	brne	.-32     	; 0x116e <_Z8Wait_seci+0x3e>
}
    118e:	26 96       	adiw	r28, 0x06	; 6
    1190:	0f b6       	in	r0, 0x3f	; 63
    1192:	f8 94       	cli
    1194:	de bf       	out	0x3e, r29	; 62
    1196:	0f be       	out	0x3f, r0	; 63
    1198:	cd bf       	out	0x3d, r28	; 61
    119a:	df 91       	pop	r29
    119c:	cf 91       	pop	r28
    119e:	08 95       	ret

000011a0 <_Z7Wait_msi>:
/************************************************************************************************************/
void Wait_ms(int delay)
{
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
    11a4:	00 d0       	rcall	.+0      	; 0x11a6 <_Z7Wait_msi+0x6>
    11a6:	00 d0       	rcall	.+0      	; 0x11a8 <_Z7Wait_msi+0x8>
    11a8:	cd b7       	in	r28, 0x3d	; 61
    11aa:	de b7       	in	r29, 0x3e	; 62
    11ac:	9c 83       	std	Y+4, r25	; 0x04
    11ae:	8b 83       	std	Y+3, r24	; 0x03
	volatile int i;

	while(delay > 0){
    11b0:	17 c0       	rjmp	.+46     	; 0x11e0 <_Z7Wait_msi+0x40>
		for(i = 0; i < 200; i++){
    11b2:	1a 82       	std	Y+2, r1	; 0x02
    11b4:	19 82       	std	Y+1, r1	; 0x01
    11b6:	06 c0       	rjmp	.+12     	; 0x11c4 <_Z7Wait_msi+0x24>
			asm volatile("nop");
    11b8:	00 00       	nop
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
		for(i = 0; i < 200; i++){
    11ba:	89 81       	ldd	r24, Y+1	; 0x01
    11bc:	9a 81       	ldd	r25, Y+2	; 0x02
    11be:	01 96       	adiw	r24, 0x01	; 1
    11c0:	9a 83       	std	Y+2, r25	; 0x02
    11c2:	89 83       	std	Y+1, r24	; 0x01
    11c4:	89 81       	ldd	r24, Y+1	; 0x01
    11c6:	9a 81       	ldd	r25, Y+2	; 0x02
    11c8:	21 e0       	ldi	r18, 0x01	; 1
    11ca:	88 3c       	cpi	r24, 0xC8	; 200
    11cc:	91 05       	cpc	r25, r1
    11ce:	0c f0       	brlt	.+2      	; 0x11d2 <_Z7Wait_msi+0x32>
    11d0:	20 e0       	ldi	r18, 0x00	; 0
    11d2:	22 23       	and	r18, r18
    11d4:	89 f7       	brne	.-30     	; 0x11b8 <_Z7Wait_msi+0x18>
			asm volatile("nop");
		}
		delay -= 1;
    11d6:	8b 81       	ldd	r24, Y+3	; 0x03
    11d8:	9c 81       	ldd	r25, Y+4	; 0x04
    11da:	01 97       	sbiw	r24, 0x01	; 1
    11dc:	9c 83       	std	Y+4, r25	; 0x04
    11de:	8b 83       	std	Y+3, r24	; 0x03
/************************************************************************************************************/
void Wait_ms(int delay)
{
	volatile int i;

	while(delay > 0){
    11e0:	21 e0       	ldi	r18, 0x01	; 1
    11e2:	8b 81       	ldd	r24, Y+3	; 0x03
    11e4:	9c 81       	ldd	r25, Y+4	; 0x04
    11e6:	18 16       	cp	r1, r24
    11e8:	19 06       	cpc	r1, r25
    11ea:	0c f0       	brlt	.+2      	; 0x11ee <_Z7Wait_msi+0x4e>
    11ec:	20 e0       	ldi	r18, 0x00	; 0
    11ee:	22 23       	and	r18, r18
    11f0:	01 f7       	brne	.-64     	; 0x11b2 <_Z7Wait_msi+0x12>
		for(i = 0; i < 200; i++){
			asm volatile("nop");
		}
		delay -= 1;
	}
}
    11f2:	0f 90       	pop	r0
    11f4:	0f 90       	pop	r0
    11f6:	0f 90       	pop	r0
    11f8:	0f 90       	pop	r0
    11fa:	df 91       	pop	r29
    11fc:	cf 91       	pop	r28
    11fe:	08 95       	ret

00001200 <_Z17SendInterruptGAVRv>:
/************************************************************************************************************/
void SendInterruptGAVR(){
    1200:	cf 93       	push	r28
    1202:	df 93       	push	r29
    1204:	00 d0       	rcall	.+0      	; 0x1206 <_Z17SendInterruptGAVRv+0x6>
    1206:	cd b7       	in	r28, 0x3d	; 61
    1208:	de b7       	in	r29, 0x3e	; 62
	//Raise interrupts to GAVR for three ish clock cycles. Tried waiting....didn't work.
	prtGAVRINT |= (1 << bnGAVRINT);
    120a:	85 e2       	ldi	r24, 0x25	; 37
    120c:	90 e0       	ldi	r25, 0x00	; 0
    120e:	25 e2       	ldi	r18, 0x25	; 37
    1210:	30 e0       	ldi	r19, 0x00	; 0
    1212:	f9 01       	movw	r30, r18
    1214:	20 81       	ld	r18, Z
    1216:	28 60       	ori	r18, 0x08	; 8
    1218:	fc 01       	movw	r30, r24
    121a:	20 83       	st	Z, r18
	for (int i=0; i<2; i++){asm ("nop");}
    121c:	1a 82       	std	Y+2, r1	; 0x02
    121e:	19 82       	std	Y+1, r1	; 0x01
    1220:	06 c0       	rjmp	.+12     	; 0x122e <_Z17SendInterruptGAVRv+0x2e>
    1222:	00 00       	nop
    1224:	89 81       	ldd	r24, Y+1	; 0x01
    1226:	9a 81       	ldd	r25, Y+2	; 0x02
    1228:	01 96       	adiw	r24, 0x01	; 1
    122a:	9a 83       	std	Y+2, r25	; 0x02
    122c:	89 83       	std	Y+1, r24	; 0x01
    122e:	21 e0       	ldi	r18, 0x01	; 1
    1230:	89 81       	ldd	r24, Y+1	; 0x01
    1232:	9a 81       	ldd	r25, Y+2	; 0x02
    1234:	82 30       	cpi	r24, 0x02	; 2
    1236:	91 05       	cpc	r25, r1
    1238:	0c f0       	brlt	.+2      	; 0x123c <_Z17SendInterruptGAVRv+0x3c>
    123a:	20 e0       	ldi	r18, 0x00	; 0
    123c:	22 23       	and	r18, r18
    123e:	89 f7       	brne	.-30     	; 0x1222 <_Z17SendInterruptGAVRv+0x22>
	prtGAVRINT &= ~(1 << bnGAVRINT);
    1240:	85 e2       	ldi	r24, 0x25	; 37
    1242:	90 e0       	ldi	r25, 0x00	; 0
    1244:	25 e2       	ldi	r18, 0x25	; 37
    1246:	30 e0       	ldi	r19, 0x00	; 0
    1248:	f9 01       	movw	r30, r18
    124a:	20 81       	ld	r18, Z
    124c:	27 7f       	andi	r18, 0xF7	; 247
    124e:	fc 01       	movw	r30, r24
    1250:	20 83       	st	Z, r18
}
    1252:	0f 90       	pop	r0
    1254:	0f 90       	pop	r0
    1256:	df 91       	pop	r29
    1258:	cf 91       	pop	r28
    125a:	08 95       	ret

0000125c <_Z13PutUartChBonec>:

/**************************************************************************************************************/
void PutUartChBone(char ch){
    125c:	cf 93       	push	r28
    125e:	df 93       	push	r29
    1260:	0f 92       	push	r0
    1262:	cd b7       	in	r28, 0x3d	; 61
    1264:	de b7       	in	r29, 0x3e	; 62
    1266:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR0A & (1 << UDRE0)));
    1268:	00 00       	nop
    126a:	80 ec       	ldi	r24, 0xC0	; 192
    126c:	90 e0       	ldi	r25, 0x00	; 0
    126e:	fc 01       	movw	r30, r24
    1270:	80 81       	ld	r24, Z
    1272:	88 2f       	mov	r24, r24
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	80 72       	andi	r24, 0x20	; 32
    1278:	90 70       	andi	r25, 0x00	; 0
    127a:	21 e0       	ldi	r18, 0x01	; 1
    127c:	00 97       	sbiw	r24, 0x00	; 0
    127e:	09 f0       	breq	.+2      	; 0x1282 <_Z13PutUartChBonec+0x26>
    1280:	20 e0       	ldi	r18, 0x00	; 0
    1282:	22 23       	and	r18, r18
    1284:	91 f7       	brne	.-28     	; 0x126a <_Z13PutUartChBonec+0xe>
	UDR0=ch;
    1286:	86 ec       	ldi	r24, 0xC6	; 198
    1288:	90 e0       	ldi	r25, 0x00	; 0
    128a:	29 81       	ldd	r18, Y+1	; 0x01
    128c:	fc 01       	movw	r30, r24
    128e:	20 83       	st	Z, r18
}
    1290:	0f 90       	pop	r0
    1292:	df 91       	pop	r29
    1294:	cf 91       	pop	r28
    1296:	08 95       	ret

00001298 <_Z9PrintBonePc>:
/*************************************************************************************************************/
void PrintBone(char string[]){
    1298:	cf 93       	push	r28
    129a:	df 93       	push	r29
    129c:	00 d0       	rcall	.+0      	; 0x129e <_Z9PrintBonePc+0x6>
    129e:	0f 92       	push	r0
    12a0:	cd b7       	in	r28, 0x3d	; 61
    12a2:	de b7       	in	r29, 0x3e	; 62
    12a4:	9b 83       	std	Y+3, r25	; 0x03
    12a6:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    12a8:	19 82       	std	Y+1, r1	; 0x01
	
	while (string[i]){
    12aa:	0e c0       	rjmp	.+28     	; 0x12c8 <_Z9PrintBonePc+0x30>
		PutUartChBone(string[i++]);
    12ac:	89 81       	ldd	r24, Y+1	; 0x01
    12ae:	88 2f       	mov	r24, r24
    12b0:	90 e0       	ldi	r25, 0x00	; 0
    12b2:	2a 81       	ldd	r18, Y+2	; 0x02
    12b4:	3b 81       	ldd	r19, Y+3	; 0x03
    12b6:	82 0f       	add	r24, r18
    12b8:	93 1f       	adc	r25, r19
    12ba:	fc 01       	movw	r30, r24
    12bc:	80 81       	ld	r24, Z
    12be:	99 81       	ldd	r25, Y+1	; 0x01
    12c0:	9f 5f       	subi	r25, 0xFF	; 255
    12c2:	99 83       	std	Y+1, r25	; 0x01
    12c4:	0e 94 2e 09 	call	0x125c	; 0x125c <_Z13PutUartChBonec>
}
/*************************************************************************************************************/
void PrintBone(char string[]){
	BYTE i=0;
	
	while (string[i]){
    12c8:	89 81       	ldd	r24, Y+1	; 0x01
    12ca:	88 2f       	mov	r24, r24
    12cc:	90 e0       	ldi	r25, 0x00	; 0
    12ce:	2a 81       	ldd	r18, Y+2	; 0x02
    12d0:	3b 81       	ldd	r19, Y+3	; 0x03
    12d2:	82 0f       	add	r24, r18
    12d4:	93 1f       	adc	r25, r19
    12d6:	fc 01       	movw	r30, r24
    12d8:	90 81       	ld	r25, Z
    12da:	81 e0       	ldi	r24, 0x01	; 1
    12dc:	99 23       	and	r25, r25
    12de:	09 f4       	brne	.+2      	; 0x12e2 <_Z9PrintBonePc+0x4a>
    12e0:	80 e0       	ldi	r24, 0x00	; 0
    12e2:	88 23       	and	r24, r24
    12e4:	19 f7       	brne	.-58     	; 0x12ac <_Z9PrintBonePc+0x14>
		PutUartChBone(string[i++]);
	}
}
    12e6:	0f 90       	pop	r0
    12e8:	0f 90       	pop	r0
    12ea:	0f 90       	pop	r0
    12ec:	df 91       	pop	r29
    12ee:	cf 91       	pop	r28
    12f0:	08 95       	ret

000012f2 <_Z13PutUartChGAVRc>:
/*************************************************************************************************************/

void PutUartChGAVR(char ch){
    12f2:	cf 93       	push	r28
    12f4:	df 93       	push	r29
    12f6:	0f 92       	push	r0
    12f8:	cd b7       	in	r28, 0x3d	; 61
    12fa:	de b7       	in	r29, 0x3e	; 62
    12fc:	89 83       	std	Y+1, r24	; 0x01
	while (!(UCSR1A & (1 << UDRE1)));
    12fe:	00 00       	nop
    1300:	88 ec       	ldi	r24, 0xC8	; 200
    1302:	90 e0       	ldi	r25, 0x00	; 0
    1304:	fc 01       	movw	r30, r24
    1306:	80 81       	ld	r24, Z
    1308:	88 2f       	mov	r24, r24
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	80 72       	andi	r24, 0x20	; 32
    130e:	90 70       	andi	r25, 0x00	; 0
    1310:	21 e0       	ldi	r18, 0x01	; 1
    1312:	00 97       	sbiw	r24, 0x00	; 0
    1314:	09 f0       	breq	.+2      	; 0x1318 <_Z13PutUartChGAVRc+0x26>
    1316:	20 e0       	ldi	r18, 0x00	; 0
    1318:	22 23       	and	r18, r18
    131a:	91 f7       	brne	.-28     	; 0x1300 <_Z13PutUartChGAVRc+0xe>
	UDR1=ch;
    131c:	8e ec       	ldi	r24, 0xCE	; 206
    131e:	90 e0       	ldi	r25, 0x00	; 0
    1320:	29 81       	ldd	r18, Y+1	; 0x01
    1322:	fc 01       	movw	r30, r24
    1324:	20 83       	st	Z, r18
}
    1326:	0f 90       	pop	r0
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	08 95       	ret

0000132e <_Z9PrintGAVRPc>:
/*************************************************************************************************************/

void PrintGAVR(char string[]){
    132e:	cf 93       	push	r28
    1330:	df 93       	push	r29
    1332:	00 d0       	rcall	.+0      	; 0x1334 <_Z9PrintGAVRPc+0x6>
    1334:	0f 92       	push	r0
    1336:	cd b7       	in	r28, 0x3d	; 61
    1338:	de b7       	in	r29, 0x3e	; 62
    133a:	9b 83       	std	Y+3, r25	; 0x03
    133c:	8a 83       	std	Y+2, r24	; 0x02
	BYTE i=0;
    133e:	19 82       	std	Y+1, r1	; 0x01
	while (string[i]){
    1340:	12 c0       	rjmp	.+36     	; 0x1366 <_Z9PrintGAVRPc+0x38>
		Wait_ms(350);
    1342:	8e e5       	ldi	r24, 0x5E	; 94
    1344:	91 e0       	ldi	r25, 0x01	; 1
    1346:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		PutUartChGAVR(string[i++]);
    134a:	89 81       	ldd	r24, Y+1	; 0x01
    134c:	88 2f       	mov	r24, r24
    134e:	90 e0       	ldi	r25, 0x00	; 0
    1350:	2a 81       	ldd	r18, Y+2	; 0x02
    1352:	3b 81       	ldd	r19, Y+3	; 0x03
    1354:	82 0f       	add	r24, r18
    1356:	93 1f       	adc	r25, r19
    1358:	fc 01       	movw	r30, r24
    135a:	80 81       	ld	r24, Z
    135c:	99 81       	ldd	r25, Y+1	; 0x01
    135e:	9f 5f       	subi	r25, 0xFF	; 255
    1360:	99 83       	std	Y+1, r25	; 0x01
    1362:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
}
/*************************************************************************************************************/

void PrintGAVR(char string[]){
	BYTE i=0;
	while (string[i]){
    1366:	89 81       	ldd	r24, Y+1	; 0x01
    1368:	88 2f       	mov	r24, r24
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	2a 81       	ldd	r18, Y+2	; 0x02
    136e:	3b 81       	ldd	r19, Y+3	; 0x03
    1370:	82 0f       	add	r24, r18
    1372:	93 1f       	adc	r25, r19
    1374:	fc 01       	movw	r30, r24
    1376:	90 81       	ld	r25, Z
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	99 23       	and	r25, r25
    137c:	09 f4       	brne	.+2      	; 0x1380 <_Z9PrintGAVRPc+0x52>
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	88 23       	and	r24, r24
    1382:	f9 f6       	brne	.-66     	; 0x1342 <_Z9PrintGAVRPc+0x14>
		Wait_ms(350);
		PutUartChGAVR(string[i++]);
	}
}
    1384:	0f 90       	pop	r0
    1386:	0f 90       	pop	r0
    1388:	0f 90       	pop	r0
    138a:	df 91       	pop	r29
    138c:	cf 91       	pop	r28
    138e:	08 95       	ret

00001390 <_Z8sendGAVRv>:
/*************************************************************************************************************/
void sendGAVR(){
    1390:	cf 93       	push	r28
    1392:	df 93       	push	r29
    1394:	cd b7       	in	r28, 0x3d	; 61
    1396:	de b7       	in	r29, 0x3e	; 62
    1398:	cb 55       	subi	r28, 0x5B	; 91
    139a:	d0 40       	sbci	r29, 0x00	; 0
    139c:	0f b6       	in	r0, 0x3f	; 63
    139e:	f8 94       	cli
    13a0:	de bf       	out	0x3e, r29	; 62
    13a2:	0f be       	out	0x3f, r0	; 63
    13a4:	cd bf       	out	0x3d, r28	; 61
	//Declare variables to be used.
	volatile static unsigned int state=0;
	volatile BOOL noCarriage=fTrue;
    13a6:	81 e0       	ldi	r24, 0x01	; 1
    13a8:	8b 87       	std	Y+11, r24	; 0x0b
	char recChar, recString[40], sentString[40];
	unsigned int strLoc=0;
    13aa:	1a 82       	std	Y+2, r1	; 0x02
    13ac:	19 82       	std	Y+1, r1	; 0x01
	
	//Set sending flag
	flagSendingGAVR=fTrue;
    13ae:	81 e0       	ldi	r24, 0x01	; 1
    13b0:	80 93 14 02 	sts	0x0214, r24
	
	//Transmission protocol
	while (flagSendingGAVR){
    13b4:	1c c2       	rjmp	.+1080   	; 0x17ee <_Z8sendGAVRv+0x45e>
		/* State 5: Successful transmission and reception. Kill sending flag, reset state, exit.					 */
		/* State 6: ACKBAD received, check to see if we have an invalid date/time in our clock or it was just noisy  */
		/*			and had error in transmission/reception. If valid, go to waiting state. Else exit and set flag.	 */
		/* State 7: Got the wrong ack for something, set a flag to let the WAVR do its thing then try again.		 */
		/*************************************************************************************************************/
		switch (state){
    13b6:	80 91 27 02 	lds	r24, 0x0227
    13ba:	90 91 28 02 	lds	r25, 0x0228
    13be:	83 30       	cpi	r24, 0x03	; 3
    13c0:	91 05       	cpc	r25, r1
    13c2:	09 f4       	brne	.+2      	; 0x13c6 <_Z8sendGAVRv+0x36>
    13c4:	00 c1       	rjmp	.+512    	; 0x15c6 <_Z8sendGAVRv+0x236>
    13c6:	84 30       	cpi	r24, 0x04	; 4
    13c8:	91 05       	cpc	r25, r1
    13ca:	48 f4       	brcc	.+18     	; 0x13de <_Z8sendGAVRv+0x4e>
    13cc:	81 30       	cpi	r24, 0x01	; 1
    13ce:	91 05       	cpc	r25, r1
    13d0:	09 f4       	brne	.+2      	; 0x13d4 <_Z8sendGAVRv+0x44>
    13d2:	78 c0       	rjmp	.+240    	; 0x14c4 <_Z8sendGAVRv+0x134>
    13d4:	82 30       	cpi	r24, 0x02	; 2
    13d6:	91 05       	cpc	r25, r1
    13d8:	08 f0       	brcs	.+2      	; 0x13dc <_Z8sendGAVRv+0x4c>
    13da:	82 c0       	rjmp	.+260    	; 0x14e0 <_Z8sendGAVRv+0x150>
    13dc:	0d c0       	rjmp	.+26     	; 0x13f8 <_Z8sendGAVRv+0x68>
    13de:	86 30       	cpi	r24, 0x06	; 6
    13e0:	91 05       	cpc	r25, r1
    13e2:	09 f4       	brne	.+2      	; 0x13e6 <_Z8sendGAVRv+0x56>
    13e4:	bc c1       	rjmp	.+888    	; 0x175e <_Z8sendGAVRv+0x3ce>
    13e6:	87 30       	cpi	r24, 0x07	; 7
    13e8:	91 05       	cpc	r25, r1
    13ea:	09 f4       	brne	.+2      	; 0x13ee <_Z8sendGAVRv+0x5e>
    13ec:	d1 c1       	rjmp	.+930    	; 0x1790 <_Z8sendGAVRv+0x400>
    13ee:	85 30       	cpi	r24, 0x05	; 5
    13f0:	91 05       	cpc	r25, r1
    13f2:	09 f4       	brne	.+2      	; 0x13f6 <_Z8sendGAVRv+0x66>
    13f4:	8b c1       	rjmp	.+790    	; 0x170c <_Z8sendGAVRv+0x37c>
    13f6:	f3 c1       	rjmp	.+998    	; 0x17de <_Z8sendGAVRv+0x44e>
			case 0: {
				SendInterruptGAVR();
    13f8:	0e 94 00 09 	call	0x1200	; 0x1200 <_Z17SendInterruptGAVRv>
				state=1;
    13fc:	81 e0       	ldi	r24, 0x01	; 1
    13fe:	90 e0       	ldi	r25, 0x00	; 0
    1400:	90 93 28 02 	sts	0x0228, r25
    1404:	80 93 27 02 	sts	0x0227, r24
				break;
    1408:	f2 c1       	rjmp	.+996    	; 0x17ee <_Z8sendGAVRv+0x45e>
			}//end case 0
			case 1: {
				//Wait for connection to set and something to come in.			
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					Wait_ms(50);				//wait for the register to start to load.
    140a:	82 e3       	ldi	r24, 0x32	; 50
    140c:	90 e0       	ldi	r25, 0x00	; 0
    140e:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
    1412:	00 00       	nop
    1414:	88 ec       	ldi	r24, 0xC8	; 200
    1416:	90 e0       	ldi	r25, 0x00	; 0
    1418:	fc 01       	movw	r30, r24
    141a:	80 81       	ld	r24, Z
    141c:	88 23       	and	r24, r24
    141e:	34 f0       	brlt	.+12     	; 0x142c <_Z8sendGAVRv+0x9c>
    1420:	80 91 14 02 	lds	r24, 0x0214
    1424:	88 23       	and	r24, r24
    1426:	11 f0       	breq	.+4      	; 0x142c <_Z8sendGAVRv+0x9c>
    1428:	81 e0       	ldi	r24, 0x01	; 1
    142a:	01 c0       	rjmp	.+2      	; 0x142e <_Z8sendGAVRv+0x9e>
    142c:	80 e0       	ldi	r24, 0x00	; 0
    142e:	88 23       	and	r24, r24
    1430:	89 f7       	brne	.-30     	; 0x1414 <_Z8sendGAVRv+0x84>
					if (!flagSendingGAVR){PrintBone("TimeoutSend");PrintBone(recString); break;}		//if timeout is why we broke, just exit
    1432:	80 91 14 02 	lds	r24, 0x0214
    1436:	88 23       	and	r24, r24
    1438:	51 f4       	brne	.+20     	; 0x144e <_Z8sendGAVRv+0xbe>
    143a:	80 e0       	ldi	r24, 0x00	; 0
    143c:	91 e0       	ldi	r25, 0x01	; 1
    143e:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1442:	ce 01       	movw	r24, r28
    1444:	c4 96       	adiw	r24, 0x34	; 52
    1446:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    144a:	00 00       	nop
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    144c:	d0 c1       	rjmp	.+928    	; 0x17ee <_Z8sendGAVRv+0x45e>
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
					Wait_ms(50);				//wait for the register to start to load.
					while (!(UCSR1A & (1 << RXC1)) && flagSendingGAVR);				//wait for next character
					if (!flagSendingGAVR){PrintBone("TimeoutSend");PrintBone(recString); break;}		//if timeout is why we broke, just exit
					recChar=UDR1;
    144e:	8e ec       	ldi	r24, 0xCE	; 206
    1450:	90 e0       	ldi	r25, 0x00	; 0
    1452:	fc 01       	movw	r30, r24
    1454:	80 81       	ld	r24, Z
    1456:	89 87       	std	Y+9, r24	; 0x09
					recString[strLoc++]=recChar;
    1458:	9e 01       	movw	r18, r28
    145a:	2c 5c       	subi	r18, 0xCC	; 204
    145c:	3f 4f       	sbci	r19, 0xFF	; 255
    145e:	89 81       	ldd	r24, Y+1	; 0x01
    1460:	9a 81       	ldd	r25, Y+2	; 0x02
    1462:	82 0f       	add	r24, r18
    1464:	93 1f       	adc	r25, r19
    1466:	29 85       	ldd	r18, Y+9	; 0x09
    1468:	fc 01       	movw	r30, r24
    146a:	20 83       	st	Z, r18
    146c:	89 81       	ldd	r24, Y+1	; 0x01
    146e:	9a 81       	ldd	r25, Y+2	; 0x02
    1470:	01 96       	adiw	r24, 0x01	; 1
    1472:	9a 83       	std	Y+2, r25	; 0x02
    1474:	89 83       	std	Y+1, r24	; 0x01
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
    1476:	89 85       	ldd	r24, Y+9	; 0x09
    1478:	8e 32       	cpi	r24, 0x2E	; 46
    147a:	b1 f4       	brne	.+44     	; 0x14a8 <_Z8sendGAVRv+0x118>
    147c:	9e 01       	movw	r18, r28
    147e:	2c 5c       	subi	r18, 0xCC	; 204
    1480:	3f 4f       	sbci	r19, 0xFF	; 255
    1482:	89 81       	ldd	r24, Y+1	; 0x01
    1484:	9a 81       	ldd	r25, Y+2	; 0x02
    1486:	82 0f       	add	r24, r18
    1488:	93 1f       	adc	r25, r19
    148a:	fc 01       	movw	r30, r24
    148c:	10 82       	st	Z, r1
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	9a 81       	ldd	r25, Y+2	; 0x02
    1492:	01 96       	adiw	r24, 0x01	; 1
    1494:	9a 83       	std	Y+2, r25	; 0x02
    1496:	89 83       	std	Y+1, r24	; 0x01
    1498:	82 e0       	ldi	r24, 0x02	; 2
    149a:	90 e0       	ldi	r25, 0x00	; 0
    149c:	90 93 28 02 	sts	0x0228, r25
    14a0:	80 93 27 02 	sts	0x0227, r24
    14a4:	1b 86       	std	Y+11, r1	; 0x0b
    14a6:	0e c0       	rjmp	.+28     	; 0x14c4 <_Z8sendGAVRv+0x134>
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
    14a8:	89 81       	ldd	r24, Y+1	; 0x01
    14aa:	9a 81       	ldd	r25, Y+2	; 0x02
    14ac:	87 32       	cpi	r24, 0x27	; 39
    14ae:	91 05       	cpc	r25, r1
    14b0:	48 f0       	brcs	.+18     	; 0x14c4 <_Z8sendGAVRv+0x134>
    14b2:	1a 82       	std	Y+2, r1	; 0x02
    14b4:	19 82       	std	Y+1, r1	; 0x01
    14b6:	1b 86       	std	Y+11, r1	; 0x0b
    14b8:	87 e0       	ldi	r24, 0x07	; 7
    14ba:	90 e0       	ldi	r25, 0x00	; 0
    14bc:	90 93 28 02 	sts	0x0228, r25
    14c0:	80 93 27 02 	sts	0x0227, r24
				break;
			}//end case 0
			case 1: {
				//Wait for connection to set and something to come in.			
				//Put together string that is being received.
				while (noCarriage && flagSendingGAVR){
    14c4:	8b 85       	ldd	r24, Y+11	; 0x0b
    14c6:	88 23       	and	r24, r24
    14c8:	31 f0       	breq	.+12     	; 0x14d6 <_Z8sendGAVRv+0x146>
    14ca:	80 91 14 02 	lds	r24, 0x0214
    14ce:	88 23       	and	r24, r24
    14d0:	11 f0       	breq	.+4      	; 0x14d6 <_Z8sendGAVRv+0x146>
    14d2:	81 e0       	ldi	r24, 0x01	; 1
    14d4:	01 c0       	rjmp	.+2      	; 0x14d8 <_Z8sendGAVRv+0x148>
    14d6:	80 e0       	ldi	r24, 0x00	; 0
    14d8:	88 23       	and	r24, r24
    14da:	09 f0       	breq	.+2      	; 0x14de <_Z8sendGAVRv+0x14e>
    14dc:	96 cf       	rjmp	.-212    	; 0x140a <_Z8sendGAVRv+0x7a>
					recString[strLoc++]=recChar;
					if (recChar=='.'){recString[strLoc++]='\0'; state=2; noCarriage=fFalse;}
					else if (strLoc >= 39){strLoc = 0; noCarriage=fFalse; state=7;}
					else;
				}//end while
				break;
    14de:	87 c1       	rjmp	.+782    	; 0x17ee <_Z8sendGAVRv+0x45e>
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
    14e0:	ce 01       	movw	r24, r28
    14e2:	c4 96       	adiw	r24, 0x34	; 52
    14e4:	2c e0       	ldi	r18, 0x0C	; 12
    14e6:	31 e0       	ldi	r19, 0x01	; 1
    14e8:	b9 01       	movw	r22, r18
    14ea:	42 e0       	ldi	r20, 0x02	; 2
    14ec:	50 e0       	ldi	r21, 0x00	; 0
    14ee:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    14f2:	00 97       	sbiw	r24, 0x00	; 0
    14f4:	39 f4       	brne	.+14     	; 0x1504 <_Z8sendGAVRv+0x174>
    14f6:	83 e0       	ldi	r24, 0x03	; 3
    14f8:	90 e0       	ldi	r25, 0x00	; 0
    14fa:	90 93 28 02 	sts	0x0228, r25
    14fe:	80 93 27 02 	sts	0x0227, r24
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else if (!strncmp(recString,"S.",2)){state=5;}									//Don't do anything differnre'ty then if we sent the correct time.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    1502:	75 c1       	rjmp	.+746    	; 0x17ee <_Z8sendGAVRv+0x45e>
				}//end while
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
    1504:	ce 01       	movw	r24, r28
    1506:	c4 96       	adiw	r24, 0x34	; 52
    1508:	2f e0       	ldi	r18, 0x0F	; 15
    150a:	31 e0       	ldi	r19, 0x01	; 1
    150c:	b9 01       	movw	r22, r18
    150e:	42 e0       	ldi	r20, 0x02	; 2
    1510:	50 e0       	ldi	r21, 0x00	; 0
    1512:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    1516:	00 97       	sbiw	r24, 0x00	; 0
    1518:	51 f4       	brne	.+20     	; 0x152e <_Z8sendGAVRv+0x19e>
    151a:	85 e0       	ldi	r24, 0x05	; 5
    151c:	90 e0       	ldi	r25, 0x00	; 0
    151e:	90 93 28 02 	sts	0x0228, r25
    1522:	80 93 27 02 	sts	0x0227, r24
    1526:	81 e0       	ldi	r24, 0x01	; 1
    1528:	80 93 10 02 	sts	0x0210, r24
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else if (!strncmp(recString,"S.",2)){state=5;}									//Don't do anything differnre'ty then if we sent the correct time.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    152c:	60 c1       	rjmp	.+704    	; 0x17ee <_Z8sendGAVRv+0x45e>
				break;
				}//end case 1
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
    152e:	ce 01       	movw	r24, r28
    1530:	c4 96       	adiw	r24, 0x34	; 52
    1532:	22 e1       	ldi	r18, 0x12	; 18
    1534:	31 e0       	ldi	r19, 0x01	; 1
    1536:	b9 01       	movw	r22, r18
    1538:	42 e0       	ldi	r20, 0x02	; 2
    153a:	50 e0       	ldi	r21, 0x00	; 0
    153c:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    1540:	00 97       	sbiw	r24, 0x00	; 0
    1542:	39 f4       	brne	.+14     	; 0x1552 <_Z8sendGAVRv+0x1c2>
    1544:	86 e0       	ldi	r24, 0x06	; 6
    1546:	90 e0       	ldi	r25, 0x00	; 0
    1548:	90 93 28 02 	sts	0x0228, r25
    154c:	80 93 27 02 	sts	0x0227, r24
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else if (!strncmp(recString,"S.",2)){state=5;}									//Don't do anything differnre'ty then if we sent the correct time.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    1550:	4e c1       	rjmp	.+668    	; 0x17ee <_Z8sendGAVRv+0x45e>
			case 2: {
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
    1552:	80 91 13 02 	lds	r24, 0x0213
    1556:	88 23       	and	r24, r24
    1558:	a9 f0       	breq	.+42     	; 0x1584 <_Z8sendGAVRv+0x1f4>
    155a:	ce 01       	movw	r24, r28
    155c:	c4 96       	adiw	r24, 0x34	; 52
    155e:	9e 01       	movw	r18, r28
    1560:	24 5f       	subi	r18, 0xF4	; 244
    1562:	3f 4f       	sbci	r19, 0xFF	; 255
    1564:	b9 01       	movw	r22, r18
    1566:	0e 94 3b 1d 	call	0x3a76	; 0x3a76 <strcmp>
    156a:	00 97       	sbiw	r24, 0x00	; 0
    156c:	59 f4       	brne	.+22     	; 0x1584 <_Z8sendGAVRv+0x1f4>
    156e:	85 e1       	ldi	r24, 0x15	; 21
    1570:	91 e0       	ldi	r25, 0x01	; 1
    1572:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1576:	85 e0       	ldi	r24, 0x05	; 5
    1578:	90 e0       	ldi	r25, 0x00	; 0
    157a:	90 93 28 02 	sts	0x0228, r25
    157e:	80 93 27 02 	sts	0x0227, r24
				else if (!strncmp(recString,"S.",2)){state=5;}									//Don't do anything differnre'ty then if we sent the correct time.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    1582:	35 c1       	rjmp	.+618    	; 0x17ee <_Z8sendGAVRv+0x45e>
				if (!strncmp(recString,"A.",2)){state=3;}		//ack
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else if (!strncmp(recString,"S.",2)){state=5;}									//Don't do anything differnre'ty then if we sent the correct time.
    1584:	ce 01       	movw	r24, r28
    1586:	c4 96       	adiw	r24, 0x34	; 52
    1588:	23 e2       	ldi	r18, 0x23	; 35
    158a:	31 e0       	ldi	r19, 0x01	; 1
    158c:	b9 01       	movw	r22, r18
    158e:	42 e0       	ldi	r20, 0x02	; 2
    1590:	50 e0       	ldi	r21, 0x00	; 0
    1592:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    1596:	00 97       	sbiw	r24, 0x00	; 0
    1598:	39 f4       	brne	.+14     	; 0x15a8 <_Z8sendGAVRv+0x218>
    159a:	85 e0       	ldi	r24, 0x05	; 5
    159c:	90 e0       	ldi	r25, 0x00	; 0
    159e:	90 93 28 02 	sts	0x0228, r25
    15a2:	80 93 27 02 	sts	0x0227, r24
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
				break;
    15a6:	23 c1       	rjmp	.+582    	; 0x17ee <_Z8sendGAVRv+0x45e>
				else if (!strncmp(recString,"G.",2)){state=5; flagWaitingForReceiveGAVR=fTrue;}	//get
				else if (!strncmp(recString,"B.",2)){state=6;}	//BAD
				//send string case.
				else if (flagUpdateGAVRClock && !strcmp(recString,sentString)){PrintBone("Correct back.");state=5;}		//they match, successful send.
				else if (!strncmp(recString,"S.",2)){state=5;}									//Don't do anything differnre'ty then if we sent the correct time.
				else{PrintBone("Comparing.");PrintBone(recString);state=7;} //invalid ack. ACKERROR goes here.
    15a8:	86 e2       	ldi	r24, 0x26	; 38
    15aa:	91 e0       	ldi	r25, 0x01	; 1
    15ac:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    15b0:	ce 01       	movw	r24, r28
    15b2:	c4 96       	adiw	r24, 0x34	; 52
    15b4:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    15b8:	87 e0       	ldi	r24, 0x07	; 7
    15ba:	90 e0       	ldi	r25, 0x00	; 0
    15bc:	90 93 28 02 	sts	0x0228, r25
    15c0:	80 93 27 02 	sts	0x0227, r24
				break;
    15c4:	14 c1       	rjmp	.+552    	; 0x17ee <_Z8sendGAVRv+0x45e>
				}//end case 2
			case 3:{
				Wait_ms(100);
    15c6:	84 e6       	ldi	r24, 0x64	; 100
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
				if (flagUserClock && !flagUpdateGAVRClock){
    15ce:	80 91 15 02 	lds	r24, 0x0215
    15d2:	88 23       	and	r24, r24
    15d4:	69 f0       	breq	.+26     	; 0x15f0 <_Z8sendGAVRv+0x260>
    15d6:	80 91 13 02 	lds	r24, 0x0213
    15da:	88 23       	and	r24, r24
    15dc:	49 f4       	brne	.+18     	; 0x15f0 <_Z8sendGAVRv+0x260>
					PrintGAVR("G.");				
    15de:	8f e0       	ldi	r24, 0x0F	; 15
    15e0:	91 e0       	ldi	r25, 0x01	; 1
    15e2:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
					PrintBone("GetTime.");
    15e6:	81 e3       	ldi	r24, 0x31	; 49
    15e8:	91 e0       	ldi	r25, 0x01	; 1
    15ea:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    15ee:	67 c0       	rjmp	.+206    	; 0x16be <_Z8sendGAVRv+0x32e>
				//If we are updating the gavr, send the time and date together regardless. preface with SYN
				} else if (flagUpdateGAVRClock && !flagUserClock){
    15f0:	80 91 13 02 	lds	r24, 0x0213
    15f4:	88 23       	and	r24, r24
    15f6:	09 f4       	brne	.+2      	; 0x15fa <_Z8sendGAVRv+0x26a>
    15f8:	57 c0       	rjmp	.+174    	; 0x16a8 <_Z8sendGAVRv+0x318>
    15fa:	80 91 15 02 	lds	r24, 0x0215
    15fe:	88 23       	and	r24, r24
    1600:	09 f0       	breq	.+2      	; 0x1604 <_Z8sendGAVRv+0x274>
    1602:	52 c0       	rjmp	.+164    	; 0x16a8 <_Z8sendGAVRv+0x318>
					strcpy(sentString,"A");			//this is a syn, not ack to save logic in GAVR code. Can change if we want.
    1604:	ce 01       	movw	r24, r28
    1606:	0c 96       	adiw	r24, 0x0c	; 12
    1608:	21 e4       	ldi	r18, 0x41	; 65
    160a:	30 e0       	ldi	r19, 0x00	; 0
    160c:	fc 01       	movw	r30, r24
    160e:	31 83       	std	Z+1, r19	; 0x01
    1610:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getTime());
    1612:	84 ee       	ldi	r24, 0xE4	; 228
    1614:	91 e0       	ldi	r25, 0x01	; 1
    1616:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    161a:	9c 01       	movw	r18, r24
    161c:	ce 01       	movw	r24, r28
    161e:	0c 96       	adiw	r24, 0x0c	; 12
    1620:	b9 01       	movw	r22, r18
    1622:	0e 94 30 1d 	call	0x3a60	; 0x3a60 <strcat>
					strcat(sentString,"/");	//add delimiter.
    1626:	ce 01       	movw	r24, r28
    1628:	0c 96       	adiw	r24, 0x0c	; 12
    162a:	9c 01       	movw	r18, r24
    162c:	f9 01       	movw	r30, r18
    162e:	01 90       	ld	r0, Z+
    1630:	00 20       	and	r0, r0
    1632:	e9 f7       	brne	.-6      	; 0x162e <_Z8sendGAVRv+0x29e>
    1634:	cf 01       	movw	r24, r30
    1636:	01 97       	sbiw	r24, 0x01	; 1
    1638:	82 1b       	sub	r24, r18
    163a:	93 0b       	sbc	r25, r19
    163c:	9e 01       	movw	r18, r28
    163e:	24 5f       	subi	r18, 0xF4	; 244
    1640:	3f 4f       	sbci	r19, 0xFF	; 255
    1642:	82 0f       	add	r24, r18
    1644:	93 1f       	adc	r25, r19
    1646:	2f e2       	ldi	r18, 0x2F	; 47
    1648:	30 e0       	ldi	r19, 0x00	; 0
    164a:	fc 01       	movw	r30, r24
    164c:	31 83       	std	Z+1, r19	; 0x01
    164e:	20 83       	st	Z, r18
					strcat(sentString,currentTime.getDate());
    1650:	84 ee       	ldi	r24, 0xE4	; 228
    1652:	91 e0       	ldi	r25, 0x01	; 1
    1654:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    1658:	9c 01       	movw	r18, r24
    165a:	ce 01       	movw	r24, r28
    165c:	0c 96       	adiw	r24, 0x0c	; 12
    165e:	b9 01       	movw	r22, r18
    1660:	0e 94 30 1d 	call	0x3a60	; 0x3a60 <strcat>
					strcat(sentString,".\0");
    1664:	ce 01       	movw	r24, r28
    1666:	0c 96       	adiw	r24, 0x0c	; 12
    1668:	9c 01       	movw	r18, r24
    166a:	f9 01       	movw	r30, r18
    166c:	01 90       	ld	r0, Z+
    166e:	00 20       	and	r0, r0
    1670:	e9 f7       	brne	.-6      	; 0x166c <_Z8sendGAVRv+0x2dc>
    1672:	cf 01       	movw	r24, r30
    1674:	01 97       	sbiw	r24, 0x01	; 1
    1676:	82 1b       	sub	r24, r18
    1678:	93 0b       	sbc	r25, r19
    167a:	9e 01       	movw	r18, r28
    167c:	24 5f       	subi	r18, 0xF4	; 244
    167e:	3f 4f       	sbci	r19, 0xFF	; 255
    1680:	82 0f       	add	r24, r18
    1682:	93 1f       	adc	r25, r19
    1684:	2e e2       	ldi	r18, 0x2E	; 46
    1686:	30 e0       	ldi	r19, 0x00	; 0
    1688:	fc 01       	movw	r30, r24
    168a:	31 83       	std	Z+1, r19	; 0x01
    168c:	20 83       	st	Z, r18
					PutUartChGAVR('S');
    168e:	83 e5       	ldi	r24, 0x53	; 83
    1690:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
					printTimeDate(fFalse,fTrue,fTrue);			//date is terminated by a . so don't need to send character
    1694:	80 e0       	ldi	r24, 0x00	; 0
    1696:	61 e0       	ldi	r22, 0x01	; 1
    1698:	41 e0       	ldi	r20, 0x01	; 1
    169a:	0e 94 9f 13 	call	0x273e	; 0x273e <_Z13printTimeDatehhh>
					PrintBone("Sending time.");
    169e:	8a e3       	ldi	r24, 0x3A	; 58
    16a0:	91 e0       	ldi	r25, 0x01	; 1
    16a2:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    16a6:	0b c0       	rjmp	.+22     	; 0x16be <_Z8sendGAVRv+0x32e>
				} else {PrintBone("noflags.");state=7; break;}	//end if-else (what we are doing).
    16a8:	88 e4       	ldi	r24, 0x48	; 72
    16aa:	91 e0       	ldi	r25, 0x01	; 1
    16ac:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    16b0:	87 e0       	ldi	r24, 0x07	; 7
    16b2:	90 e0       	ldi	r25, 0x00	; 0
    16b4:	90 93 28 02 	sts	0x0228, r25
    16b8:	80 93 27 02 	sts	0x0227, r24
    16bc:	98 c0       	rjmp	.+304    	; 0x17ee <_Z8sendGAVRv+0x45e>
							
				//Reset the recString to receive the next ACK.
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    16be:	1c 82       	std	Y+4, r1	; 0x04
    16c0:	1b 82       	std	Y+3, r1	; 0x03
    16c2:	0e c0       	rjmp	.+28     	; 0x16e0 <_Z8sendGAVRv+0x350>
    16c4:	9e 01       	movw	r18, r28
    16c6:	2c 5c       	subi	r18, 0xCC	; 204
    16c8:	3f 4f       	sbci	r19, 0xFF	; 255
    16ca:	8b 81       	ldd	r24, Y+3	; 0x03
    16cc:	9c 81       	ldd	r25, Y+4	; 0x04
    16ce:	82 0f       	add	r24, r18
    16d0:	93 1f       	adc	r25, r19
    16d2:	fc 01       	movw	r30, r24
    16d4:	10 82       	st	Z, r1
    16d6:	8b 81       	ldd	r24, Y+3	; 0x03
    16d8:	9c 81       	ldd	r25, Y+4	; 0x04
    16da:	01 96       	adiw	r24, 0x01	; 1
    16dc:	9c 83       	std	Y+4, r25	; 0x04
    16de:	8b 83       	std	Y+3, r24	; 0x03
    16e0:	2b 81       	ldd	r18, Y+3	; 0x03
    16e2:	3c 81       	ldd	r19, Y+4	; 0x04
    16e4:	41 e0       	ldi	r20, 0x01	; 1
    16e6:	89 81       	ldd	r24, Y+1	; 0x01
    16e8:	9a 81       	ldd	r25, Y+2	; 0x02
    16ea:	28 17       	cp	r18, r24
    16ec:	39 07       	cpc	r19, r25
    16ee:	08 f0       	brcs	.+2      	; 0x16f2 <_Z8sendGAVRv+0x362>
    16f0:	40 e0       	ldi	r20, 0x00	; 0
    16f2:	44 23       	and	r20, r20
    16f4:	39 f7       	brne	.-50     	; 0x16c4 <_Z8sendGAVRv+0x334>
					
				//Reset the carriage feature, string location and go back to the receiving state.
				noCarriage=fTrue;
    16f6:	81 e0       	ldi	r24, 0x01	; 1
    16f8:	8b 87       	std	Y+11, r24	; 0x0b
				strLoc=0;
    16fa:	1a 82       	std	Y+2, r1	; 0x02
    16fc:	19 82       	std	Y+1, r1	; 0x01
				state=1;
    16fe:	81 e0       	ldi	r24, 0x01	; 1
    1700:	90 e0       	ldi	r25, 0x00	; 0
    1702:	90 93 28 02 	sts	0x0228, r25
    1706:	80 93 27 02 	sts	0x0227, r24
				break;
    170a:	71 c0       	rjmp	.+226    	; 0x17ee <_Z8sendGAVRv+0x45e>
				}//end case 3
			case 5:{
				//Successful communications overall
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    170c:	1e 82       	std	Y+6, r1	; 0x06
    170e:	1d 82       	std	Y+5, r1	; 0x05
    1710:	0e c0       	rjmp	.+28     	; 0x172e <_Z8sendGAVRv+0x39e>
    1712:	9e 01       	movw	r18, r28
    1714:	2c 5c       	subi	r18, 0xCC	; 204
    1716:	3f 4f       	sbci	r19, 0xFF	; 255
    1718:	8d 81       	ldd	r24, Y+5	; 0x05
    171a:	9e 81       	ldd	r25, Y+6	; 0x06
    171c:	82 0f       	add	r24, r18
    171e:	93 1f       	adc	r25, r19
    1720:	fc 01       	movw	r30, r24
    1722:	10 82       	st	Z, r1
    1724:	8d 81       	ldd	r24, Y+5	; 0x05
    1726:	9e 81       	ldd	r25, Y+6	; 0x06
    1728:	01 96       	adiw	r24, 0x01	; 1
    172a:	9e 83       	std	Y+6, r25	; 0x06
    172c:	8d 83       	std	Y+5, r24	; 0x05
    172e:	2d 81       	ldd	r18, Y+5	; 0x05
    1730:	3e 81       	ldd	r19, Y+6	; 0x06
    1732:	41 e0       	ldi	r20, 0x01	; 1
    1734:	89 81       	ldd	r24, Y+1	; 0x01
    1736:	9a 81       	ldd	r25, Y+2	; 0x02
    1738:	28 17       	cp	r18, r24
    173a:	39 07       	cpc	r19, r25
    173c:	08 f0       	brcs	.+2      	; 0x1740 <_Z8sendGAVRv+0x3b0>
    173e:	40 e0       	ldi	r20, 0x00	; 0
    1740:	44 23       	and	r20, r20
    1742:	39 f7       	brne	.-50     	; 0x1712 <_Z8sendGAVRv+0x382>
				PrintBone("Success.");
    1744:	81 e5       	ldi	r24, 0x51	; 81
    1746:	91 e0       	ldi	r25, 0x01	; 1
    1748:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
				flagSendingGAVR=fFalse;
    174c:	10 92 14 02 	sts	0x0214, r1
				flagUpdateGAVRClock=fFalse;							//Always true if we get here.
    1750:	10 92 13 02 	sts	0x0213, r1
				state=0;
    1754:	10 92 28 02 	sts	0x0228, r1
    1758:	10 92 27 02 	sts	0x0227, r1
				break;
    175c:	48 c0       	rjmp	.+144    	; 0x17ee <_Z8sendGAVRv+0x45e>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
    175e:	84 ee       	ldi	r24, 0xE4	; 228
    1760:	91 e0       	ldi	r25, 0x01	; 1
    1762:	0e 94 bc 06 	call	0xd78	; 0xd78 <_ZN6myTime13checkValidityEv>
    1766:	8a 87       	std	Y+10, r24	; 0x0a
				if (dateOK){state=7;}
    1768:	8a 85       	ldd	r24, Y+10	; 0x0a
    176a:	88 23       	and	r24, r24
    176c:	39 f0       	breq	.+14     	; 0x177c <_Z8sendGAVRv+0x3ec>
    176e:	87 e0       	ldi	r24, 0x07	; 7
    1770:	90 e0       	ldi	r25, 0x00	; 0
    1772:	90 93 28 02 	sts	0x0228, r25
    1776:	80 93 27 02 	sts	0x0227, r24
				else {state=7; flagInvalidDateTime=fTrue;}
				break;
    177a:	39 c0       	rjmp	.+114    	; 0x17ee <_Z8sendGAVRv+0x45e>
				}//end case 5
			case 6:{
				//ACKBAD. Check the date and time to see if its okay. IF okay, go to state 7 to set waiting flag. otherwise set invalid time and close through state 5.
				BOOL dateOK = currentTime.checkValidity();
				if (dateOK){state=7;}
				else {state=7; flagInvalidDateTime=fTrue;}
    177c:	87 e0       	ldi	r24, 0x07	; 7
    177e:	90 e0       	ldi	r25, 0x00	; 0
    1780:	90 93 28 02 	sts	0x0228, r25
    1784:	80 93 27 02 	sts	0x0227, r24
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	80 93 16 02 	sts	0x0216, r24
				break;
    178e:	2f c0       	rjmp	.+94     	; 0x17ee <_Z8sendGAVRv+0x45e>
				}//end case 6
			case 7:{
				//Got the wrong ACK back, or invalid ACK. Wait for next cycle then resend. Keep all the flags the same
				PrintBone("ErrorS.");
    1790:	8a e5       	ldi	r24, 0x5A	; 90
    1792:	91 e0       	ldi	r25, 0x01	; 1
    1794:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
				flagSendingGAVR=fFalse;
    1798:	10 92 14 02 	sts	0x0214, r1
				for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    179c:	18 86       	std	Y+8, r1	; 0x08
    179e:	1f 82       	std	Y+7, r1	; 0x07
    17a0:	0e c0       	rjmp	.+28     	; 0x17be <_Z8sendGAVRv+0x42e>
    17a2:	9e 01       	movw	r18, r28
    17a4:	2c 5c       	subi	r18, 0xCC	; 204
    17a6:	3f 4f       	sbci	r19, 0xFF	; 255
    17a8:	8f 81       	ldd	r24, Y+7	; 0x07
    17aa:	98 85       	ldd	r25, Y+8	; 0x08
    17ac:	82 0f       	add	r24, r18
    17ae:	93 1f       	adc	r25, r19
    17b0:	fc 01       	movw	r30, r24
    17b2:	10 82       	st	Z, r1
    17b4:	8f 81       	ldd	r24, Y+7	; 0x07
    17b6:	98 85       	ldd	r25, Y+8	; 0x08
    17b8:	01 96       	adiw	r24, 0x01	; 1
    17ba:	98 87       	std	Y+8, r25	; 0x08
    17bc:	8f 83       	std	Y+7, r24	; 0x07
    17be:	2f 81       	ldd	r18, Y+7	; 0x07
    17c0:	38 85       	ldd	r19, Y+8	; 0x08
    17c2:	41 e0       	ldi	r20, 0x01	; 1
    17c4:	89 81       	ldd	r24, Y+1	; 0x01
    17c6:	9a 81       	ldd	r25, Y+2	; 0x02
    17c8:	28 17       	cp	r18, r24
    17ca:	39 07       	cpc	r19, r25
    17cc:	08 f0       	brcs	.+2      	; 0x17d0 <_Z8sendGAVRv+0x440>
    17ce:	40 e0       	ldi	r20, 0x00	; 0
    17d0:	44 23       	and	r20, r20
    17d2:	39 f7       	brne	.-50     	; 0x17a2 <_Z8sendGAVRv+0x412>
				state=0;
    17d4:	10 92 28 02 	sts	0x0228, r1
    17d8:	10 92 27 02 	sts	0x0227, r1
				break;
    17dc:	08 c0       	rjmp	.+16     	; 0x17ee <_Z8sendGAVRv+0x45e>
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; break;}
    17de:	10 92 28 02 	sts	0x0228, r1
    17e2:	10 92 27 02 	sts	0x0227, r1
    17e6:	10 92 14 02 	sts	0x0214, r1
    17ea:	1b 86       	std	Y+11, r1	; 0x0b
    17ec:	00 00       	nop
	
	//Set sending flag
	flagSendingGAVR=fTrue;
	
	//Transmission protocol
	while (flagSendingGAVR){
    17ee:	90 91 14 02 	lds	r25, 0x0214
    17f2:	81 e0       	ldi	r24, 0x01	; 1
    17f4:	99 23       	and	r25, r25
    17f6:	09 f4       	brne	.+2      	; 0x17fa <_Z8sendGAVRv+0x46a>
    17f8:	80 e0       	ldi	r24, 0x00	; 0
    17fa:	88 23       	and	r24, r24
    17fc:	09 f0       	breq	.+2      	; 0x1800 <_Z8sendGAVRv+0x470>
    17fe:	db cd       	rjmp	.-1098   	; 0x13b6 <_Z8sendGAVRv+0x26>
				break;
				}//end case 7
			default:{state=0; flagSendingGAVR=fFalse; noCarriage=fFalse; break;}
		}//end switch
	}//end while
}//end function 	
    1800:	c5 5a       	subi	r28, 0xA5	; 165
    1802:	df 4f       	sbci	r29, 0xFF	; 255
    1804:	0f b6       	in	r0, 0x3f	; 63
    1806:	f8 94       	cli
    1808:	de bf       	out	0x3e, r29	; 62
    180a:	0f be       	out	0x3f, r0	; 63
    180c:	cd bf       	out	0x3d, r28	; 61
    180e:	df 91       	pop	r29
    1810:	cf 91       	pop	r28
    1812:	08 95       	ret

00001814 <_Z11ReceiveGAVRv>:

/*************************************************************************************************************/
void ReceiveGAVR(){
    1814:	cf 93       	push	r28
    1816:	df 93       	push	r29
    1818:	cd b7       	in	r28, 0x3d	; 61
    181a:	de b7       	in	r29, 0x3e	; 62
    181c:	c1 55       	subi	r28, 0x51	; 81
    181e:	d0 40       	sbci	r29, 0x00	; 0
    1820:	0f b6       	in	r0, 0x3f	; 63
    1822:	f8 94       	cli
    1824:	de bf       	out	0x3e, r29	; 62
    1826:	0f be       	out	0x3f, r0	; 63
    1828:	cd bf       	out	0x3d, r28	; 61
	unsigned int state=0;
    182a:	1a 82       	std	Y+2, r1	; 0x02
    182c:	19 82       	std	Y+1, r1	; 0x01
	char recChar, recString[40];
	unsigned int strLoc=0;
    182e:	1c 82       	std	Y+4, r1	; 0x04
    1830:	1b 82       	std	Y+3, r1	; 0x03
	BOOL noCarriage=fTrue;
    1832:	81 e0       	ldi	r24, 0x01	; 1
    1834:	8d 83       	std	Y+5, r24	; 0x05
	
	//While Loop
	while (flagReceivingGAVR){
    1836:	57 c3       	rjmp	.+1710   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
		/** State 5: Exit case. Lower "flagReceivingGAVR" which causes and exit.													   **/
		/** State 6: ACKERROR state. Send "ACKERROR", then exit through state 5.													   **/
		/** State 7: Successful acquire of time/date.																				   **/
		/** Default: Set state to 0, doesn't really matter though. Exit signalling timeout to sender.								   **/
		/********************************************************************************************************************************/
		switch(state){
    1838:	89 81       	ldd	r24, Y+1	; 0x01
    183a:	9a 81       	ldd	r25, Y+2	; 0x02
    183c:	83 30       	cpi	r24, 0x03	; 3
    183e:	91 05       	cpc	r25, r1
    1840:	09 f4       	brne	.+2      	; 0x1844 <_Z11ReceiveGAVRv+0x30>
    1842:	e1 c0       	rjmp	.+450    	; 0x1a06 <_Z11ReceiveGAVRv+0x1f2>
    1844:	84 30       	cpi	r24, 0x04	; 4
    1846:	91 05       	cpc	r25, r1
    1848:	48 f4       	brcc	.+18     	; 0x185c <_Z11ReceiveGAVRv+0x48>
    184a:	81 30       	cpi	r24, 0x01	; 1
    184c:	91 05       	cpc	r25, r1
    184e:	09 f4       	brne	.+2      	; 0x1852 <_Z11ReceiveGAVRv+0x3e>
    1850:	8d c0       	rjmp	.+282    	; 0x196c <_Z11ReceiveGAVRv+0x158>
    1852:	82 30       	cpi	r24, 0x02	; 2
    1854:	91 05       	cpc	r25, r1
    1856:	08 f0       	brcs	.+2      	; 0x185a <_Z11ReceiveGAVRv+0x46>
    1858:	97 c0       	rjmp	.+302    	; 0x1988 <_Z11ReceiveGAVRv+0x174>
    185a:	11 c0       	rjmp	.+34     	; 0x187e <_Z11ReceiveGAVRv+0x6a>
    185c:	85 30       	cpi	r24, 0x05	; 5
    185e:	91 05       	cpc	r25, r1
    1860:	09 f4       	brne	.+2      	; 0x1864 <_Z11ReceiveGAVRv+0x50>
    1862:	f3 c2       	rjmp	.+1510   	; 0x1e4a <_Z11ReceiveGAVRv+0x636>
    1864:	85 30       	cpi	r24, 0x05	; 5
    1866:	91 05       	cpc	r25, r1
    1868:	08 f4       	brcc	.+2      	; 0x186c <_Z11ReceiveGAVRv+0x58>
    186a:	ce c2       	rjmp	.+1436   	; 0x1e08 <_Z11ReceiveGAVRv+0x5f4>
    186c:	86 30       	cpi	r24, 0x06	; 6
    186e:	91 05       	cpc	r25, r1
    1870:	09 f4       	brne	.+2      	; 0x1874 <_Z11ReceiveGAVRv+0x60>
    1872:	0e c3       	rjmp	.+1564   	; 0x1e90 <_Z11ReceiveGAVRv+0x67c>
    1874:	87 30       	cpi	r24, 0x07	; 7
    1876:	91 05       	cpc	r25, r1
    1878:	09 f4       	brne	.+2      	; 0x187c <_Z11ReceiveGAVRv+0x68>
    187a:	1b c3       	rjmp	.+1590   	; 0x1eb2 <_Z11ReceiveGAVRv+0x69e>
    187c:	2d c3       	rjmp	.+1626   	; 0x1ed8 <_Z11ReceiveGAVRv+0x6c4>
				case 0:{
					//Beginning case
					strLoc=0;
    187e:	1c 82       	std	Y+4, r1	; 0x04
    1880:	1b 82       	std	Y+3, r1	; 0x03
					recChar = UDR1;
    1882:	8e ec       	ldi	r24, 0xCE	; 206
    1884:	90 e0       	ldi	r25, 0x00	; 0
    1886:	fc 01       	movw	r30, r24
    1888:	80 81       	ld	r24, Z
    188a:	8e 8b       	std	Y+22, r24	; 0x16
					if (recChar=='.'){
    188c:	8e 89       	ldd	r24, Y+22	; 0x16
    188e:	8e 32       	cpi	r24, 0x2E	; 46
    1890:	29 f4       	brne	.+10     	; 0x189c <_Z11ReceiveGAVRv+0x88>
						state=6;															//Go to error state.
    1892:	86 e0       	ldi	r24, 0x06	; 6
    1894:	90 e0       	ldi	r25, 0x00	; 0
    1896:	9a 83       	std	Y+2, r25	; 0x02
    1898:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
    189a:	25 c3       	rjmp	.+1610   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
					//Beginning case
					strLoc=0;
					recChar = UDR1;
					if (recChar=='.'){
						state=6;															//Go to error state.
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
    189c:	9e 01       	movw	r18, r28
    189e:	26 5d       	subi	r18, 0xD6	; 214
    18a0:	3f 4f       	sbci	r19, 0xFF	; 255
    18a2:	8b 81       	ldd	r24, Y+3	; 0x03
    18a4:	9c 81       	ldd	r25, Y+4	; 0x04
    18a6:	82 0f       	add	r24, r18
    18a8:	93 1f       	adc	r25, r19
    18aa:	2e 89       	ldd	r18, Y+22	; 0x16
    18ac:	fc 01       	movw	r30, r24
    18ae:	20 83       	st	Z, r18
    18b0:	8b 81       	ldd	r24, Y+3	; 0x03
    18b2:	9c 81       	ldd	r25, Y+4	; 0x04
    18b4:	01 96       	adiw	r24, 0x01	; 1
    18b6:	9c 83       	std	Y+4, r25	; 0x04
    18b8:	8b 83       	std	Y+3, r24	; 0x03
    18ba:	81 e0       	ldi	r24, 0x01	; 1
    18bc:	90 e0       	ldi	r25, 0x00	; 0
    18be:	9a 83       	std	Y+2, r25	; 0x02
    18c0:	89 83       	std	Y+1, r24	; 0x01
					break;
    18c2:	11 c3       	rjmp	.+1570   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						Wait_ms(50);
    18c4:	82 e3       	ldi	r24, 0x32	; 50
    18c6:	90 e0       	ldi	r25, 0x00	; 0
    18c8:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
    18cc:	00 00       	nop
    18ce:	88 ec       	ldi	r24, 0xC8	; 200
    18d0:	90 e0       	ldi	r25, 0x00	; 0
    18d2:	fc 01       	movw	r30, r24
    18d4:	80 81       	ld	r24, Z
    18d6:	88 23       	and	r24, r24
    18d8:	34 f0       	brlt	.+12     	; 0x18e6 <_Z11ReceiveGAVRv+0xd2>
    18da:	80 91 0f 02 	lds	r24, 0x020F
    18de:	88 23       	and	r24, r24
    18e0:	11 f0       	breq	.+4      	; 0x18e6 <_Z11ReceiveGAVRv+0xd2>
    18e2:	81 e0       	ldi	r24, 0x01	; 1
    18e4:	01 c0       	rjmp	.+2      	; 0x18e8 <_Z11ReceiveGAVRv+0xd4>
    18e6:	80 e0       	ldi	r24, 0x00	; 0
    18e8:	88 23       	and	r24, r24
    18ea:	89 f7       	brne	.-30     	; 0x18ce <_Z11ReceiveGAVRv+0xba>
						if (!flagReceivingGAVR){state=0; PrintBone("Timeout-RG");PrintBone(recString);break;}							//if there was a timeout, break out and reset state
    18ec:	80 91 0f 02 	lds	r24, 0x020F
    18f0:	88 23       	and	r24, r24
    18f2:	61 f4       	brne	.+24     	; 0x190c <_Z11ReceiveGAVRv+0xf8>
    18f4:	1a 82       	std	Y+2, r1	; 0x02
    18f6:	19 82       	std	Y+1, r1	; 0x01
    18f8:	82 e6       	ldi	r24, 0x62	; 98
    18fa:	91 e0       	ldi	r25, 0x01	; 1
    18fc:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1900:	ce 01       	movw	r24, r28
    1902:	8a 96       	adiw	r24, 0x2a	; 42
    1904:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1908:	00 00       	nop
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    190a:	ed c2       	rjmp	.+1498   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
						Wait_ms(50);
						while (!(UCSR1A & (1 << RXC1)) && flagReceivingGAVR);				//get the next character
						if (!flagReceivingGAVR){state=0; PrintBone("Timeout-RG");PrintBone(recString);break;}							//if there was a timeout, break out and reset state
						recChar=UDR1;
    190c:	8e ec       	ldi	r24, 0xCE	; 206
    190e:	90 e0       	ldi	r25, 0x00	; 0
    1910:	fc 01       	movw	r30, r24
    1912:	80 81       	ld	r24, Z
    1914:	8e 8b       	std	Y+22, r24	; 0x16
						recString[strLoc++]=recChar;										//'.' always included into recString
    1916:	9e 01       	movw	r18, r28
    1918:	26 5d       	subi	r18, 0xD6	; 214
    191a:	3f 4f       	sbci	r19, 0xFF	; 255
    191c:	8b 81       	ldd	r24, Y+3	; 0x03
    191e:	9c 81       	ldd	r25, Y+4	; 0x04
    1920:	82 0f       	add	r24, r18
    1922:	93 1f       	adc	r25, r19
    1924:	2e 89       	ldd	r18, Y+22	; 0x16
    1926:	fc 01       	movw	r30, r24
    1928:	20 83       	st	Z, r18
    192a:	8b 81       	ldd	r24, Y+3	; 0x03
    192c:	9c 81       	ldd	r25, Y+4	; 0x04
    192e:	01 96       	adiw	r24, 0x01	; 1
    1930:	9c 83       	std	Y+4, r25	; 0x04
    1932:	8b 83       	std	Y+3, r24	; 0x03
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    1934:	8e 89       	ldd	r24, Y+22	; 0x16
    1936:	8e 32       	cpi	r24, 0x2E	; 46
    1938:	79 f4       	brne	.+30     	; 0x1958 <_Z11ReceiveGAVRv+0x144>
    193a:	9e 01       	movw	r18, r28
    193c:	26 5d       	subi	r18, 0xD6	; 214
    193e:	3f 4f       	sbci	r19, 0xFF	; 255
    1940:	8b 81       	ldd	r24, Y+3	; 0x03
    1942:	9c 81       	ldd	r25, Y+4	; 0x04
    1944:	82 0f       	add	r24, r18
    1946:	93 1f       	adc	r25, r19
    1948:	fc 01       	movw	r30, r24
    194a:	10 82       	st	Z, r1
    194c:	1d 82       	std	Y+5, r1	; 0x05
    194e:	82 e0       	ldi	r24, 0x02	; 2
    1950:	90 e0       	ldi	r25, 0x00	; 0
    1952:	9a 83       	std	Y+2, r25	; 0x02
    1954:	89 83       	std	Y+1, r24	; 0x01
    1956:	0a c0       	rjmp	.+20     	; 0x196c <_Z11ReceiveGAVRv+0x158>
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
    1958:	8b 81       	ldd	r24, Y+3	; 0x03
    195a:	9c 81       	ldd	r25, Y+4	; 0x04
    195c:	87 32       	cpi	r24, 0x27	; 39
    195e:	91 05       	cpc	r25, r1
    1960:	28 f0       	brcs	.+10     	; 0x196c <_Z11ReceiveGAVRv+0x158>
    1962:	86 e0       	ldi	r24, 0x06	; 6
    1964:	90 e0       	ldi	r25, 0x00	; 0
    1966:	9a 83       	std	Y+2, r25	; 0x02
    1968:	89 83       	std	Y+1, r24	; 0x01
    196a:	1d 82       	std	Y+5, r1	; 0x05
					} else  {recString[strLoc++]=recChar; state=1;}							//Add to string, go to state 2
					break;
				}//end case 0
				case 1:{
					//Assemble string case
					while (noCarriage && flagReceivingGAVR){	//while there isn't a timeout and no carry
    196c:	8d 81       	ldd	r24, Y+5	; 0x05
    196e:	88 23       	and	r24, r24
    1970:	31 f0       	breq	.+12     	; 0x197e <_Z11ReceiveGAVRv+0x16a>
    1972:	80 91 0f 02 	lds	r24, 0x020F
    1976:	88 23       	and	r24, r24
    1978:	11 f0       	breq	.+4      	; 0x197e <_Z11ReceiveGAVRv+0x16a>
    197a:	81 e0       	ldi	r24, 0x01	; 1
    197c:	01 c0       	rjmp	.+2      	; 0x1980 <_Z11ReceiveGAVRv+0x16c>
    197e:	80 e0       	ldi	r24, 0x00	; 0
    1980:	88 23       	and	r24, r24
    1982:	09 f0       	breq	.+2      	; 0x1986 <_Z11ReceiveGAVRv+0x172>
    1984:	9f cf       	rjmp	.-194    	; 0x18c4 <_Z11ReceiveGAVRv+0xb0>
						recString[strLoc++]=recChar;										//'.' always included into recString
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if(strLoc >= 39){state=6;noCarriage=fFalse;}
						else;//end if-elseif-else
					}//end while
					break;
    1986:	af c2       	rjmp	.+1374   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
    1988:	ce 01       	movw	r24, r28
    198a:	8a 96       	adiw	r24, 0x2a	; 42
    198c:	2d e6       	ldi	r18, 0x6D	; 109
    198e:	31 e0       	ldi	r19, 0x01	; 1
    1990:	b9 01       	movw	r22, r18
    1992:	48 e0       	ldi	r20, 0x08	; 8
    1994:	50 e0       	ldi	r21, 0x00	; 0
    1996:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    199a:	00 97       	sbiw	r24, 0x00	; 0
    199c:	29 f4       	brne	.+10     	; 0x19a8 <_Z11ReceiveGAVRv+0x194>
    199e:	84 e0       	ldi	r24, 0x04	; 4
    19a0:	90 e0       	ldi	r25, 0x00	; 0
    19a2:	9a 83       	std	Y+2, r25	; 0x02
    19a4:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else if (!strncmp(recString,"S.",2)){state=5; PrintGAVR(recString);}			//Revision 4/13
					else {state=6;}
					break;
    19a6:	9f c2       	rjmp	.+1342   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
					break;
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
    19a8:	8c a5       	lds	r24, 0x6c
    19aa:	91 e0       	ldi	r25, 0x01	; 1
    19ac:	8a 33       	cpi	r24, 0x3A	; 58
    19ae:	09 f0       	breq	.+2      	; 0x19b2 <_Z11ReceiveGAVRv+0x19e>
    19b0:	90 e0       	ldi	r25, 0x00	; 0
    19b2:	2d a5       	lds	r18, 0x6d
    19b4:	81 e0       	ldi	r24, 0x01	; 1
    19b6:	2a 33       	cpi	r18, 0x3A	; 58
    19b8:	09 f0       	breq	.+2      	; 0x19bc <_Z11ReceiveGAVRv+0x1a8>
    19ba:	80 e0       	ldi	r24, 0x00	; 0
    19bc:	89 27       	eor	r24, r25
    19be:	88 23       	and	r24, r24
    19c0:	49 f0       	breq	.+18     	; 0x19d4 <_Z11ReceiveGAVRv+0x1c0>
    19c2:	83 e0       	ldi	r24, 0x03	; 3
    19c4:	90 e0       	ldi	r25, 0x00	; 0
    19c6:	9a 83       	std	Y+2, r25	; 0x02
    19c8:	89 83       	std	Y+1, r24	; 0x01
    19ca:	80 e7       	ldi	r24, 0x70	; 112
    19cc:	91 e0       	ldi	r25, 0x01	; 1
    19ce:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					else if (!strncmp(recString,"S.",2)){state=5; PrintGAVR(recString);}			//Revision 4/13
					else {state=6;}
					break;
    19d2:	89 c2       	rjmp	.+1298   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 1
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else if (!strncmp(recString,"S.",2)){state=5; PrintGAVR(recString);}			//Revision 4/13
    19d4:	ce 01       	movw	r24, r28
    19d6:	8a 96       	adiw	r24, 0x2a	; 42
    19d8:	23 e2       	ldi	r18, 0x23	; 35
    19da:	31 e0       	ldi	r19, 0x01	; 1
    19dc:	b9 01       	movw	r22, r18
    19de:	42 e0       	ldi	r20, 0x02	; 2
    19e0:	50 e0       	ldi	r21, 0x00	; 0
    19e2:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    19e6:	00 97       	sbiw	r24, 0x00	; 0
    19e8:	49 f4       	brne	.+18     	; 0x19fc <_Z11ReceiveGAVRv+0x1e8>
    19ea:	85 e0       	ldi	r24, 0x05	; 5
    19ec:	90 e0       	ldi	r25, 0x00	; 0
    19ee:	9a 83       	std	Y+2, r25	; 0x02
    19f0:	89 83       	std	Y+1, r24	; 0x01
    19f2:	ce 01       	movw	r24, r28
    19f4:	8a 96       	adiw	r24, 0x2a	; 42
    19f6:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
					else {state=6;}
					break;
    19fa:	75 c2       	rjmp	.+1258   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				case 2:{
					//Got string, see what it is case.
					if (!strncmp(recString,"N.",8)){state=4;} //set appropriate flags and respond in appropriate way.
					else if ((recString[2]==':') != (recString[3]==':')){state=3;PrintBone("Got a time.");}//go parse the string for a time and date. SYN03:33:12/DATE or SYN3:33:12/DATE, either char 4 or 5 is :
					else if (!strncmp(recString,"S.",2)){state=5; PrintGAVR(recString);}			//Revision 4/13
					else {state=6;}
    19fc:	86 e0       	ldi	r24, 0x06	; 6
    19fe:	90 e0       	ldi	r25, 0x00	; 0
    1a00:	9a 83       	std	Y+2, r25	; 0x02
    1a02:	89 83       	std	Y+1, r24	; 0x01
					break;
    1a04:	70 c2       	rjmp	.+1248   	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 2
				case 3:{
					//Parse for date/time case
					if (flagUserClock){
    1a06:	80 91 15 02 	lds	r24, 0x0215
    1a0a:	88 23       	and	r24, r24
    1a0c:	09 f4       	brne	.+2      	; 0x1a10 <_Z11ReceiveGAVRv+0x1fc>
    1a0e:	f3 c1       	rjmp	.+998    	; 0x1df6 <_Z11ReceiveGAVRv+0x5e2>
						//Go through the string and parse for the time. Must go through the time to get the date.
						BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    1a10:	1f 8a       	std	Y+23, r1	; 0x17
    1a12:	18 8e       	std	Y+24, r1	; 0x18
						int counter=1;
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	90 e0       	ldi	r25, 0x00	; 0
    1a18:	9f 83       	std	Y+7, r25	; 0x07
    1a1a:	8e 83       	std	Y+6, r24	; 0x06
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    1a1c:	1a 8e       	std	Y+26, r1	; 0x1a
    1a1e:	19 8e       	std	Y+25, r1	; 0x19
    1a20:	1c 8e       	std	Y+28, r1	; 0x1c
    1a22:	1b 8e       	std	Y+27, r1	; 0x1b
    1a24:	1e 8e       	std	Y+30, r1	; 0x1e
    1a26:	1d 8e       	std	Y+29, r1	; 0x1d
    1a28:	18 a2       	lds	r17, 0x98
    1a2a:	1f 8e       	std	Y+31, r1	; 0x1f
    1a2c:	1a a2       	lds	r17, 0x9a
    1a2e:	19 a2       	lds	r17, 0x99
    1a30:	1c a2       	lds	r17, 0x9c
    1a32:	1b a2       	lds	r17, 0x9b
    1a34:	19 86       	std	Y+9, r1	; 0x09
    1a36:	18 86       	std	Y+8, r1	; 0x08
    1a38:	1b 86       	std	Y+11, r1	; 0x0b
    1a3a:	1a 86       	std	Y+10, r1	; 0x0a
    1a3c:	1d 86       	std	Y+13, r1	; 0x0d
    1a3e:	1c 86       	std	Y+12, r1	; 0x0c
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    1a40:	73 c0       	rjmp	.+230    	; 0x1b28 <_Z11ReceiveGAVRv+0x314>
							//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
							if (recString[counter]!=':' && hms<3){
    1a42:	9e 01       	movw	r18, r28
    1a44:	26 5d       	subi	r18, 0xD6	; 214
    1a46:	3f 4f       	sbci	r19, 0xFF	; 255
    1a48:	8e 81       	ldd	r24, Y+6	; 0x06
    1a4a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a4c:	82 0f       	add	r24, r18
    1a4e:	93 1f       	adc	r25, r19
    1a50:	fc 01       	movw	r30, r24
    1a52:	80 81       	ld	r24, Z
    1a54:	8a 33       	cpi	r24, 0x3A	; 58
    1a56:	e9 f0       	breq	.+58     	; 0x1a92 <_Z11ReceiveGAVRv+0x27e>
    1a58:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a5a:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a5c:	83 30       	cpi	r24, 0x03	; 3
    1a5e:	91 05       	cpc	r25, r1
    1a60:	c4 f4       	brge	.+48     	; 0x1a92 <_Z11ReceiveGAVRv+0x27e>
								tempStringNum[placement++]=recString[counter];
    1a62:	9e 01       	movw	r18, r28
    1a64:	26 5d       	subi	r18, 0xD6	; 214
    1a66:	3f 4f       	sbci	r19, 0xFF	; 255
    1a68:	8e 81       	ldd	r24, Y+6	; 0x06
    1a6a:	9f 81       	ldd	r25, Y+7	; 0x07
    1a6c:	82 0f       	add	r24, r18
    1a6e:	93 1f       	adc	r25, r19
    1a70:	fc 01       	movw	r30, r24
    1a72:	40 81       	ld	r20, Z
    1a74:	9e 01       	movw	r18, r28
    1a76:	2b 5d       	subi	r18, 0xDB	; 219
    1a78:	3f 4f       	sbci	r19, 0xFF	; 255
    1a7a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a7c:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a7e:	82 0f       	add	r24, r18
    1a80:	93 1f       	adc	r25, r19
    1a82:	fc 01       	movw	r30, r24
    1a84:	40 83       	st	Z, r20
    1a86:	8c 85       	ldd	r24, Y+12	; 0x0c
    1a88:	9d 85       	ldd	r25, Y+13	; 0x0d
    1a8a:	01 96       	adiw	r24, 0x01	; 1
    1a8c:	9d 87       	std	Y+13, r25	; 0x0d
    1a8e:	8c 87       	std	Y+12, r24	; 0x0c
    1a90:	46 c0       	rjmp	.+140    	; 0x1b1e <_Z11ReceiveGAVRv+0x30a>
							//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
							} else if (hms<2 && recString[counter] == ':') {
    1a92:	8a 85       	ldd	r24, Y+10	; 0x0a
    1a94:	9b 85       	ldd	r25, Y+11	; 0x0b
    1a96:	82 30       	cpi	r24, 0x02	; 2
    1a98:	91 05       	cpc	r25, r1
    1a9a:	0c f0       	brlt	.+2      	; 0x1a9e <_Z11ReceiveGAVRv+0x28a>
    1a9c:	40 c0       	rjmp	.+128    	; 0x1b1e <_Z11ReceiveGAVRv+0x30a>
    1a9e:	9e 01       	movw	r18, r28
    1aa0:	26 5d       	subi	r18, 0xD6	; 214
    1aa2:	3f 4f       	sbci	r19, 0xFF	; 255
    1aa4:	8e 81       	ldd	r24, Y+6	; 0x06
    1aa6:	9f 81       	ldd	r25, Y+7	; 0x07
    1aa8:	82 0f       	add	r24, r18
    1aaa:	93 1f       	adc	r25, r19
    1aac:	fc 01       	movw	r30, r24
    1aae:	80 81       	ld	r24, Z
    1ab0:	8a 33       	cpi	r24, 0x3A	; 58
    1ab2:	a9 f5       	brne	.+106    	; 0x1b1e <_Z11ReceiveGAVRv+0x30a>
								tempNum[hms++] = atoi(tempStringNum);
    1ab4:	ce 01       	movw	r24, r28
    1ab6:	85 96       	adiw	r24, 0x25	; 37
    1ab8:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
    1abc:	9c 01       	movw	r18, r24
    1abe:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ac0:	9b 85       	ldd	r25, Y+11	; 0x0b
    1ac2:	88 0f       	add	r24, r24
    1ac4:	99 1f       	adc	r25, r25
    1ac6:	ae 01       	movw	r20, r28
    1ac8:	4f 5f       	subi	r20, 0xFF	; 255
    1aca:	5f 4f       	sbci	r21, 0xFF	; 255
    1acc:	84 0f       	add	r24, r20
    1ace:	95 1f       	adc	r25, r21
    1ad0:	48 96       	adiw	r24, 0x18	; 24
    1ad2:	fc 01       	movw	r30, r24
    1ad4:	31 83       	std	Z+1, r19	; 0x01
    1ad6:	20 83       	st	Z, r18
    1ad8:	8a 85       	ldd	r24, Y+10	; 0x0a
    1ada:	9b 85       	ldd	r25, Y+11	; 0x0b
    1adc:	01 96       	adiw	r24, 0x01	; 1
    1ade:	9b 87       	std	Y+11, r25	; 0x0b
    1ae0:	8a 87       	std	Y+10, r24	; 0x0a
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1ae2:	1f 86       	std	Y+15, r1	; 0x0f
    1ae4:	1e 86       	std	Y+14, r1	; 0x0e
    1ae6:	0e c0       	rjmp	.+28     	; 0x1b04 <_Z11ReceiveGAVRv+0x2f0>
    1ae8:	9e 01       	movw	r18, r28
    1aea:	2b 5d       	subi	r18, 0xDB	; 219
    1aec:	3f 4f       	sbci	r19, 0xFF	; 255
    1aee:	8e 85       	ldd	r24, Y+14	; 0x0e
    1af0:	9f 85       	ldd	r25, Y+15	; 0x0f
    1af2:	82 0f       	add	r24, r18
    1af4:	93 1f       	adc	r25, r19
    1af6:	fc 01       	movw	r30, r24
    1af8:	10 82       	st	Z, r1
    1afa:	8e 85       	ldd	r24, Y+14	; 0x0e
    1afc:	9f 85       	ldd	r25, Y+15	; 0x0f
    1afe:	01 96       	adiw	r24, 0x01	; 1
    1b00:	9f 87       	std	Y+15, r25	; 0x0f
    1b02:	8e 87       	std	Y+14, r24	; 0x0e
    1b04:	41 e0       	ldi	r20, 0x01	; 1
    1b06:	2e 85       	ldd	r18, Y+14	; 0x0e
    1b08:	3f 85       	ldd	r19, Y+15	; 0x0f
    1b0a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1b0c:	9d 85       	ldd	r25, Y+13	; 0x0d
    1b0e:	82 17       	cp	r24, r18
    1b10:	93 07       	cpc	r25, r19
    1b12:	0c f4       	brge	.+2      	; 0x1b16 <_Z11ReceiveGAVRv+0x302>
    1b14:	40 e0       	ldi	r20, 0x00	; 0
    1b16:	44 23       	and	r20, r20
    1b18:	39 f7       	brne	.-50     	; 0x1ae8 <_Z11ReceiveGAVRv+0x2d4>
								placement=0;												//reset placement
    1b1a:	1d 86       	std	Y+13, r1	; 0x0d
    1b1c:	1c 86       	std	Y+12, r1	; 0x0c
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
    1b1e:	8e 81       	ldd	r24, Y+6	; 0x06
    1b20:	9f 81       	ldd	r25, Y+7	; 0x07
    1b22:	01 96       	adiw	r24, 0x01	; 1
    1b24:	9f 83       	std	Y+7, r25	; 0x07
    1b26:	8e 83       	std	Y+6, r24	; 0x06
						int counter=1;
						int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
						char tempStringNum[5];
						
						//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
						while (recString[counter] != '/' && recString[counter] != '\0'){
    1b28:	9e 01       	movw	r18, r28
    1b2a:	26 5d       	subi	r18, 0xD6	; 214
    1b2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1b2e:	8e 81       	ldd	r24, Y+6	; 0x06
    1b30:	9f 81       	ldd	r25, Y+7	; 0x07
    1b32:	82 0f       	add	r24, r18
    1b34:	93 1f       	adc	r25, r19
    1b36:	fc 01       	movw	r30, r24
    1b38:	80 81       	ld	r24, Z
    1b3a:	8f 32       	cpi	r24, 0x2F	; 47
    1b3c:	69 f0       	breq	.+26     	; 0x1b58 <_Z11ReceiveGAVRv+0x344>
    1b3e:	9e 01       	movw	r18, r28
    1b40:	26 5d       	subi	r18, 0xD6	; 214
    1b42:	3f 4f       	sbci	r19, 0xFF	; 255
    1b44:	8e 81       	ldd	r24, Y+6	; 0x06
    1b46:	9f 81       	ldd	r25, Y+7	; 0x07
    1b48:	82 0f       	add	r24, r18
    1b4a:	93 1f       	adc	r25, r19
    1b4c:	fc 01       	movw	r30, r24
    1b4e:	80 81       	ld	r24, Z
    1b50:	88 23       	and	r24, r24
    1b52:	11 f0       	breq	.+4      	; 0x1b58 <_Z11ReceiveGAVRv+0x344>
    1b54:	81 e0       	ldi	r24, 0x01	; 1
    1b56:	01 c0       	rjmp	.+2      	; 0x1b5a <_Z11ReceiveGAVRv+0x346>
    1b58:	80 e0       	ldi	r24, 0x00	; 0
    1b5a:	88 23       	and	r24, r24
    1b5c:	09 f0       	breq	.+2      	; 0x1b60 <_Z11ReceiveGAVRv+0x34c>
    1b5e:	71 cf       	rjmp	.-286    	; 0x1a42 <_Z11ReceiveGAVRv+0x22e>
							//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
							} else;
							counter++;
						}//end while
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
    1b60:	9e 01       	movw	r18, r28
    1b62:	26 5d       	subi	r18, 0xD6	; 214
    1b64:	3f 4f       	sbci	r19, 0xFF	; 255
    1b66:	8e 81       	ldd	r24, Y+6	; 0x06
    1b68:	9f 81       	ldd	r25, Y+7	; 0x07
    1b6a:	82 0f       	add	r24, r18
    1b6c:	93 1f       	adc	r25, r19
    1b6e:	fc 01       	movw	r30, r24
    1b70:	80 81       	ld	r24, Z
    1b72:	8f 32       	cpi	r24, 0x2F	; 47
    1b74:	b9 f4       	brne	.+46     	; 0x1ba4 <_Z11ReceiveGAVRv+0x390>
							tempNum[hms] = atoi(tempStringNum);
    1b76:	ce 01       	movw	r24, r28
    1b78:	85 96       	adiw	r24, 0x25	; 37
    1b7a:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
    1b7e:	9c 01       	movw	r18, r24
    1b80:	8a 85       	ldd	r24, Y+10	; 0x0a
    1b82:	9b 85       	ldd	r25, Y+11	; 0x0b
    1b84:	88 0f       	add	r24, r24
    1b86:	99 1f       	adc	r25, r25
    1b88:	ae 01       	movw	r20, r28
    1b8a:	4f 5f       	subi	r20, 0xFF	; 255
    1b8c:	5f 4f       	sbci	r21, 0xFF	; 255
    1b8e:	84 0f       	add	r24, r20
    1b90:	95 1f       	adc	r25, r21
    1b92:	48 96       	adiw	r24, 0x18	; 24
    1b94:	fc 01       	movw	r30, r24
    1b96:	31 83       	std	Z+1, r19	; 0x01
    1b98:	20 83       	st	Z, r18
							successTime=fTrue;
    1b9a:	81 e0       	ldi	r24, 0x01	; 1
    1b9c:	8f 8b       	std	Y+23, r24	; 0x17
							break;
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1b9e:	19 8a       	std	Y+17, r1	; 0x11
    1ba0:	18 8a       	std	Y+16, r1	; 0x10
    1ba2:	17 c0       	rjmp	.+46     	; 0x1bd2 <_Z11ReceiveGAVRv+0x3be>
						//Found a '/', assign tempNum otherwise exit with ACKBAD
						if (recString[counter] == '/'){
							tempNum[hms] = atoi(tempStringNum);
							successTime=fTrue;
						} else {
							state=5;
    1ba4:	85 e0       	ldi	r24, 0x05	; 5
    1ba6:	90 e0       	ldi	r25, 0x00	; 0
    1ba8:	9a 83       	std	Y+2, r25	; 0x02
    1baa:	89 83       	std	Y+1, r24	; 0x01
							PrintGAVR("B.");
    1bac:	82 e1       	ldi	r24, 0x12	; 18
    1bae:	91 e0       	ldi	r25, 0x01	; 1
    1bb0:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
							break;
    1bb4:	98 c1       	rjmp	.+816    	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
						}
						
						//If flag for Date is set, then parse the string and do something with it.
						//Now get the date. have to null the tempStringNum
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    1bb6:	9e 01       	movw	r18, r28
    1bb8:	2b 5d       	subi	r18, 0xDB	; 219
    1bba:	3f 4f       	sbci	r19, 0xFF	; 255
    1bbc:	88 89       	ldd	r24, Y+16	; 0x10
    1bbe:	99 89       	ldd	r25, Y+17	; 0x11
    1bc0:	82 0f       	add	r24, r18
    1bc2:	93 1f       	adc	r25, r19
    1bc4:	fc 01       	movw	r30, r24
    1bc6:	10 82       	st	Z, r1
    1bc8:	88 89       	ldd	r24, Y+16	; 0x10
    1bca:	99 89       	ldd	r25, Y+17	; 0x11
    1bcc:	01 96       	adiw	r24, 0x01	; 1
    1bce:	99 8b       	std	Y+17, r25	; 0x11
    1bd0:	88 8b       	std	Y+16, r24	; 0x10
    1bd2:	41 e0       	ldi	r20, 0x01	; 1
    1bd4:	28 89       	ldd	r18, Y+16	; 0x10
    1bd6:	39 89       	ldd	r19, Y+17	; 0x11
    1bd8:	8c 85       	ldd	r24, Y+12	; 0x0c
    1bda:	9d 85       	ldd	r25, Y+13	; 0x0d
    1bdc:	82 17       	cp	r24, r18
    1bde:	93 07       	cpc	r25, r19
    1be0:	0c f4       	brge	.+2      	; 0x1be4 <_Z11ReceiveGAVRv+0x3d0>
    1be2:	40 e0       	ldi	r20, 0x00	; 0
    1be4:	44 23       	and	r20, r20
    1be6:	39 f7       	brne	.-50     	; 0x1bb6 <_Z11ReceiveGAVRv+0x3a2>
						placement=0;
    1be8:	1d 86       	std	Y+13, r1	; 0x0d
    1bea:	1c 86       	std	Y+12, r1	; 0x0c
						counter++;	//get past the '/'
    1bec:	8e 81       	ldd	r24, Y+6	; 0x06
    1bee:	9f 81       	ldd	r25, Y+7	; 0x07
    1bf0:	01 96       	adiw	r24, 0x01	; 1
    1bf2:	9f 83       	std	Y+7, r25	; 0x07
    1bf4:	8e 83       	std	Y+6, r24	; 0x06
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1bf6:	73 c0       	rjmp	.+230    	; 0x1cde <_Z11ReceiveGAVRv+0x4ca>
							//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
							if  (recString[counter] != ',' && dmy < 3){
    1bf8:	9e 01       	movw	r18, r28
    1bfa:	26 5d       	subi	r18, 0xD6	; 214
    1bfc:	3f 4f       	sbci	r19, 0xFF	; 255
    1bfe:	8e 81       	ldd	r24, Y+6	; 0x06
    1c00:	9f 81       	ldd	r25, Y+7	; 0x07
    1c02:	82 0f       	add	r24, r18
    1c04:	93 1f       	adc	r25, r19
    1c06:	fc 01       	movw	r30, r24
    1c08:	80 81       	ld	r24, Z
    1c0a:	8c 32       	cpi	r24, 0x2C	; 44
    1c0c:	e9 f0       	breq	.+58     	; 0x1c48 <_Z11ReceiveGAVRv+0x434>
    1c0e:	88 85       	ldd	r24, Y+8	; 0x08
    1c10:	99 85       	ldd	r25, Y+9	; 0x09
    1c12:	83 30       	cpi	r24, 0x03	; 3
    1c14:	91 05       	cpc	r25, r1
    1c16:	c4 f4       	brge	.+48     	; 0x1c48 <_Z11ReceiveGAVRv+0x434>
								tempStringNum[placement++]=recString[counter];
    1c18:	9e 01       	movw	r18, r28
    1c1a:	26 5d       	subi	r18, 0xD6	; 214
    1c1c:	3f 4f       	sbci	r19, 0xFF	; 255
    1c1e:	8e 81       	ldd	r24, Y+6	; 0x06
    1c20:	9f 81       	ldd	r25, Y+7	; 0x07
    1c22:	82 0f       	add	r24, r18
    1c24:	93 1f       	adc	r25, r19
    1c26:	fc 01       	movw	r30, r24
    1c28:	40 81       	ld	r20, Z
    1c2a:	9e 01       	movw	r18, r28
    1c2c:	2b 5d       	subi	r18, 0xDB	; 219
    1c2e:	3f 4f       	sbci	r19, 0xFF	; 255
    1c30:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c32:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c34:	82 0f       	add	r24, r18
    1c36:	93 1f       	adc	r25, r19
    1c38:	fc 01       	movw	r30, r24
    1c3a:	40 83       	st	Z, r20
    1c3c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c3e:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c40:	01 96       	adiw	r24, 0x01	; 1
    1c42:	9d 87       	std	Y+13, r25	; 0x0d
    1c44:	8c 87       	std	Y+12, r24	; 0x0c
    1c46:	46 c0       	rjmp	.+140    	; 0x1cd4 <_Z11ReceiveGAVRv+0x4c0>
							//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
							} else if (dmy<2 && recString[counter]==','){
    1c48:	88 85       	ldd	r24, Y+8	; 0x08
    1c4a:	99 85       	ldd	r25, Y+9	; 0x09
    1c4c:	82 30       	cpi	r24, 0x02	; 2
    1c4e:	91 05       	cpc	r25, r1
    1c50:	0c f0       	brlt	.+2      	; 0x1c54 <_Z11ReceiveGAVRv+0x440>
    1c52:	40 c0       	rjmp	.+128    	; 0x1cd4 <_Z11ReceiveGAVRv+0x4c0>
    1c54:	9e 01       	movw	r18, r28
    1c56:	26 5d       	subi	r18, 0xD6	; 214
    1c58:	3f 4f       	sbci	r19, 0xFF	; 255
    1c5a:	8e 81       	ldd	r24, Y+6	; 0x06
    1c5c:	9f 81       	ldd	r25, Y+7	; 0x07
    1c5e:	82 0f       	add	r24, r18
    1c60:	93 1f       	adc	r25, r19
    1c62:	fc 01       	movw	r30, r24
    1c64:	80 81       	ld	r24, Z
    1c66:	8c 32       	cpi	r24, 0x2C	; 44
    1c68:	a9 f5       	brne	.+106    	; 0x1cd4 <_Z11ReceiveGAVRv+0x4c0>
								tempNum1[dmy++] = atoi(tempStringNum);
    1c6a:	ce 01       	movw	r24, r28
    1c6c:	85 96       	adiw	r24, 0x25	; 37
    1c6e:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
    1c72:	9c 01       	movw	r18, r24
    1c74:	88 85       	ldd	r24, Y+8	; 0x08
    1c76:	99 85       	ldd	r25, Y+9	; 0x09
    1c78:	88 0f       	add	r24, r24
    1c7a:	99 1f       	adc	r25, r25
    1c7c:	ae 01       	movw	r20, r28
    1c7e:	4f 5f       	subi	r20, 0xFF	; 255
    1c80:	5f 4f       	sbci	r21, 0xFF	; 255
    1c82:	84 0f       	add	r24, r20
    1c84:	95 1f       	adc	r25, r21
    1c86:	4e 96       	adiw	r24, 0x1e	; 30
    1c88:	fc 01       	movw	r30, r24
    1c8a:	31 83       	std	Z+1, r19	; 0x01
    1c8c:	20 83       	st	Z, r18
    1c8e:	88 85       	ldd	r24, Y+8	; 0x08
    1c90:	99 85       	ldd	r25, Y+9	; 0x09
    1c92:	01 96       	adiw	r24, 0x01	; 1
    1c94:	99 87       	std	Y+9, r25	; 0x09
    1c96:	88 87       	std	Y+8, r24	; 0x08
								for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    1c98:	1b 8a       	std	Y+19, r1	; 0x13
    1c9a:	1a 8a       	std	Y+18, r1	; 0x12
    1c9c:	0e c0       	rjmp	.+28     	; 0x1cba <_Z11ReceiveGAVRv+0x4a6>
    1c9e:	9e 01       	movw	r18, r28
    1ca0:	2b 5d       	subi	r18, 0xDB	; 219
    1ca2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca4:	8a 89       	ldd	r24, Y+18	; 0x12
    1ca6:	9b 89       	ldd	r25, Y+19	; 0x13
    1ca8:	82 0f       	add	r24, r18
    1caa:	93 1f       	adc	r25, r19
    1cac:	fc 01       	movw	r30, r24
    1cae:	10 82       	st	Z, r1
    1cb0:	8a 89       	ldd	r24, Y+18	; 0x12
    1cb2:	9b 89       	ldd	r25, Y+19	; 0x13
    1cb4:	01 96       	adiw	r24, 0x01	; 1
    1cb6:	9b 8b       	std	Y+19, r25	; 0x13
    1cb8:	8a 8b       	std	Y+18, r24	; 0x12
    1cba:	41 e0       	ldi	r20, 0x01	; 1
    1cbc:	2a 89       	ldd	r18, Y+18	; 0x12
    1cbe:	3b 89       	ldd	r19, Y+19	; 0x13
    1cc0:	8c 85       	ldd	r24, Y+12	; 0x0c
    1cc2:	9d 85       	ldd	r25, Y+13	; 0x0d
    1cc4:	82 17       	cp	r24, r18
    1cc6:	93 07       	cpc	r25, r19
    1cc8:	0c f4       	brge	.+2      	; 0x1ccc <_Z11ReceiveGAVRv+0x4b8>
    1cca:	40 e0       	ldi	r20, 0x00	; 0
    1ccc:	44 23       	and	r20, r20
    1cce:	39 f7       	brne	.-50     	; 0x1c9e <_Z11ReceiveGAVRv+0x48a>
								placement=0;
    1cd0:	1d 86       	std	Y+13, r1	; 0x0d
    1cd2:	1c 86       	std	Y+12, r1	; 0x0c
							} else;
							counter++;							
    1cd4:	8e 81       	ldd	r24, Y+6	; 0x06
    1cd6:	9f 81       	ldd	r25, Y+7	; 0x07
    1cd8:	01 96       	adiw	r24, 0x01	; 1
    1cda:	9f 83       	std	Y+7, r25	; 0x07
    1cdc:	8e 83       	std	Y+6, r24	; 0x06
						for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
						placement=0;
						counter++;	//get past the '/'
						
						//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
						while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    1cde:	9e 01       	movw	r18, r28
    1ce0:	26 5d       	subi	r18, 0xD6	; 214
    1ce2:	3f 4f       	sbci	r19, 0xFF	; 255
    1ce4:	8e 81       	ldd	r24, Y+6	; 0x06
    1ce6:	9f 81       	ldd	r25, Y+7	; 0x07
    1ce8:	82 0f       	add	r24, r18
    1cea:	93 1f       	adc	r25, r19
    1cec:	fc 01       	movw	r30, r24
    1cee:	80 81       	ld	r24, Z
    1cf0:	8e 32       	cpi	r24, 0x2E	; 46
    1cf2:	a1 f0       	breq	.+40     	; 0x1d1c <_Z11ReceiveGAVRv+0x508>
    1cf4:	9e 01       	movw	r18, r28
    1cf6:	26 5d       	subi	r18, 0xD6	; 214
    1cf8:	3f 4f       	sbci	r19, 0xFF	; 255
    1cfa:	8e 81       	ldd	r24, Y+6	; 0x06
    1cfc:	9f 81       	ldd	r25, Y+7	; 0x07
    1cfe:	82 0f       	add	r24, r18
    1d00:	93 1f       	adc	r25, r19
    1d02:	fc 01       	movw	r30, r24
    1d04:	80 81       	ld	r24, Z
    1d06:	88 23       	and	r24, r24
    1d08:	49 f0       	breq	.+18     	; 0x1d1c <_Z11ReceiveGAVRv+0x508>
    1d0a:	2e 81       	ldd	r18, Y+6	; 0x06
    1d0c:	3f 81       	ldd	r19, Y+7	; 0x07
    1d0e:	8b 81       	ldd	r24, Y+3	; 0x03
    1d10:	9c 81       	ldd	r25, Y+4	; 0x04
    1d12:	28 17       	cp	r18, r24
    1d14:	39 07       	cpc	r19, r25
    1d16:	11 f0       	breq	.+4      	; 0x1d1c <_Z11ReceiveGAVRv+0x508>
    1d18:	81 e0       	ldi	r24, 0x01	; 1
    1d1a:	01 c0       	rjmp	.+2      	; 0x1d1e <_Z11ReceiveGAVRv+0x50a>
    1d1c:	80 e0       	ldi	r24, 0x00	; 0
    1d1e:	88 23       	and	r24, r24
    1d20:	09 f0       	breq	.+2      	; 0x1d24 <_Z11ReceiveGAVRv+0x510>
    1d22:	6a cf       	rjmp	.-300    	; 0x1bf8 <_Z11ReceiveGAVRv+0x3e4>
								placement=0;
							} else;
							counter++;							
						}//end while
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
    1d24:	9e 01       	movw	r18, r28
    1d26:	26 5d       	subi	r18, 0xD6	; 214
    1d28:	3f 4f       	sbci	r19, 0xFF	; 255
    1d2a:	8e 81       	ldd	r24, Y+6	; 0x06
    1d2c:	9f 81       	ldd	r25, Y+7	; 0x07
    1d2e:	82 0f       	add	r24, r18
    1d30:	93 1f       	adc	r25, r19
    1d32:	fc 01       	movw	r30, r24
    1d34:	80 81       	ld	r24, Z
    1d36:	8e 32       	cpi	r24, 0x2E	; 46
    1d38:	c1 f4       	brne	.+48     	; 0x1d6a <_Z11ReceiveGAVRv+0x556>
							tempNum1[dmy] = atoi(tempStringNum);
    1d3a:	ce 01       	movw	r24, r28
    1d3c:	85 96       	adiw	r24, 0x25	; 37
    1d3e:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
    1d42:	9c 01       	movw	r18, r24
    1d44:	88 85       	ldd	r24, Y+8	; 0x08
    1d46:	99 85       	ldd	r25, Y+9	; 0x09
    1d48:	88 0f       	add	r24, r24
    1d4a:	99 1f       	adc	r25, r25
    1d4c:	ae 01       	movw	r20, r28
    1d4e:	4f 5f       	subi	r20, 0xFF	; 255
    1d50:	5f 4f       	sbci	r21, 0xFF	; 255
    1d52:	84 0f       	add	r24, r20
    1d54:	95 1f       	adc	r25, r21
    1d56:	4e 96       	adiw	r24, 0x1e	; 30
    1d58:	fc 01       	movw	r30, r24
    1d5a:	31 83       	std	Z+1, r19	; 0x01
    1d5c:	20 83       	st	Z, r18
							successDate=fTrue;
    1d5e:	81 e0       	ldi	r24, 0x01	; 1
    1d60:	88 8f       	std	Y+24, r24	; 0x18
							state=5;
							break;
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (successDate && successTime){
    1d62:	88 8d       	ldd	r24, Y+24	; 0x18
    1d64:	88 23       	and	r24, r24
    1d66:	51 f4       	brne	.+20     	; 0x1d7c <_Z11ReceiveGAVRv+0x568>
    1d68:	37 c0       	rjmp	.+110    	; 0x1dd8 <_Z11ReceiveGAVRv+0x5c4>
						//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
						if (recString[counter] == '.'){
							tempNum1[dmy] = atoi(tempStringNum);
							successDate=fTrue;
						} else {//something in the string was wrong, ACKBAD and then exit
							PrintGAVR("B.");
    1d6a:	82 e1       	ldi	r24, 0x12	; 18
    1d6c:	91 e0       	ldi	r25, 0x01	; 1
    1d6e:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
							state=5;
    1d72:	85 e0       	ldi	r24, 0x05	; 5
    1d74:	90 e0       	ldi	r25, 0x00	; 0
    1d76:	9a 83       	std	Y+2, r25	; 0x02
    1d78:	89 83       	std	Y+1, r24	; 0x01
							break;
    1d7a:	b5 c0       	rjmp	.+362    	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
						}
										
						//Make sure the settings are okay before setting the time. If not, send ACKBAD and exit.
						if (successDate && successTime){
    1d7c:	8f 89       	ldd	r24, Y+23	; 0x17
    1d7e:	88 23       	and	r24, r24
    1d80:	59 f1       	breq	.+86     	; 0x1dd8 <_Z11ReceiveGAVRv+0x5c4>
							currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    1d82:	69 8d       	ldd	r22, Y+25	; 0x19
    1d84:	7a 8d       	ldd	r23, Y+26	; 0x1a
    1d86:	4b 8d       	ldd	r20, Y+27	; 0x1b
    1d88:	5c 8d       	ldd	r21, Y+28	; 0x1c
    1d8a:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1d8c:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1d8e:	84 ee       	ldi	r24, 0xE4	; 228
    1d90:	91 e0       	ldi	r25, 0x01	; 1
    1d92:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
							currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    1d96:	6f 8d       	ldd	r22, Y+31	; 0x1f
    1d98:	78 a1       	lds	r23, 0x48
    1d9a:	49 a1       	lds	r20, 0x49
    1d9c:	5a a1       	lds	r21, 0x4a
    1d9e:	2b a1       	lds	r18, 0x4b
    1da0:	3c a1       	lds	r19, 0x4c
    1da2:	84 ee       	ldi	r24, 0xE4	; 228
    1da4:	91 e0       	ldi	r25, 0x01	; 1
    1da6:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
							saveDateTime_eeprom(fTrue,fTrue);
    1daa:	81 e0       	ldi	r24, 0x01	; 1
    1dac:	61 e0       	ldi	r22, 0x01	; 1
    1dae:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
							flagUserClock=fFalse;
    1db2:	10 92 15 02 	sts	0x0215, r1
							flagWaitingForReceiveGAVR=fFalse;			
    1db6:	10 92 10 02 	sts	0x0210, r1
							//send ACK
							recString[0]='A';
    1dba:	81 e4       	ldi	r24, 0x41	; 65
    1dbc:	8a a7       	lds	r24, 0x7a
							PrintGAVR(recString);
    1dbe:	ce 01       	movw	r24, r28
    1dc0:	8a 96       	adiw	r24, 0x2a	; 42
    1dc2:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
							PrintBone("Set my time.");
    1dc6:	8c e7       	ldi	r24, 0x7C	; 124
    1dc8:	91 e0       	ldi	r25, 0x01	; 1
    1dca:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
							state=7;
    1dce:	87 e0       	ldi	r24, 0x07	; 7
    1dd0:	90 e0       	ldi	r25, 0x00	; 0
    1dd2:	9a 83       	std	Y+2, r25	; 0x02
    1dd4:	89 83       	std	Y+1, r24	; 0x01
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("NO.");
						state=5;
					}// end if-else (flagUserClock)					
					//Exit
					break;
    1dd6:	87 c0       	rjmp	.+270    	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
							PrintGAVR(recString);
							PrintBone("Set my time.");
							state=7;
						} else {			//If one was unsucessful, we need to keep waiting for the date
							//Here is a choice: Do we watn  to user to indicate the time is wrong, or just make them set it? Doesn't really matter.
							flagUserClock=fTrue;
    1dd8:	81 e0       	ldi	r24, 0x01	; 1
    1dda:	80 93 15 02 	sts	0x0215, r24
							flagWaitingForReceiveGAVR=fTrue;
    1dde:	81 e0       	ldi	r24, 0x01	; 1
    1de0:	80 93 10 02 	sts	0x0210, r24
							PrintBone("Bad time.");
    1de4:	89 e8       	ldi	r24, 0x89	; 137
    1de6:	91 e0       	ldi	r25, 0x01	; 1
    1de8:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
							state=5;						
    1dec:	85 e0       	ldi	r24, 0x05	; 5
    1dee:	90 e0       	ldi	r25, 0x00	; 0
    1df0:	9a 83       	std	Y+2, r25	; 0x02
    1df2:	89 83       	std	Y+1, r24	; 0x01
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("NO.");
						state=5;
					}// end if-else (flagUserClock)					
					//Exit
					break;
    1df4:	78 c0       	rjmp	.+240    	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
							PrintBone("Bad time.");
							state=5;						
						}//end if-else flagUserTime && successDate/Time
																																	
					} else {	//don't need the date or time, wasn't looking for it. Respond with ACKNO. Should reset all flags on GAVR side.
						PrintGAVR("NO.");
    1df6:	83 e9       	ldi	r24, 0x93	; 147
    1df8:	91 e0       	ldi	r25, 0x01	; 1
    1dfa:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
						state=5;
    1dfe:	85 e0       	ldi	r24, 0x05	; 5
    1e00:	90 e0       	ldi	r25, 0x00	; 0
    1e02:	9a 83       	std	Y+2, r25	; 0x02
    1e04:	89 83       	std	Y+1, r24	; 0x01
					}// end if-else (flagUserClock)					
					//Exit
					break;
    1e06:	6f c0       	rjmp	.+222    	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
					}//end case 3				
				case 4:{
					Wait_ms(100);
    1e08:	84 e6       	ldi	r24, 0x64	; 100
    1e0a:	90 e0       	ldi	r25, 0x00	; 0
    1e0c:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					//Successful SYNNEED case.
					if (!flagUserClock){	//If we don't need the date or time, update with what we have.
    1e10:	80 91 15 02 	lds	r24, 0x0215
    1e14:	88 23       	and	r24, r24
    1e16:	61 f4       	brne	.+24     	; 0x1e30 <_Z11ReceiveGAVRv+0x61c>
						flagUpdateGAVRClock=fTrue;
    1e18:	81 e0       	ldi	r24, 0x01	; 1
    1e1a:	80 93 13 02 	sts	0x0213, r24
						PrintGAVR("N.");				//respond with correct ack
    1e1e:	8d e6       	ldi	r24, 0x6D	; 109
    1e20:	91 e0       	ldi	r25, 0x01	; 1
    1e22:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
						PrintBone("GAVR Needs.");
    1e26:	87 e9       	ldi	r24, 0x97	; 151
    1e28:	91 e0       	ldi	r25, 0x01	; 1
    1e2a:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    1e2e:	08 c0       	rjmp	.+16     	; 0x1e40 <_Z11ReceiveGAVRv+0x62c>
					} else {
						PrintBone("NO.");
    1e30:	83 e9       	ldi	r24, 0x93	; 147
    1e32:	91 e0       	ldi	r25, 0x01	; 1
    1e34:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
						PrintGAVR("NO.");	//say we can't give you anything, ask the user.
    1e38:	83 e9       	ldi	r24, 0x93	; 147
    1e3a:	91 e0       	ldi	r25, 0x01	; 1
    1e3c:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
						//Should be expecting something from the GAVR with user date and time, this reminds the GAVR.
					} //end if-else
					state=5;
    1e40:	85 e0       	ldi	r24, 0x05	; 5
    1e42:	90 e0       	ldi	r25, 0x00	; 0
    1e44:	9a 83       	std	Y+2, r25	; 0x02
    1e46:	89 83       	std	Y+1, r24	; 0x01
					break;					
    1e48:	4e c0       	rjmp	.+156    	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 4
				case 5:{
					//Exit case
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    1e4a:	1d 8a       	std	Y+21, r1	; 0x15
    1e4c:	1c 8a       	std	Y+20, r1	; 0x14
    1e4e:	0e c0       	rjmp	.+28     	; 0x1e6c <_Z11ReceiveGAVRv+0x658>
    1e50:	9e 01       	movw	r18, r28
    1e52:	26 5d       	subi	r18, 0xD6	; 214
    1e54:	3f 4f       	sbci	r19, 0xFF	; 255
    1e56:	8c 89       	ldd	r24, Y+20	; 0x14
    1e58:	9d 89       	ldd	r25, Y+21	; 0x15
    1e5a:	82 0f       	add	r24, r18
    1e5c:	93 1f       	adc	r25, r19
    1e5e:	fc 01       	movw	r30, r24
    1e60:	10 82       	st	Z, r1
    1e62:	8c 89       	ldd	r24, Y+20	; 0x14
    1e64:	9d 89       	ldd	r25, Y+21	; 0x15
    1e66:	01 96       	adiw	r24, 0x01	; 1
    1e68:	9d 8b       	std	Y+21, r25	; 0x15
    1e6a:	8c 8b       	std	Y+20, r24	; 0x14
    1e6c:	2c 89       	ldd	r18, Y+20	; 0x14
    1e6e:	3d 89       	ldd	r19, Y+21	; 0x15
    1e70:	41 e0       	ldi	r20, 0x01	; 1
    1e72:	8b 81       	ldd	r24, Y+3	; 0x03
    1e74:	9c 81       	ldd	r25, Y+4	; 0x04
    1e76:	28 17       	cp	r18, r24
    1e78:	39 07       	cpc	r19, r25
    1e7a:	08 f0       	brcs	.+2      	; 0x1e7e <_Z11ReceiveGAVRv+0x66a>
    1e7c:	40 e0       	ldi	r20, 0x00	; 0
    1e7e:	44 23       	and	r20, r20
    1e80:	39 f7       	brne	.-50     	; 0x1e50 <_Z11ReceiveGAVRv+0x63c>
					flagReceivingGAVR=fFalse;
    1e82:	10 92 0f 02 	sts	0x020F, r1
					flagWaitingForReceiveGAVR=fFalse;
    1e86:	10 92 10 02 	sts	0x0210, r1
					state=0;		//just in case
    1e8a:	1a 82       	std	Y+2, r1	; 0x02
    1e8c:	19 82       	std	Y+1, r1	; 0x01
					break;
    1e8e:	2b c0       	rjmp	.+86     	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 5
				case 6:{
					//Error in ACK case
					Wait_ms(150);
    1e90:	86 e9       	ldi	r24, 0x96	; 150
    1e92:	90 e0       	ldi	r25, 0x00	; 0
    1e94:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					PrintGAVR("E.");
    1e98:	83 ea       	ldi	r24, 0xA3	; 163
    1e9a:	91 e0       	ldi	r25, 0x01	; 1
    1e9c:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
					PrintBone("ErrorR.");
    1ea0:	86 ea       	ldi	r24, 0xA6	; 166
    1ea2:	91 e0       	ldi	r25, 0x01	; 1
    1ea4:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					state=5;
    1ea8:	85 e0       	ldi	r24, 0x05	; 5
    1eaa:	90 e0       	ldi	r25, 0x00	; 0
    1eac:	9a 83       	std	Y+2, r25	; 0x02
    1eae:	89 83       	std	Y+1, r24	; 0x01
					break;
    1eb0:	1a c0       	rjmp	.+52     	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 6
				case 7:{
					Wait_ms(150);
    1eb2:	86 e9       	ldi	r24, 0x96	; 150
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
					//Successful grab of date/time case
					recString[0]='A';
    1eba:	81 e4       	ldi	r24, 0x41	; 65
    1ebc:	8a a7       	lds	r24, 0x7a
					PrintGAVR(recString);
    1ebe:	ce 01       	movw	r24, r28
    1ec0:	8a 96       	adiw	r24, 0x2a	; 42
    1ec2:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
					state=5;
    1ec6:	85 e0       	ldi	r24, 0x05	; 5
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	9a 83       	std	Y+2, r25	; 0x02
    1ecc:	89 83       	std	Y+1, r24	; 0x01
					PrintBone("Success.");
    1ece:	81 e5       	ldi	r24, 0x51	; 81
    1ed0:	91 e0       	ldi	r25, 0x01	; 1
    1ed2:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					break;		
    1ed6:	07 c0       	rjmp	.+14     	; 0x1ee6 <_Z11ReceiveGAVRv+0x6d2>
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
    1ed8:	1a 82       	std	Y+2, r1	; 0x02
    1eda:	19 82       	std	Y+1, r1	; 0x01
    1edc:	1c 82       	std	Y+4, r1	; 0x04
    1ede:	1b 82       	std	Y+3, r1	; 0x03
    1ee0:	10 92 0f 02 	sts	0x020F, r1
    1ee4:	00 00       	nop
	char recChar, recString[40];
	unsigned int strLoc=0;
	BOOL noCarriage=fTrue;
	
	//While Loop
	while (flagReceivingGAVR){
    1ee6:	90 91 0f 02 	lds	r25, 0x020F
    1eea:	81 e0       	ldi	r24, 0x01	; 1
    1eec:	99 23       	and	r25, r25
    1eee:	09 f4       	brne	.+2      	; 0x1ef2 <_Z11ReceiveGAVRv+0x6de>
    1ef0:	80 e0       	ldi	r24, 0x00	; 0
    1ef2:	88 23       	and	r24, r24
    1ef4:	09 f0       	breq	.+2      	; 0x1ef8 <_Z11ReceiveGAVRv+0x6e4>
    1ef6:	a0 cc       	rjmp	.-1728   	; 0x1838 <_Z11ReceiveGAVRv+0x24>
					break;		
				}//end case 7
				default: {state=0; strLoc=0; flagReceivingGAVR=fFalse; break;}				
			}//end switch	
		}//end while flagReceivingGAVR	
}	
    1ef8:	cf 5a       	subi	r28, 0xAF	; 175
    1efa:	df 4f       	sbci	r29, 0xFF	; 255
    1efc:	0f b6       	in	r0, 0x3f	; 63
    1efe:	f8 94       	cli
    1f00:	de bf       	out	0x3e, r29	; 62
    1f02:	0f be       	out	0x3f, r0	; 63
    1f04:	cd bf       	out	0x3d, r28	; 61
    1f06:	df 91       	pop	r29
    1f08:	cf 91       	pop	r28
    1f0a:	08 95       	ret

00001f0c <_Z11ReceiveBonev>:
/*************************************************************************************************************/
void ReceiveBone(){
    1f0c:	cf 93       	push	r28
    1f0e:	df 93       	push	r29
    1f10:	cd b7       	in	r28, 0x3d	; 61
    1f12:	de b7       	in	r29, 0x3e	; 62
    1f14:	c5 56       	subi	r28, 0x65	; 101
    1f16:	d0 40       	sbci	r29, 0x00	; 0
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	f8 94       	cli
    1f1c:	de bf       	out	0x3e, r29	; 62
    1f1e:	0f be       	out	0x3f, r0	; 63
    1f20:	cd bf       	out	0x3d, r28	; 61
	BYTE state=0,strLoc=0;
    1f22:	19 82       	std	Y+1, r1	; 0x01
    1f24:	1a 82       	std	Y+2, r1	; 0x02
	char recChar, recString[40];
	BOOL noCarriage=fTrue;
    1f26:	81 e0       	ldi	r24, 0x01	; 1
    1f28:	8b 83       	std	Y+3, r24	; 0x03
	while (flagReceivingBone){
    1f2a:	f6 c3       	rjmp	.+2028   	; 0x2718 <_Z11ReceiveBonev+0x80c>
			/* State 6: Graceful exit. Exit from a command like adc or temp.																*/
			/* State 7: Parse the input string for the time and date. Should be time(:)'/'date(,) where : and , are the delimiters. Term by */
			/*			'.'																													*/
			/********************************************************************************************************************************/
			
			switch(state){
    1f2c:	89 81       	ldd	r24, Y+1	; 0x01
    1f2e:	88 2f       	mov	r24, r24
    1f30:	90 e0       	ldi	r25, 0x00	; 0
    1f32:	83 30       	cpi	r24, 0x03	; 3
    1f34:	91 05       	cpc	r25, r1
    1f36:	09 f4       	brne	.+2      	; 0x1f3a <_Z11ReceiveBonev+0x2e>
    1f38:	48 c1       	rjmp	.+656    	; 0x21ca <_Z11ReceiveBonev+0x2be>
    1f3a:	84 30       	cpi	r24, 0x04	; 4
    1f3c:	91 05       	cpc	r25, r1
    1f3e:	5c f4       	brge	.+22     	; 0x1f56 <_Z11ReceiveBonev+0x4a>
    1f40:	81 30       	cpi	r24, 0x01	; 1
    1f42:	91 05       	cpc	r25, r1
    1f44:	09 f4       	brne	.+2      	; 0x1f48 <_Z11ReceiveBonev+0x3c>
    1f46:	77 c0       	rjmp	.+238    	; 0x2036 <_Z11ReceiveBonev+0x12a>
    1f48:	82 30       	cpi	r24, 0x02	; 2
    1f4a:	91 05       	cpc	r25, r1
    1f4c:	0c f0       	brlt	.+2      	; 0x1f50 <_Z11ReceiveBonev+0x44>
    1f4e:	83 c0       	rjmp	.+262    	; 0x2056 <_Z11ReceiveBonev+0x14a>
    1f50:	00 97       	sbiw	r24, 0x00	; 0
    1f52:	91 f0       	breq	.+36     	; 0x1f78 <_Z11ReceiveBonev+0x6c>
    1f54:	dd c3       	rjmp	.+1978   	; 0x2710 <_Z11ReceiveBonev+0x804>
    1f56:	85 30       	cpi	r24, 0x05	; 5
    1f58:	91 05       	cpc	r25, r1
    1f5a:	09 f4       	brne	.+2      	; 0x1f5e <_Z11ReceiveBonev+0x52>
    1f5c:	82 c1       	rjmp	.+772    	; 0x2262 <_Z11ReceiveBonev+0x356>
    1f5e:	85 30       	cpi	r24, 0x05	; 5
    1f60:	91 05       	cpc	r25, r1
    1f62:	0c f4       	brge	.+2      	; 0x1f66 <_Z11ReceiveBonev+0x5a>
    1f64:	59 c1       	rjmp	.+690    	; 0x2218 <_Z11ReceiveBonev+0x30c>
    1f66:	86 30       	cpi	r24, 0x06	; 6
    1f68:	91 05       	cpc	r25, r1
    1f6a:	09 f4       	brne	.+2      	; 0x1f6e <_Z11ReceiveBonev+0x62>
    1f6c:	a3 c1       	rjmp	.+838    	; 0x22b4 <_Z11ReceiveBonev+0x3a8>
    1f6e:	87 30       	cpi	r24, 0x07	; 7
    1f70:	91 05       	cpc	r25, r1
    1f72:	09 f4       	brne	.+2      	; 0x1f76 <_Z11ReceiveBonev+0x6a>
    1f74:	c0 c1       	rjmp	.+896    	; 0x22f6 <_Z11ReceiveBonev+0x3ea>
    1f76:	cc c3       	rjmp	.+1944   	; 0x2710 <_Z11ReceiveBonev+0x804>
				case 0:{
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
    1f78:	1a 82       	std	Y+2, r1	; 0x02
					recChar = UDR0;
    1f7a:	86 ec       	ldi	r24, 0xC6	; 198
    1f7c:	90 e0       	ldi	r25, 0x00	; 0
    1f7e:	fc 01       	movw	r30, r24
    1f80:	80 81       	ld	r24, Z
    1f82:	8c 8f       	std	Y+28, r24	; 0x1c
					if (recChar=='.'){
    1f84:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1f86:	8e 32       	cpi	r24, 0x2E	; 46
    1f88:	19 f4       	brne	.+6      	; 0x1f90 <_Z11ReceiveBonev+0x84>
						state=5;
    1f8a:	85 e0       	ldi	r24, 0x05	; 5
    1f8c:	89 83       	std	Y+1, r24	; 0x01
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
    1f8e:	c4 c3       	rjmp	.+1928   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					//Get the first character. If a '.', exit to bad state.
					strLoc=0;
					recChar = UDR0;
					if (recChar=='.'){
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
    1f90:	8a 81       	ldd	r24, Y+2	; 0x02
    1f92:	88 2f       	mov	r24, r24
    1f94:	90 e0       	ldi	r25, 0x00	; 0
    1f96:	9e 01       	movw	r18, r28
    1f98:	22 5c       	subi	r18, 0xC2	; 194
    1f9a:	3f 4f       	sbci	r19, 0xFF	; 255
    1f9c:	82 0f       	add	r24, r18
    1f9e:	93 1f       	adc	r25, r19
    1fa0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1fa2:	fc 01       	movw	r30, r24
    1fa4:	20 83       	st	Z, r18
    1fa6:	8a 81       	ldd	r24, Y+2	; 0x02
    1fa8:	8f 5f       	subi	r24, 0xFF	; 255
    1faa:	8a 83       	std	Y+2, r24	; 0x02
    1fac:	81 e0       	ldi	r24, 0x01	; 1
    1fae:	89 83       	std	Y+1, r24	; 0x01
					break;				
    1fb0:	b3 c3       	rjmp	.+1894   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						Wait_ms(50);
    1fb2:	82 e3       	ldi	r24, 0x32	; 50
    1fb4:	90 e0       	ldi	r25, 0x00	; 0
    1fb6:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
						while ((!(UCSR0A & (1 << RXC0))) && flagReceivingBone);		//get the next character
    1fba:	00 00       	nop
    1fbc:	80 ec       	ldi	r24, 0xC0	; 192
    1fbe:	90 e0       	ldi	r25, 0x00	; 0
    1fc0:	fc 01       	movw	r30, r24
    1fc2:	80 81       	ld	r24, Z
    1fc4:	88 23       	and	r24, r24
    1fc6:	34 f0       	brlt	.+12     	; 0x1fd4 <_Z11ReceiveBonev+0xc8>
    1fc8:	80 91 0d 02 	lds	r24, 0x020D
    1fcc:	88 23       	and	r24, r24
    1fce:	11 f0       	breq	.+4      	; 0x1fd4 <_Z11ReceiveBonev+0xc8>
    1fd0:	81 e0       	ldi	r24, 0x01	; 1
    1fd2:	01 c0       	rjmp	.+2      	; 0x1fd6 <_Z11ReceiveBonev+0xca>
    1fd4:	80 e0       	ldi	r24, 0x00	; 0
    1fd6:	88 23       	and	r24, r24
    1fd8:	89 f7       	brne	.-30     	; 0x1fbc <_Z11ReceiveBonev+0xb0>
						if (!flagReceivingBone){break;}					//if there was a timeout, break out and reset state
    1fda:	80 91 0d 02 	lds	r24, 0x020D
    1fde:	88 23       	and	r24, r24
    1fe0:	c1 f1       	breq	.+112    	; 0x2052 <_Z11ReceiveBonev+0x146>
						recChar=UDR0;
    1fe2:	86 ec       	ldi	r24, 0xC6	; 198
    1fe4:	90 e0       	ldi	r25, 0x00	; 0
    1fe6:	fc 01       	movw	r30, r24
    1fe8:	80 81       	ld	r24, Z
    1fea:	8c 8f       	std	Y+28, r24	; 0x1c
						recString[strLoc++]=recChar;
    1fec:	8a 81       	ldd	r24, Y+2	; 0x02
    1fee:	88 2f       	mov	r24, r24
    1ff0:	90 e0       	ldi	r25, 0x00	; 0
    1ff2:	9e 01       	movw	r18, r28
    1ff4:	22 5c       	subi	r18, 0xC2	; 194
    1ff6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ff8:	82 0f       	add	r24, r18
    1ffa:	93 1f       	adc	r25, r19
    1ffc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1ffe:	fc 01       	movw	r30, r24
    2000:	20 83       	st	Z, r18
    2002:	8a 81       	ldd	r24, Y+2	; 0x02
    2004:	8f 5f       	subi	r24, 0xFF	; 255
    2006:	8a 83       	std	Y+2, r24	; 0x02
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
    2008:	8c 8d       	ldd	r24, Y+28	; 0x1c
    200a:	8e 32       	cpi	r24, 0x2E	; 46
    200c:	71 f4       	brne	.+28     	; 0x202a <_Z11ReceiveBonev+0x11e>
    200e:	8a 81       	ldd	r24, Y+2	; 0x02
    2010:	88 2f       	mov	r24, r24
    2012:	90 e0       	ldi	r25, 0x00	; 0
    2014:	9e 01       	movw	r18, r28
    2016:	22 5c       	subi	r18, 0xC2	; 194
    2018:	3f 4f       	sbci	r19, 0xFF	; 255
    201a:	82 0f       	add	r24, r18
    201c:	93 1f       	adc	r25, r19
    201e:	fc 01       	movw	r30, r24
    2020:	10 82       	st	Z, r1
    2022:	1b 82       	std	Y+3, r1	; 0x03
    2024:	82 e0       	ldi	r24, 0x02	; 2
    2026:	89 83       	std	Y+1, r24	; 0x01
    2028:	06 c0       	rjmp	.+12     	; 0x2036 <_Z11ReceiveBonev+0x12a>
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
    202a:	8a 81       	ldd	r24, Y+2	; 0x02
    202c:	87 32       	cpi	r24, 0x27	; 39
    202e:	18 f0       	brcs	.+6      	; 0x2036 <_Z11ReceiveBonev+0x12a>
    2030:	85 e0       	ldi	r24, 0x05	; 5
    2032:	89 83       	std	Y+1, r24	; 0x01
    2034:	1b 82       	std	Y+3, r1	; 0x03
						state=5;
					} else  {recString[strLoc++]=recChar; state=1;}	
					break;				
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
    2036:	8b 81       	ldd	r24, Y+3	; 0x03
    2038:	88 23       	and	r24, r24
    203a:	31 f0       	breq	.+12     	; 0x2048 <_Z11ReceiveBonev+0x13c>
    203c:	80 91 0d 02 	lds	r24, 0x020D
    2040:	88 23       	and	r24, r24
    2042:	11 f0       	breq	.+4      	; 0x2048 <_Z11ReceiveBonev+0x13c>
    2044:	81 e0       	ldi	r24, 0x01	; 1
    2046:	01 c0       	rjmp	.+2      	; 0x204a <_Z11ReceiveBonev+0x13e>
    2048:	80 e0       	ldi	r24, 0x00	; 0
    204a:	88 23       	and	r24, r24
    204c:	09 f0       	breq	.+2      	; 0x2050 <_Z11ReceiveBonev+0x144>
    204e:	b1 cf       	rjmp	.-158    	; 0x1fb2 <_Z11ReceiveBonev+0xa6>
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    2050:	63 c3       	rjmp	.+1734   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 0
				case 1:{
					while (noCarriage && flagReceivingBone){	//while there isn't a timeout and no carry
						Wait_ms(50);
						while ((!(UCSR0A & (1 << RXC0))) && flagReceivingBone);		//get the next character
						if (!flagReceivingBone){break;}					//if there was a timeout, break out and reset state
    2052:	00 00       	nop
						recString[strLoc++]=recChar;
						if (recChar == '.'){recString[strLoc]='\0'; noCarriage=fFalse; state=2;}
						else if (strLoc >= 39){state=5;noCarriage=fFalse;}
						else; //end if-elseif-else
					}//end while
					break;
    2054:	61 c3       	rjmp	.+1730   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
    2056:	ce 01       	movw	r24, r28
    2058:	ce 96       	adiw	r24, 0x3e	; 62
    205a:	2e ea       	ldi	r18, 0xAE	; 174
    205c:	31 e0       	ldi	r19, 0x01	; 1
    205e:	b9 01       	movw	r22, r18
    2060:	42 e0       	ldi	r20, 0x02	; 2
    2062:	50 e0       	ldi	r21, 0x00	; 0
    2064:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    2068:	00 97       	sbiw	r24, 0x00	; 0
    206a:	41 f4       	brne	.+16     	; 0x207c <_Z11ReceiveBonev+0x170>
    206c:	81 e0       	ldi	r24, 0x01	; 1
    206e:	60 e0       	ldi	r22, 0x00	; 0
    2070:	41 e0       	ldi	r20, 0x01	; 1
    2072:	0e 94 9f 13 	call	0x273e	; 0x273e <_Z13printTimeDatehhh>
    2076:	86 e0       	ldi	r24, 0x06	; 6
    2078:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    207a:	4e c3       	rjmp	.+1692   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end while
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
    207c:	ce 01       	movw	r24, r28
    207e:	ce 96       	adiw	r24, 0x3e	; 62
    2080:	21 eb       	ldi	r18, 0xB1	; 177
    2082:	31 e0       	ldi	r19, 0x01	; 1
    2084:	b9 01       	movw	r22, r18
    2086:	42 e0       	ldi	r20, 0x02	; 2
    2088:	50 e0       	ldi	r21, 0x00	; 0
    208a:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    208e:	00 97       	sbiw	r24, 0x00	; 0
    2090:	41 f4       	brne	.+16     	; 0x20a2 <_Z11ReceiveBonev+0x196>
    2092:	81 e0       	ldi	r24, 0x01	; 1
    2094:	61 e0       	ldi	r22, 0x01	; 1
    2096:	40 e0       	ldi	r20, 0x00	; 0
    2098:	0e 94 9f 13 	call	0x273e	; 0x273e <_Z13printTimeDatehhh>
    209c:	86 e0       	ldi	r24, 0x06	; 6
    209e:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    20a0:	3b c3       	rjmp	.+1654   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					break;
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
    20a2:	ce 01       	movw	r24, r28
    20a4:	ce 96       	adiw	r24, 0x3e	; 62
    20a6:	24 eb       	ldi	r18, 0xB4	; 180
    20a8:	31 e0       	ldi	r19, 0x01	; 1
    20aa:	b9 01       	movw	r22, r18
    20ac:	42 e0       	ldi	r20, 0x02	; 2
    20ae:	50 e0       	ldi	r21, 0x00	; 0
    20b0:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    20b4:	00 97       	sbiw	r24, 0x00	; 0
    20b6:	41 f4       	brne	.+16     	; 0x20c8 <_Z11ReceiveBonev+0x1bc>
    20b8:	81 e0       	ldi	r24, 0x01	; 1
    20ba:	61 e0       	ldi	r22, 0x01	; 1
    20bc:	41 e0       	ldi	r20, 0x01	; 1
    20be:	0e 94 9f 13 	call	0x273e	; 0x273e <_Z13printTimeDatehhh>
    20c2:	86 e0       	ldi	r24, 0x06	; 6
    20c4:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    20c6:	28 c3       	rjmp	.+1616   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 1
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
    20c8:	ce 01       	movw	r24, r28
    20ca:	ce 96       	adiw	r24, 0x3e	; 62
    20cc:	27 eb       	ldi	r18, 0xB7	; 183
    20ce:	31 e0       	ldi	r19, 0x01	; 1
    20d0:	b9 01       	movw	r22, r18
    20d2:	42 e0       	ldi	r20, 0x02	; 2
    20d4:	50 e0       	ldi	r21, 0x00	; 0
    20d6:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    20da:	00 97       	sbiw	r24, 0x00	; 0
    20dc:	59 f4       	brne	.+22     	; 0x20f4 <_Z11ReceiveBonev+0x1e8>
    20de:	81 e0       	ldi	r24, 0x01	; 1
    20e0:	60 e0       	ldi	r22, 0x00	; 0
    20e2:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    20e6:	ce 01       	movw	r24, r28
    20e8:	ce 96       	adiw	r24, 0x3e	; 62
    20ea:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    20ee:	86 e0       	ldi	r24, 0x06	; 6
    20f0:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    20f2:	12 c3       	rjmp	.+1572   	; 0x2718 <_Z11ReceiveBonev+0x80c>
				case 2:{
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    20f4:	ce 01       	movw	r24, r28
    20f6:	ce 96       	adiw	r24, 0x3e	; 62
    20f8:	2a eb       	ldi	r18, 0xBA	; 186
    20fa:	31 e0       	ldi	r19, 0x01	; 1
    20fc:	b9 01       	movw	r22, r18
    20fe:	42 e0       	ldi	r20, 0x02	; 2
    2100:	50 e0       	ldi	r21, 0x00	; 0
    2102:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    2106:	00 97       	sbiw	r24, 0x00	; 0
    2108:	a1 f4       	brne	.+40     	; 0x2132 <_Z11ReceiveBonev+0x226>
    210a:	80 91 e0 01 	lds	r24, 0x01E0
    210e:	90 91 e1 01 	lds	r25, 0x01E1
    2112:	9e 01       	movw	r18, r28
    2114:	23 5e       	subi	r18, 0xE3	; 227
    2116:	3f 4f       	sbci	r19, 0xFF	; 255
    2118:	b9 01       	movw	r22, r18
    211a:	4a e0       	ldi	r20, 0x0A	; 10
    211c:	50 e0       	ldi	r21, 0x00	; 0
    211e:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <utoa>
    2122:	1b a2       	lds	r17, 0x9b
    2124:	ce 01       	movw	r24, r28
    2126:	4d 96       	adiw	r24, 0x1d	; 29
    2128:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    212c:	86 e0       	ldi	r24, 0x06	; 6
    212e:	89 83       	std	Y+1, r24	; 0x01
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    2130:	f3 c2       	rjmp	.+1510   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					if (!strncmp(recString,"d.",2)){printTimeDate(fTrue,fFalse,fTrue); state=6;}
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
    2132:	ce 01       	movw	r24, r28
    2134:	ce 96       	adiw	r24, 0x3e	; 62
    2136:	2d eb       	ldi	r18, 0xBD	; 189
    2138:	31 e0       	ldi	r19, 0x01	; 1
    213a:	b9 01       	movw	r22, r18
    213c:	43 e0       	ldi	r20, 0x03	; 3
    213e:	50 e0       	ldi	r21, 0x00	; 0
    2140:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    2144:	00 97       	sbiw	r24, 0x00	; 0
    2146:	a1 f4       	brne	.+40     	; 0x2170 <_Z11ReceiveBonev+0x264>
    2148:	80 91 e2 01 	lds	r24, 0x01E2
    214c:	90 91 e3 01 	lds	r25, 0x01E3
    2150:	9e 01       	movw	r18, r28
    2152:	2c 5d       	subi	r18, 0xDC	; 220
    2154:	3f 4f       	sbci	r19, 0xFF	; 255
    2156:	b9 01       	movw	r22, r18
    2158:	4a e0       	ldi	r20, 0x0A	; 10
    215a:	50 e0       	ldi	r21, 0x00	; 0
    215c:	0e 94 82 1d 	call	0x3b04	; 0x3b04 <utoa>
    2160:	1a a6       	lds	r17, 0xba
    2162:	ce 01       	movw	r24, r28
    2164:	84 96       	adiw	r24, 0x24	; 36
    2166:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    216a:	86 e0       	ldi	r24, 0x06	; 6
    216c:	89 83       	std	Y+1, r24	; 0x01
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    216e:	d4 c2       	rjmp	.+1448   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					else if (!strncmp(recString,"t.",2)){printTimeDate(fTrue,fTrue,fFalse);state=6;}
					else if (!strncmp(recString,"b.",2)){printTimeDate(fTrue,fTrue,fTrue);state=6;}
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
    2170:	ce 01       	movw	r24, r28
    2172:	80 5c       	subi	r24, 0xC0	; 192
    2174:	9f 4f       	sbci	r25, 0xFF	; 255
    2176:	fc 01       	movw	r30, r24
    2178:	80 81       	ld	r24, Z
    217a:	21 e0       	ldi	r18, 0x01	; 1
    217c:	8a 33       	cpi	r24, 0x3A	; 58
    217e:	09 f0       	breq	.+2      	; 0x2182 <_Z11ReceiveBonev+0x276>
    2180:	20 e0       	ldi	r18, 0x00	; 0
    2182:	ce 01       	movw	r24, r28
    2184:	8f 5b       	subi	r24, 0xBF	; 191
    2186:	9f 4f       	sbci	r25, 0xFF	; 255
    2188:	fc 01       	movw	r30, r24
    218a:	90 81       	ld	r25, Z
    218c:	81 e0       	ldi	r24, 0x01	; 1
    218e:	9a 33       	cpi	r25, 0x3A	; 58
    2190:	09 f0       	breq	.+2      	; 0x2194 <_Z11ReceiveBonev+0x288>
    2192:	80 e0       	ldi	r24, 0x00	; 0
    2194:	82 27       	eor	r24, r18
    2196:	88 23       	and	r24, r24
    2198:	19 f0       	breq	.+6      	; 0x21a0 <_Z11ReceiveBonev+0x294>
						state=7;	
    219a:	87 e0       	ldi	r24, 0x07	; 7
    219c:	89 83       	std	Y+1, r24	; 0x01
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
					break;
    219e:	bc c2       	rjmp	.+1400   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					else if (!strncmp(recString,"s.",2)){saveDateTime_eeprom(fTrue,fFalse);PrintBone(recString);state=6;}
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
    21a0:	ce 01       	movw	r24, r28
    21a2:	ce 96       	adiw	r24, 0x3e	; 62
    21a4:	2d e6       	ldi	r18, 0x6D	; 109
    21a6:	31 e0       	ldi	r19, 0x01	; 1
    21a8:	b9 01       	movw	r22, r18
    21aa:	42 e0       	ldi	r20, 0x02	; 2
    21ac:	50 e0       	ldi	r21, 0x00	; 0
    21ae:	0e 94 4b 1d 	call	0x3a96	; 0x3a96 <strncmp>
    21b2:	00 97       	sbiw	r24, 0x00	; 0
    21b4:	39 f4       	brne	.+14     	; 0x21c4 <_Z11ReceiveBonev+0x2b8>
    21b6:	8d e6       	ldi	r24, 0x6D	; 109
    21b8:	91 e0       	ldi	r25, 0x01	; 1
    21ba:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
    21be:	86 e0       	ldi	r24, 0x06	; 6
    21c0:	89 83       	std	Y+1, r24	; 0x01
					else {state=5;}						
					break;
    21c2:	aa c2       	rjmp	.+1364   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					else if (!strncmp(recString,"a.",2)){char tempChar[7]; utoa(globalADC,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if (!strncmp(recString,"te.",3)){char tempChar[7]; utoa(globalTemp,tempChar,10); tempChar[6]='\0'; PrintBone(tempChar);state=6;}
					else if ((recString[2] == ':') != (recString[3] == ':')){//time/date string, go parse in state 7
						state=7;	
					} else if (!strncmp(recString,"N.",2)){PrintBone("N."); state=6;}//NONE time.	
					else {state=5;}						
    21c4:	85 e0       	ldi	r24, 0x05	; 5
    21c6:	89 83       	std	Y+1, r24	; 0x01
					break;
    21c8:	a7 c2       	rjmp	.+1358   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 2
				case 3:{
					//Successful receive state of time, change SYN to ACK, then print what we got.
					recString[0]='A';
    21ca:	81 e4       	ldi	r24, 0x41	; 65
    21cc:	8e af       	sts	0x7e, r24
					PrintBone(recString);
    21ce:	ce 01       	movw	r24, r28
    21d0:	ce 96       	adiw	r24, 0x3e	; 62
    21d2:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					state=0;
    21d6:	19 82       	std	Y+1, r1	; 0x01
					flagReceivingBone=fFalse;
    21d8:	10 92 0d 02 	sts	0x020D, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    21dc:	1d 82       	std	Y+5, r1	; 0x05
    21de:	1c 82       	std	Y+4, r1	; 0x04
    21e0:	0e c0       	rjmp	.+28     	; 0x21fe <_Z11ReceiveBonev+0x2f2>
    21e2:	9e 01       	movw	r18, r28
    21e4:	22 5c       	subi	r18, 0xC2	; 194
    21e6:	3f 4f       	sbci	r19, 0xFF	; 255
    21e8:	8c 81       	ldd	r24, Y+4	; 0x04
    21ea:	9d 81       	ldd	r25, Y+5	; 0x05
    21ec:	82 0f       	add	r24, r18
    21ee:	93 1f       	adc	r25, r19
    21f0:	fc 01       	movw	r30, r24
    21f2:	10 82       	st	Z, r1
    21f4:	8c 81       	ldd	r24, Y+4	; 0x04
    21f6:	9d 81       	ldd	r25, Y+5	; 0x05
    21f8:	01 96       	adiw	r24, 0x01	; 1
    21fa:	9d 83       	std	Y+5, r25	; 0x05
    21fc:	8c 83       	std	Y+4, r24	; 0x04
    21fe:	8a 81       	ldd	r24, Y+2	; 0x02
    2200:	28 2f       	mov	r18, r24
    2202:	30 e0       	ldi	r19, 0x00	; 0
    2204:	41 e0       	ldi	r20, 0x01	; 1
    2206:	8c 81       	ldd	r24, Y+4	; 0x04
    2208:	9d 81       	ldd	r25, Y+5	; 0x05
    220a:	82 17       	cp	r24, r18
    220c:	93 07       	cpc	r25, r19
    220e:	0c f0       	brlt	.+2      	; 0x2212 <_Z11ReceiveBonev+0x306>
    2210:	40 e0       	ldi	r20, 0x00	; 0
    2212:	44 23       	and	r20, r20
    2214:	31 f7       	brne	.-52     	; 0x21e2 <_Z11ReceiveBonev+0x2d6>
					break;
    2216:	80 c2       	rjmp	.+1280   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 3
				case 4:{
					//Bad time string.
					PrintBone("B.");
    2218:	82 e1       	ldi	r24, 0x12	; 18
    221a:	91 e0       	ldi	r25, 0x01	; 1
    221c:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    2220:	10 92 0d 02 	sts	0x020D, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    2224:	1f 82       	std	Y+7, r1	; 0x07
    2226:	1e 82       	std	Y+6, r1	; 0x06
    2228:	0e c0       	rjmp	.+28     	; 0x2246 <_Z11ReceiveBonev+0x33a>
    222a:	9e 01       	movw	r18, r28
    222c:	22 5c       	subi	r18, 0xC2	; 194
    222e:	3f 4f       	sbci	r19, 0xFF	; 255
    2230:	8e 81       	ldd	r24, Y+6	; 0x06
    2232:	9f 81       	ldd	r25, Y+7	; 0x07
    2234:	82 0f       	add	r24, r18
    2236:	93 1f       	adc	r25, r19
    2238:	fc 01       	movw	r30, r24
    223a:	10 82       	st	Z, r1
    223c:	8e 81       	ldd	r24, Y+6	; 0x06
    223e:	9f 81       	ldd	r25, Y+7	; 0x07
    2240:	01 96       	adiw	r24, 0x01	; 1
    2242:	9f 83       	std	Y+7, r25	; 0x07
    2244:	8e 83       	std	Y+6, r24	; 0x06
    2246:	8a 81       	ldd	r24, Y+2	; 0x02
    2248:	28 2f       	mov	r18, r24
    224a:	30 e0       	ldi	r19, 0x00	; 0
    224c:	41 e0       	ldi	r20, 0x01	; 1
    224e:	8e 81       	ldd	r24, Y+6	; 0x06
    2250:	9f 81       	ldd	r25, Y+7	; 0x07
    2252:	82 17       	cp	r24, r18
    2254:	93 07       	cpc	r25, r19
    2256:	0c f0       	brlt	.+2      	; 0x225a <_Z11ReceiveBonev+0x34e>
    2258:	40 e0       	ldi	r20, 0x00	; 0
    225a:	44 23       	and	r20, r20
    225c:	31 f7       	brne	.-52     	; 0x222a <_Z11ReceiveBonev+0x31e>
					state=0;
    225e:	19 82       	std	Y+1, r1	; 0x01
					break;
    2260:	5b c2       	rjmp	.+1206   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 4
				case 5:{
					//Didn't get a good ack or there was an error.
					PrintBone("E.");
    2262:	83 ea       	ldi	r24, 0xA3	; 163
    2264:	91 e0       	ldi	r25, 0x01	; 1
    2266:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					PrintBone(recString);
    226a:	ce 01       	movw	r24, r28
    226c:	ce 96       	adiw	r24, 0x3e	; 62
    226e:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
					flagReceivingBone=fFalse;
    2272:	10 92 0d 02 	sts	0x020D, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    2276:	19 86       	std	Y+9, r1	; 0x09
    2278:	18 86       	std	Y+8, r1	; 0x08
    227a:	0e c0       	rjmp	.+28     	; 0x2298 <_Z11ReceiveBonev+0x38c>
    227c:	9e 01       	movw	r18, r28
    227e:	22 5c       	subi	r18, 0xC2	; 194
    2280:	3f 4f       	sbci	r19, 0xFF	; 255
    2282:	88 85       	ldd	r24, Y+8	; 0x08
    2284:	99 85       	ldd	r25, Y+9	; 0x09
    2286:	82 0f       	add	r24, r18
    2288:	93 1f       	adc	r25, r19
    228a:	fc 01       	movw	r30, r24
    228c:	10 82       	st	Z, r1
    228e:	88 85       	ldd	r24, Y+8	; 0x08
    2290:	99 85       	ldd	r25, Y+9	; 0x09
    2292:	01 96       	adiw	r24, 0x01	; 1
    2294:	99 87       	std	Y+9, r25	; 0x09
    2296:	88 87       	std	Y+8, r24	; 0x08
    2298:	8a 81       	ldd	r24, Y+2	; 0x02
    229a:	28 2f       	mov	r18, r24
    229c:	30 e0       	ldi	r19, 0x00	; 0
    229e:	41 e0       	ldi	r20, 0x01	; 1
    22a0:	88 85       	ldd	r24, Y+8	; 0x08
    22a2:	99 85       	ldd	r25, Y+9	; 0x09
    22a4:	82 17       	cp	r24, r18
    22a6:	93 07       	cpc	r25, r19
    22a8:	0c f0       	brlt	.+2      	; 0x22ac <_Z11ReceiveBonev+0x3a0>
    22aa:	40 e0       	ldi	r20, 0x00	; 0
    22ac:	44 23       	and	r20, r20
    22ae:	31 f7       	brne	.-52     	; 0x227c <_Z11ReceiveBonev+0x370>
					state=0;
    22b0:	19 82       	std	Y+1, r1	; 0x01
					break;
    22b2:	32 c2       	rjmp	.+1124   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 5
				case 6:{
					//Graceful exit.
					flagReceivingBone=fFalse;
    22b4:	10 92 0d 02 	sts	0x020D, r1
					for (int i=0; i<strLoc; i++){recString[i]=NULL;}
    22b8:	1b 86       	std	Y+11, r1	; 0x0b
    22ba:	1a 86       	std	Y+10, r1	; 0x0a
    22bc:	0e c0       	rjmp	.+28     	; 0x22da <_Z11ReceiveBonev+0x3ce>
    22be:	9e 01       	movw	r18, r28
    22c0:	22 5c       	subi	r18, 0xC2	; 194
    22c2:	3f 4f       	sbci	r19, 0xFF	; 255
    22c4:	8a 85       	ldd	r24, Y+10	; 0x0a
    22c6:	9b 85       	ldd	r25, Y+11	; 0x0b
    22c8:	82 0f       	add	r24, r18
    22ca:	93 1f       	adc	r25, r19
    22cc:	fc 01       	movw	r30, r24
    22ce:	10 82       	st	Z, r1
    22d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    22d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    22d4:	01 96       	adiw	r24, 0x01	; 1
    22d6:	9b 87       	std	Y+11, r25	; 0x0b
    22d8:	8a 87       	std	Y+10, r24	; 0x0a
    22da:	8a 81       	ldd	r24, Y+2	; 0x02
    22dc:	28 2f       	mov	r18, r24
    22de:	30 e0       	ldi	r19, 0x00	; 0
    22e0:	41 e0       	ldi	r20, 0x01	; 1
    22e2:	8a 85       	ldd	r24, Y+10	; 0x0a
    22e4:	9b 85       	ldd	r25, Y+11	; 0x0b
    22e6:	82 17       	cp	r24, r18
    22e8:	93 07       	cpc	r25, r19
    22ea:	0c f0       	brlt	.+2      	; 0x22ee <_Z11ReceiveBonev+0x3e2>
    22ec:	40 e0       	ldi	r20, 0x00	; 0
    22ee:	44 23       	and	r20, r20
    22f0:	31 f7       	brne	.-52     	; 0x22be <_Z11ReceiveBonev+0x3b2>
					state=0;
    22f2:	19 82       	std	Y+1, r1	; 0x01
					break;
    22f4:	11 c2       	rjmp	.+1058   	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 6
				case 7:{
					//Parse the string
					//Go through the string and parse for the time. Must go through the time to get the date.
					BOOL successTime=fFalse, successDate=fFalse;			//whether or not we have successfully parsed string
    22f6:	1c 86       	std	Y+12, r1	; 0x0c
    22f8:	1d 86       	std	Y+13, r1	; 0x0d
					int counter=1;
    22fa:	81 e0       	ldi	r24, 0x01	; 1
    22fc:	90 e0       	ldi	r25, 0x00	; 0
    22fe:	9f 87       	std	Y+15, r25	; 0x0f
    2300:	8e 87       	std	Y+14, r24	; 0x0e
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
    2302:	1c a6       	lds	r17, 0xbc
    2304:	1b a6       	lds	r17, 0xbb
    2306:	1e a6       	lds	r17, 0xbe
    2308:	1d a6       	lds	r17, 0xbd
    230a:	18 aa       	sts	0x98, r17
    230c:	1f a6       	lds	r17, 0xbf
    230e:	1a aa       	sts	0x9a, r17
    2310:	19 aa       	sts	0x99, r17
    2312:	1c aa       	sts	0x9c, r17
    2314:	1b aa       	sts	0x9b, r17
    2316:	1e aa       	sts	0x9e, r17
    2318:	1d aa       	sts	0x9d, r17
    231a:	19 8a       	std	Y+17, r1	; 0x11
    231c:	18 8a       	std	Y+16, r1	; 0x10
    231e:	1b 8a       	std	Y+19, r1	; 0x13
    2320:	1a 8a       	std	Y+18, r1	; 0x12
    2322:	1d 8a       	std	Y+21, r1	; 0x15
    2324:	1c 8a       	std	Y+20, r1	; 0x14
					char tempStringNum[7];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    2326:	73 c0       	rjmp	.+230    	; 0x240e <_Z11ReceiveBonev+0x502>
						//If the character isn't a colon, we haven't gotten 3 int values add to tempStringNum
						if (recString[counter]!=':' && hms<3){
    2328:	9e 01       	movw	r18, r28
    232a:	22 5c       	subi	r18, 0xC2	; 194
    232c:	3f 4f       	sbci	r19, 0xFF	; 255
    232e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2330:	9f 85       	ldd	r25, Y+15	; 0x0f
    2332:	82 0f       	add	r24, r18
    2334:	93 1f       	adc	r25, r19
    2336:	fc 01       	movw	r30, r24
    2338:	80 81       	ld	r24, Z
    233a:	8a 33       	cpi	r24, 0x3A	; 58
    233c:	e9 f0       	breq	.+58     	; 0x2378 <_Z11ReceiveBonev+0x46c>
    233e:	8a 89       	ldd	r24, Y+18	; 0x12
    2340:	9b 89       	ldd	r25, Y+19	; 0x13
    2342:	83 30       	cpi	r24, 0x03	; 3
    2344:	91 05       	cpc	r25, r1
    2346:	c4 f4       	brge	.+48     	; 0x2378 <_Z11ReceiveBonev+0x46c>
							tempStringNum[placement++]=recString[counter];
    2348:	9e 01       	movw	r18, r28
    234a:	22 5c       	subi	r18, 0xC2	; 194
    234c:	3f 4f       	sbci	r19, 0xFF	; 255
    234e:	8e 85       	ldd	r24, Y+14	; 0x0e
    2350:	9f 85       	ldd	r25, Y+15	; 0x0f
    2352:	82 0f       	add	r24, r18
    2354:	93 1f       	adc	r25, r19
    2356:	fc 01       	movw	r30, r24
    2358:	40 81       	ld	r20, Z
    235a:	9e 01       	movw	r18, r28
    235c:	29 5c       	subi	r18, 0xC9	; 201
    235e:	3f 4f       	sbci	r19, 0xFF	; 255
    2360:	8c 89       	ldd	r24, Y+20	; 0x14
    2362:	9d 89       	ldd	r25, Y+21	; 0x15
    2364:	82 0f       	add	r24, r18
    2366:	93 1f       	adc	r25, r19
    2368:	fc 01       	movw	r30, r24
    236a:	40 83       	st	Z, r20
    236c:	8c 89       	ldd	r24, Y+20	; 0x14
    236e:	9d 89       	ldd	r25, Y+21	; 0x15
    2370:	01 96       	adiw	r24, 0x01	; 1
    2372:	9d 8b       	std	Y+21, r25	; 0x15
    2374:	8c 8b       	std	Y+20, r24	; 0x14
    2376:	46 c0       	rjmp	.+140    	; 0x2404 <_Z11ReceiveBonev+0x4f8>
						//If haven't gotten 3 int's and character is colon, store int(stringNum) into tempNum[<current time param>]
						} else if (hms<2 && recString[counter] == ':') {
    2378:	8a 89       	ldd	r24, Y+18	; 0x12
    237a:	9b 89       	ldd	r25, Y+19	; 0x13
    237c:	82 30       	cpi	r24, 0x02	; 2
    237e:	91 05       	cpc	r25, r1
    2380:	0c f0       	brlt	.+2      	; 0x2384 <_Z11ReceiveBonev+0x478>
    2382:	40 c0       	rjmp	.+128    	; 0x2404 <_Z11ReceiveBonev+0x4f8>
    2384:	9e 01       	movw	r18, r28
    2386:	22 5c       	subi	r18, 0xC2	; 194
    2388:	3f 4f       	sbci	r19, 0xFF	; 255
    238a:	8e 85       	ldd	r24, Y+14	; 0x0e
    238c:	9f 85       	ldd	r25, Y+15	; 0x0f
    238e:	82 0f       	add	r24, r18
    2390:	93 1f       	adc	r25, r19
    2392:	fc 01       	movw	r30, r24
    2394:	80 81       	ld	r24, Z
    2396:	8a 33       	cpi	r24, 0x3A	; 58
    2398:	a9 f5       	brne	.+106    	; 0x2404 <_Z11ReceiveBonev+0x4f8>
							tempNum[hms++] = atoi(tempStringNum);
    239a:	ce 01       	movw	r24, r28
    239c:	c7 96       	adiw	r24, 0x37	; 55
    239e:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
    23a2:	9c 01       	movw	r18, r24
    23a4:	8a 89       	ldd	r24, Y+18	; 0x12
    23a6:	9b 89       	ldd	r25, Y+19	; 0x13
    23a8:	88 0f       	add	r24, r24
    23aa:	99 1f       	adc	r25, r25
    23ac:	ae 01       	movw	r20, r28
    23ae:	4f 5f       	subi	r20, 0xFF	; 255
    23b0:	5f 4f       	sbci	r21, 0xFF	; 255
    23b2:	84 0f       	add	r24, r20
    23b4:	95 1f       	adc	r25, r21
    23b6:	8a 96       	adiw	r24, 0x2a	; 42
    23b8:	fc 01       	movw	r30, r24
    23ba:	31 83       	std	Z+1, r19	; 0x01
    23bc:	20 83       	st	Z, r18
    23be:	8a 89       	ldd	r24, Y+18	; 0x12
    23c0:	9b 89       	ldd	r25, Y+19	; 0x13
    23c2:	01 96       	adiw	r24, 0x01	; 1
    23c4:	9b 8b       	std	Y+19, r25	; 0x13
    23c6:	8a 8b       	std	Y+18, r24	; 0x12
							for (int j=0; j <= placement; j++){tempStringNum[j]=(char)NULL;}	//reset the string
    23c8:	1f 8a       	std	Y+23, r1	; 0x17
    23ca:	1e 8a       	std	Y+22, r1	; 0x16
    23cc:	0e c0       	rjmp	.+28     	; 0x23ea <_Z11ReceiveBonev+0x4de>
    23ce:	9e 01       	movw	r18, r28
    23d0:	29 5c       	subi	r18, 0xC9	; 201
    23d2:	3f 4f       	sbci	r19, 0xFF	; 255
    23d4:	8e 89       	ldd	r24, Y+22	; 0x16
    23d6:	9f 89       	ldd	r25, Y+23	; 0x17
    23d8:	82 0f       	add	r24, r18
    23da:	93 1f       	adc	r25, r19
    23dc:	fc 01       	movw	r30, r24
    23de:	10 82       	st	Z, r1
    23e0:	8e 89       	ldd	r24, Y+22	; 0x16
    23e2:	9f 89       	ldd	r25, Y+23	; 0x17
    23e4:	01 96       	adiw	r24, 0x01	; 1
    23e6:	9f 8b       	std	Y+23, r25	; 0x17
    23e8:	8e 8b       	std	Y+22, r24	; 0x16
    23ea:	41 e0       	ldi	r20, 0x01	; 1
    23ec:	2e 89       	ldd	r18, Y+22	; 0x16
    23ee:	3f 89       	ldd	r19, Y+23	; 0x17
    23f0:	8c 89       	ldd	r24, Y+20	; 0x14
    23f2:	9d 89       	ldd	r25, Y+21	; 0x15
    23f4:	82 17       	cp	r24, r18
    23f6:	93 07       	cpc	r25, r19
    23f8:	0c f4       	brge	.+2      	; 0x23fc <_Z11ReceiveBonev+0x4f0>
    23fa:	40 e0       	ldi	r20, 0x00	; 0
    23fc:	44 23       	and	r20, r20
    23fe:	39 f7       	brne	.-50     	; 0x23ce <_Z11ReceiveBonev+0x4c2>
							placement=0;												//reset placement
    2400:	1d 8a       	std	Y+21, r1	; 0x15
    2402:	1c 8a       	std	Y+20, r1	; 0x14
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
    2404:	8e 85       	ldd	r24, Y+14	; 0x0e
    2406:	9f 85       	ldd	r25, Y+15	; 0x0f
    2408:	01 96       	adiw	r24, 0x01	; 1
    240a:	9f 87       	std	Y+15, r25	; 0x0f
    240c:	8e 87       	std	Y+14, r24	; 0x0e
					int counter=1;
					int tempNum[3]={0,0,0}, tempNum1[3]={0,0,0},dmy=0, hms=0, placement=0;
					char tempStringNum[7];
					
					//Parse the string for the time. Always looks for the time. If not end of string or '/' indicating start of date, continue
					while (recString[counter] != '/' && recString[counter] != '\0'){
    240e:	9e 01       	movw	r18, r28
    2410:	22 5c       	subi	r18, 0xC2	; 194
    2412:	3f 4f       	sbci	r19, 0xFF	; 255
    2414:	8e 85       	ldd	r24, Y+14	; 0x0e
    2416:	9f 85       	ldd	r25, Y+15	; 0x0f
    2418:	82 0f       	add	r24, r18
    241a:	93 1f       	adc	r25, r19
    241c:	fc 01       	movw	r30, r24
    241e:	80 81       	ld	r24, Z
    2420:	8f 32       	cpi	r24, 0x2F	; 47
    2422:	69 f0       	breq	.+26     	; 0x243e <_Z11ReceiveBonev+0x532>
    2424:	9e 01       	movw	r18, r28
    2426:	22 5c       	subi	r18, 0xC2	; 194
    2428:	3f 4f       	sbci	r19, 0xFF	; 255
    242a:	8e 85       	ldd	r24, Y+14	; 0x0e
    242c:	9f 85       	ldd	r25, Y+15	; 0x0f
    242e:	82 0f       	add	r24, r18
    2430:	93 1f       	adc	r25, r19
    2432:	fc 01       	movw	r30, r24
    2434:	80 81       	ld	r24, Z
    2436:	88 23       	and	r24, r24
    2438:	11 f0       	breq	.+4      	; 0x243e <_Z11ReceiveBonev+0x532>
    243a:	81 e0       	ldi	r24, 0x01	; 1
    243c:	01 c0       	rjmp	.+2      	; 0x2440 <_Z11ReceiveBonev+0x534>
    243e:	80 e0       	ldi	r24, 0x00	; 0
    2440:	88 23       	and	r24, r24
    2442:	09 f0       	breq	.+2      	; 0x2446 <_Z11ReceiveBonev+0x53a>
    2444:	71 cf       	rjmp	.-286    	; 0x2328 <_Z11ReceiveBonev+0x41c>
						//If nothing else, somethign is wrong but it won't matter because we'll eventually hit \0 and exit with ACKBAD
						} else;
						counter++;
					}//end while
					//Found a '/', assign tempNum otherwise exit with ACKBAD
					if (recString[counter] == '/'){
    2446:	9e 01       	movw	r18, r28
    2448:	22 5c       	subi	r18, 0xC2	; 194
    244a:	3f 4f       	sbci	r19, 0xFF	; 255
    244c:	8e 85       	ldd	r24, Y+14	; 0x0e
    244e:	9f 85       	ldd	r25, Y+15	; 0x0f
    2450:	82 0f       	add	r24, r18
    2452:	93 1f       	adc	r25, r19
    2454:	fc 01       	movw	r30, r24
    2456:	80 81       	ld	r24, Z
    2458:	8f 32       	cpi	r24, 0x2F	; 47
    245a:	a9 f4       	brne	.+42     	; 0x2486 <_Z11ReceiveBonev+0x57a>
						tempNum[hms] = atoi(tempStringNum);
    245c:	ce 01       	movw	r24, r28
    245e:	c7 96       	adiw	r24, 0x37	; 55
    2460:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
    2464:	9c 01       	movw	r18, r24
    2466:	8a 89       	ldd	r24, Y+18	; 0x12
    2468:	9b 89       	ldd	r25, Y+19	; 0x13
    246a:	88 0f       	add	r24, r24
    246c:	99 1f       	adc	r25, r25
    246e:	ae 01       	movw	r20, r28
    2470:	4f 5f       	subi	r20, 0xFF	; 255
    2472:	5f 4f       	sbci	r21, 0xFF	; 255
    2474:	84 0f       	add	r24, r20
    2476:	95 1f       	adc	r25, r21
    2478:	8a 96       	adiw	r24, 0x2a	; 42
    247a:	fc 01       	movw	r30, r24
    247c:	31 83       	std	Z+1, r19	; 0x01
    247e:	20 83       	st	Z, r18
						successTime=fTrue;
    2480:	81 e0       	ldi	r24, 0x01	; 1
    2482:	8c 87       	std	Y+12, r24	; 0x0c
    2484:	02 c0       	rjmp	.+4      	; 0x248a <_Z11ReceiveBonev+0x57e>
					} else {
						state=4;
    2486:	84 e0       	ldi	r24, 0x04	; 4
    2488:	89 83       	std	Y+1, r24	; 0x01
					}
					
					//If flag for Date is set, then parse the string and do something with it.
					//Now get the date. have to null the tempStringNum
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
    248a:	19 8e       	std	Y+25, r1	; 0x19
    248c:	18 8e       	std	Y+24, r1	; 0x18
    248e:	0e c0       	rjmp	.+28     	; 0x24ac <_Z11ReceiveBonev+0x5a0>
    2490:	9e 01       	movw	r18, r28
    2492:	29 5c       	subi	r18, 0xC9	; 201
    2494:	3f 4f       	sbci	r19, 0xFF	; 255
    2496:	88 8d       	ldd	r24, Y+24	; 0x18
    2498:	99 8d       	ldd	r25, Y+25	; 0x19
    249a:	82 0f       	add	r24, r18
    249c:	93 1f       	adc	r25, r19
    249e:	fc 01       	movw	r30, r24
    24a0:	10 82       	st	Z, r1
    24a2:	88 8d       	ldd	r24, Y+24	; 0x18
    24a4:	99 8d       	ldd	r25, Y+25	; 0x19
    24a6:	01 96       	adiw	r24, 0x01	; 1
    24a8:	99 8f       	std	Y+25, r25	; 0x19
    24aa:	88 8f       	std	Y+24, r24	; 0x18
    24ac:	41 e0       	ldi	r20, 0x01	; 1
    24ae:	28 8d       	ldd	r18, Y+24	; 0x18
    24b0:	39 8d       	ldd	r19, Y+25	; 0x19
    24b2:	8c 89       	ldd	r24, Y+20	; 0x14
    24b4:	9d 89       	ldd	r25, Y+21	; 0x15
    24b6:	82 17       	cp	r24, r18
    24b8:	93 07       	cpc	r25, r19
    24ba:	0c f4       	brge	.+2      	; 0x24be <_Z11ReceiveBonev+0x5b2>
    24bc:	40 e0       	ldi	r20, 0x00	; 0
    24be:	44 23       	and	r20, r20
    24c0:	39 f7       	brne	.-50     	; 0x2490 <_Z11ReceiveBonev+0x584>
					placement=0;
    24c2:	1d 8a       	std	Y+21, r1	; 0x15
    24c4:	1c 8a       	std	Y+20, r1	; 0x14
					counter++;	//get past the '/'
    24c6:	8e 85       	ldd	r24, Y+14	; 0x0e
    24c8:	9f 85       	ldd	r25, Y+15	; 0x0f
    24ca:	01 96       	adiw	r24, 0x01	; 1
    24cc:	9f 87       	std	Y+15, r25	; 0x0f
    24ce:	8e 87       	std	Y+14, r24	; 0x0e
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    24d0:	73 c0       	rjmp	.+230    	; 0x25b8 <_Z11ReceiveBonev+0x6ac>
						//If char isn't sepaerator or end of string of dmy has been hit, add to buffer
						if  (recString[counter] != ',' && dmy < 3){
    24d2:	9e 01       	movw	r18, r28
    24d4:	22 5c       	subi	r18, 0xC2	; 194
    24d6:	3f 4f       	sbci	r19, 0xFF	; 255
    24d8:	8e 85       	ldd	r24, Y+14	; 0x0e
    24da:	9f 85       	ldd	r25, Y+15	; 0x0f
    24dc:	82 0f       	add	r24, r18
    24de:	93 1f       	adc	r25, r19
    24e0:	fc 01       	movw	r30, r24
    24e2:	80 81       	ld	r24, Z
    24e4:	8c 32       	cpi	r24, 0x2C	; 44
    24e6:	e9 f0       	breq	.+58     	; 0x2522 <_Z11ReceiveBonev+0x616>
    24e8:	88 89       	ldd	r24, Y+16	; 0x10
    24ea:	99 89       	ldd	r25, Y+17	; 0x11
    24ec:	83 30       	cpi	r24, 0x03	; 3
    24ee:	91 05       	cpc	r25, r1
    24f0:	c4 f4       	brge	.+48     	; 0x2522 <_Z11ReceiveBonev+0x616>
							tempStringNum[placement++]=recString[counter];
    24f2:	9e 01       	movw	r18, r28
    24f4:	22 5c       	subi	r18, 0xC2	; 194
    24f6:	3f 4f       	sbci	r19, 0xFF	; 255
    24f8:	8e 85       	ldd	r24, Y+14	; 0x0e
    24fa:	9f 85       	ldd	r25, Y+15	; 0x0f
    24fc:	82 0f       	add	r24, r18
    24fe:	93 1f       	adc	r25, r19
    2500:	fc 01       	movw	r30, r24
    2502:	40 81       	ld	r20, Z
    2504:	9e 01       	movw	r18, r28
    2506:	29 5c       	subi	r18, 0xC9	; 201
    2508:	3f 4f       	sbci	r19, 0xFF	; 255
    250a:	8c 89       	ldd	r24, Y+20	; 0x14
    250c:	9d 89       	ldd	r25, Y+21	; 0x15
    250e:	82 0f       	add	r24, r18
    2510:	93 1f       	adc	r25, r19
    2512:	fc 01       	movw	r30, r24
    2514:	40 83       	st	Z, r20
    2516:	8c 89       	ldd	r24, Y+20	; 0x14
    2518:	9d 89       	ldd	r25, Y+21	; 0x15
    251a:	01 96       	adiw	r24, 0x01	; 1
    251c:	9d 8b       	std	Y+21, r25	; 0x15
    251e:	8c 8b       	std	Y+20, r24	; 0x14
    2520:	46 c0       	rjmp	.+140    	; 0x25ae <_Z11ReceiveBonev+0x6a2>
						//If a comma was found, need to store that sucker in the tempNum1[x]. dmy needs to be 0 or 1 aka month or day.
						} else if (dmy<2 && recString[counter]==','){
    2522:	88 89       	ldd	r24, Y+16	; 0x10
    2524:	99 89       	ldd	r25, Y+17	; 0x11
    2526:	82 30       	cpi	r24, 0x02	; 2
    2528:	91 05       	cpc	r25, r1
    252a:	0c f0       	brlt	.+2      	; 0x252e <_Z11ReceiveBonev+0x622>
    252c:	40 c0       	rjmp	.+128    	; 0x25ae <_Z11ReceiveBonev+0x6a2>
    252e:	9e 01       	movw	r18, r28
    2530:	22 5c       	subi	r18, 0xC2	; 194
    2532:	3f 4f       	sbci	r19, 0xFF	; 255
    2534:	8e 85       	ldd	r24, Y+14	; 0x0e
    2536:	9f 85       	ldd	r25, Y+15	; 0x0f
    2538:	82 0f       	add	r24, r18
    253a:	93 1f       	adc	r25, r19
    253c:	fc 01       	movw	r30, r24
    253e:	80 81       	ld	r24, Z
    2540:	8c 32       	cpi	r24, 0x2C	; 44
    2542:	a9 f5       	brne	.+106    	; 0x25ae <_Z11ReceiveBonev+0x6a2>
							tempNum1[dmy++] = atoi(tempStringNum);
    2544:	ce 01       	movw	r24, r28
    2546:	c7 96       	adiw	r24, 0x37	; 55
    2548:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
    254c:	9c 01       	movw	r18, r24
    254e:	88 89       	ldd	r24, Y+16	; 0x10
    2550:	99 89       	ldd	r25, Y+17	; 0x11
    2552:	88 0f       	add	r24, r24
    2554:	99 1f       	adc	r25, r25
    2556:	ae 01       	movw	r20, r28
    2558:	4f 5f       	subi	r20, 0xFF	; 255
    255a:	5f 4f       	sbci	r21, 0xFF	; 255
    255c:	84 0f       	add	r24, r20
    255e:	95 1f       	adc	r25, r21
    2560:	c0 96       	adiw	r24, 0x30	; 48
    2562:	fc 01       	movw	r30, r24
    2564:	31 83       	std	Z+1, r19	; 0x01
    2566:	20 83       	st	Z, r18
    2568:	88 89       	ldd	r24, Y+16	; 0x10
    256a:	99 89       	ldd	r25, Y+17	; 0x11
    256c:	01 96       	adiw	r24, 0x01	; 1
    256e:	99 8b       	std	Y+17, r25	; 0x11
    2570:	88 8b       	std	Y+16, r24	; 0x10
							for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}
    2572:	1b 8e       	std	Y+27, r1	; 0x1b
    2574:	1a 8e       	std	Y+26, r1	; 0x1a
    2576:	0e c0       	rjmp	.+28     	; 0x2594 <_Z11ReceiveBonev+0x688>
    2578:	9e 01       	movw	r18, r28
    257a:	29 5c       	subi	r18, 0xC9	; 201
    257c:	3f 4f       	sbci	r19, 0xFF	; 255
    257e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2580:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2582:	82 0f       	add	r24, r18
    2584:	93 1f       	adc	r25, r19
    2586:	fc 01       	movw	r30, r24
    2588:	10 82       	st	Z, r1
    258a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    258c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    258e:	01 96       	adiw	r24, 0x01	; 1
    2590:	9b 8f       	std	Y+27, r25	; 0x1b
    2592:	8a 8f       	std	Y+26, r24	; 0x1a
    2594:	41 e0       	ldi	r20, 0x01	; 1
    2596:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2598:	3b 8d       	ldd	r19, Y+27	; 0x1b
    259a:	8c 89       	ldd	r24, Y+20	; 0x14
    259c:	9d 89       	ldd	r25, Y+21	; 0x15
    259e:	82 17       	cp	r24, r18
    25a0:	93 07       	cpc	r25, r19
    25a2:	0c f4       	brge	.+2      	; 0x25a6 <_Z11ReceiveBonev+0x69a>
    25a4:	40 e0       	ldi	r20, 0x00	; 0
    25a6:	44 23       	and	r20, r20
    25a8:	39 f7       	brne	.-50     	; 0x2578 <_Z11ReceiveBonev+0x66c>
							placement=0;
    25aa:	1d 8a       	std	Y+21, r1	; 0x15
    25ac:	1c 8a       	std	Y+20, r1	; 0x14
						} else;
						counter++;							
    25ae:	8e 85       	ldd	r24, Y+14	; 0x0e
    25b0:	9f 85       	ldd	r25, Y+15	; 0x0f
    25b2:	01 96       	adiw	r24, 0x01	; 1
    25b4:	9f 87       	std	Y+15, r25	; 0x0f
    25b6:	8e 87       	std	Y+14, r24	; 0x0e
					for (int j=0; j <= placement; j++){tempStringNum[j]=NULL;}	//reset the string
					placement=0;
					counter++;	//get past the '/'
					
					//Loop through the string. If not end of file and counter isn't end of string, and not terminator '.', continue
					while (recString[counter] != '.' && recString[counter] != '\0' && counter != strLoc){
    25b8:	9e 01       	movw	r18, r28
    25ba:	22 5c       	subi	r18, 0xC2	; 194
    25bc:	3f 4f       	sbci	r19, 0xFF	; 255
    25be:	8e 85       	ldd	r24, Y+14	; 0x0e
    25c0:	9f 85       	ldd	r25, Y+15	; 0x0f
    25c2:	82 0f       	add	r24, r18
    25c4:	93 1f       	adc	r25, r19
    25c6:	fc 01       	movw	r30, r24
    25c8:	80 81       	ld	r24, Z
    25ca:	8e 32       	cpi	r24, 0x2E	; 46
    25cc:	a9 f0       	breq	.+42     	; 0x25f8 <_Z11ReceiveBonev+0x6ec>
    25ce:	9e 01       	movw	r18, r28
    25d0:	22 5c       	subi	r18, 0xC2	; 194
    25d2:	3f 4f       	sbci	r19, 0xFF	; 255
    25d4:	8e 85       	ldd	r24, Y+14	; 0x0e
    25d6:	9f 85       	ldd	r25, Y+15	; 0x0f
    25d8:	82 0f       	add	r24, r18
    25da:	93 1f       	adc	r25, r19
    25dc:	fc 01       	movw	r30, r24
    25de:	80 81       	ld	r24, Z
    25e0:	88 23       	and	r24, r24
    25e2:	51 f0       	breq	.+20     	; 0x25f8 <_Z11ReceiveBonev+0x6ec>
    25e4:	8a 81       	ldd	r24, Y+2	; 0x02
    25e6:	28 2f       	mov	r18, r24
    25e8:	30 e0       	ldi	r19, 0x00	; 0
    25ea:	8e 85       	ldd	r24, Y+14	; 0x0e
    25ec:	9f 85       	ldd	r25, Y+15	; 0x0f
    25ee:	28 17       	cp	r18, r24
    25f0:	39 07       	cpc	r19, r25
    25f2:	11 f0       	breq	.+4      	; 0x25f8 <_Z11ReceiveBonev+0x6ec>
    25f4:	81 e0       	ldi	r24, 0x01	; 1
    25f6:	01 c0       	rjmp	.+2      	; 0x25fa <_Z11ReceiveBonev+0x6ee>
    25f8:	80 e0       	ldi	r24, 0x00	; 0
    25fa:	88 23       	and	r24, r24
    25fc:	09 f0       	breq	.+2      	; 0x2600 <_Z11ReceiveBonev+0x6f4>
    25fe:	69 cf       	rjmp	.-302    	; 0x24d2 <_Z11ReceiveBonev+0x5c6>
						} else;
						counter++;							
					}//end while
					
					//Assign last date if the reason we broke the while loop was a '.'. If not, ACKBAD and exit.
					if (recString[counter] == '.'){
    2600:	9e 01       	movw	r18, r28
    2602:	22 5c       	subi	r18, 0xC2	; 194
    2604:	3f 4f       	sbci	r19, 0xFF	; 255
    2606:	8e 85       	ldd	r24, Y+14	; 0x0e
    2608:	9f 85       	ldd	r25, Y+15	; 0x0f
    260a:	82 0f       	add	r24, r18
    260c:	93 1f       	adc	r25, r19
    260e:	fc 01       	movw	r30, r24
    2610:	80 81       	ld	r24, Z
    2612:	8e 32       	cpi	r24, 0x2E	; 46
    2614:	a9 f4       	brne	.+42     	; 0x2640 <_Z11ReceiveBonev+0x734>
						tempNum1[dmy] = atoi(tempStringNum);
    2616:	ce 01       	movw	r24, r28
    2618:	c7 96       	adiw	r24, 0x37	; 55
    261a:	0e 94 12 1d 	call	0x3a24	; 0x3a24 <atoi>
    261e:	9c 01       	movw	r18, r24
    2620:	88 89       	ldd	r24, Y+16	; 0x10
    2622:	99 89       	ldd	r25, Y+17	; 0x11
    2624:	88 0f       	add	r24, r24
    2626:	99 1f       	adc	r25, r25
    2628:	ae 01       	movw	r20, r28
    262a:	4f 5f       	subi	r20, 0xFF	; 255
    262c:	5f 4f       	sbci	r21, 0xFF	; 255
    262e:	84 0f       	add	r24, r20
    2630:	95 1f       	adc	r25, r21
    2632:	c0 96       	adiw	r24, 0x30	; 48
    2634:	fc 01       	movw	r30, r24
    2636:	31 83       	std	Z+1, r19	; 0x01
    2638:	20 83       	st	Z, r18
						successDate=fTrue;
    263a:	81 e0       	ldi	r24, 0x01	; 1
    263c:	8d 87       	std	Y+13, r24	; 0x0d
    263e:	02 c0       	rjmp	.+4      	; 0x2644 <_Z11ReceiveBonev+0x738>
					} else {//something in the string was wrong, ACKBAD and then exit
						state=4;
    2640:	84 e0       	ldi	r24, 0x04	; 4
    2642:	89 83       	std	Y+1, r24	; 0x01
					}	
					
					//NOw set the time and date, then save it to EEPROM
					if (successDate && successTime){
    2644:	8d 85       	ldd	r24, Y+13	; 0x0d
    2646:	88 23       	and	r24, r24
    2648:	19 f1       	breq	.+70     	; 0x2690 <_Z11ReceiveBonev+0x784>
    264a:	8c 85       	ldd	r24, Y+12	; 0x0c
    264c:	88 23       	and	r24, r24
    264e:	01 f1       	breq	.+64     	; 0x2690 <_Z11ReceiveBonev+0x784>
						currentTime.setDate(tempNum1[0],tempNum1[1],tempNum1[2]);
    2650:	69 a9       	sts	0x49, r22
    2652:	7a a9       	sts	0x4a, r23
    2654:	4b a9       	sts	0x4b, r20
    2656:	5c a9       	sts	0x4c, r21
    2658:	2d a9       	sts	0x4d, r18
    265a:	3e a9       	sts	0x4e, r19
    265c:	84 ee       	ldi	r24, 0xE4	; 228
    265e:	91 e0       	ldi	r25, 0x01	; 1
    2660:	0e 94 84 01 	call	0x308	; 0x308 <_ZN6myDate7setDateEiii>
						currentTime.setTime(tempNum[0],tempNum[1],tempNum[2]);
    2664:	6b a5       	lds	r22, 0x6b
    2666:	7c a5       	lds	r23, 0x6c
    2668:	4d a5       	lds	r20, 0x6d
    266a:	5e a5       	lds	r21, 0x6e
    266c:	2f a5       	lds	r18, 0x6f
    266e:	38 a9       	sts	0x48, r19
    2670:	84 ee       	ldi	r24, 0xE4	; 228
    2672:	91 e0       	ldi	r25, 0x01	; 1
    2674:	0e 94 54 05 	call	0xaa8	; 0xaa8 <_ZN6myTime7setTimeEiii>
						saveDateTime_eeprom(fTrue,fTrue);
    2678:	81 e0       	ldi	r24, 0x01	; 1
    267a:	61 e0       	ldi	r22, 0x01	; 1
    267c:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    2680:	81 e0       	ldi	r24, 0x01	; 1
    2682:	80 93 13 02 	sts	0x0213, r24
						//Make sure UserClock flags are down
						flagUserClock=fFalse;
    2686:	10 92 15 02 	sts	0x0215, r1
						state=3;	//Graceful exit
    268a:	83 e0       	ldi	r24, 0x03	; 3
    268c:	89 83       	std	Y+1, r24	; 0x01
    268e:	3b c0       	rjmp	.+118    	; 0x2706 <_Z11ReceiveBonev+0x7fa>
						
					} else if (!(successDate && successTime) && restart){
    2690:	8d 85       	ldd	r24, Y+13	; 0x0d
    2692:	88 23       	and	r24, r24
    2694:	19 f0       	breq	.+6      	; 0x269c <_Z11ReceiveBonev+0x790>
    2696:	8c 85       	ldd	r24, Y+12	; 0x0c
    2698:	88 23       	and	r24, r24
    269a:	61 f4       	brne	.+24     	; 0x26b4 <_Z11ReceiveBonev+0x7a8>
    269c:	80 91 1d 02 	lds	r24, 0x021D
    26a0:	88 23       	and	r24, r24
    26a2:	41 f0       	breq	.+16     	; 0x26b4 <_Z11ReceiveBonev+0x7a8>
						//Even if we have updated the date and time with EEPROM data, do it again.
						flagUpdateGAVRClock=fTrue;
    26a4:	81 e0       	ldi	r24, 0x01	; 1
    26a6:	80 93 13 02 	sts	0x0213, r24
						flagUserClock=fFalse;
    26aa:	10 92 15 02 	sts	0x0215, r1
						state=4;	//ACKBAD
    26ae:	84 e0       	ldi	r24, 0x04	; 4
    26b0:	89 83       	std	Y+1, r24	; 0x01
    26b2:	29 c0       	rjmp	.+82     	; 0x2706 <_Z11ReceiveBonev+0x7fa>
					} else if (!(successDate && successTime) && flagFreshStart && !restart){
    26b4:	8d 85       	ldd	r24, Y+13	; 0x0d
    26b6:	88 23       	and	r24, r24
    26b8:	19 f0       	breq	.+6      	; 0x26c0 <_Z11ReceiveBonev+0x7b4>
    26ba:	8c 85       	ldd	r24, Y+12	; 0x0c
    26bc:	88 23       	and	r24, r24
    26be:	81 f4       	brne	.+32     	; 0x26e0 <_Z11ReceiveBonev+0x7d4>
    26c0:	80 91 1e 02 	lds	r24, 0x021E
    26c4:	88 23       	and	r24, r24
    26c6:	61 f0       	breq	.+24     	; 0x26e0 <_Z11ReceiveBonev+0x7d4>
    26c8:	80 91 1d 02 	lds	r24, 0x021D
    26cc:	88 23       	and	r24, r24
    26ce:	41 f4       	brne	.+16     	; 0x26e0 <_Z11ReceiveBonev+0x7d4>
						flagUserClock=fTrue;
    26d0:	81 e0       	ldi	r24, 0x01	; 1
    26d2:	80 93 15 02 	sts	0x0215, r24
						flagUpdateGAVRClock=fFalse;
    26d6:	10 92 13 02 	sts	0x0213, r1
						state=4;	//ACKBAD
    26da:	84 e0       	ldi	r24, 0x04	; 4
    26dc:	89 83       	std	Y+1, r24	; 0x01
    26de:	13 c0       	rjmp	.+38     	; 0x2706 <_Z11ReceiveBonev+0x7fa>
					} else if (!(successDate && successTime) && !flagFreshStart && !restart){state=4;}	//Don't change the flags, keep them the correct way
    26e0:	8d 85       	ldd	r24, Y+13	; 0x0d
    26e2:	88 23       	and	r24, r24
    26e4:	19 f0       	breq	.+6      	; 0x26ec <_Z11ReceiveBonev+0x7e0>
    26e6:	8c 85       	ldd	r24, Y+12	; 0x0c
    26e8:	88 23       	and	r24, r24
    26ea:	59 f4       	brne	.+22     	; 0x2702 <_Z11ReceiveBonev+0x7f6>
    26ec:	80 91 1e 02 	lds	r24, 0x021E
    26f0:	88 23       	and	r24, r24
    26f2:	39 f4       	brne	.+14     	; 0x2702 <_Z11ReceiveBonev+0x7f6>
    26f4:	80 91 1d 02 	lds	r24, 0x021D
    26f8:	88 23       	and	r24, r24
    26fa:	19 f4       	brne	.+6      	; 0x2702 <_Z11ReceiveBonev+0x7f6>
    26fc:	84 e0       	ldi	r24, 0x04	; 4
    26fe:	89 83       	std	Y+1, r24	; 0x01
    2700:	02 c0       	rjmp	.+4      	; 0x2706 <_Z11ReceiveBonev+0x7fa>
					else {state=4;}
    2702:	84 e0       	ldi	r24, 0x04	; 4
    2704:	89 83       	std	Y+1, r24	; 0x01
					//Lower restart flags. Should have parallel case in timer just in case this state doesn't happen.
					flagFreshStart=fFalse;
    2706:	10 92 1e 02 	sts	0x021E, r1
					restart=fFalse;	
    270a:	10 92 1d 02 	sts	0x021D, r1
					break;
    270e:	04 c0       	rjmp	.+8      	; 0x2718 <_Z11ReceiveBonev+0x80c>
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
    2710:	10 92 0d 02 	sts	0x020D, r1
    2714:	19 82       	std	Y+1, r1	; 0x01
    2716:	00 00       	nop
/*************************************************************************************************************/
void ReceiveBone(){
	BYTE state=0,strLoc=0;
	char recChar, recString[40];
	BOOL noCarriage=fTrue;
	while (flagReceivingBone){
    2718:	90 91 0d 02 	lds	r25, 0x020D
    271c:	81 e0       	ldi	r24, 0x01	; 1
    271e:	99 23       	and	r25, r25
    2720:	09 f4       	brne	.+2      	; 0x2724 <_Z11ReceiveBonev+0x818>
    2722:	80 e0       	ldi	r24, 0x00	; 0
    2724:	88 23       	and	r24, r24
    2726:	09 f0       	breq	.+2      	; 0x272a <_Z11ReceiveBonev+0x81e>
    2728:	01 cc       	rjmp	.-2046   	; 0x1f2c <_Z11ReceiveBonev+0x20>
					break;
					}//end case 7									
				default:{flagReceivingBone=fFalse; state=0;break;}
			}//end switch
	}//end while(flagUARTbone)	
}//end ReceiveBone()
    272a:	cb 59       	subi	r28, 0x9B	; 155
    272c:	df 4f       	sbci	r29, 0xFF	; 255
    272e:	0f b6       	in	r0, 0x3f	; 63
    2730:	f8 94       	cli
    2732:	de bf       	out	0x3e, r29	; 62
    2734:	0f be       	out	0x3f, r0	; 63
    2736:	cd bf       	out	0x3d, r28	; 61
    2738:	df 91       	pop	r29
    273a:	cf 91       	pop	r28
    273c:	08 95       	ret

0000273e <_Z13printTimeDatehhh>:

/*************************************************************************************************************/
//To print to WAVR, cariable needs to be false. Print to Bone requires WAVRorBone to be true
void printTimeDate(BOOL WAVRorBone, BOOL pTime,BOOL pDate){
    273e:	cf 93       	push	r28
    2740:	df 93       	push	r29
    2742:	cd b7       	in	r28, 0x3d	; 61
    2744:	de b7       	in	r29, 0x3e	; 62
    2746:	eb 97       	sbiw	r28, 0x3b	; 59
    2748:	0f b6       	in	r0, 0x3f	; 63
    274a:	f8 94       	cli
    274c:	de bf       	out	0x3e, r29	; 62
    274e:	0f be       	out	0x3f, r0	; 63
    2750:	cd bf       	out	0x3d, r28	; 61
    2752:	89 af       	sts	0x79, r24
    2754:	6a af       	sts	0x7a, r22
    2756:	4b af       	sts	0x7b, r20
	if (WAVRorBone){ //Printing to BeagleBone
    2758:	89 ad       	sts	0x69, r24
    275a:	88 23       	and	r24, r24
    275c:	49 f1       	breq	.+82     	; 0x27b0 <_Z13printTimeDatehhh+0x72>
		if (pTime){
    275e:	8a ad       	sts	0x6a, r24
    2760:	88 23       	and	r24, r24
    2762:	89 f0       	breq	.+34     	; 0x2786 <_Z13printTimeDatehhh+0x48>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    2764:	84 ee       	ldi	r24, 0xE4	; 228
    2766:	91 e0       	ldi	r25, 0x01	; 1
    2768:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    276c:	9c 01       	movw	r18, r24
    276e:	ce 01       	movw	r24, r28
    2770:	01 96       	adiw	r24, 0x01	; 1
    2772:	b9 01       	movw	r22, r18
    2774:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <strcpy>
			PrintBone(tempTime);
    2778:	ce 01       	movw	r24, r28
    277a:	01 96       	adiw	r24, 0x01	; 1
    277c:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
			PutUartChBone('/');
    2780:	8f e2       	ldi	r24, 0x2F	; 47
    2782:	0e 94 2e 09 	call	0x125c	; 0x125c <_Z13PutUartChBonec>
		}
		if (pDate){
    2786:	8b ad       	sts	0x6b, r24
    2788:	88 23       	and	r24, r24
    278a:	d1 f1       	breq	.+116    	; 0x2800 <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    278c:	84 ee       	ldi	r24, 0xE4	; 228
    278e:	91 e0       	ldi	r25, 0x01	; 1
    2790:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    2794:	9c 01       	movw	r18, r24
    2796:	ce 01       	movw	r24, r28
    2798:	0c 96       	adiw	r24, 0x0c	; 12
    279a:	b9 01       	movw	r22, r18
    279c:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <strcpy>
			PrintBone(tempDate);
    27a0:	ce 01       	movw	r24, r28
    27a2:	0c 96       	adiw	r24, 0x0c	; 12
    27a4:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
			PutUartChGAVR('.');
    27a8:	8e e2       	ldi	r24, 0x2E	; 46
    27aa:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
    27ae:	28 c0       	rjmp	.+80     	; 0x2800 <_Z13printTimeDatehhh+0xc2>
		}
	} else { //Printing to GAVR
		if (pTime){
    27b0:	8a ad       	sts	0x6a, r24
    27b2:	88 23       	and	r24, r24
    27b4:	89 f0       	breq	.+34     	; 0x27d8 <_Z13printTimeDatehhh+0x9a>
			char tempTime[11];
			strcpy(tempTime,currentTime.getTime());
    27b6:	84 ee       	ldi	r24, 0xE4	; 228
    27b8:	91 e0       	ldi	r25, 0x01	; 1
    27ba:	0e 94 fa 06 	call	0xdf4	; 0xdf4 <_ZN6myTime7getTimeEv>
    27be:	9c 01       	movw	r18, r24
    27c0:	ce 01       	movw	r24, r28
    27c2:	4d 96       	adiw	r24, 0x1d	; 29
    27c4:	b9 01       	movw	r22, r18
    27c6:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <strcpy>
			PrintGAVR(tempTime);
    27ca:	ce 01       	movw	r24, r28
    27cc:	4d 96       	adiw	r24, 0x1d	; 29
    27ce:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
			PutUartChGAVR('/');
    27d2:	8f e2       	ldi	r24, 0x2F	; 47
    27d4:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
		}
		if (pDate){
    27d8:	8b ad       	sts	0x6b, r24
    27da:	88 23       	and	r24, r24
    27dc:	89 f0       	breq	.+34     	; 0x2800 <_Z13printTimeDatehhh+0xc2>
			char tempDate[17];
			strcpy(tempDate,currentTime.getDate());
    27de:	84 ee       	ldi	r24, 0xE4	; 228
    27e0:	91 e0       	ldi	r25, 0x01	; 1
    27e2:	0e 94 86 03 	call	0x70c	; 0x70c <_ZN6myDate7getDateEv>
    27e6:	9c 01       	movw	r18, r24
    27e8:	ce 01       	movw	r24, r28
    27ea:	88 96       	adiw	r24, 0x28	; 40
    27ec:	b9 01       	movw	r22, r18
    27ee:	0e 94 44 1d 	call	0x3a88	; 0x3a88 <strcpy>
			PrintGAVR(tempDate);
    27f2:	ce 01       	movw	r24, r28
    27f4:	88 96       	adiw	r24, 0x28	; 40
    27f6:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
			PutUartChGAVR('.');
    27fa:	8e e2       	ldi	r24, 0x2E	; 46
    27fc:	0e 94 79 09 	call	0x12f2	; 0x12f2 <_Z13PutUartChGAVRc>
		}
	}
}
    2800:	eb 96       	adiw	r28, 0x3b	; 59
    2802:	0f b6       	in	r0, 0x3f	; 63
    2804:	f8 94       	cli
    2806:	de bf       	out	0x3e, r29	; 62
    2808:	0f be       	out	0x3f, r0	; 63
    280a:	cd bf       	out	0x3d, r28	; 61
    280c:	df 91       	pop	r29
    280e:	cf 91       	pop	r28
    2810:	08 95       	ret

00002812 <__vector_6>:
/****************************************************************************************************************/


/*--------------------------Interrupt Service Routines------------------------------------------------------------------------------------*/
//PCINT_17: Getting information from the GAVR
ISR(PCINT2_vect){
    2812:	1f 92       	push	r1
    2814:	0f 92       	push	r0
    2816:	0f b6       	in	r0, 0x3f	; 63
    2818:	0f 92       	push	r0
    281a:	11 24       	eor	r1, r1
    281c:	2f 93       	push	r18
    281e:	3f 93       	push	r19
    2820:	4f 93       	push	r20
    2822:	5f 93       	push	r21
    2824:	6f 93       	push	r22
    2826:	7f 93       	push	r23
    2828:	8f 93       	push	r24
    282a:	9f 93       	push	r25
    282c:	af 93       	push	r26
    282e:	bf 93       	push	r27
    2830:	ef 93       	push	r30
    2832:	ff 93       	push	r31
    2834:	cf 93       	push	r28
    2836:	df 93       	push	r29
    2838:	cd b7       	in	r28, 0x3d	; 61
    283a:	de b7       	in	r29, 0x3e	; 62
	cli();
    283c:	f8 94       	cli
	if (PINC & (1 << PCINT17)){
    283e:	86 e2       	ldi	r24, 0x26	; 38
    2840:	90 e0       	ldi	r25, 0x00	; 0
    2842:	fc 01       	movw	r30, r24
    2844:	80 81       	ld	r24, Z
    2846:	88 2f       	mov	r24, r24
    2848:	90 e0       	ldi	r25, 0x00	; 0
    284a:	82 70       	andi	r24, 0x02	; 2
    284c:	90 70       	andi	r25, 0x00	; 0
    284e:	21 e0       	ldi	r18, 0x01	; 1
    2850:	00 97       	sbiw	r24, 0x00	; 0
    2852:	09 f4       	brne	.+2      	; 0x2856 <__vector_6+0x44>
    2854:	20 e0       	ldi	r18, 0x00	; 0
    2856:	22 23       	and	r18, r18
    2858:	e1 f0       	breq	.+56     	; 0x2892 <__vector_6+0x80>
		__killCommINT();
    285a:	8d e3       	ldi	r24, 0x3D	; 61
    285c:	90 e0       	ldi	r25, 0x00	; 0
    285e:	fc 01       	movw	r30, r24
    2860:	10 82       	st	Z, r1
    2862:	8d e6       	ldi	r24, 0x6D	; 109
    2864:	90 e0       	ldi	r25, 0x00	; 0
    2866:	fc 01       	movw	r30, r24
    2868:	10 82       	st	Z, r1
		//Do work, correct interrupt
		UCSR1B |= (1 << RXCIE1);
    286a:	89 ec       	ldi	r24, 0xC9	; 201
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	29 ec       	ldi	r18, 0xC9	; 201
    2870:	30 e0       	ldi	r19, 0x00	; 0
    2872:	f9 01       	movw	r30, r18
    2874:	20 81       	ld	r18, Z
    2876:	20 68       	ori	r18, 0x80	; 128
    2878:	fc 01       	movw	r30, r24
    287a:	20 83       	st	Z, r18
		flagGoToSleep=fFalse;
    287c:	10 92 0c 02 	sts	0x020C, r1
		flagNormalMode=fFalse;
    2880:	10 92 0e 02 	sts	0x020E, r1
		flagWaitingForSYNGAVR=fTrue;
    2884:	81 e0       	ldi	r24, 0x01	; 1
    2886:	80 93 11 02 	sts	0x0211, r24
		//Acknowledge
		PrintGAVR("A.");
    288a:	8c e0       	ldi	r24, 0x0C	; 12
    288c:	91 e0       	ldi	r25, 0x01	; 1
    288e:	0e 94 97 09 	call	0x132e	; 0x132e <_Z9PrintGAVRPc>
	}
	sei();
    2892:	78 94       	sei
}	
    2894:	df 91       	pop	r29
    2896:	cf 91       	pop	r28
    2898:	ff 91       	pop	r31
    289a:	ef 91       	pop	r30
    289c:	bf 91       	pop	r27
    289e:	af 91       	pop	r26
    28a0:	9f 91       	pop	r25
    28a2:	8f 91       	pop	r24
    28a4:	7f 91       	pop	r23
    28a6:	6f 91       	pop	r22
    28a8:	5f 91       	pop	r21
    28aa:	4f 91       	pop	r20
    28ac:	3f 91       	pop	r19
    28ae:	2f 91       	pop	r18
    28b0:	0f 90       	pop	r0
    28b2:	0f be       	out	0x3f, r0	; 63
    28b4:	0f 90       	pop	r0
    28b6:	1f 90       	pop	r1
    28b8:	18 95       	reti

000028ba <__vector_3>:
/********************************************************/
//INT2: Getting information from BeagleBone
ISR(INT2_vect){	//about to get time, get things ready
    28ba:	1f 92       	push	r1
    28bc:	0f 92       	push	r0
    28be:	0f b6       	in	r0, 0x3f	; 63
    28c0:	0f 92       	push	r0
    28c2:	11 24       	eor	r1, r1
    28c4:	2f 93       	push	r18
    28c6:	3f 93       	push	r19
    28c8:	4f 93       	push	r20
    28ca:	5f 93       	push	r21
    28cc:	6f 93       	push	r22
    28ce:	7f 93       	push	r23
    28d0:	8f 93       	push	r24
    28d2:	9f 93       	push	r25
    28d4:	af 93       	push	r26
    28d6:	bf 93       	push	r27
    28d8:	ef 93       	push	r30
    28da:	ff 93       	push	r31
    28dc:	cf 93       	push	r28
    28de:	df 93       	push	r29
    28e0:	cd b7       	in	r28, 0x3d	; 61
    28e2:	de b7       	in	r29, 0x3e	; 62
	cli();
    28e4:	f8 94       	cli
	if (!flagShutdown){		//If things are off, don't let noise do an interrupt. Shouldn't happen anyways.
    28e6:	80 91 1a 02 	lds	r24, 0x021A
    28ea:	88 23       	and	r24, r24
    28ec:	e1 f4       	brne	.+56     	; 0x2926 <__vector_3+0x6c>
		flagGoToSleep=fFalse;	//no sleeping, wait for UART_RX
    28ee:	10 92 0c 02 	sts	0x020C, r1
		flagNormalMode=fFalse;
    28f2:	10 92 0e 02 	sts	0x020E, r1
		flagWaitingForSYNBone=fTrue;
    28f6:	81 e0       	ldi	r24, 0x01	; 1
    28f8:	80 93 12 02 	sts	0x0212, r24
		__killCommINT();
    28fc:	8d e3       	ldi	r24, 0x3D	; 61
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	fc 01       	movw	r30, r24
    2902:	10 82       	st	Z, r1
    2904:	8d e6       	ldi	r24, 0x6D	; 109
    2906:	90 e0       	ldi	r25, 0x00	; 0
    2908:	fc 01       	movw	r30, r24
    290a:	10 82       	st	Z, r1
		//Acknowledge connection, disable INT2_vect
		PrintBone("A.");
    290c:	8c e0       	ldi	r24, 0x0C	; 12
    290e:	91 e0       	ldi	r25, 0x01	; 1
    2910:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
		UCSR0B |= (1 << RXCIE0);
    2914:	81 ec       	ldi	r24, 0xC1	; 193
    2916:	90 e0       	ldi	r25, 0x00	; 0
    2918:	21 ec       	ldi	r18, 0xC1	; 193
    291a:	30 e0       	ldi	r19, 0x00	; 0
    291c:	f9 01       	movw	r30, r18
    291e:	20 81       	ld	r18, Z
    2920:	20 68       	ori	r18, 0x80	; 128
    2922:	fc 01       	movw	r30, r24
    2924:	20 83       	st	Z, r18
	}
	sei();
    2926:	78 94       	sei
}
    2928:	df 91       	pop	r29
    292a:	cf 91       	pop	r28
    292c:	ff 91       	pop	r31
    292e:	ef 91       	pop	r30
    2930:	bf 91       	pop	r27
    2932:	af 91       	pop	r26
    2934:	9f 91       	pop	r25
    2936:	8f 91       	pop	r24
    2938:	7f 91       	pop	r23
    293a:	6f 91       	pop	r22
    293c:	5f 91       	pop	r21
    293e:	4f 91       	pop	r20
    2940:	3f 91       	pop	r19
    2942:	2f 91       	pop	r18
    2944:	0f 90       	pop	r0
    2946:	0f be       	out	0x3f, r0	; 63
    2948:	0f 90       	pop	r0
    294a:	1f 90       	pop	r1
    294c:	18 95       	reti

0000294e <__vector_20>:
/********************************************************/
//UART Receive from BeagleBone
ISR(USART0_RX_vect){
    294e:	1f 92       	push	r1
    2950:	0f 92       	push	r0
    2952:	0f b6       	in	r0, 0x3f	; 63
    2954:	0f 92       	push	r0
    2956:	11 24       	eor	r1, r1
    2958:	2f 93       	push	r18
    295a:	3f 93       	push	r19
    295c:	8f 93       	push	r24
    295e:	9f 93       	push	r25
    2960:	ef 93       	push	r30
    2962:	ff 93       	push	r31
    2964:	cf 93       	push	r28
    2966:	df 93       	push	r29
    2968:	cd b7       	in	r28, 0x3d	; 61
    296a:	de b7       	in	r29, 0x3e	; 62
	cli();
    296c:	f8 94       	cli
	if (flagWaitingForSYNBone){
    296e:	80 91 12 02 	lds	r24, 0x0212
    2972:	88 23       	and	r24, r24
    2974:	31 f0       	breq	.+12     	; 0x2982 <__vector_20+0x34>
		flagReceivingBone=fTrue;
    2976:	81 e0       	ldi	r24, 0x01	; 1
    2978:	80 93 0d 02 	sts	0x020D, r24
		flagWaitingForSYNBone=fFalse;
    297c:	10 92 12 02 	sts	0x0212, r1
    2980:	02 c0       	rjmp	.+4      	; 0x2986 <__vector_20+0x38>
	} else {
		flagReceivingBone=fFalse;		//there was a timeout between the initial interrupt and when we are getting this.
    2982:	10 92 0d 02 	sts	0x020D, r1
	}	
	UCSR0B &= ~(1 << RXCIE0);
    2986:	81 ec       	ldi	r24, 0xC1	; 193
    2988:	90 e0       	ldi	r25, 0x00	; 0
    298a:	21 ec       	ldi	r18, 0xC1	; 193
    298c:	30 e0       	ldi	r19, 0x00	; 0
    298e:	f9 01       	movw	r30, r18
    2990:	20 81       	ld	r18, Z
    2992:	2f 77       	andi	r18, 0x7F	; 127
    2994:	fc 01       	movw	r30, r24
    2996:	20 83       	st	Z, r18
	sei();
    2998:	78 94       	sei
}
    299a:	df 91       	pop	r29
    299c:	cf 91       	pop	r28
    299e:	ff 91       	pop	r31
    29a0:	ef 91       	pop	r30
    29a2:	9f 91       	pop	r25
    29a4:	8f 91       	pop	r24
    29a6:	3f 91       	pop	r19
    29a8:	2f 91       	pop	r18
    29aa:	0f 90       	pop	r0
    29ac:	0f be       	out	0x3f, r0	; 63
    29ae:	0f 90       	pop	r0
    29b0:	1f 90       	pop	r1
    29b2:	18 95       	reti

000029b4 <__vector_28>:
/********************************************************/
ISR(USART1_RX_vect){
    29b4:	1f 92       	push	r1
    29b6:	0f 92       	push	r0
    29b8:	0f b6       	in	r0, 0x3f	; 63
    29ba:	0f 92       	push	r0
    29bc:	11 24       	eor	r1, r1
    29be:	2f 93       	push	r18
    29c0:	3f 93       	push	r19
    29c2:	8f 93       	push	r24
    29c4:	9f 93       	push	r25
    29c6:	ef 93       	push	r30
    29c8:	ff 93       	push	r31
    29ca:	cf 93       	push	r28
    29cc:	df 93       	push	r29
    29ce:	cd b7       	in	r28, 0x3d	; 61
    29d0:	de b7       	in	r29, 0x3e	; 62
	cli();
    29d2:	f8 94       	cli
	if (flagWaitingForSYNGAVR){
    29d4:	80 91 11 02 	lds	r24, 0x0211
    29d8:	88 23       	and	r24, r24
    29da:	31 f0       	breq	.+12     	; 0x29e8 <__vector_28+0x34>
		flagReceivingGAVR=fTrue;
    29dc:	81 e0       	ldi	r24, 0x01	; 1
    29de:	80 93 0f 02 	sts	0x020F, r24
		flagWaitingForSYNGAVR=fFalse;
    29e2:	10 92 11 02 	sts	0x0211, r1
    29e6:	02 c0       	rjmp	.+4      	; 0x29ec <__vector_28+0x38>
	}else {
		flagReceivingGAVR=fFalse;
    29e8:	10 92 0f 02 	sts	0x020F, r1
	}
	UCSR1B &= ~(1 <<RXCIE1);	//disable interrupt
    29ec:	89 ec       	ldi	r24, 0xC9	; 201
    29ee:	90 e0       	ldi	r25, 0x00	; 0
    29f0:	29 ec       	ldi	r18, 0xC9	; 201
    29f2:	30 e0       	ldi	r19, 0x00	; 0
    29f4:	f9 01       	movw	r30, r18
    29f6:	20 81       	ld	r18, Z
    29f8:	2f 77       	andi	r18, 0x7F	; 127
    29fa:	fc 01       	movw	r30, r24
    29fc:	20 83       	st	Z, r18
	sei();
    29fe:	78 94       	sei
}
    2a00:	df 91       	pop	r29
    2a02:	cf 91       	pop	r28
    2a04:	ff 91       	pop	r31
    2a06:	ef 91       	pop	r30
    2a08:	9f 91       	pop	r25
    2a0a:	8f 91       	pop	r24
    2a0c:	3f 91       	pop	r19
    2a0e:	2f 91       	pop	r18
    2a10:	0f 90       	pop	r0
    2a12:	0f be       	out	0x3f, r0	; 63
    2a14:	0f 90       	pop	r0
    2a16:	1f 90       	pop	r1
    2a18:	18 95       	reti

00002a1a <__vector_11>:

/********************************************************/
//RTC Timer.
ISR(TIMER2_OVF_vect){
    2a1a:	1f 92       	push	r1
    2a1c:	0f 92       	push	r0
    2a1e:	0f b6       	in	r0, 0x3f	; 63
    2a20:	0f 92       	push	r0
    2a22:	11 24       	eor	r1, r1
    2a24:	2f 93       	push	r18
    2a26:	3f 93       	push	r19
    2a28:	4f 93       	push	r20
    2a2a:	5f 93       	push	r21
    2a2c:	6f 93       	push	r22
    2a2e:	7f 93       	push	r23
    2a30:	8f 93       	push	r24
    2a32:	9f 93       	push	r25
    2a34:	af 93       	push	r26
    2a36:	bf 93       	push	r27
    2a38:	ef 93       	push	r30
    2a3a:	ff 93       	push	r31
    2a3c:	cf 93       	push	r28
    2a3e:	df 93       	push	r29
    2a40:	cd b7       	in	r28, 0x3d	; 61
    2a42:	de b7       	in	r29, 0x3e	; 62
	cli();
    2a44:	f8 94       	cli
	prtSLEEPled ^= (1 << bnSLEEPled);
    2a46:	8b e2       	ldi	r24, 0x2B	; 43
    2a48:	90 e0       	ldi	r25, 0x00	; 0
    2a4a:	2b e2       	ldi	r18, 0x2B	; 43
    2a4c:	30 e0       	ldi	r19, 0x00	; 0
    2a4e:	f9 01       	movw	r30, r18
    2a50:	30 81       	ld	r19, Z
    2a52:	20 e8       	ldi	r18, 0x80	; 128
    2a54:	23 27       	eor	r18, r19
    2a56:	fc 01       	movw	r30, r24
    2a58:	20 83       	st	Z, r18
	static unsigned int gavrSendTimeout=0, boneReceiveTimeout=0, gavrReceiveTimeout=0, startupTimeout=0;
	
	currentTime.addSeconds(1);
    2a5a:	84 ee       	ldi	r24, 0xE4	; 228
    2a5c:	91 e0       	ldi	r25, 0x01	; 1
    2a5e:	61 e0       	ldi	r22, 0x01	; 1
    2a60:	70 e0       	ldi	r23, 0x00	; 0
    2a62:	0e 94 72 06 	call	0xce4	; 0xce4 <_ZN6myTime10addSecondsEi>
	
	//GAVR Transmission Timeout
	if (flagSendingGAVR && gavrSendTimeout <=COMM_TIMEOUT_SEC){gavrSendTimeout++;}
    2a66:	80 91 14 02 	lds	r24, 0x0214
    2a6a:	88 23       	and	r24, r24
    2a6c:	89 f0       	breq	.+34     	; 0x2a90 <__vector_11+0x76>
    2a6e:	80 91 1f 02 	lds	r24, 0x021F
    2a72:	90 91 20 02 	lds	r25, 0x0220
    2a76:	89 30       	cpi	r24, 0x09	; 9
    2a78:	91 05       	cpc	r25, r1
    2a7a:	50 f4       	brcc	.+20     	; 0x2a90 <__vector_11+0x76>
    2a7c:	80 91 1f 02 	lds	r24, 0x021F
    2a80:	90 91 20 02 	lds	r25, 0x0220
    2a84:	01 96       	adiw	r24, 0x01	; 1
    2a86:	90 93 20 02 	sts	0x0220, r25
    2a8a:	80 93 1f 02 	sts	0x021F, r24
    2a8e:	43 c0       	rjmp	.+134    	; 0x2b16 <__vector_11+0xfc>
	else if (flagSendingGAVR && gavrSendTimeout > COMM_TIMEOUT_SEC){__killUARTrec();flagSendingGAVR=fFalse;flagGoToSleep=fTrue; gavrSendTimeout=0; __enableCommINT();}
    2a90:	80 91 14 02 	lds	r24, 0x0214
    2a94:	88 23       	and	r24, r24
    2a96:	89 f1       	breq	.+98     	; 0x2afa <__vector_11+0xe0>
    2a98:	80 91 1f 02 	lds	r24, 0x021F
    2a9c:	90 91 20 02 	lds	r25, 0x0220
    2aa0:	89 30       	cpi	r24, 0x09	; 9
    2aa2:	91 05       	cpc	r25, r1
    2aa4:	50 f1       	brcs	.+84     	; 0x2afa <__vector_11+0xe0>
    2aa6:	81 ec       	ldi	r24, 0xC1	; 193
    2aa8:	90 e0       	ldi	r25, 0x00	; 0
    2aaa:	21 ec       	ldi	r18, 0xC1	; 193
    2aac:	30 e0       	ldi	r19, 0x00	; 0
    2aae:	f9 01       	movw	r30, r18
    2ab0:	20 81       	ld	r18, Z
    2ab2:	20 68       	ori	r18, 0x80	; 128
    2ab4:	fc 01       	movw	r30, r24
    2ab6:	20 83       	st	Z, r18
    2ab8:	89 ec       	ldi	r24, 0xC9	; 201
    2aba:	90 e0       	ldi	r25, 0x00	; 0
    2abc:	29 ec       	ldi	r18, 0xC9	; 201
    2abe:	30 e0       	ldi	r19, 0x00	; 0
    2ac0:	f9 01       	movw	r30, r18
    2ac2:	20 81       	ld	r18, Z
    2ac4:	20 68       	ori	r18, 0x80	; 128
    2ac6:	fc 01       	movw	r30, r24
    2ac8:	20 83       	st	Z, r18
    2aca:	10 92 14 02 	sts	0x0214, r1
    2ace:	81 e0       	ldi	r24, 0x01	; 1
    2ad0:	80 93 0c 02 	sts	0x020C, r24
    2ad4:	10 92 20 02 	sts	0x0220, r1
    2ad8:	10 92 1f 02 	sts	0x021F, r1
    2adc:	8d e3       	ldi	r24, 0x3D	; 61
    2ade:	90 e0       	ldi	r25, 0x00	; 0
    2ae0:	2d e3       	ldi	r18, 0x3D	; 61
    2ae2:	30 e0       	ldi	r19, 0x00	; 0
    2ae4:	f9 01       	movw	r30, r18
    2ae6:	20 81       	ld	r18, Z
    2ae8:	24 60       	ori	r18, 0x04	; 4
    2aea:	fc 01       	movw	r30, r24
    2aec:	20 83       	st	Z, r18
    2aee:	8d e6       	ldi	r24, 0x6D	; 109
    2af0:	90 e0       	ldi	r25, 0x00	; 0
    2af2:	22 e0       	ldi	r18, 0x02	; 2
    2af4:	fc 01       	movw	r30, r24
    2af6:	20 83       	st	Z, r18
    2af8:	0e c0       	rjmp	.+28     	; 0x2b16 <__vector_11+0xfc>
	else if (!flagSendingGAVR && gavrSendTimeout > 0){gavrSendTimeout=0;}
    2afa:	80 91 14 02 	lds	r24, 0x0214
    2afe:	88 23       	and	r24, r24
    2b00:	51 f4       	brne	.+20     	; 0x2b16 <__vector_11+0xfc>
    2b02:	80 91 1f 02 	lds	r24, 0x021F
    2b06:	90 91 20 02 	lds	r25, 0x0220
    2b0a:	00 97       	sbiw	r24, 0x00	; 0
    2b0c:	21 f0       	breq	.+8      	; 0x2b16 <__vector_11+0xfc>
    2b0e:	10 92 20 02 	sts	0x0220, r1
    2b12:	10 92 1f 02 	sts	0x021F, r1
	else;
	
	//BeagleBone Reception Timeout
	if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout <=COMM_TIMEOUT_SEC)){boneReceiveTimeout++;}
    2b16:	80 91 0d 02 	lds	r24, 0x020D
    2b1a:	88 23       	and	r24, r24
    2b1c:	21 f4       	brne	.+8      	; 0x2b26 <__vector_11+0x10c>
    2b1e:	80 91 12 02 	lds	r24, 0x0212
    2b22:	88 23       	and	r24, r24
    2b24:	89 f0       	breq	.+34     	; 0x2b48 <__vector_11+0x12e>
    2b26:	80 91 21 02 	lds	r24, 0x0221
    2b2a:	90 91 22 02 	lds	r25, 0x0222
    2b2e:	89 30       	cpi	r24, 0x09	; 9
    2b30:	91 05       	cpc	r25, r1
    2b32:	50 f4       	brcc	.+20     	; 0x2b48 <__vector_11+0x12e>
    2b34:	80 91 21 02 	lds	r24, 0x0221
    2b38:	90 91 22 02 	lds	r25, 0x0222
    2b3c:	01 96       	adiw	r24, 0x01	; 1
    2b3e:	90 93 22 02 	sts	0x0222, r25
    2b42:	80 93 21 02 	sts	0x0221, r24
    2b46:	50 c0       	rjmp	.+160    	; 0x2be8 <__vector_11+0x1ce>
	else if ((flagReceivingBone|| flagWaitingForSYNBone) && (boneReceiveTimeout > COMM_TIMEOUT_SEC)){__killUARTrec();flagReceivingBone=fFalse; flagWaitingForSYNBone=fFalse;flagGoToSleep=fTrue; flagNormalMode=fTrue; boneReceiveTimeout=0; __enableCommINT();}
    2b48:	80 91 0d 02 	lds	r24, 0x020D
    2b4c:	88 23       	and	r24, r24
    2b4e:	21 f4       	brne	.+8      	; 0x2b58 <__vector_11+0x13e>
    2b50:	80 91 12 02 	lds	r24, 0x0212
    2b54:	88 23       	and	r24, r24
    2b56:	b1 f1       	breq	.+108    	; 0x2bc4 <__vector_11+0x1aa>
    2b58:	80 91 21 02 	lds	r24, 0x0221
    2b5c:	90 91 22 02 	lds	r25, 0x0222
    2b60:	89 30       	cpi	r24, 0x09	; 9
    2b62:	91 05       	cpc	r25, r1
    2b64:	78 f1       	brcs	.+94     	; 0x2bc4 <__vector_11+0x1aa>
    2b66:	81 ec       	ldi	r24, 0xC1	; 193
    2b68:	90 e0       	ldi	r25, 0x00	; 0
    2b6a:	21 ec       	ldi	r18, 0xC1	; 193
    2b6c:	30 e0       	ldi	r19, 0x00	; 0
    2b6e:	f9 01       	movw	r30, r18
    2b70:	20 81       	ld	r18, Z
    2b72:	20 68       	ori	r18, 0x80	; 128
    2b74:	fc 01       	movw	r30, r24
    2b76:	20 83       	st	Z, r18
    2b78:	89 ec       	ldi	r24, 0xC9	; 201
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	29 ec       	ldi	r18, 0xC9	; 201
    2b7e:	30 e0       	ldi	r19, 0x00	; 0
    2b80:	f9 01       	movw	r30, r18
    2b82:	20 81       	ld	r18, Z
    2b84:	20 68       	ori	r18, 0x80	; 128
    2b86:	fc 01       	movw	r30, r24
    2b88:	20 83       	st	Z, r18
    2b8a:	10 92 0d 02 	sts	0x020D, r1
    2b8e:	10 92 12 02 	sts	0x0212, r1
    2b92:	81 e0       	ldi	r24, 0x01	; 1
    2b94:	80 93 0c 02 	sts	0x020C, r24
    2b98:	81 e0       	ldi	r24, 0x01	; 1
    2b9a:	80 93 0e 02 	sts	0x020E, r24
    2b9e:	10 92 22 02 	sts	0x0222, r1
    2ba2:	10 92 21 02 	sts	0x0221, r1
    2ba6:	8d e3       	ldi	r24, 0x3D	; 61
    2ba8:	90 e0       	ldi	r25, 0x00	; 0
    2baa:	2d e3       	ldi	r18, 0x3D	; 61
    2bac:	30 e0       	ldi	r19, 0x00	; 0
    2bae:	f9 01       	movw	r30, r18
    2bb0:	20 81       	ld	r18, Z
    2bb2:	24 60       	ori	r18, 0x04	; 4
    2bb4:	fc 01       	movw	r30, r24
    2bb6:	20 83       	st	Z, r18
    2bb8:	8d e6       	ldi	r24, 0x6D	; 109
    2bba:	90 e0       	ldi	r25, 0x00	; 0
    2bbc:	22 e0       	ldi	r18, 0x02	; 2
    2bbe:	fc 01       	movw	r30, r24
    2bc0:	20 83       	st	Z, r18
    2bc2:	12 c0       	rjmp	.+36     	; 0x2be8 <__vector_11+0x1ce>
	else if ((!flagReceivingBone && !flagWaitingForSYNBone) && boneReceiveTimeout > 0){boneReceiveTimeout=0;}
    2bc4:	80 91 0d 02 	lds	r24, 0x020D
    2bc8:	88 23       	and	r24, r24
    2bca:	71 f4       	brne	.+28     	; 0x2be8 <__vector_11+0x1ce>
    2bcc:	80 91 12 02 	lds	r24, 0x0212
    2bd0:	88 23       	and	r24, r24
    2bd2:	51 f4       	brne	.+20     	; 0x2be8 <__vector_11+0x1ce>
    2bd4:	80 91 21 02 	lds	r24, 0x0221
    2bd8:	90 91 22 02 	lds	r25, 0x0222
    2bdc:	00 97       	sbiw	r24, 0x00	; 0
    2bde:	21 f0       	breq	.+8      	; 0x2be8 <__vector_11+0x1ce>
    2be0:	10 92 22 02 	sts	0x0222, r1
    2be4:	10 92 21 02 	sts	0x0221, r1
	else;

	//GAVR Reception Timeout
	if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout <= COMM_TIMEOUT_SEC){gavrReceiveTimeout++;}
    2be8:	80 91 0f 02 	lds	r24, 0x020F
    2bec:	88 23       	and	r24, r24
    2bee:	21 f4       	brne	.+8      	; 0x2bf8 <__vector_11+0x1de>
    2bf0:	80 91 11 02 	lds	r24, 0x0211
    2bf4:	88 23       	and	r24, r24
    2bf6:	89 f0       	breq	.+34     	; 0x2c1a <__vector_11+0x200>
    2bf8:	80 91 23 02 	lds	r24, 0x0223
    2bfc:	90 91 24 02 	lds	r25, 0x0224
    2c00:	89 30       	cpi	r24, 0x09	; 9
    2c02:	91 05       	cpc	r25, r1
    2c04:	50 f4       	brcc	.+20     	; 0x2c1a <__vector_11+0x200>
    2c06:	80 91 23 02 	lds	r24, 0x0223
    2c0a:	90 91 24 02 	lds	r25, 0x0224
    2c0e:	01 96       	adiw	r24, 0x01	; 1
    2c10:	90 93 24 02 	sts	0x0224, r25
    2c14:	80 93 23 02 	sts	0x0223, r24
    2c18:	50 c0       	rjmp	.+160    	; 0x2cba <__vector_11+0x2a0>
	else if ((flagReceivingGAVR || flagWaitingForSYNGAVR) && gavrReceiveTimeout > COMM_TIMEOUT_SEC){__killUARTrec(); flagReceivingGAVR=fFalse;flagGoToSleep=fTrue; flagWaitingForSYNGAVR=fFalse;flagNormalMode=fTrue;gavrReceiveTimeout=0; __enableCommINT();}
    2c1a:	80 91 0f 02 	lds	r24, 0x020F
    2c1e:	88 23       	and	r24, r24
    2c20:	21 f4       	brne	.+8      	; 0x2c2a <__vector_11+0x210>
    2c22:	80 91 11 02 	lds	r24, 0x0211
    2c26:	88 23       	and	r24, r24
    2c28:	b1 f1       	breq	.+108    	; 0x2c96 <__vector_11+0x27c>
    2c2a:	80 91 23 02 	lds	r24, 0x0223
    2c2e:	90 91 24 02 	lds	r25, 0x0224
    2c32:	89 30       	cpi	r24, 0x09	; 9
    2c34:	91 05       	cpc	r25, r1
    2c36:	78 f1       	brcs	.+94     	; 0x2c96 <__vector_11+0x27c>
    2c38:	81 ec       	ldi	r24, 0xC1	; 193
    2c3a:	90 e0       	ldi	r25, 0x00	; 0
    2c3c:	21 ec       	ldi	r18, 0xC1	; 193
    2c3e:	30 e0       	ldi	r19, 0x00	; 0
    2c40:	f9 01       	movw	r30, r18
    2c42:	20 81       	ld	r18, Z
    2c44:	20 68       	ori	r18, 0x80	; 128
    2c46:	fc 01       	movw	r30, r24
    2c48:	20 83       	st	Z, r18
    2c4a:	89 ec       	ldi	r24, 0xC9	; 201
    2c4c:	90 e0       	ldi	r25, 0x00	; 0
    2c4e:	29 ec       	ldi	r18, 0xC9	; 201
    2c50:	30 e0       	ldi	r19, 0x00	; 0
    2c52:	f9 01       	movw	r30, r18
    2c54:	20 81       	ld	r18, Z
    2c56:	20 68       	ori	r18, 0x80	; 128
    2c58:	fc 01       	movw	r30, r24
    2c5a:	20 83       	st	Z, r18
    2c5c:	10 92 0f 02 	sts	0x020F, r1
    2c60:	81 e0       	ldi	r24, 0x01	; 1
    2c62:	80 93 0c 02 	sts	0x020C, r24
    2c66:	10 92 11 02 	sts	0x0211, r1
    2c6a:	81 e0       	ldi	r24, 0x01	; 1
    2c6c:	80 93 0e 02 	sts	0x020E, r24
    2c70:	10 92 24 02 	sts	0x0224, r1
    2c74:	10 92 23 02 	sts	0x0223, r1
    2c78:	8d e3       	ldi	r24, 0x3D	; 61
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	2d e3       	ldi	r18, 0x3D	; 61
    2c7e:	30 e0       	ldi	r19, 0x00	; 0
    2c80:	f9 01       	movw	r30, r18
    2c82:	20 81       	ld	r18, Z
    2c84:	24 60       	ori	r18, 0x04	; 4
    2c86:	fc 01       	movw	r30, r24
    2c88:	20 83       	st	Z, r18
    2c8a:	8d e6       	ldi	r24, 0x6D	; 109
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	22 e0       	ldi	r18, 0x02	; 2
    2c90:	fc 01       	movw	r30, r24
    2c92:	20 83       	st	Z, r18
    2c94:	12 c0       	rjmp	.+36     	; 0x2cba <__vector_11+0x2a0>
	else if ((!flagReceivingGAVR && !flagWaitingForSYNGAVR) && gavrReceiveTimeout > 0){gavrReceiveTimeout=0;}
    2c96:	80 91 0f 02 	lds	r24, 0x020F
    2c9a:	88 23       	and	r24, r24
    2c9c:	71 f4       	brne	.+28     	; 0x2cba <__vector_11+0x2a0>
    2c9e:	80 91 11 02 	lds	r24, 0x0211
    2ca2:	88 23       	and	r24, r24
    2ca4:	51 f4       	brne	.+20     	; 0x2cba <__vector_11+0x2a0>
    2ca6:	80 91 23 02 	lds	r24, 0x0223
    2caa:	90 91 24 02 	lds	r25, 0x0224
    2cae:	00 97       	sbiw	r24, 0x00	; 0
    2cb0:	21 f0       	breq	.+8      	; 0x2cba <__vector_11+0x2a0>
    2cb2:	10 92 24 02 	sts	0x0224, r1
    2cb6:	10 92 23 02 	sts	0x0223, r1
		flagNormalMode=fTrue;
	} else if (!(flagFreshStart || restart) && startupTimeout > 0){startupTimeout=0;}
	else;
	sei();
#endif
}//End timer 2 overflow.
    2cba:	df 91       	pop	r29
    2cbc:	cf 91       	pop	r28
    2cbe:	ff 91       	pop	r31
    2cc0:	ef 91       	pop	r30
    2cc2:	bf 91       	pop	r27
    2cc4:	af 91       	pop	r26
    2cc6:	9f 91       	pop	r25
    2cc8:	8f 91       	pop	r24
    2cca:	7f 91       	pop	r23
    2ccc:	6f 91       	pop	r22
    2cce:	5f 91       	pop	r21
    2cd0:	4f 91       	pop	r20
    2cd2:	3f 91       	pop	r19
    2cd4:	2f 91       	pop	r18
    2cd6:	0f 90       	pop	r0
    2cd8:	0f be       	out	0x3f, r0	; 63
    2cda:	0f 90       	pop	r0
    2cdc:	1f 90       	pop	r1
    2cde:	18 95       	reti

00002ce0 <main>:

/*--------------------------END-Interrupt Service Routines--------------------------------------------------------------------------------*/
/*--------------------------START-Main Program--------------------------------------------------------------------------------------------*/

int main(void)
{
    2ce0:	cf 93       	push	r28
    2ce2:	df 93       	push	r29
    2ce4:	cd b7       	in	r28, 0x3d	; 61
    2ce6:	de b7       	in	r29, 0x3e	; 62
	//Setup
	DeviceInit();
    2ce8:	0e 94 01 18 	call	0x3002	; 0x3002 <_Z10DeviceInitv>
	AppInit(MYUBRR);
    2cec:	83 e3       	ldi	r24, 0x33	; 51
    2cee:	90 e0       	ldi	r25, 0x00	; 0
    2cf0:	0e 94 28 18 	call	0x3050	; 0x3050 <_Z7AppInitj>
	EnableRTCTimer();
    2cf4:	0e 94 cc 19 	call	0x3398	; 0x3398 <_Z14EnableRTCTimerv>
	InitBools();
    2cf8:	0e 94 a1 19 	call	0x3342	; 0x3342 <_Z9InitBoolsv>
	getDateTime_eeprom(fTrue,fTrue);
    2cfc:	81 e0       	ldi	r24, 0x01	; 1
    2cfe:	61 e0       	ldi	r22, 0x01	; 1
    2d00:	0e 94 84 07 	call	0xf08	; 0xf08 <_Z18getDateTime_eepromhh>
	//Prep/make sure power/temp is good
	Wait_sec(2);
    2d04:	82 e0       	ldi	r24, 0x02	; 2
    2d06:	90 e0       	ldi	r25, 0x00	; 0
    2d08:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	GetTemp();
    2d0c:	0e 94 3e 1b 	call	0x367c	; 0x367c <_Z7GetTempv>
	TakeADC();
    2d10:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <_Z7TakeADCv>
	flagGoodTemp=fTrue;
    2d14:	81 e0       	ldi	r24, 0x01	; 1
    2d16:	80 93 1b 02 	sts	0x021B, r24
	if (flagGoodVolts && flagGoodTemp){				//Good to power on system
    2d1a:	80 91 1c 02 	lds	r24, 0x021C
    2d1e:	88 23       	and	r24, r24
    2d20:	e1 f0       	breq	.+56     	; 0x2d5a <main+0x7a>
    2d22:	80 91 1b 02 	lds	r24, 0x021B
    2d26:	88 23       	and	r24, r24
    2d28:	c1 f0       	breq	.+48     	; 0x2d5a <main+0x7a>
		PowerUp(POWER_UP_INTERVAL);
    2d2a:	83 e0       	ldi	r24, 0x03	; 3
    2d2c:	90 e0       	ldi	r25, 0x00	; 0
    2d2e:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <_Z7PowerUpj>
		__enableCommINT();
    2d32:	8d e3       	ldi	r24, 0x3D	; 61
    2d34:	90 e0       	ldi	r25, 0x00	; 0
    2d36:	2d e3       	ldi	r18, 0x3D	; 61
    2d38:	30 e0       	ldi	r19, 0x00	; 0
    2d3a:	f9 01       	movw	r30, r18
    2d3c:	20 81       	ld	r18, Z
    2d3e:	24 60       	ori	r18, 0x04	; 4
    2d40:	fc 01       	movw	r30, r24
    2d42:	20 83       	st	Z, r18
    2d44:	8d e6       	ldi	r24, 0x6D	; 109
    2d46:	90 e0       	ldi	r25, 0x00	; 0
    2d48:	22 e0       	ldi	r18, 0x02	; 2
    2d4a:	fc 01       	movw	r30, r24
    2d4c:	20 83       	st	Z, r18
		flagFreshStart=fTrue;
    2d4e:	81 e0       	ldi	r24, 0x01	; 1
    2d50:	80 93 1e 02 	sts	0x021E, r24
		flagShutdown=fFalse;
    2d54:	10 92 1a 02 	sts	0x021A, r1
    2d58:	0d c0       	rjmp	.+26     	; 0x2d74 <main+0x94>
	} else {										//Something isn't right, don't power on the system.
		__killCommINT();
    2d5a:	8d e3       	ldi	r24, 0x3D	; 61
    2d5c:	90 e0       	ldi	r25, 0x00	; 0
    2d5e:	fc 01       	movw	r30, r24
    2d60:	10 82       	st	Z, r1
    2d62:	8d e6       	ldi	r24, 0x6D	; 109
    2d64:	90 e0       	ldi	r25, 0x00	; 0
    2d66:	fc 01       	movw	r30, r24
    2d68:	10 82       	st	Z, r1
		flagShutdown=fTrue;
    2d6a:	81 e0       	ldi	r24, 0x01	; 1
    2d6c:	80 93 1a 02 	sts	0x021A, r24
		flagFreshStart=fFalse;
    2d70:	10 92 1e 02 	sts	0x021E, r1
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
    2d74:	88 e2       	ldi	r24, 0x28	; 40
    2d76:	90 e0       	ldi	r25, 0x00	; 0
    2d78:	28 e2       	ldi	r18, 0x28	; 40
    2d7a:	30 e0       	ldi	r19, 0x00	; 0
    2d7c:	f9 01       	movw	r30, r18
    2d7e:	20 81       	ld	r18, Z
    2d80:	24 60       	ori	r18, 0x04	; 4
    2d82:	fc 01       	movw	r30, r24
    2d84:	20 83       	st	Z, r18
    2d86:	01 c0       	rjmp	.+2      	; 0x2d8a <main+0xaa>
	//main programming loop
	while(fTrue)
    2d88:	00 00       	nop
	{		
		//If receiving UART string, go get rest of it.
		if (flagReceivingBone && !flagReceivingGAVR){
    2d8a:	80 91 0d 02 	lds	r24, 0x020D
    2d8e:	88 23       	and	r24, r24
    2d90:	11 f1       	breq	.+68     	; 0x2dd6 <main+0xf6>
    2d92:	80 91 0f 02 	lds	r24, 0x020F
    2d96:	88 23       	and	r24, r24
    2d98:	f1 f4       	brne	.+60     	; 0x2dd6 <main+0xf6>
			ReceiveBone();
    2d9a:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <_Z11ReceiveBonev>
			Wait_sec(4);
    2d9e:	84 e0       	ldi	r24, 0x04	; 4
    2da0:	90 e0       	ldi	r25, 0x00	; 0
    2da2:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			if (!flagReceivingGAVR){
    2da6:	80 91 0f 02 	lds	r24, 0x020F
    2daa:	88 23       	and	r24, r24
    2dac:	a1 f4       	brne	.+40     	; 0x2dd6 <main+0xf6>
				__enableCommINT();
    2dae:	8d e3       	ldi	r24, 0x3D	; 61
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	2d e3       	ldi	r18, 0x3D	; 61
    2db4:	30 e0       	ldi	r19, 0x00	; 0
    2db6:	f9 01       	movw	r30, r18
    2db8:	20 81       	ld	r18, Z
    2dba:	24 60       	ori	r18, 0x04	; 4
    2dbc:	fc 01       	movw	r30, r24
    2dbe:	20 83       	st	Z, r18
    2dc0:	8d e6       	ldi	r24, 0x6D	; 109
    2dc2:	90 e0       	ldi	r25, 0x00	; 0
    2dc4:	22 e0       	ldi	r18, 0x02	; 2
    2dc6:	fc 01       	movw	r30, r24
    2dc8:	20 83       	st	Z, r18
				flagGoToSleep=fTrue;
    2dca:	81 e0       	ldi	r24, 0x01	; 1
    2dcc:	80 93 0c 02 	sts	0x020C, r24
				flagNormalMode=fTrue;
    2dd0:	81 e0       	ldi	r24, 0x01	; 1
    2dd2:	80 93 0e 02 	sts	0x020E, r24
			} //Otherwise, keep the CommInts down...			
		}//end flag Receiving from Bone 
		
		//Receiving Data/Signals from GAVR. GAVR has the priority
		if (flagReceivingGAVR){
    2dd6:	80 91 0f 02 	lds	r24, 0x020F
    2dda:	88 23       	and	r24, r24
    2ddc:	11 f1       	breq	.+68     	; 0x2e22 <main+0x142>
			PrintBone("Receiving from WAVR.");
    2dde:	81 ec       	ldi	r24, 0xC1	; 193
    2de0:	91 e0       	ldi	r25, 0x01	; 1
    2de2:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
			ReceiveGAVR();
    2de6:	0e 94 0a 0c 	call	0x1814	; 0x1814 <_Z11ReceiveGAVRv>
			Wait_sec(4);	
    2dea:	84 e0       	ldi	r24, 0x04	; 4
    2dec:	90 e0       	ldi	r25, 0x00	; 0
    2dee:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			if (!flagReceivingBone){		
    2df2:	80 91 0d 02 	lds	r24, 0x020D
    2df6:	88 23       	and	r24, r24
    2df8:	a1 f4       	brne	.+40     	; 0x2e22 <main+0x142>
				__enableCommINT();	
    2dfa:	8d e3       	ldi	r24, 0x3D	; 61
    2dfc:	90 e0       	ldi	r25, 0x00	; 0
    2dfe:	2d e3       	ldi	r18, 0x3D	; 61
    2e00:	30 e0       	ldi	r19, 0x00	; 0
    2e02:	f9 01       	movw	r30, r18
    2e04:	20 81       	ld	r18, Z
    2e06:	24 60       	ori	r18, 0x04	; 4
    2e08:	fc 01       	movw	r30, r24
    2e0a:	20 83       	st	Z, r18
    2e0c:	8d e6       	ldi	r24, 0x6D	; 109
    2e0e:	90 e0       	ldi	r25, 0x00	; 0
    2e10:	22 e0       	ldi	r18, 0x02	; 2
    2e12:	fc 01       	movw	r30, r24
    2e14:	20 83       	st	Z, r18
				flagGoToSleep=fTrue;
    2e16:	81 e0       	ldi	r24, 0x01	; 1
    2e18:	80 93 0c 02 	sts	0x020C, r24
				flagNormalMode=fTrue;
    2e1c:	81 e0       	ldi	r24, 0x01	; 1
    2e1e:	80 93 0e 02 	sts	0x020E, r24
			}
		}//end flag Receiving from GAVR case
		
		//Communication with GAVR. Either updating the date/time on it or asking for date and time. The internal send machine deals with the flags.
		if ((flagUpdateGAVRClock  || flagUserClock) && !flagWaitingForReceiveGAVR && !flagReceivingBone && !flagReceivingGAVR && !flagWaitingForSYNGAVR && !flagWaitingForSYNBone){
    2e22:	80 91 13 02 	lds	r24, 0x0213
    2e26:	88 23       	and	r24, r24
    2e28:	21 f4       	brne	.+8      	; 0x2e32 <main+0x152>
    2e2a:	80 91 15 02 	lds	r24, 0x0215
    2e2e:	88 23       	and	r24, r24
    2e30:	d1 f1       	breq	.+116    	; 0x2ea6 <main+0x1c6>
    2e32:	80 91 10 02 	lds	r24, 0x0210
    2e36:	88 23       	and	r24, r24
    2e38:	b1 f5       	brne	.+108    	; 0x2ea6 <main+0x1c6>
    2e3a:	80 91 0d 02 	lds	r24, 0x020D
    2e3e:	88 23       	and	r24, r24
    2e40:	91 f5       	brne	.+100    	; 0x2ea6 <main+0x1c6>
    2e42:	80 91 0f 02 	lds	r24, 0x020F
    2e46:	88 23       	and	r24, r24
    2e48:	71 f5       	brne	.+92     	; 0x2ea6 <main+0x1c6>
    2e4a:	80 91 11 02 	lds	r24, 0x0211
    2e4e:	88 23       	and	r24, r24
    2e50:	51 f5       	brne	.+84     	; 0x2ea6 <main+0x1c6>
    2e52:	80 91 12 02 	lds	r24, 0x0212
    2e56:	88 23       	and	r24, r24
    2e58:	31 f5       	brne	.+76     	; 0x2ea6 <main+0x1c6>
			PrintBone("SendingG.");
    2e5a:	86 ed       	ldi	r24, 0xD6	; 214
    2e5c:	91 e0       	ldi	r25, 0x01	; 1
    2e5e:	0e 94 4c 09 	call	0x1298	; 0x1298 <_Z9PrintBonePc>
			sendGAVR();
    2e62:	0e 94 c8 09 	call	0x1390	; 0x1390 <_Z8sendGAVRv>
			Wait_sec(4);
    2e66:	84 e0       	ldi	r24, 0x04	; 4
    2e68:	90 e0       	ldi	r25, 0x00	; 0
    2e6a:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
			if (!flagReceivingGAVR && !flagReceivingBone){
    2e6e:	80 91 0f 02 	lds	r24, 0x020F
    2e72:	88 23       	and	r24, r24
    2e74:	c1 f4       	brne	.+48     	; 0x2ea6 <main+0x1c6>
    2e76:	80 91 0d 02 	lds	r24, 0x020D
    2e7a:	88 23       	and	r24, r24
    2e7c:	a1 f4       	brne	.+40     	; 0x2ea6 <main+0x1c6>
				__enableCommINT();
    2e7e:	8d e3       	ldi	r24, 0x3D	; 61
    2e80:	90 e0       	ldi	r25, 0x00	; 0
    2e82:	2d e3       	ldi	r18, 0x3D	; 61
    2e84:	30 e0       	ldi	r19, 0x00	; 0
    2e86:	f9 01       	movw	r30, r18
    2e88:	20 81       	ld	r18, Z
    2e8a:	24 60       	ori	r18, 0x04	; 4
    2e8c:	fc 01       	movw	r30, r24
    2e8e:	20 83       	st	Z, r18
    2e90:	8d e6       	ldi	r24, 0x6D	; 109
    2e92:	90 e0       	ldi	r25, 0x00	; 0
    2e94:	22 e0       	ldi	r18, 0x02	; 2
    2e96:	fc 01       	movw	r30, r24
    2e98:	20 83       	st	Z, r18
				flagGoToSleep=fTrue;
    2e9a:	81 e0       	ldi	r24, 0x01	; 1
    2e9c:	80 93 0c 02 	sts	0x020C, r24
				flagNormalMode=fTrue;
    2ea0:	81 e0       	ldi	r24, 0x01	; 1
    2ea2:	80 93 0e 02 	sts	0x020E, r24
			}			
		}//end send to GAVR case

		//When to save to EEPROM. Saves time on lower half of the hour, saves data and time on lower half-hour of midday.
		if (flagNormalMode){
    2ea6:	80 91 0e 02 	lds	r24, 0x020E
    2eaa:	88 23       	and	r24, r24
    2eac:	49 f1       	breq	.+82     	; 0x2f00 <main+0x220>
			if (currentTime.getMinutes()%30 == 0){
    2eae:	84 ee       	ldi	r24, 0xE4	; 228
    2eb0:	91 e0       	ldi	r25, 0x01	; 1
    2eb2:	0e 94 a5 04 	call	0x94a	; 0x94a <_ZN6myTime10getMinutesEv>
    2eb6:	9e e1       	ldi	r25, 0x1E	; 30
    2eb8:	69 2f       	mov	r22, r25
    2eba:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <__udivmodqi4>
    2ebe:	89 2f       	mov	r24, r25
    2ec0:	98 2f       	mov	r25, r24
    2ec2:	81 e0       	ldi	r24, 0x01	; 1
    2ec4:	99 23       	and	r25, r25
    2ec6:	09 f0       	breq	.+2      	; 0x2eca <main+0x1ea>
    2ec8:	80 e0       	ldi	r24, 0x00	; 0
    2eca:	88 23       	and	r24, r24
    2ecc:	c9 f0       	breq	.+50     	; 0x2f00 <main+0x220>
				if (currentTime.getHours()%12 == 0){
    2ece:	84 ee       	ldi	r24, 0xE4	; 228
    2ed0:	91 e0       	ldi	r25, 0x01	; 1
    2ed2:	0e 94 b6 04 	call	0x96c	; 0x96c <_ZN6myTime8getHoursEv>
    2ed6:	9c e0       	ldi	r25, 0x0C	; 12
    2ed8:	69 2f       	mov	r22, r25
    2eda:	0e 94 d9 1c 	call	0x39b2	; 0x39b2 <__udivmodqi4>
    2ede:	89 2f       	mov	r24, r25
    2ee0:	98 2f       	mov	r25, r24
    2ee2:	81 e0       	ldi	r24, 0x01	; 1
    2ee4:	99 23       	and	r25, r25
    2ee6:	09 f0       	breq	.+2      	; 0x2eea <main+0x20a>
    2ee8:	80 e0       	ldi	r24, 0x00	; 0
    2eea:	88 23       	and	r24, r24
    2eec:	29 f0       	breq	.+10     	; 0x2ef8 <main+0x218>
					saveDateTime_eeprom(fTrue,fTrue);
    2eee:	81 e0       	ldi	r24, 0x01	; 1
    2ef0:	61 e0       	ldi	r22, 0x01	; 1
    2ef2:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
    2ef6:	04 c0       	rjmp	.+8      	; 0x2f00 <main+0x220>
				} else {
					saveDateTime_eeprom(fTrue,fFalse);
    2ef8:	81 e0       	ldi	r24, 0x01	; 1
    2efa:	60 e0       	ldi	r22, 0x00	; 0
    2efc:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
				}	
			}						
		}//end time capture/save

		//Take ADC reading to check battery level, temp to check board temperature.
		if (flagNormalMode){
    2f00:	80 91 0e 02 	lds	r24, 0x020E
    2f04:	88 23       	and	r24, r24
    2f06:	19 f1       	breq	.+70     	; 0x2f4e <main+0x26e>
			TakeADC();
    2f08:	0e 94 68 1a 	call	0x34d0	; 0x34d0 <_Z7TakeADCv>
			GetTemp();
    2f0c:	0e 94 3e 1b 	call	0x367c	; 0x367c <_Z7GetTempv>
			flagGoodTemp=fTrue;
    2f10:	81 e0       	ldi	r24, 0x01	; 1
    2f12:	80 93 1b 02 	sts	0x021B, r24
			//If both are good & shutdown is low, keep it low. If shutdown is high, pull low and enable restart
			if (flagGoodVolts && flagGoodTemp){
    2f16:	80 91 1c 02 	lds	r24, 0x021C
    2f1a:	88 23       	and	r24, r24
    2f1c:	71 f0       	breq	.+28     	; 0x2f3a <main+0x25a>
    2f1e:	80 91 1b 02 	lds	r24, 0x021B
    2f22:	88 23       	and	r24, r24
    2f24:	51 f0       	breq	.+20     	; 0x2f3a <main+0x25a>
				if(flagShutdown){restart = fTrue; flagShutdown=fFalse;}
    2f26:	80 91 1a 02 	lds	r24, 0x021A
    2f2a:	88 23       	and	r24, r24
    2f2c:	81 f0       	breq	.+32     	; 0x2f4e <main+0x26e>
    2f2e:	81 e0       	ldi	r24, 0x01	; 1
    2f30:	80 93 1d 02 	sts	0x021D, r24
    2f34:	10 92 1a 02 	sts	0x021A, r1
    2f38:	0a c0       	rjmp	.+20     	; 0x2f4e <main+0x26e>
			//If one is bad and shutdown is low, pull high as well as pull new shutdown high to indicate imminent power kill
			} else {
				if (!flagShutdown){
    2f3a:	80 91 1a 02 	lds	r24, 0x021A
    2f3e:	88 23       	and	r24, r24
    2f40:	31 f4       	brne	.+12     	; 0x2f4e <main+0x26e>
					flagNewShutdown = fTrue;
    2f42:	81 e0       	ldi	r24, 0x01	; 1
    2f44:	80 93 19 02 	sts	0x0219, r24
					flagShutdown=fTrue;
    2f48:	81 e0       	ldi	r24, 0x01	; 1
    2f4a:	80 93 1a 02 	sts	0x021A, r24
				}
			}
		}//end normal mode Check Analog Signals		
		
		//About to shutdown, save EEPROM
		if (flagNewShutdown){
    2f4e:	80 91 19 02 	lds	r24, 0x0219
    2f52:	88 23       	and	r24, r24
    2f54:	b9 f0       	breq	.+46     	; 0x2f84 <main+0x2a4>
			//Make sure nothing messes with the routine that we care about
			__killCommINT();
    2f56:	8d e3       	ldi	r24, 0x3D	; 61
    2f58:	90 e0       	ldi	r25, 0x00	; 0
    2f5a:	fc 01       	movw	r30, r24
    2f5c:	10 82       	st	Z, r1
    2f5e:	8d e6       	ldi	r24, 0x6D	; 109
    2f60:	90 e0       	ldi	r25, 0x00	; 0
    2f62:	fc 01       	movw	r30, r24
    2f64:	10 82       	st	Z, r1
			flagGoToSleep = fTrue;
    2f66:	81 e0       	ldi	r24, 0x01	; 1
    2f68:	80 93 0c 02 	sts	0x020C, r24
			flagReceivingBone = fFalse;
    2f6c:	10 92 0d 02 	sts	0x020D, r1
			flagUserClock=fFalse;						//reset this so next boot is correct. Done in restart case as well for redundancy
    2f70:	10 92 15 02 	sts	0x0215, r1
			saveDateTime_eeprom(fTrue,fTrue);
    2f74:	81 e0       	ldi	r24, 0x01	; 1
    2f76:	61 e0       	ldi	r22, 0x01	; 1
    2f78:	0e 94 3c 08 	call	0x1078	; 0x1078 <_Z19saveDateTime_eepromhh>
			
			//Kill power--Alert comes in that function
			PowerDown();
    2f7c:	0e 94 44 1c 	call	0x3888	; 0x3888 <_Z9PowerDownv>
			flagNewShutdown = fFalse;
    2f80:	10 92 19 02 	sts	0x0219, r1
		}//end new shutdown
		
		//If Restart, broadcast date and time to BeagleBone and other AVR
		if (restart){
    2f84:	80 91 1d 02 	lds	r24, 0x021D
    2f88:	88 23       	and	r24, r24
    2f8a:	c9 f0       	breq	.+50     	; 0x2fbe <main+0x2de>
			//Enable COmmunication protocols and then power up. Power up specifies the timing for it to happen	
			PowerUp(POWER_UP_INTERVAL);
    2f8c:	83 e0       	ldi	r24, 0x03	; 3
    2f8e:	90 e0       	ldi	r25, 0x00	; 0
    2f90:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <_Z7PowerUpj>
			__enableCommINT();
    2f94:	8d e3       	ldi	r24, 0x3D	; 61
    2f96:	90 e0       	ldi	r25, 0x00	; 0
    2f98:	2d e3       	ldi	r18, 0x3D	; 61
    2f9a:	30 e0       	ldi	r19, 0x00	; 0
    2f9c:	f9 01       	movw	r30, r18
    2f9e:	20 81       	ld	r18, Z
    2fa0:	24 60       	ori	r18, 0x04	; 4
    2fa2:	fc 01       	movw	r30, r24
    2fa4:	20 83       	st	Z, r18
    2fa6:	8d e6       	ldi	r24, 0x6D	; 109
    2fa8:	90 e0       	ldi	r25, 0x00	; 0
    2faa:	22 e0       	ldi	r18, 0x02	; 2
    2fac:	fc 01       	movw	r30, r24
    2fae:	20 83       	st	Z, r18
			//Update the GAVRClock since it's a restart, we have the correct date and time. If BeagleBone sends GPS data, use that to back it up.
			flagUpdateGAVRClock=fTrue;
    2fb0:	81 e0       	ldi	r24, 0x01	; 1
    2fb2:	80 93 13 02 	sts	0x0213, r24
			flagUserClock=fFalse;	
    2fb6:	10 92 15 02 	sts	0x0215, r1
			restart=fFalse;	
    2fba:	10 92 1d 02 	sts	0x021D, r1
		}//end restart		
		
		//If it's time to go to sleep, go to sleep. INT0 or TIM2_overflow will wake it up.
		if (flagGoToSleep && (!flagUserClock || !flagUpdateGAVRClock)){GoToSleep(flagShutdown);}
    2fbe:	80 91 0c 02 	lds	r24, 0x020C
    2fc2:	88 23       	and	r24, r24
    2fc4:	61 f0       	breq	.+24     	; 0x2fde <main+0x2fe>
    2fc6:	80 91 15 02 	lds	r24, 0x0215
    2fca:	88 23       	and	r24, r24
    2fcc:	21 f0       	breq	.+8      	; 0x2fd6 <main+0x2f6>
    2fce:	80 91 13 02 	lds	r24, 0x0213
    2fd2:	88 23       	and	r24, r24
    2fd4:	21 f4       	brne	.+8      	; 0x2fde <main+0x2fe>
    2fd6:	80 91 1a 02 	lds	r24, 0x021A
    2fda:	0e 94 0a 1a 	call	0x3414	; 0x3414 <_Z9GoToSleeph>
		
		//Add logic for an invalid date and time somehow getting in here
		if (flagInvalidDateTime && !flagShutdown){
    2fde:	80 91 16 02 	lds	r24, 0x0216
    2fe2:	88 23       	and	r24, r24
    2fe4:	09 f4       	brne	.+2      	; 0x2fe8 <main+0x308>
    2fe6:	d0 ce       	rjmp	.-608    	; 0x2d88 <main+0xa8>
    2fe8:	80 91 1a 02 	lds	r24, 0x021A
    2fec:	88 23       	and	r24, r24
    2fee:	09 f0       	breq	.+2      	; 0x2ff2 <main+0x312>
    2ff0:	cb ce       	rjmp	.-618    	; 0x2d88 <main+0xa8>
			flagInvalidDateTime=fFalse;
    2ff2:	10 92 16 02 	sts	0x0216, r1
			flagUserClock=fTrue;
    2ff6:	81 e0       	ldi	r24, 0x01	; 1
    2ff8:	80 93 15 02 	sts	0x0215, r24
			flagUpdateGAVRClock=fFalse;
    2ffc:	10 92 13 02 	sts	0x0213, r1
		flagFreshStart=fFalse;
	}
	
	prtSTATUSled |= (1 << bnSTATUSled);
	//main programming loop
	while(fTrue)
    3000:	c3 ce       	rjmp	.-634    	; 0x2d88 <main+0xa8>

00003002 <_Z10DeviceInitv>:

/*--------------------------END-Main Program-------------------------------------------------------------------------------------*/
/*--------------------------START-Public Funtions--------------------------------------------------------------------------------*/

/*************************************************************************************************************/
void DeviceInit(){
    3002:	cf 93       	push	r28
    3004:	df 93       	push	r29
    3006:	cd b7       	in	r28, 0x3d	; 61
    3008:	de b7       	in	r29, 0x3e	; 62
	//Set all ports to input with no pull
	DDRA = 0;
    300a:	81 e2       	ldi	r24, 0x21	; 33
    300c:	90 e0       	ldi	r25, 0x00	; 0
    300e:	fc 01       	movw	r30, r24
    3010:	10 82       	st	Z, r1
	DDRB = 0;
    3012:	84 e2       	ldi	r24, 0x24	; 36
    3014:	90 e0       	ldi	r25, 0x00	; 0
    3016:	fc 01       	movw	r30, r24
    3018:	10 82       	st	Z, r1
	DDRC = 0;
    301a:	87 e2       	ldi	r24, 0x27	; 39
    301c:	90 e0       	ldi	r25, 0x00	; 0
    301e:	fc 01       	movw	r30, r24
    3020:	10 82       	st	Z, r1
	DDRD = 0;
    3022:	8a e2       	ldi	r24, 0x2A	; 42
    3024:	90 e0       	ldi	r25, 0x00	; 0
    3026:	fc 01       	movw	r30, r24
    3028:	10 82       	st	Z, r1
	
	PORTA = 0;
    302a:	82 e2       	ldi	r24, 0x22	; 34
    302c:	90 e0       	ldi	r25, 0x00	; 0
    302e:	fc 01       	movw	r30, r24
    3030:	10 82       	st	Z, r1
	PORTB = 0;
    3032:	85 e2       	ldi	r24, 0x25	; 37
    3034:	90 e0       	ldi	r25, 0x00	; 0
    3036:	fc 01       	movw	r30, r24
    3038:	10 82       	st	Z, r1
	PORTC = 0;
    303a:	88 e2       	ldi	r24, 0x28	; 40
    303c:	90 e0       	ldi	r25, 0x00	; 0
    303e:	fc 01       	movw	r30, r24
    3040:	10 82       	st	Z, r1
	PORTD = 0;
    3042:	8b e2       	ldi	r24, 0x2B	; 43
    3044:	90 e0       	ldi	r25, 0x00	; 0
    3046:	fc 01       	movw	r30, r24
    3048:	10 82       	st	Z, r1
}
    304a:	df 91       	pop	r29
    304c:	cf 91       	pop	r28
    304e:	08 95       	ret

00003050 <_Z7AppInitj>:
/*************************************************************************************************************/
void AppInit(unsigned int ubrr){
    3050:	cf 93       	push	r28
    3052:	df 93       	push	r29
    3054:	00 d0       	rcall	.+0      	; 0x3056 <_Z7AppInitj+0x6>
    3056:	cd b7       	in	r28, 0x3d	; 61
    3058:	de b7       	in	r29, 0x3e	; 62
    305a:	9a 83       	std	Y+2, r25	; 0x02
    305c:	89 83       	std	Y+1, r24	; 0x01
	
	//Set BAUD rate of UART
	UBRR0L = ubrr;   												//set low byte of baud rate
    305e:	84 ec       	ldi	r24, 0xC4	; 196
    3060:	90 e0       	ldi	r25, 0x00	; 0
    3062:	29 81       	ldd	r18, Y+1	; 0x01
    3064:	fc 01       	movw	r30, r24
    3066:	20 83       	st	Z, r18
	UBRR0H = (ubrr >> 8);											//set high byte of baud rate
    3068:	85 ec       	ldi	r24, 0xC5	; 197
    306a:	90 e0       	ldi	r25, 0x00	; 0
    306c:	29 81       	ldd	r18, Y+1	; 0x01
    306e:	3a 81       	ldd	r19, Y+2	; 0x02
    3070:	23 2f       	mov	r18, r19
    3072:	33 27       	eor	r19, r19
    3074:	fc 01       	movw	r30, r24
    3076:	20 83       	st	Z, r18
	//UCSR0A |= (1 << U2X0);										//set high speed baud clock, in ASYNC mode
	
	//Enable UART_TX0 and UART_RX0
	UCSR0B = (1 << TXEN0)|(1 << RXEN0);
    3078:	81 ec       	ldi	r24, 0xC1	; 193
    307a:	90 e0       	ldi	r25, 0x00	; 0
    307c:	28 e1       	ldi	r18, 0x18	; 24
    307e:	fc 01       	movw	r30, r24
    3080:	20 83       	st	Z, r18
	UCSR0C = (1 << UCSZ01)|(1 << UCSZ00);							//Asynchronous; 8 data bits, no parity
    3082:	82 ec       	ldi	r24, 0xC2	; 194
    3084:	90 e0       	ldi	r25, 0x00	; 0
    3086:	26 e0       	ldi	r18, 0x06	; 6
    3088:	fc 01       	movw	r30, r24
    308a:	20 83       	st	Z, r18
	//UCSR0B |= (1 << RXCIE0);
	
	//Set BAUD for UART1
	UBRR1L = ubrr;
    308c:	8c ec       	ldi	r24, 0xCC	; 204
    308e:	90 e0       	ldi	r25, 0x00	; 0
    3090:	29 81       	ldd	r18, Y+1	; 0x01
    3092:	fc 01       	movw	r30, r24
    3094:	20 83       	st	Z, r18
	UBRR1H = (ubrr >> 8);
    3096:	8d ec       	ldi	r24, 0xCD	; 205
    3098:	90 e0       	ldi	r25, 0x00	; 0
    309a:	29 81       	ldd	r18, Y+1	; 0x01
    309c:	3a 81       	ldd	r19, Y+2	; 0x02
    309e:	23 2f       	mov	r18, r19
    30a0:	33 27       	eor	r19, r19
    30a2:	fc 01       	movw	r30, r24
    30a4:	20 83       	st	Z, r18
	//UCSR1A |= (1 << U2X1);
	
	//Enable UART_TX1 and UART_RX1
	UCSR1B = (1 << TXEN1)|(1 << RXEN1);
    30a6:	89 ec       	ldi	r24, 0xC9	; 201
    30a8:	90 e0       	ldi	r25, 0x00	; 0
    30aa:	28 e1       	ldi	r18, 0x18	; 24
    30ac:	fc 01       	movw	r30, r24
    30ae:	20 83       	st	Z, r18
	UCSR1C = (1 << UCSZ11)|(1 << UCSZ10);
    30b0:	8a ec       	ldi	r24, 0xCA	; 202
    30b2:	90 e0       	ldi	r25, 0x00	; 0
    30b4:	26 e0       	ldi	r18, 0x06	; 6
    30b6:	fc 01       	movw	r30, r24
    30b8:	20 83       	st	Z, r18
	//UCSR1B |= (1 << RXCIE1);
	__killUARTrec();
    30ba:	81 ec       	ldi	r24, 0xC1	; 193
    30bc:	90 e0       	ldi	r25, 0x00	; 0
    30be:	21 ec       	ldi	r18, 0xC1	; 193
    30c0:	30 e0       	ldi	r19, 0x00	; 0
    30c2:	f9 01       	movw	r30, r18
    30c4:	20 81       	ld	r18, Z
    30c6:	20 68       	ori	r18, 0x80	; 128
    30c8:	fc 01       	movw	r30, r24
    30ca:	20 83       	st	Z, r18
    30cc:	89 ec       	ldi	r24, 0xC9	; 201
    30ce:	90 e0       	ldi	r25, 0x00	; 0
    30d0:	29 ec       	ldi	r18, 0xC9	; 201
    30d2:	30 e0       	ldi	r19, 0x00	; 0
    30d4:	f9 01       	movw	r30, r18
    30d6:	20 81       	ld	r18, Z
    30d8:	20 68       	ori	r18, 0x80	; 128
    30da:	fc 01       	movw	r30, r24
    30dc:	20 83       	st	Z, r18
	
	//Disable power to all peripherals
	PRR0 |= (1 << PRTWI)|(1 << PRTIM0)|(1 << PRUSART1)|(1 << PRTIM1)|(1 << PRADC)|(1 << PRSPI);  //Turn EVERYTHING off initially except USART0(UART0)
    30de:	84 e6       	ldi	r24, 0x64	; 100
    30e0:	90 e0       	ldi	r25, 0x00	; 0
    30e2:	24 e6       	ldi	r18, 0x64	; 100
    30e4:	30 e0       	ldi	r19, 0x00	; 0
    30e6:	f9 01       	movw	r30, r18
    30e8:	20 81       	ld	r18, Z
    30ea:	2d 6b       	ori	r18, 0xBD	; 189
    30ec:	fc 01       	movw	r30, r24
    30ee:	20 83       	st	Z, r18

	//Enable status LEDs
	ddrSLEEPled |= (1 << bnSLEEPled);
    30f0:	8a e2       	ldi	r24, 0x2A	; 42
    30f2:	90 e0       	ldi	r25, 0x00	; 0
    30f4:	2a e2       	ldi	r18, 0x2A	; 42
    30f6:	30 e0       	ldi	r19, 0x00	; 0
    30f8:	f9 01       	movw	r30, r18
    30fa:	20 81       	ld	r18, Z
    30fc:	20 68       	ori	r18, 0x80	; 128
    30fe:	fc 01       	movw	r30, r24
    3100:	20 83       	st	Z, r18
	ddrSTATUSled |= (1 << bnSTATUSled);
    3102:	87 e2       	ldi	r24, 0x27	; 39
    3104:	90 e0       	ldi	r25, 0x00	; 0
    3106:	27 e2       	ldi	r18, 0x27	; 39
    3108:	30 e0       	ldi	r19, 0x00	; 0
    310a:	f9 01       	movw	r30, r18
    310c:	20 81       	ld	r18, Z
    310e:	24 60       	ori	r18, 0x04	; 4
    3110:	fc 01       	movw	r30, r24
    3112:	20 83       	st	Z, r18
	prtSLEEPled |= (1 << bnSLEEPled);	//turn off initially
    3114:	8b e2       	ldi	r24, 0x2B	; 43
    3116:	90 e0       	ldi	r25, 0x00	; 0
    3118:	2b e2       	ldi	r18, 0x2B	; 43
    311a:	30 e0       	ldi	r19, 0x00	; 0
    311c:	f9 01       	movw	r30, r18
    311e:	20 81       	ld	r18, Z
    3120:	20 68       	ori	r18, 0x80	; 128
    3122:	fc 01       	movw	r30, r24
    3124:	20 83       	st	Z, r18
	prtSTATUSled &= ~(1 << bnSTATUSled);	//turn on initially
    3126:	88 e2       	ldi	r24, 0x28	; 40
    3128:	90 e0       	ldi	r25, 0x00	; 0
    312a:	28 e2       	ldi	r18, 0x28	; 40
    312c:	30 e0       	ldi	r19, 0x00	; 0
    312e:	f9 01       	movw	r30, r18
    3130:	20 81       	ld	r18, Z
    3132:	2b 7f       	andi	r18, 0xFB	; 251
    3134:	fc 01       	movw	r30, r24
    3136:	20 83       	st	Z, r18
	
	//Enable BB and GAVR interrupts for COMMUNICATION
	ddrBONEINT |= (1 << bnBONEINT);
    3138:	81 e2       	ldi	r24, 0x21	; 33
    313a:	90 e0       	ldi	r25, 0x00	; 0
    313c:	21 e2       	ldi	r18, 0x21	; 33
    313e:	30 e0       	ldi	r19, 0x00	; 0
    3140:	f9 01       	movw	r30, r18
    3142:	20 81       	ld	r18, Z
    3144:	22 60       	ori	r18, 0x02	; 2
    3146:	fc 01       	movw	r30, r24
    3148:	20 83       	st	Z, r18
	ddrGAVRINT |= (1 << bnGAVRINT);
    314a:	84 e2       	ldi	r24, 0x24	; 36
    314c:	90 e0       	ldi	r25, 0x00	; 0
    314e:	24 e2       	ldi	r18, 0x24	; 36
    3150:	30 e0       	ldi	r19, 0x00	; 0
    3152:	f9 01       	movw	r30, r18
    3154:	20 81       	ld	r18, Z
    3156:	28 60       	ori	r18, 0x08	; 8
    3158:	fc 01       	movw	r30, r24
    315a:	20 83       	st	Z, r18
	prtBONEINT &= ~(1 << bnBONEINT);
    315c:	82 e2       	ldi	r24, 0x22	; 34
    315e:	90 e0       	ldi	r25, 0x00	; 0
    3160:	22 e2       	ldi	r18, 0x22	; 34
    3162:	30 e0       	ldi	r19, 0x00	; 0
    3164:	f9 01       	movw	r30, r18
    3166:	20 81       	ld	r18, Z
    3168:	2d 7f       	andi	r18, 0xFD	; 253
    316a:	fc 01       	movw	r30, r24
    316c:	20 83       	st	Z, r18
	prtGAVRINT &= ~(1 << bnGAVRINT);
    316e:	85 e2       	ldi	r24, 0x25	; 37
    3170:	90 e0       	ldi	r25, 0x00	; 0
    3172:	25 e2       	ldi	r18, 0x25	; 37
    3174:	30 e0       	ldi	r19, 0x00	; 0
    3176:	f9 01       	movw	r30, r18
    3178:	20 81       	ld	r18, Z
    317a:	27 7f       	andi	r18, 0xF7	; 247
    317c:	fc 01       	movw	r30, r24
    317e:	20 83       	st	Z, r18
	
	//Enable GAVR interrupt pin, our PB3, it's INT2
	ddrInterrupts |= (1 << bnGAVRint)|(1 << bnBBint);
    3180:	81 e2       	ldi	r24, 0x21	; 33
    3182:	90 e0       	ldi	r25, 0x00	; 0
    3184:	21 e2       	ldi	r18, 0x21	; 33
    3186:	30 e0       	ldi	r19, 0x00	; 0
    3188:	f9 01       	movw	r30, r18
    318a:	20 81       	ld	r18, Z
    318c:	2c 60       	ori	r18, 0x0C	; 12
    318e:	fc 01       	movw	r30, r24
    3190:	20 83       	st	Z, r18
	prtInterrupts &= ~((1 << bnGAVRint)|(1 << bnBBint));
    3192:	82 e2       	ldi	r24, 0x22	; 34
    3194:	90 e0       	ldi	r25, 0x00	; 0
    3196:	22 e2       	ldi	r18, 0x22	; 34
    3198:	30 e0       	ldi	r19, 0x00	; 0
    319a:	f9 01       	movw	r30, r18
    319c:	20 81       	ld	r18, Z
    319e:	23 7f       	andi	r18, 0xF3	; 243
    31a0:	fc 01       	movw	r30, r24
    31a2:	20 83       	st	Z, r18
	
	//Enable enable signals
	ddrENABLE |= (1 << bnGPSen)|(1 << bnGAVRen)|(1 << bnLCDen)|(1 << bnBBen);
    31a4:	81 e2       	ldi	r24, 0x21	; 33
    31a6:	90 e0       	ldi	r25, 0x00	; 0
    31a8:	21 e2       	ldi	r18, 0x21	; 33
    31aa:	30 e0       	ldi	r19, 0x00	; 0
    31ac:	f9 01       	movw	r30, r18
    31ae:	20 81       	ld	r18, Z
    31b0:	20 6f       	ori	r18, 0xF0	; 240
    31b2:	fc 01       	movw	r30, r24
    31b4:	20 83       	st	Z, r18
	ddrTEMPen |= (1 << bnTEMPen);
    31b6:	84 e2       	ldi	r24, 0x24	; 36
    31b8:	90 e0       	ldi	r25, 0x00	; 0
    31ba:	24 e2       	ldi	r18, 0x24	; 36
    31bc:	30 e0       	ldi	r19, 0x00	; 0
    31be:	f9 01       	movw	r30, r18
    31c0:	20 81       	ld	r18, Z
    31c2:	21 60       	ori	r18, 0x01	; 1
    31c4:	fc 01       	movw	r30, r24
    31c6:	20 83       	st	Z, r18
	ddrMAINen |= (1 << bnMAINen);
    31c8:	87 e2       	ldi	r24, 0x27	; 39
    31ca:	90 e0       	ldi	r25, 0x00	; 0
    31cc:	27 e2       	ldi	r18, 0x27	; 39
    31ce:	30 e0       	ldi	r19, 0x00	; 0
    31d0:	f9 01       	movw	r30, r18
    31d2:	20 81       	ld	r18, Z
    31d4:	21 60       	ori	r18, 0x01	; 1
    31d6:	fc 01       	movw	r30, r24
    31d8:	20 83       	st	Z, r18
	__killMain();
    31da:	88 e2       	ldi	r24, 0x28	; 40
    31dc:	90 e0       	ldi	r25, 0x00	; 0
    31de:	28 e2       	ldi	r18, 0x28	; 40
    31e0:	30 e0       	ldi	r19, 0x00	; 0
    31e2:	f9 01       	movw	r30, r18
    31e4:	20 81       	ld	r18, Z
    31e6:	2e 7f       	andi	r18, 0xFE	; 254
    31e8:	fc 01       	movw	r30, r24
    31ea:	20 83       	st	Z, r18
	__killBeagleBone();
    31ec:	82 e2       	ldi	r24, 0x22	; 34
    31ee:	90 e0       	ldi	r25, 0x00	; 0
    31f0:	22 e2       	ldi	r18, 0x22	; 34
    31f2:	30 e0       	ldi	r19, 0x00	; 0
    31f4:	f9 01       	movw	r30, r18
    31f6:	20 81       	ld	r18, Z
    31f8:	2f 7e       	andi	r18, 0xEF	; 239
    31fa:	fc 01       	movw	r30, r24
    31fc:	20 83       	st	Z, r18
	__enableTemp();
    31fe:	85 e2       	ldi	r24, 0x25	; 37
    3200:	90 e0       	ldi	r25, 0x00	; 0
    3202:	25 e2       	ldi	r18, 0x25	; 37
    3204:	30 e0       	ldi	r19, 0x00	; 0
    3206:	f9 01       	movw	r30, r18
    3208:	20 81       	ld	r18, Z
    320a:	21 60       	ori	r18, 0x01	; 1
    320c:	fc 01       	movw	r30, r24
    320e:	20 83       	st	Z, r18
	__killLCD();
    3210:	82 e2       	ldi	r24, 0x22	; 34
    3212:	90 e0       	ldi	r25, 0x00	; 0
    3214:	22 e2       	ldi	r18, 0x22	; 34
    3216:	30 e0       	ldi	r19, 0x00	; 0
    3218:	f9 01       	movw	r30, r18
    321a:	20 81       	ld	r18, Z
    321c:	2f 7d       	andi	r18, 0xDF	; 223
    321e:	fc 01       	movw	r30, r24
    3220:	20 83       	st	Z, r18
	__killGPSandGAVR();
    3222:	82 e2       	ldi	r24, 0x22	; 34
    3224:	90 e0       	ldi	r25, 0x00	; 0
    3226:	22 e2       	ldi	r18, 0x22	; 34
    3228:	30 e0       	ldi	r19, 0x00	; 0
    322a:	f9 01       	movw	r30, r18
    322c:	20 81       	ld	r18, Z
    322e:	2f 73       	andi	r18, 0x3F	; 63
    3230:	fc 01       	movw	r30, r24
    3232:	20 83       	st	Z, r18

	//Enable GPIO lines
	ddrBBio |= (1 << bnW1B10)|(1 << bnW2B11);
    3234:	87 e2       	ldi	r24, 0x27	; 39
    3236:	90 e0       	ldi	r25, 0x00	; 0
    3238:	27 e2       	ldi	r18, 0x27	; 39
    323a:	30 e0       	ldi	r19, 0x00	; 0
    323c:	f9 01       	movw	r30, r18
    323e:	20 81       	ld	r18, Z
    3240:	20 63       	ori	r18, 0x30	; 48
    3242:	fc 01       	movw	r30, r24
    3244:	20 83       	st	Z, r18
	prtBBio &= ~((1 << bnW1B10)|(1 << bnW2B11));
    3246:	88 e2       	ldi	r24, 0x28	; 40
    3248:	90 e0       	ldi	r25, 0x00	; 0
    324a:	28 e2       	ldi	r18, 0x28	; 40
    324c:	30 e0       	ldi	r19, 0x00	; 0
    324e:	f9 01       	movw	r30, r18
    3250:	20 81       	ld	r18, Z
    3252:	2f 7c       	andi	r18, 0xCF	; 207
    3254:	fc 01       	movw	r30, r24
    3256:	20 83       	st	Z, r18
	ddrW6B8 |= (1 << bnW6B8);
    3258:	84 e2       	ldi	r24, 0x24	; 36
    325a:	90 e0       	ldi	r25, 0x00	; 0
    325c:	24 e2       	ldi	r18, 0x24	; 36
    325e:	30 e0       	ldi	r19, 0x00	; 0
    3260:	f9 01       	movw	r30, r18
    3262:	20 81       	ld	r18, Z
    3264:	22 60       	ori	r18, 0x02	; 2
    3266:	fc 01       	movw	r30, r24
    3268:	20 83       	st	Z, r18
	prtW6B8 |= (1 << bnW6B8);
    326a:	85 e2       	ldi	r24, 0x25	; 37
    326c:	90 e0       	ldi	r25, 0x00	; 0
    326e:	25 e2       	ldi	r18, 0x25	; 37
    3270:	30 e0       	ldi	r19, 0x00	; 0
    3272:	f9 01       	movw	r30, r18
    3274:	20 81       	ld	r18, Z
    3276:	22 60       	ori	r18, 0x02	; 2
    3278:	fc 01       	movw	r30, r24
    327a:	20 83       	st	Z, r18
	ddrBBio &= ~(1 << bnW0B9);			//Whether BeagleBone is awake or not
    327c:	87 e2       	ldi	r24, 0x27	; 39
    327e:	90 e0       	ldi	r25, 0x00	; 0
    3280:	27 e2       	ldi	r18, 0x27	; 39
    3282:	30 e0       	ldi	r19, 0x00	; 0
    3284:	f9 01       	movw	r30, r18
    3286:	20 81       	ld	r18, Z
    3288:	27 7f       	andi	r18, 0xF7	; 247
    328a:	fc 01       	movw	r30, r24
    328c:	20 83       	st	Z, r18
	ddrGAVRio |= (1 << bnW4G1)|(1 << bnW5G2);
    328e:	8a e2       	ldi	r24, 0x2A	; 42
    3290:	90 e0       	ldi	r25, 0x00	; 0
    3292:	2a e2       	ldi	r18, 0x2A	; 42
    3294:	30 e0       	ldi	r19, 0x00	; 0
    3296:	f9 01       	movw	r30, r18
    3298:	20 81       	ld	r18, Z
    329a:	20 66       	ori	r18, 0x60	; 96
    329c:	fc 01       	movw	r30, r24
    329e:	20 83       	st	Z, r18
	prtGAVRio &= ~((1 << bnW4G1)|(1 << bnW5G2));
    32a0:	8b e2       	ldi	r24, 0x2B	; 43
    32a2:	90 e0       	ldi	r25, 0x00	; 0
    32a4:	2b e2       	ldi	r18, 0x2B	; 43
    32a6:	30 e0       	ldi	r19, 0x00	; 0
    32a8:	f9 01       	movw	r30, r18
    32aa:	20 81       	ld	r18, Z
    32ac:	2f 79       	andi	r18, 0x9F	; 159
    32ae:	fc 01       	movw	r30, r24
    32b0:	20 83       	st	Z, r18
	ddrGAVRio &= ~(1 << bnW3G0);		//Whether GAVR is running or not
    32b2:	8a e2       	ldi	r24, 0x2A	; 42
    32b4:	90 e0       	ldi	r25, 0x00	; 0
    32b6:	2a e2       	ldi	r18, 0x2A	; 42
    32b8:	30 e0       	ldi	r19, 0x00	; 0
    32ba:	f9 01       	movw	r30, r18
    32bc:	20 81       	ld	r18, Z
    32be:	2f 7e       	andi	r18, 0xEF	; 239
    32c0:	fc 01       	movw	r30, r24
    32c2:	20 83       	st	Z, r18
	
	//Enable INT2. Note* Pin change interrupts will NOT wake AVR from Power-Save mode. Only INT0-2 will.
	__killCommINT();
    32c4:	8d e3       	ldi	r24, 0x3D	; 61
    32c6:	90 e0       	ldi	r25, 0x00	; 0
    32c8:	fc 01       	movw	r30, r24
    32ca:	10 82       	st	Z, r1
    32cc:	8d e6       	ldi	r24, 0x6D	; 109
    32ce:	90 e0       	ldi	r25, 0x00	; 0
    32d0:	fc 01       	movw	r30, r24
    32d2:	10 82       	st	Z, r1
	EICRA = (1 << ISC21)|(1 << ISC20);			//falling edge of INT2 enables interrupt
    32d4:	89 e6       	ldi	r24, 0x69	; 105
    32d6:	90 e0       	ldi	r25, 0x00	; 0
    32d8:	20 e3       	ldi	r18, 0x30	; 48
    32da:	fc 01       	movw	r30, r24
    32dc:	20 83       	st	Z, r18
	//Enable PCINT17
	PCICR |= (1 << PCIE2);
    32de:	88 e6       	ldi	r24, 0x68	; 104
    32e0:	90 e0       	ldi	r25, 0x00	; 0
    32e2:	28 e6       	ldi	r18, 0x68	; 104
    32e4:	30 e0       	ldi	r19, 0x00	; 0
    32e6:	f9 01       	movw	r30, r18
    32e8:	20 81       	ld	r18, Z
    32ea:	24 60       	ori	r18, 0x04	; 4
    32ec:	fc 01       	movw	r30, r24
    32ee:	20 83       	st	Z, r18
	
	//Enable SPI for TI temperature
	ddrSpi0 |= (1 << bnMosi0)|(1 << bnSck0)|(1 << bnSS0);	//outputs
    32f0:	84 e2       	ldi	r24, 0x24	; 36
    32f2:	90 e0       	ldi	r25, 0x00	; 0
    32f4:	24 e2       	ldi	r18, 0x24	; 36
    32f6:	30 e0       	ldi	r19, 0x00	; 0
    32f8:	f9 01       	movw	r30, r18
    32fa:	20 81       	ld	r18, Z
    32fc:	20 6b       	ori	r18, 0xB0	; 176
    32fe:	fc 01       	movw	r30, r24
    3300:	20 83       	st	Z, r18
	ddrSpi0 &= ~(1 << bnMiso0);
    3302:	84 e2       	ldi	r24, 0x24	; 36
    3304:	90 e0       	ldi	r25, 0x00	; 0
    3306:	24 e2       	ldi	r18, 0x24	; 36
    3308:	30 e0       	ldi	r19, 0x00	; 0
    330a:	f9 01       	movw	r30, r18
    330c:	20 81       	ld	r18, Z
    330e:	2f 7b       	andi	r18, 0xBF	; 191
    3310:	fc 01       	movw	r30, r24
    3312:	20 83       	st	Z, r18
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);		//keep SS and SCK high
    3314:	85 e2       	ldi	r24, 0x25	; 37
    3316:	90 e0       	ldi	r25, 0x00	; 0
    3318:	25 e2       	ldi	r18, 0x25	; 37
    331a:	30 e0       	ldi	r19, 0x00	; 0
    331c:	f9 01       	movw	r30, r18
    331e:	20 81       	ld	r18, Z
    3320:	20 69       	ori	r18, 0x90	; 144
    3322:	fc 01       	movw	r30, r24
    3324:	20 83       	st	Z, r18
	prtSpi0 &= ~(1 << bnMosi0);		//keep Miso low
    3326:	85 e2       	ldi	r24, 0x25	; 37
    3328:	90 e0       	ldi	r25, 0x00	; 0
    332a:	25 e2       	ldi	r18, 0x25	; 37
    332c:	30 e0       	ldi	r19, 0x00	; 0
    332e:	f9 01       	movw	r30, r18
    3330:	20 81       	ld	r18, Z
    3332:	2f 7d       	andi	r18, 0xDF	; 223
    3334:	fc 01       	movw	r30, r24
    3336:	20 83       	st	Z, r18
	
}
    3338:	0f 90       	pop	r0
    333a:	0f 90       	pop	r0
    333c:	df 91       	pop	r29
    333e:	cf 91       	pop	r28
    3340:	08 95       	ret

00003342 <_Z9InitBoolsv>:
/*************************************************************************************************************/
void InitBools(){
    3342:	cf 93       	push	r28
    3344:	df 93       	push	r29
    3346:	cd b7       	in	r28, 0x3d	; 61
    3348:	de b7       	in	r29, 0x3e	; 62
	//Init variables
	flagGoToSleep = fTrue;			//changes to fTrue in final implementation
    334a:	81 e0       	ldi	r24, 0x01	; 1
    334c:	80 93 0c 02 	sts	0x020C, r24
	flagReceivingBone = fFalse;
    3350:	10 92 0d 02 	sts	0x020D, r1
	flagNormalMode=fTrue;
    3354:	81 e0       	ldi	r24, 0x01	; 1
    3356:	80 93 0e 02 	sts	0x020E, r24
	flagReceivingGAVR=fFalse;
    335a:	10 92 0f 02 	sts	0x020F, r1
	flagWaitingForReceiveGAVR=fFalse;
    335e:	10 92 10 02 	sts	0x0210, r1
	flagWaitingForSYNGAVR=fFalse;
    3362:	10 92 11 02 	sts	0x0211, r1
	flagWaitingForSYNBone=fFalse;
    3366:	10 92 12 02 	sts	0x0212, r1

	flagUpdateGAVRClock=fFalse;
    336a:	10 92 13 02 	sts	0x0213, r1
	flagSendingGAVR=fFalse;
    336e:	10 92 14 02 	sts	0x0214, r1
	flagUserClock=fFalse;
    3372:	10 92 15 02 	sts	0x0215, r1
	flagInvalidDateTime=fFalse;
    3376:	10 92 16 02 	sts	0x0216, r1
	flagWaitingToSendGAVR=fFalse;
    337a:	10 92 17 02 	sts	0x0217, r1
	flagGPSTime=fFalse;
    337e:	10 92 18 02 	sts	0x0218, r1
	
	restart=fFalse;
    3382:	10 92 1d 02 	sts	0x021D, r1
	//flagNewShutdown=fFalse;
	flagShutdown=fFalse;		//Initialized in startup procedure in beginning of "main"
    3386:	10 92 1a 02 	sts	0x021A, r1
	flagGoodVolts=fFalse;
    338a:	10 92 1c 02 	sts	0x021C, r1
	flagGoodTemp=fFalse;
    338e:	10 92 1b 02 	sts	0x021B, r1
	//flagFreshStart=fTrue;		//Initialized in startup procedure in beginning of "main"
}
    3392:	df 91       	pop	r29
    3394:	cf 91       	pop	r28
    3396:	08 95       	ret

00003398 <_Z14EnableRTCTimerv>:
/*************************************************************************************************************/
void EnableRTCTimer(){
    3398:	cf 93       	push	r28
    339a:	df 93       	push	r29
    339c:	cd b7       	in	r28, 0x3d	; 61
    339e:	de b7       	in	r29, 0x3e	; 62
	//Asynchronous should be done based on TOSC1 and TOSC2
	//Give power back to Timer2
	PRR0 &= ~(1 << PRTIM2);
    33a0:	84 e6       	ldi	r24, 0x64	; 100
    33a2:	90 e0       	ldi	r25, 0x00	; 0
    33a4:	24 e6       	ldi	r18, 0x64	; 100
    33a6:	30 e0       	ldi	r19, 0x00	; 0
    33a8:	f9 01       	movw	r30, r18
    33aa:	20 81       	ld	r18, Z
    33ac:	2f 7b       	andi	r18, 0xBF	; 191
    33ae:	fc 01       	movw	r30, r24
    33b0:	20 83       	st	Z, r18
	Wait_ms(5);	//give it time to power on
    33b2:	85 e0       	ldi	r24, 0x05	; 5
    33b4:	90 e0       	ldi	r25, 0x00	; 0
    33b6:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
	
	//Set to Asynchronous mode, uses TOSC1/TOSC2 pins
	ASSR |= (1 << AS2);
    33ba:	86 eb       	ldi	r24, 0xB6	; 182
    33bc:	90 e0       	ldi	r25, 0x00	; 0
    33be:	26 eb       	ldi	r18, 0xB6	; 182
    33c0:	30 e0       	ldi	r19, 0x00	; 0
    33c2:	f9 01       	movw	r30, r18
    33c4:	20 81       	ld	r18, Z
    33c6:	20 62       	ori	r18, 0x20	; 32
    33c8:	fc 01       	movw	r30, r24
    33ca:	20 83       	st	Z, r18
	
	//Set prescaler, initialize registers
	TCCR2B |= (1 << CS22)|(1 << CS20);	//128 prescaler, should click into overflow every second
    33cc:	81 eb       	ldi	r24, 0xB1	; 177
    33ce:	90 e0       	ldi	r25, 0x00	; 0
    33d0:	21 eb       	ldi	r18, 0xB1	; 177
    33d2:	30 e0       	ldi	r19, 0x00	; 0
    33d4:	f9 01       	movw	r30, r18
    33d6:	20 81       	ld	r18, Z
    33d8:	25 60       	ori	r18, 0x05	; 5
    33da:	fc 01       	movw	r30, r24
    33dc:	20 83       	st	Z, r18
	while ((ASSR & ((1 << TCR2BUB)|(1 << TCN2UB))));	//wait for it not to be busy
    33de:	86 eb       	ldi	r24, 0xB6	; 182
    33e0:	90 e0       	ldi	r25, 0x00	; 0
    33e2:	fc 01       	movw	r30, r24
    33e4:	80 81       	ld	r24, Z
    33e6:	88 2f       	mov	r24, r24
    33e8:	90 e0       	ldi	r25, 0x00	; 0
    33ea:	81 71       	andi	r24, 0x11	; 17
    33ec:	90 70       	andi	r25, 0x00	; 0
    33ee:	21 e0       	ldi	r18, 0x01	; 1
    33f0:	00 97       	sbiw	r24, 0x00	; 0
    33f2:	09 f4       	brne	.+2      	; 0x33f6 <_Z14EnableRTCTimerv+0x5e>
    33f4:	20 e0       	ldi	r18, 0x00	; 0
    33f6:	22 23       	and	r18, r18
    33f8:	91 f7       	brne	.-28     	; 0x33de <_Z14EnableRTCTimerv+0x46>
	TIFR2 = (1 << TOV2);								//Clear any interrupts pending for the timer
    33fa:	87 e3       	ldi	r24, 0x37	; 55
    33fc:	90 e0       	ldi	r25, 0x00	; 0
    33fe:	21 e0       	ldi	r18, 0x01	; 1
    3400:	fc 01       	movw	r30, r24
    3402:	20 83       	st	Z, r18
	TIMSK2 = (1 << TOIE2);								//Enable overflow on it
    3404:	80 e7       	ldi	r24, 0x70	; 112
    3406:	90 e0       	ldi	r25, 0x00	; 0
    3408:	21 e0       	ldi	r18, 0x01	; 1
    340a:	fc 01       	movw	r30, r24
    340c:	20 83       	st	Z, r18
	
	//Away we go
}
    340e:	df 91       	pop	r29
    3410:	cf 91       	pop	r28
    3412:	08 95       	ret

00003414 <_Z9GoToSleeph>:

/*************************************************************************************************************/

void GoToSleep(BOOL shortOrLong){
    3414:	cf 93       	push	r28
    3416:	df 93       	push	r29
    3418:	00 d0       	rcall	.+0      	; 0x341a <_Z9GoToSleeph+0x6>
    341a:	00 d0       	rcall	.+0      	; 0x341c <_Z9GoToSleeph+0x8>
    341c:	0f 92       	push	r0
    341e:	cd b7       	in	r28, 0x3d	; 61
    3420:	de b7       	in	r29, 0x3e	; 62
    3422:	8d 83       	std	Y+5, r24	; 0x05
		sei();
    3424:	78 94       	sei
		int sleepTime, sleepTicks = 0;
    3426:	1c 82       	std	Y+4, r1	; 0x04
    3428:	1b 82       	std	Y+3, r1	; 0x03
		//If bool is true, we are in low power mode/backup, sleep for 60 seconds then check ADC again
		if (shortOrLong){
    342a:	8d 81       	ldd	r24, Y+5	; 0x05
    342c:	88 23       	and	r24, r24
    342e:	29 f0       	breq	.+10     	; 0x343a <_Z9GoToSleeph+0x26>
			sleepTime = SLEEP_TICKS_LOWV;
    3430:	8c e0       	ldi	r24, 0x0C	; 12
    3432:	90 e0       	ldi	r25, 0x00	; 0
    3434:	9a 83       	std	Y+2, r25	; 0x02
    3436:	89 83       	std	Y+1, r24	; 0x01
    3438:	04 c0       	rjmp	.+8      	; 0x3442 <_Z9GoToSleeph+0x2e>
		} else {
			sleepTime = SLEEP_TICKS_HIGHV;
    343a:	8a e0       	ldi	r24, 0x0A	; 10
    343c:	90 e0       	ldi	r25, 0x00	; 0
    343e:	9a 83       	std	Y+2, r25	; 0x02
    3440:	89 83       	std	Y+1, r24	; 0x01
		}
		//Turn off status LED, put on TIM2 led
		prtSTATUSled &= ~(1 << bnSTATUSled);
    3442:	88 e2       	ldi	r24, 0x28	; 40
    3444:	90 e0       	ldi	r25, 0x00	; 0
    3446:	28 e2       	ldi	r18, 0x28	; 40
    3448:	30 e0       	ldi	r19, 0x00	; 0
    344a:	f9 01       	movw	r30, r18
    344c:	20 81       	ld	r18, Z
    344e:	2b 7f       	andi	r18, 0xFB	; 251
    3450:	fc 01       	movw	r30, r24
    3452:	20 83       	st	Z, r18
		
		//Set to power save, then enable
		SMCR = (1 << SM1)|(1 << SM0);
    3454:	83 e5       	ldi	r24, 0x53	; 83
    3456:	90 e0       	ldi	r25, 0x00	; 0
    3458:	26 e0       	ldi	r18, 0x06	; 6
    345a:	fc 01       	movw	r30, r24
    345c:	20 83       	st	Z, r18
		SMCR |= (1 << SE);
    345e:	83 e5       	ldi	r24, 0x53	; 83
    3460:	90 e0       	ldi	r25, 0x00	; 0
    3462:	23 e5       	ldi	r18, 0x53	; 83
    3464:	30 e0       	ldi	r19, 0x00	; 0
    3466:	f9 01       	movw	r30, r18
    3468:	20 81       	ld	r18, Z
    346a:	21 60       	ori	r18, 0x01	; 1
    346c:	fc 01       	movw	r30, r24
    346e:	20 83       	st	Z, r18
		
		//Give time to registers
		Wait_ms(1);
    3470:	81 e0       	ldi	r24, 0x01	; 1
    3472:	90 e0       	ldi	r25, 0x00	; 0
    3474:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3478:	06 c0       	rjmp	.+12     	; 0x3486 <_Z9GoToSleeph+0x72>
			asm volatile("SLEEP");
    347a:	88 95       	sleep
			sleepTicks++;
    347c:	8b 81       	ldd	r24, Y+3	; 0x03
    347e:	9c 81       	ldd	r25, Y+4	; 0x04
    3480:	01 96       	adiw	r24, 0x01	; 1
    3482:	9c 83       	std	Y+4, r25	; 0x04
    3484:	8b 83       	std	Y+3, r24	; 0x03
		SMCR |= (1 << SE);
		
		//Give time to registers
		Wait_ms(1);
		//Go to sleep
		while (sleepTicks < sleepTime && flagGoToSleep){
    3486:	2b 81       	ldd	r18, Y+3	; 0x03
    3488:	3c 81       	ldd	r19, Y+4	; 0x04
    348a:	89 81       	ldd	r24, Y+1	; 0x01
    348c:	9a 81       	ldd	r25, Y+2	; 0x02
    348e:	28 17       	cp	r18, r24
    3490:	39 07       	cpc	r19, r25
    3492:	34 f4       	brge	.+12     	; 0x34a0 <_Z9GoToSleeph+0x8c>
    3494:	80 91 0c 02 	lds	r24, 0x020C
    3498:	88 23       	and	r24, r24
    349a:	11 f0       	breq	.+4      	; 0x34a0 <_Z9GoToSleeph+0x8c>
    349c:	81 e0       	ldi	r24, 0x01	; 1
    349e:	01 c0       	rjmp	.+2      	; 0x34a2 <_Z9GoToSleeph+0x8e>
    34a0:	80 e0       	ldi	r24, 0x00	; 0
    34a2:	88 23       	and	r24, r24
    34a4:	51 f7       	brne	.-44     	; 0x347a <_Z9GoToSleeph+0x66>
			asm volatile("SLEEP");
			sleepTicks++;
		} //endwhile
		
		//Give it time to power back on
		Wait_ms(1);
    34a6:	81 e0       	ldi	r24, 0x01	; 1
    34a8:	90 e0       	ldi	r25, 0x00	; 0
    34aa:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
		
		//Done sleeping, turn off sleeping led
		prtSTATUSled |= (1 << bnSTATUSled);
    34ae:	88 e2       	ldi	r24, 0x28	; 40
    34b0:	90 e0       	ldi	r25, 0x00	; 0
    34b2:	28 e2       	ldi	r18, 0x28	; 40
    34b4:	30 e0       	ldi	r19, 0x00	; 0
    34b6:	f9 01       	movw	r30, r18
    34b8:	20 81       	ld	r18, Z
    34ba:	24 60       	ori	r18, 0x04	; 4
    34bc:	fc 01       	movw	r30, r24
    34be:	20 83       	st	Z, r18
}
    34c0:	0f 90       	pop	r0
    34c2:	0f 90       	pop	r0
    34c4:	0f 90       	pop	r0
    34c6:	0f 90       	pop	r0
    34c8:	0f 90       	pop	r0
    34ca:	df 91       	pop	r29
    34cc:	cf 91       	pop	r28
    34ce:	08 95       	ret

000034d0 <_Z7TakeADCv>:
/*************************************************************************************************************/

void TakeADC(){
    34d0:	cf 93       	push	r28
    34d2:	df 93       	push	r29
    34d4:	cd b7       	in	r28, 0x3d	; 61
    34d6:	de b7       	in	r29, 0x3e	; 62
    34d8:	2e 97       	sbiw	r28, 0x0e	; 14
    34da:	0f b6       	in	r0, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	de bf       	out	0x3e, r29	; 62
    34e0:	0f be       	out	0x3f, r0	; 63
    34e2:	cd bf       	out	0x3d, r28	; 61
	WORD adcReading = 0;
    34e4:	1c 82       	std	Y+4, r1	; 0x04
    34e6:	1b 82       	std	Y+3, r1	; 0x03
	
	prtInterrupts |= (1 << bnBBint);
    34e8:	82 e2       	ldi	r24, 0x22	; 34
    34ea:	90 e0       	ldi	r25, 0x00	; 0
    34ec:	22 e2       	ldi	r18, 0x22	; 34
    34ee:	30 e0       	ldi	r19, 0x00	; 0
    34f0:	f9 01       	movw	r30, r18
    34f2:	20 81       	ld	r18, Z
    34f4:	24 60       	ori	r18, 0x04	; 4
    34f6:	fc 01       	movw	r30, r24
    34f8:	20 83       	st	Z, r18
	
	__killCommINT();
    34fa:	8d e3       	ldi	r24, 0x3D	; 61
    34fc:	90 e0       	ldi	r25, 0x00	; 0
    34fe:	fc 01       	movw	r30, r24
    3500:	10 82       	st	Z, r1
    3502:	8d e6       	ldi	r24, 0x6D	; 109
    3504:	90 e0       	ldi	r25, 0x00	; 0
    3506:	fc 01       	movw	r30, r24
    3508:	10 82       	st	Z, r1
	//Turn Power on to ADC
	PRR0 &= ~(1 << PRADC);	
    350a:	84 e6       	ldi	r24, 0x64	; 100
    350c:	90 e0       	ldi	r25, 0x00	; 0
    350e:	24 e6       	ldi	r18, 0x64	; 100
    3510:	30 e0       	ldi	r19, 0x00	; 0
    3512:	f9 01       	movw	r30, r18
    3514:	20 81       	ld	r18, Z
    3516:	2e 7f       	andi	r18, 0xFE	; 254
    3518:	fc 01       	movw	r30, r24
    351a:	20 83       	st	Z, r18
	ADMUX |= (1 << REFS1);	//internal 1.1V reference
    351c:	8c e7       	ldi	r24, 0x7C	; 124
    351e:	90 e0       	ldi	r25, 0x00	; 0
    3520:	2c e7       	ldi	r18, 0x7C	; 124
    3522:	30 e0       	ldi	r19, 0x00	; 0
    3524:	f9 01       	movw	r30, r18
    3526:	20 81       	ld	r18, Z
    3528:	20 68       	ori	r18, 0x80	; 128
    352a:	fc 01       	movw	r30, r24
    352c:	20 83       	st	Z, r18
	ADCSRA |= (1 << ADEN)|(1 << ADPS2);			//clkIO/16
    352e:	8a e7       	ldi	r24, 0x7A	; 122
    3530:	90 e0       	ldi	r25, 0x00	; 0
    3532:	2a e7       	ldi	r18, 0x7A	; 122
    3534:	30 e0       	ldi	r19, 0x00	; 0
    3536:	f9 01       	movw	r30, r18
    3538:	20 81       	ld	r18, Z
    353a:	24 68       	ori	r18, 0x84	; 132
    353c:	fc 01       	movw	r30, r24
    353e:	20 83       	st	Z, r18
	DIDR0 = 0xFE;								//disable all ADC's except ADC0
    3540:	8e e7       	ldi	r24, 0x7E	; 126
    3542:	90 e0       	ldi	r25, 0x00	; 0
    3544:	2e ef       	ldi	r18, 0xFE	; 254
    3546:	fc 01       	movw	r30, r24
    3548:	20 83       	st	Z, r18
	Wait_ms(2);									//Tim for registers to setup
    354a:	82 e0       	ldi	r24, 0x02	; 2
    354c:	90 e0       	ldi	r25, 0x00	; 0
    354e:	0e 94 d0 08 	call	0x11a0	; 0x11a0 <_Z7Wait_msi>
	
	//cli();
	//Run conversion twice, throw first one out
	for (int i = 0; i < 2; i++){ADCSRA |= (1 << ADSC); while (ADCSRA & (1 << ADSC));}	
    3552:	1a 82       	std	Y+2, r1	; 0x02
    3554:	19 82       	std	Y+1, r1	; 0x01
    3556:	1c c0       	rjmp	.+56     	; 0x3590 <_Z7TakeADCv+0xc0>
    3558:	8a e7       	ldi	r24, 0x7A	; 122
    355a:	90 e0       	ldi	r25, 0x00	; 0
    355c:	2a e7       	ldi	r18, 0x7A	; 122
    355e:	30 e0       	ldi	r19, 0x00	; 0
    3560:	f9 01       	movw	r30, r18
    3562:	20 81       	ld	r18, Z
    3564:	20 64       	ori	r18, 0x40	; 64
    3566:	fc 01       	movw	r30, r24
    3568:	20 83       	st	Z, r18
    356a:	8a e7       	ldi	r24, 0x7A	; 122
    356c:	90 e0       	ldi	r25, 0x00	; 0
    356e:	fc 01       	movw	r30, r24
    3570:	80 81       	ld	r24, Z
    3572:	88 2f       	mov	r24, r24
    3574:	90 e0       	ldi	r25, 0x00	; 0
    3576:	80 74       	andi	r24, 0x40	; 64
    3578:	90 70       	andi	r25, 0x00	; 0
    357a:	21 e0       	ldi	r18, 0x01	; 1
    357c:	00 97       	sbiw	r24, 0x00	; 0
    357e:	09 f4       	brne	.+2      	; 0x3582 <_Z7TakeADCv+0xb2>
    3580:	20 e0       	ldi	r18, 0x00	; 0
    3582:	22 23       	and	r18, r18
    3584:	91 f7       	brne	.-28     	; 0x356a <_Z7TakeADCv+0x9a>
    3586:	89 81       	ldd	r24, Y+1	; 0x01
    3588:	9a 81       	ldd	r25, Y+2	; 0x02
    358a:	01 96       	adiw	r24, 0x01	; 1
    358c:	9a 83       	std	Y+2, r25	; 0x02
    358e:	89 83       	std	Y+1, r24	; 0x01
    3590:	21 e0       	ldi	r18, 0x01	; 1
    3592:	89 81       	ldd	r24, Y+1	; 0x01
    3594:	9a 81       	ldd	r25, Y+2	; 0x02
    3596:	82 30       	cpi	r24, 0x02	; 2
    3598:	91 05       	cpc	r25, r1
    359a:	0c f0       	brlt	.+2      	; 0x359e <_Z7TakeADCv+0xce>
    359c:	20 e0       	ldi	r18, 0x00	; 0
    359e:	22 23       	and	r18, r18
    35a0:	d9 f6       	brne	.-74     	; 0x3558 <_Z7TakeADCv+0x88>
	
	//Re-enable interrupts	
	//sei();
	
	//Put conversion into buffer
	adcReading = ADCL;
    35a2:	88 e7       	ldi	r24, 0x78	; 120
    35a4:	90 e0       	ldi	r25, 0x00	; 0
    35a6:	fc 01       	movw	r30, r24
    35a8:	80 81       	ld	r24, Z
    35aa:	88 2f       	mov	r24, r24
    35ac:	90 e0       	ldi	r25, 0x00	; 0
    35ae:	9c 83       	std	Y+4, r25	; 0x04
    35b0:	8b 83       	std	Y+3, r24	; 0x03
	adcReading |= (ADCH << 8);
    35b2:	89 e7       	ldi	r24, 0x79	; 121
    35b4:	90 e0       	ldi	r25, 0x00	; 0
    35b6:	fc 01       	movw	r30, r24
    35b8:	80 81       	ld	r24, Z
    35ba:	88 2f       	mov	r24, r24
    35bc:	90 e0       	ldi	r25, 0x00	; 0
    35be:	98 2f       	mov	r25, r24
    35c0:	88 27       	eor	r24, r24
    35c2:	2b 81       	ldd	r18, Y+3	; 0x03
    35c4:	3c 81       	ldd	r19, Y+4	; 0x04
    35c6:	82 2b       	or	r24, r18
    35c8:	93 2b       	or	r25, r19
    35ca:	9c 83       	std	Y+4, r25	; 0x04
    35cc:	8b 83       	std	Y+3, r24	; 0x03
		
	//Assign global reading and set flag
	globalADC=adcReading;
    35ce:	8b 81       	ldd	r24, Y+3	; 0x03
    35d0:	9c 81       	ldd	r25, Y+4	; 0x04
    35d2:	90 93 e1 01 	sts	0x01E1, r25
    35d6:	80 93 e0 01 	sts	0x01E0, r24
	flagGoodVolts = (adcReading < LOW_BATT_ADC) ? fFalse : fTrue;
    35da:	21 e0       	ldi	r18, 0x01	; 1
    35dc:	8b 81       	ldd	r24, Y+3	; 0x03
    35de:	9c 81       	ldd	r25, Y+4	; 0x04
    35e0:	f3 e0       	ldi	r31, 0x03	; 3
    35e2:	82 37       	cpi	r24, 0x72	; 114
    35e4:	9f 07       	cpc	r25, r31
    35e6:	08 f4       	brcc	.+2      	; 0x35ea <_Z7TakeADCv+0x11a>
    35e8:	20 e0       	ldi	r18, 0x00	; 0
    35ea:	20 93 1c 02 	sts	0x021C, r18
		
	//Disable ADC hardware/registers
	ADCSRA = 0;
    35ee:	8a e7       	ldi	r24, 0x7A	; 122
    35f0:	90 e0       	ldi	r25, 0x00	; 0
    35f2:	fc 01       	movw	r30, r24
    35f4:	10 82       	st	Z, r1
	ADMUX = 0;
    35f6:	8c e7       	ldi	r24, 0x7C	; 124
    35f8:	90 e0       	ldi	r25, 0x00	; 0
    35fa:	fc 01       	movw	r30, r24
    35fc:	10 82       	st	Z, r1
	DIDR0 |= (1 << ADC0D);
    35fe:	8e e7       	ldi	r24, 0x7E	; 126
    3600:	90 e0       	ldi	r25, 0x00	; 0
    3602:	2e e7       	ldi	r18, 0x7E	; 126
    3604:	30 e0       	ldi	r19, 0x00	; 0
    3606:	f9 01       	movw	r30, r18
    3608:	20 81       	ld	r18, Z
    360a:	21 60       	ori	r18, 0x01	; 1
    360c:	fc 01       	movw	r30, r24
    360e:	20 83       	st	Z, r18
	
	//Turn off power
	PRR0 |= (1 << PRADC);
    3610:	84 e6       	ldi	r24, 0x64	; 100
    3612:	90 e0       	ldi	r25, 0x00	; 0
    3614:	24 e6       	ldi	r18, 0x64	; 100
    3616:	30 e0       	ldi	r19, 0x00	; 0
    3618:	f9 01       	movw	r30, r18
    361a:	20 81       	ld	r18, Z
    361c:	21 60       	ori	r18, 0x01	; 1
    361e:	fc 01       	movw	r30, r24
    3620:	20 83       	st	Z, r18

	char tempString[10];
	itoa(globalADC,tempString,10);
    3622:	80 91 e0 01 	lds	r24, 0x01E0
    3626:	90 91 e1 01 	lds	r25, 0x01E1
    362a:	9e 01       	movw	r18, r28
    362c:	2b 5f       	subi	r18, 0xFB	; 251
    362e:	3f 4f       	sbci	r19, 0xFF	; 255
    3630:	b9 01       	movw	r22, r18
    3632:	4a e0       	ldi	r20, 0x0A	; 10
    3634:	50 e0       	ldi	r21, 0x00	; 0
    3636:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <itoa>
	tempString[9]='\0';
    363a:	1e 86       	std	Y+14, r1	; 0x0e
	//PrintBone("ADC: ");
	//PrintBone(tempString);
	prtInterrupts &= ~(1 << bnBBint);
    363c:	82 e2       	ldi	r24, 0x22	; 34
    363e:	90 e0       	ldi	r25, 0x00	; 0
    3640:	22 e2       	ldi	r18, 0x22	; 34
    3642:	30 e0       	ldi	r19, 0x00	; 0
    3644:	f9 01       	movw	r30, r18
    3646:	20 81       	ld	r18, Z
    3648:	2b 7f       	andi	r18, 0xFB	; 251
    364a:	fc 01       	movw	r30, r24
    364c:	20 83       	st	Z, r18
	__enableCommINT();
    364e:	8d e3       	ldi	r24, 0x3D	; 61
    3650:	90 e0       	ldi	r25, 0x00	; 0
    3652:	2d e3       	ldi	r18, 0x3D	; 61
    3654:	30 e0       	ldi	r19, 0x00	; 0
    3656:	f9 01       	movw	r30, r18
    3658:	20 81       	ld	r18, Z
    365a:	24 60       	ori	r18, 0x04	; 4
    365c:	fc 01       	movw	r30, r24
    365e:	20 83       	st	Z, r18
    3660:	8d e6       	ldi	r24, 0x6D	; 109
    3662:	90 e0       	ldi	r25, 0x00	; 0
    3664:	22 e0       	ldi	r18, 0x02	; 2
    3666:	fc 01       	movw	r30, r24
    3668:	20 83       	st	Z, r18
}
    366a:	2e 96       	adiw	r28, 0x0e	; 14
    366c:	0f b6       	in	r0, 0x3f	; 63
    366e:	f8 94       	cli
    3670:	de bf       	out	0x3e, r29	; 62
    3672:	0f be       	out	0x3f, r0	; 63
    3674:	cd bf       	out	0x3d, r28	; 61
    3676:	df 91       	pop	r29
    3678:	cf 91       	pop	r28
    367a:	08 95       	ret

0000367c <_Z7GetTempv>:

/*************************************************************************************************************/

void GetTemp(){
    367c:	cf 93       	push	r28
    367e:	df 93       	push	r29
    3680:	cd b7       	in	r28, 0x3d	; 61
    3682:	de b7       	in	r29, 0x3e	; 62
    3684:	2b 97       	sbiw	r28, 0x0b	; 11
    3686:	0f b6       	in	r0, 0x3f	; 63
    3688:	f8 94       	cli
    368a:	de bf       	out	0x3e, r29	; 62
    368c:	0f be       	out	0x3f, r0	; 63
    368e:	cd bf       	out	0x3d, r28	; 61
	WORD rawTemp = 0;
    3690:	1a 82       	std	Y+2, r1	; 0x02
    3692:	19 82       	std	Y+1, r1	; 0x01

	__killCommINT();
    3694:	8d e3       	ldi	r24, 0x3D	; 61
    3696:	90 e0       	ldi	r25, 0x00	; 0
    3698:	fc 01       	movw	r30, r24
    369a:	10 82       	st	Z, r1
    369c:	8d e6       	ldi	r24, 0x6D	; 109
    369e:	90 e0       	ldi	r25, 0x00	; 0
    36a0:	fc 01       	movw	r30, r24
    36a2:	10 82       	st	Z, r1

	PRR0 &= ~(1 << PRSPI);
    36a4:	84 e6       	ldi	r24, 0x64	; 100
    36a6:	90 e0       	ldi	r25, 0x00	; 0
    36a8:	24 e6       	ldi	r18, 0x64	; 100
    36aa:	30 e0       	ldi	r19, 0x00	; 0
    36ac:	f9 01       	movw	r30, r18
    36ae:	20 81       	ld	r18, Z
    36b0:	2b 7f       	andi	r18, 0xFB	; 251
    36b2:	fc 01       	movw	r30, r24
    36b4:	20 83       	st	Z, r18
		
	#ifdef BACKUP
		SPCR0 |= (1 << MSTR0)|(1 << SPE0)|(1 << SPR00);			//enables SPI, master, fck/64
	#else
		SPCR |= (1 << MSTR)|(1 << SPE)|(1 << SPR0);
    36b6:	8c e4       	ldi	r24, 0x4C	; 76
    36b8:	90 e0       	ldi	r25, 0x00	; 0
    36ba:	2c e4       	ldi	r18, 0x4C	; 76
    36bc:	30 e0       	ldi	r19, 0x00	; 0
    36be:	f9 01       	movw	r30, r18
    36c0:	20 81       	ld	r18, Z
    36c2:	21 65       	ori	r18, 0x51	; 81
    36c4:	fc 01       	movw	r30, r24
    36c6:	20 83       	st	Z, r18
	#endif
	
	Wait_sec(2);
    36c8:	82 e0       	ldi	r24, 0x02	; 2
    36ca:	90 e0       	ldi	r25, 0x00	; 0
    36cc:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	//Slave select goes low, sck goes low,  to signal start of transmission
	prtSpi0 &= ~((1 << bnSck0)|(1 << bnSS0));
    36d0:	85 e2       	ldi	r24, 0x25	; 37
    36d2:	90 e0       	ldi	r25, 0x00	; 0
    36d4:	25 e2       	ldi	r18, 0x25	; 37
    36d6:	30 e0       	ldi	r19, 0x00	; 0
    36d8:	f9 01       	movw	r30, r18
    36da:	20 81       	ld	r18, Z
    36dc:	2f 76       	andi	r18, 0x6F	; 111
    36de:	fc 01       	movw	r30, r24
    36e0:	20 83       	st	Z, r18
	
	cli();
    36e2:	f8 94       	cli
		SPDR0 = 0x00;
		while (!(SPSR0 & (1 << SPIF0)));
		rawTemp |= SPDR0;
		SPCR0=0x00;	
	#else	
		SPDR=0x00;
    36e4:	8e e4       	ldi	r24, 0x4E	; 78
    36e6:	90 e0       	ldi	r25, 0x00	; 0
    36e8:	fc 01       	movw	r30, r24
    36ea:	10 82       	st	Z, r1
		//Wait for data to be receieved.
		while (!(SPSR & (1 << SPIF)));
    36ec:	00 00       	nop
    36ee:	8d e4       	ldi	r24, 0x4D	; 77
    36f0:	90 e0       	ldi	r25, 0x00	; 0
    36f2:	fc 01       	movw	r30, r24
    36f4:	80 81       	ld	r24, Z
    36f6:	80 95       	com	r24
    36f8:	88 1f       	adc	r24, r24
    36fa:	88 27       	eor	r24, r24
    36fc:	88 1f       	adc	r24, r24
    36fe:	88 23       	and	r24, r24
    3700:	b1 f7       	brne	.-20     	; 0x36ee <_Z7GetTempv+0x72>
		rawTemp = (SPDR << 8);
    3702:	8e e4       	ldi	r24, 0x4E	; 78
    3704:	90 e0       	ldi	r25, 0x00	; 0
    3706:	fc 01       	movw	r30, r24
    3708:	80 81       	ld	r24, Z
    370a:	88 2f       	mov	r24, r24
    370c:	90 e0       	ldi	r25, 0x00	; 0
    370e:	98 2f       	mov	r25, r24
    3710:	88 27       	eor	r24, r24
    3712:	9a 83       	std	Y+2, r25	; 0x02
    3714:	89 83       	std	Y+1, r24	; 0x01
		SPDR= 0x00;
    3716:	8e e4       	ldi	r24, 0x4E	; 78
    3718:	90 e0       	ldi	r25, 0x00	; 0
    371a:	fc 01       	movw	r30, r24
    371c:	10 82       	st	Z, r1
		while (!(SPSR & (1 << SPIF)));
    371e:	00 00       	nop
    3720:	8d e4       	ldi	r24, 0x4D	; 77
    3722:	90 e0       	ldi	r25, 0x00	; 0
    3724:	fc 01       	movw	r30, r24
    3726:	80 81       	ld	r24, Z
    3728:	80 95       	com	r24
    372a:	88 1f       	adc	r24, r24
    372c:	88 27       	eor	r24, r24
    372e:	88 1f       	adc	r24, r24
    3730:	88 23       	and	r24, r24
    3732:	b1 f7       	brne	.-20     	; 0x3720 <_Z7GetTempv+0xa4>
		rawTemp |= SPDR;	
    3734:	8e e4       	ldi	r24, 0x4E	; 78
    3736:	90 e0       	ldi	r25, 0x00	; 0
    3738:	fc 01       	movw	r30, r24
    373a:	80 81       	ld	r24, Z
    373c:	88 2f       	mov	r24, r24
    373e:	90 e0       	ldi	r25, 0x00	; 0
    3740:	29 81       	ldd	r18, Y+1	; 0x01
    3742:	3a 81       	ldd	r19, Y+2	; 0x02
    3744:	82 2b       	or	r24, r18
    3746:	93 2b       	or	r25, r19
    3748:	9a 83       	std	Y+2, r25	; 0x02
    374a:	89 83       	std	Y+1, r24	; 0x01
		SPCR=0x00;
    374c:	8c e4       	ldi	r24, 0x4C	; 76
    374e:	90 e0       	ldi	r25, 0x00	; 0
    3750:	fc 01       	movw	r30, r24
    3752:	10 82       	st	Z, r1
	#endif
		
	//Set flag to correct value, update global value
	//flagGoodTemp = (rawTemp < HIGH_TEMP) ? fTrue : fFalse;
	globalTemp=rawTemp;
    3754:	89 81       	ldd	r24, Y+1	; 0x01
    3756:	9a 81       	ldd	r25, Y+2	; 0x02
    3758:	90 93 e3 01 	sts	0x01E3, r25
    375c:	80 93 e2 01 	sts	0x01E2, r24
	
	//re enable interrupts
	sei();
    3760:	78 94       	sei
	
	//Bring SS high, clear SPCR0 register and turn power off to SPI and device
	prtSpi0 |= (1 << bnSS0)|(1 << bnSck0);
    3762:	85 e2       	ldi	r24, 0x25	; 37
    3764:	90 e0       	ldi	r25, 0x00	; 0
    3766:	25 e2       	ldi	r18, 0x25	; 37
    3768:	30 e0       	ldi	r19, 0x00	; 0
    376a:	f9 01       	movw	r30, r18
    376c:	20 81       	ld	r18, Z
    376e:	20 69       	ori	r18, 0x90	; 144
    3770:	fc 01       	movw	r30, r24
    3772:	20 83       	st	Z, r18
	//__killTemp();
	PRR0 |= (1 << PRSPI);
    3774:	84 e6       	ldi	r24, 0x64	; 100
    3776:	90 e0       	ldi	r25, 0x00	; 0
    3778:	24 e6       	ldi	r18, 0x64	; 100
    377a:	30 e0       	ldi	r19, 0x00	; 0
    377c:	f9 01       	movw	r30, r18
    377e:	20 81       	ld	r18, Z
    3780:	24 60       	ori	r18, 0x04	; 4
    3782:	fc 01       	movw	r30, r24
    3784:	20 83       	st	Z, r18
	
	char tempString[9];
	itoa(globalTemp,tempString,10);
    3786:	80 91 e2 01 	lds	r24, 0x01E2
    378a:	90 91 e3 01 	lds	r25, 0x01E3
    378e:	9e 01       	movw	r18, r28
    3790:	2d 5f       	subi	r18, 0xFD	; 253
    3792:	3f 4f       	sbci	r19, 0xFF	; 255
    3794:	b9 01       	movw	r22, r18
    3796:	4a e0       	ldi	r20, 0x0A	; 10
    3798:	50 e0       	ldi	r21, 0x00	; 0
    379a:	0e 94 59 1d 	call	0x3ab2	; 0x3ab2 <itoa>
	tempString[8]='\0';
    379e:	1b 86       	std	Y+11, r1	; 0x0b

	__enableCommINT();
    37a0:	8d e3       	ldi	r24, 0x3D	; 61
    37a2:	90 e0       	ldi	r25, 0x00	; 0
    37a4:	2d e3       	ldi	r18, 0x3D	; 61
    37a6:	30 e0       	ldi	r19, 0x00	; 0
    37a8:	f9 01       	movw	r30, r18
    37aa:	20 81       	ld	r18, Z
    37ac:	24 60       	ori	r18, 0x04	; 4
    37ae:	fc 01       	movw	r30, r24
    37b0:	20 83       	st	Z, r18
    37b2:	8d e6       	ldi	r24, 0x6D	; 109
    37b4:	90 e0       	ldi	r25, 0x00	; 0
    37b6:	22 e0       	ldi	r18, 0x02	; 2
    37b8:	fc 01       	movw	r30, r24
    37ba:	20 83       	st	Z, r18
}
    37bc:	2b 96       	adiw	r28, 0x0b	; 11
    37be:	0f b6       	in	r0, 0x3f	; 63
    37c0:	f8 94       	cli
    37c2:	de bf       	out	0x3e, r29	; 62
    37c4:	0f be       	out	0x3f, r0	; 63
    37c6:	cd bf       	out	0x3d, r28	; 61
    37c8:	df 91       	pop	r29
    37ca:	cf 91       	pop	r28
    37cc:	08 95       	ret

000037ce <_Z7PowerUpj>:
/*************************************************************************************************************/
void PowerUp(WORD interval){
    37ce:	cf 93       	push	r28
    37d0:	df 93       	push	r29
    37d2:	00 d0       	rcall	.+0      	; 0x37d4 <_Z7PowerUpj+0x6>
    37d4:	cd b7       	in	r28, 0x3d	; 61
    37d6:	de b7       	in	r29, 0x3e	; 62
    37d8:	9a 83       	std	Y+2, r25	; 0x02
    37da:	89 83       	std	Y+1, r24	; 0x01
	__killCommINT();
    37dc:	8d e3       	ldi	r24, 0x3D	; 61
    37de:	90 e0       	ldi	r25, 0x00	; 0
    37e0:	fc 01       	movw	r30, r24
    37e2:	10 82       	st	Z, r1
    37e4:	8d e6       	ldi	r24, 0x6D	; 109
    37e6:	90 e0       	ldi	r25, 0x00	; 0
    37e8:	fc 01       	movw	r30, r24
    37ea:	10 82       	st	Z, r1
	
	//First power on main regulator
	__enableMain();
    37ec:	88 e2       	ldi	r24, 0x28	; 40
    37ee:	90 e0       	ldi	r25, 0x00	; 0
    37f0:	28 e2       	ldi	r18, 0x28	; 40
    37f2:	30 e0       	ldi	r19, 0x00	; 0
    37f4:	f9 01       	movw	r30, r18
    37f6:	20 81       	ld	r18, Z
    37f8:	21 60       	ori	r18, 0x01	; 1
    37fa:	fc 01       	movw	r30, r24
    37fc:	20 83       	st	Z, r18
	Wait_sec(interval);
    37fe:	89 81       	ldd	r24, Y+1	; 0x01
    3800:	9a 81       	ldd	r25, Y+2	; 0x02
    3802:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	
	//Power on BeagleBone next, takes longer time.
	__enableBeagleBone();
    3806:	82 e2       	ldi	r24, 0x22	; 34
    3808:	90 e0       	ldi	r25, 0x00	; 0
    380a:	22 e2       	ldi	r18, 0x22	; 34
    380c:	30 e0       	ldi	r19, 0x00	; 0
    380e:	f9 01       	movw	r30, r18
    3810:	20 81       	ld	r18, Z
    3812:	20 61       	ori	r18, 0x10	; 16
    3814:	fc 01       	movw	r30, r24
    3816:	20 83       	st	Z, r18
	Wait_sec(interval*2);
    3818:	89 81       	ldd	r24, Y+1	; 0x01
    381a:	9a 81       	ldd	r25, Y+2	; 0x02
    381c:	88 0f       	add	r24, r24
    381e:	99 1f       	adc	r25, r25
    3820:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	
	//Power on GAVR and Enable GPS
	__enableGPSandGAVR();
    3824:	82 e2       	ldi	r24, 0x22	; 34
    3826:	90 e0       	ldi	r25, 0x00	; 0
    3828:	22 e2       	ldi	r18, 0x22	; 34
    382a:	30 e0       	ldi	r19, 0x00	; 0
    382c:	f9 01       	movw	r30, r18
    382e:	20 81       	ld	r18, Z
    3830:	20 6c       	ori	r18, 0xC0	; 192
    3832:	fc 01       	movw	r30, r24
    3834:	20 83       	st	Z, r18

	//Power on LCD
	__enableLCD();
    3836:	82 e2       	ldi	r24, 0x22	; 34
    3838:	90 e0       	ldi	r25, 0x00	; 0
    383a:	22 e2       	ldi	r18, 0x22	; 34
    383c:	30 e0       	ldi	r19, 0x00	; 0
    383e:	f9 01       	movw	r30, r18
    3840:	20 81       	ld	r18, Z
    3842:	20 62       	ori	r18, 0x20	; 32
    3844:	fc 01       	movw	r30, r24
    3846:	20 83       	st	Z, r18
	Wait_sec(interval);
    3848:	89 81       	ldd	r24, Y+1	; 0x01
    384a:	9a 81       	ldd	r25, Y+2	; 0x02
    384c:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	
	__enableCommINT();
    3850:	8d e3       	ldi	r24, 0x3D	; 61
    3852:	90 e0       	ldi	r25, 0x00	; 0
    3854:	2d e3       	ldi	r18, 0x3D	; 61
    3856:	30 e0       	ldi	r19, 0x00	; 0
    3858:	f9 01       	movw	r30, r18
    385a:	20 81       	ld	r18, Z
    385c:	24 60       	ori	r18, 0x04	; 4
    385e:	fc 01       	movw	r30, r24
    3860:	20 83       	st	Z, r18
    3862:	8d e6       	ldi	r24, 0x6D	; 109
    3864:	90 e0       	ldi	r25, 0x00	; 0
    3866:	22 e0       	ldi	r18, 0x02	; 2
    3868:	fc 01       	movw	r30, r24
    386a:	20 83       	st	Z, r18
	PRR0 &= ~(1 << PRUSART1);
    386c:	84 e6       	ldi	r24, 0x64	; 100
    386e:	90 e0       	ldi	r25, 0x00	; 0
    3870:	24 e6       	ldi	r18, 0x64	; 100
    3872:	30 e0       	ldi	r19, 0x00	; 0
    3874:	f9 01       	movw	r30, r18
    3876:	20 81       	ld	r18, Z
    3878:	2f 7e       	andi	r18, 0xEF	; 239
    387a:	fc 01       	movw	r30, r24
    387c:	20 83       	st	Z, r18
	
}
    387e:	0f 90       	pop	r0
    3880:	0f 90       	pop	r0
    3882:	df 91       	pop	r29
    3884:	cf 91       	pop	r28
    3886:	08 95       	ret

00003888 <_Z9PowerDownv>:
/*************************************************************************************************************/
void PowerDown(){
    3888:	cf 93       	push	r28
    388a:	df 93       	push	r29
    388c:	cd b7       	in	r28, 0x3d	; 61
    388e:	de b7       	in	r29, 0x3e	; 62
	PRR0 |= (1 << PRUSART1);
    3890:	84 e6       	ldi	r24, 0x64	; 100
    3892:	90 e0       	ldi	r25, 0x00	; 0
    3894:	24 e6       	ldi	r18, 0x64	; 100
    3896:	30 e0       	ldi	r19, 0x00	; 0
    3898:	f9 01       	movw	r30, r18
    389a:	20 81       	ld	r18, Z
    389c:	20 61       	ori	r18, 0x10	; 16
    389e:	fc 01       	movw	r30, r24
    38a0:	20 83       	st	Z, r18
	
	__killCommINT();
    38a2:	8d e3       	ldi	r24, 0x3D	; 61
    38a4:	90 e0       	ldi	r25, 0x00	; 0
    38a6:	fc 01       	movw	r30, r24
    38a8:	10 82       	st	Z, r1
    38aa:	8d e6       	ldi	r24, 0x6D	; 109
    38ac:	90 e0       	ldi	r25, 0x00	; 0
    38ae:	fc 01       	movw	r30, r24
    38b0:	10 82       	st	Z, r1

	//Signify interrupts, wait 6 seconds for all processing to stop.
	prtInterrupts |= (1 << bnGAVRint);
    38b2:	82 e2       	ldi	r24, 0x22	; 34
    38b4:	90 e0       	ldi	r25, 0x00	; 0
    38b6:	22 e2       	ldi	r18, 0x22	; 34
    38b8:	30 e0       	ldi	r19, 0x00	; 0
    38ba:	f9 01       	movw	r30, r18
    38bc:	20 81       	ld	r18, Z
    38be:	28 60       	ori	r18, 0x08	; 8
    38c0:	fc 01       	movw	r30, r24
    38c2:	20 83       	st	Z, r18
	prtBONEINT |= (1 << bnBONEINT);
    38c4:	82 e2       	ldi	r24, 0x22	; 34
    38c6:	90 e0       	ldi	r25, 0x00	; 0
    38c8:	22 e2       	ldi	r18, 0x22	; 34
    38ca:	30 e0       	ldi	r19, 0x00	; 0
    38cc:	f9 01       	movw	r30, r18
    38ce:	20 81       	ld	r18, Z
    38d0:	22 60       	ori	r18, 0x02	; 2
    38d2:	fc 01       	movw	r30, r24
    38d4:	20 83       	st	Z, r18
	Wait_sec(6);
    38d6:	86 e0       	ldi	r24, 0x06	; 6
    38d8:	90 e0       	ldi	r25, 0x00	; 0
    38da:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	prtInterrupts &= ~(1 << bnGAVRint);
    38de:	82 e2       	ldi	r24, 0x22	; 34
    38e0:	90 e0       	ldi	r25, 0x00	; 0
    38e2:	22 e2       	ldi	r18, 0x22	; 34
    38e4:	30 e0       	ldi	r19, 0x00	; 0
    38e6:	f9 01       	movw	r30, r18
    38e8:	20 81       	ld	r18, Z
    38ea:	27 7f       	andi	r18, 0xF7	; 247
    38ec:	fc 01       	movw	r30, r24
    38ee:	20 83       	st	Z, r18
	prtBONEINT &= ~(1 << bnBONEINT);						//This signal is used instead of BBint on prtInterrupts since there is an issue with Kernel omap_mux on beaglebone.
    38f0:	82 e2       	ldi	r24, 0x22	; 34
    38f2:	90 e0       	ldi	r25, 0x00	; 0
    38f4:	22 e2       	ldi	r18, 0x22	; 34
    38f6:	30 e0       	ldi	r19, 0x00	; 0
    38f8:	f9 01       	movw	r30, r18
    38fa:	20 81       	ld	r18, Z
    38fc:	2d 7f       	andi	r18, 0xFD	; 253
    38fe:	fc 01       	movw	r30, r24
    3900:	20 83       	st	Z, r18

	//Kill LCD and GPS/GAVR first.
	__killLCD();
    3902:	82 e2       	ldi	r24, 0x22	; 34
    3904:	90 e0       	ldi	r25, 0x00	; 0
    3906:	22 e2       	ldi	r18, 0x22	; 34
    3908:	30 e0       	ldi	r19, 0x00	; 0
    390a:	f9 01       	movw	r30, r18
    390c:	20 81       	ld	r18, Z
    390e:	2f 7d       	andi	r18, 0xDF	; 223
    3910:	fc 01       	movw	r30, r24
    3912:	20 83       	st	Z, r18
	__killGPSandGAVR();
    3914:	82 e2       	ldi	r24, 0x22	; 34
    3916:	90 e0       	ldi	r25, 0x00	; 0
    3918:	22 e2       	ldi	r18, 0x22	; 34
    391a:	30 e0       	ldi	r19, 0x00	; 0
    391c:	f9 01       	movw	r30, r18
    391e:	20 81       	ld	r18, Z
    3920:	2f 73       	andi	r18, 0x3F	; 63
    3922:	fc 01       	movw	r30, r24
    3924:	20 83       	st	Z, r18
	
	//Give the BeagleBone another 15 seconds to execute "halt"
	Wait_sec(15);
    3926:	8f e0       	ldi	r24, 0x0F	; 15
    3928:	90 e0       	ldi	r25, 0x00	; 0
    392a:	0e 94 98 08 	call	0x1130	; 0x1130 <_Z8Wait_seci>
	__killBeagleBone();
    392e:	82 e2       	ldi	r24, 0x22	; 34
    3930:	90 e0       	ldi	r25, 0x00	; 0
    3932:	22 e2       	ldi	r18, 0x22	; 34
    3934:	30 e0       	ldi	r19, 0x00	; 0
    3936:	f9 01       	movw	r30, r18
    3938:	20 81       	ld	r18, Z
    393a:	2f 7e       	andi	r18, 0xEF	; 239
    393c:	fc 01       	movw	r30, r24
    393e:	20 83       	st	Z, r18
	__killMain();
    3940:	88 e2       	ldi	r24, 0x28	; 40
    3942:	90 e0       	ldi	r25, 0x00	; 0
    3944:	28 e2       	ldi	r18, 0x28	; 40
    3946:	30 e0       	ldi	r19, 0x00	; 0
    3948:	f9 01       	movw	r30, r18
    394a:	20 81       	ld	r18, Z
    394c:	2e 7f       	andi	r18, 0xFE	; 254
    394e:	fc 01       	movw	r30, r24
    3950:	20 83       	st	Z, r18
}
    3952:	df 91       	pop	r29
    3954:	cf 91       	pop	r28
    3956:	08 95       	ret

00003958 <_Z41__static_initialization_and_destruction_0ii>:
    3958:	cf 93       	push	r28
    395a:	df 93       	push	r29
    395c:	00 d0       	rcall	.+0      	; 0x395e <_Z41__static_initialization_and_destruction_0ii+0x6>
    395e:	00 d0       	rcall	.+0      	; 0x3960 <_Z41__static_initialization_and_destruction_0ii+0x8>
    3960:	cd b7       	in	r28, 0x3d	; 61
    3962:	de b7       	in	r29, 0x3e	; 62
    3964:	9a 83       	std	Y+2, r25	; 0x02
    3966:	89 83       	std	Y+1, r24	; 0x01
    3968:	7c 83       	std	Y+4, r23	; 0x04
    396a:	6b 83       	std	Y+3, r22	; 0x03
    396c:	89 81       	ldd	r24, Y+1	; 0x01
    396e:	9a 81       	ldd	r25, Y+2	; 0x02
    3970:	81 30       	cpi	r24, 0x01	; 1
    3972:	91 05       	cpc	r25, r1
    3974:	51 f4       	brne	.+20     	; 0x398a <_Z41__static_initialization_and_destruction_0ii+0x32>
    3976:	8b 81       	ldd	r24, Y+3	; 0x03
    3978:	9c 81       	ldd	r25, Y+4	; 0x04
    397a:	2f ef       	ldi	r18, 0xFF	; 255
    397c:	8f 3f       	cpi	r24, 0xFF	; 255
    397e:	92 07       	cpc	r25, r18
    3980:	21 f4       	brne	.+8      	; 0x398a <_Z41__static_initialization_and_destruction_0ii+0x32>

/*********************************************GLOBAL VARIABLES***************************************************/
/****************************************************************************************************************/
WORD globalADC=0, globalTemp=0;
//volatile int timeOut=0;
myTime currentTime;  //The clock, MUST BE GLOBAL. In final program, will initiate with NOTHING, then GPS will update on the actual time into beaglebone, beaglebone pings us, then dunzo OR have UART into this as well, then get time and be done.
    3982:	84 ee       	ldi	r24, 0xE4	; 228
    3984:	91 e0       	ldi	r25, 0x01	; 1
    3986:	0e 94 10 04 	call	0x820	; 0x820 <_ZN6myTimeC1Ev>
	
	//Give the BeagleBone another 15 seconds to execute "halt"
	Wait_sec(15);
	__killBeagleBone();
	__killMain();
}
    398a:	0f 90       	pop	r0
    398c:	0f 90       	pop	r0
    398e:	0f 90       	pop	r0
    3990:	0f 90       	pop	r0
    3992:	df 91       	pop	r29
    3994:	cf 91       	pop	r28
    3996:	08 95       	ret

00003998 <_GLOBAL__sub_I__ZN6myDateC2Ev>:
    3998:	cf 93       	push	r28
    399a:	df 93       	push	r29
    399c:	cd b7       	in	r28, 0x3d	; 61
    399e:	de b7       	in	r29, 0x3e	; 62
    39a0:	81 e0       	ldi	r24, 0x01	; 1
    39a2:	90 e0       	ldi	r25, 0x00	; 0
    39a4:	6f ef       	ldi	r22, 0xFF	; 255
    39a6:	7f ef       	ldi	r23, 0xFF	; 255
    39a8:	0e 94 ac 1c 	call	0x3958	; 0x3958 <_Z41__static_initialization_and_destruction_0ii>
    39ac:	df 91       	pop	r29
    39ae:	cf 91       	pop	r28
    39b0:	08 95       	ret

000039b2 <__udivmodqi4>:
    39b2:	99 1b       	sub	r25, r25
    39b4:	79 e0       	ldi	r23, 0x09	; 9
    39b6:	04 c0       	rjmp	.+8      	; 0x39c0 <__udivmodqi4_ep>

000039b8 <__udivmodqi4_loop>:
    39b8:	99 1f       	adc	r25, r25
    39ba:	96 17       	cp	r25, r22
    39bc:	08 f0       	brcs	.+2      	; 0x39c0 <__udivmodqi4_ep>
    39be:	96 1b       	sub	r25, r22

000039c0 <__udivmodqi4_ep>:
    39c0:	88 1f       	adc	r24, r24
    39c2:	7a 95       	dec	r23
    39c4:	c9 f7       	brne	.-14     	; 0x39b8 <__udivmodqi4_loop>
    39c6:	80 95       	com	r24
    39c8:	08 95       	ret

000039ca <__divmodhi4>:
    39ca:	97 fb       	bst	r25, 7
    39cc:	09 2e       	mov	r0, r25
    39ce:	07 26       	eor	r0, r23
    39d0:	0a d0       	rcall	.+20     	; 0x39e6 <__divmodhi4_neg1>
    39d2:	77 fd       	sbrc	r23, 7
    39d4:	04 d0       	rcall	.+8      	; 0x39de <__divmodhi4_neg2>
    39d6:	0c d0       	rcall	.+24     	; 0x39f0 <__udivmodhi4>
    39d8:	06 d0       	rcall	.+12     	; 0x39e6 <__divmodhi4_neg1>
    39da:	00 20       	and	r0, r0
    39dc:	1a f4       	brpl	.+6      	; 0x39e4 <__divmodhi4_exit>

000039de <__divmodhi4_neg2>:
    39de:	70 95       	com	r23
    39e0:	61 95       	neg	r22
    39e2:	7f 4f       	sbci	r23, 0xFF	; 255

000039e4 <__divmodhi4_exit>:
    39e4:	08 95       	ret

000039e6 <__divmodhi4_neg1>:
    39e6:	f6 f7       	brtc	.-4      	; 0x39e4 <__divmodhi4_exit>
    39e8:	90 95       	com	r25
    39ea:	81 95       	neg	r24
    39ec:	9f 4f       	sbci	r25, 0xFF	; 255
    39ee:	08 95       	ret

000039f0 <__udivmodhi4>:
    39f0:	aa 1b       	sub	r26, r26
    39f2:	bb 1b       	sub	r27, r27
    39f4:	51 e1       	ldi	r21, 0x11	; 17
    39f6:	07 c0       	rjmp	.+14     	; 0x3a06 <__udivmodhi4_ep>

000039f8 <__udivmodhi4_loop>:
    39f8:	aa 1f       	adc	r26, r26
    39fa:	bb 1f       	adc	r27, r27
    39fc:	a6 17       	cp	r26, r22
    39fe:	b7 07       	cpc	r27, r23
    3a00:	10 f0       	brcs	.+4      	; 0x3a06 <__udivmodhi4_ep>
    3a02:	a6 1b       	sub	r26, r22
    3a04:	b7 0b       	sbc	r27, r23

00003a06 <__udivmodhi4_ep>:
    3a06:	88 1f       	adc	r24, r24
    3a08:	99 1f       	adc	r25, r25
    3a0a:	5a 95       	dec	r21
    3a0c:	a9 f7       	brne	.-22     	; 0x39f8 <__udivmodhi4_loop>
    3a0e:	80 95       	com	r24
    3a10:	90 95       	com	r25
    3a12:	bc 01       	movw	r22, r24
    3a14:	cd 01       	movw	r24, r26
    3a16:	08 95       	ret

00003a18 <__tablejump2__>:
    3a18:	ee 0f       	add	r30, r30
    3a1a:	ff 1f       	adc	r31, r31

00003a1c <__tablejump__>:
    3a1c:	05 90       	lpm	r0, Z+
    3a1e:	f4 91       	lpm	r31, Z
    3a20:	e0 2d       	mov	r30, r0
    3a22:	09 94       	ijmp

00003a24 <atoi>:
    3a24:	fc 01       	movw	r30, r24
    3a26:	88 27       	eor	r24, r24
    3a28:	99 27       	eor	r25, r25
    3a2a:	e8 94       	clt
    3a2c:	21 91       	ld	r18, Z+
    3a2e:	20 32       	cpi	r18, 0x20	; 32
    3a30:	e9 f3       	breq	.-6      	; 0x3a2c <atoi+0x8>
    3a32:	29 30       	cpi	r18, 0x09	; 9
    3a34:	10 f0       	brcs	.+4      	; 0x3a3a <atoi+0x16>
    3a36:	2e 30       	cpi	r18, 0x0E	; 14
    3a38:	c8 f3       	brcs	.-14     	; 0x3a2c <atoi+0x8>
    3a3a:	2b 32       	cpi	r18, 0x2B	; 43
    3a3c:	41 f0       	breq	.+16     	; 0x3a4e <atoi+0x2a>
    3a3e:	2d 32       	cpi	r18, 0x2D	; 45
    3a40:	39 f4       	brne	.+14     	; 0x3a50 <atoi+0x2c>
    3a42:	68 94       	set
    3a44:	04 c0       	rjmp	.+8      	; 0x3a4e <atoi+0x2a>
    3a46:	0e 94 7a 1d 	call	0x3af4	; 0x3af4 <__mulhi_const_10>
    3a4a:	82 0f       	add	r24, r18
    3a4c:	91 1d       	adc	r25, r1
    3a4e:	21 91       	ld	r18, Z+
    3a50:	20 53       	subi	r18, 0x30	; 48
    3a52:	2a 30       	cpi	r18, 0x0A	; 10
    3a54:	c0 f3       	brcs	.-16     	; 0x3a46 <atoi+0x22>
    3a56:	1e f4       	brtc	.+6      	; 0x3a5e <atoi+0x3a>
    3a58:	90 95       	com	r25
    3a5a:	81 95       	neg	r24
    3a5c:	9f 4f       	sbci	r25, 0xFF	; 255
    3a5e:	08 95       	ret

00003a60 <strcat>:
    3a60:	fb 01       	movw	r30, r22
    3a62:	dc 01       	movw	r26, r24
    3a64:	0d 90       	ld	r0, X+
    3a66:	00 20       	and	r0, r0
    3a68:	e9 f7       	brne	.-6      	; 0x3a64 <strcat+0x4>
    3a6a:	11 97       	sbiw	r26, 0x01	; 1
    3a6c:	01 90       	ld	r0, Z+
    3a6e:	0d 92       	st	X+, r0
    3a70:	00 20       	and	r0, r0
    3a72:	e1 f7       	brne	.-8      	; 0x3a6c <strcat+0xc>
    3a74:	08 95       	ret

00003a76 <strcmp>:
    3a76:	fb 01       	movw	r30, r22
    3a78:	dc 01       	movw	r26, r24
    3a7a:	8d 91       	ld	r24, X+
    3a7c:	01 90       	ld	r0, Z+
    3a7e:	80 19       	sub	r24, r0
    3a80:	01 10       	cpse	r0, r1
    3a82:	d9 f3       	breq	.-10     	; 0x3a7a <strcmp+0x4>
    3a84:	99 0b       	sbc	r25, r25
    3a86:	08 95       	ret

00003a88 <strcpy>:
    3a88:	fb 01       	movw	r30, r22
    3a8a:	dc 01       	movw	r26, r24
    3a8c:	01 90       	ld	r0, Z+
    3a8e:	0d 92       	st	X+, r0
    3a90:	00 20       	and	r0, r0
    3a92:	e1 f7       	brne	.-8      	; 0x3a8c <strcpy+0x4>
    3a94:	08 95       	ret

00003a96 <strncmp>:
    3a96:	fb 01       	movw	r30, r22
    3a98:	dc 01       	movw	r26, r24
    3a9a:	41 50       	subi	r20, 0x01	; 1
    3a9c:	50 40       	sbci	r21, 0x00	; 0
    3a9e:	30 f0       	brcs	.+12     	; 0x3aac <strncmp+0x16>
    3aa0:	8d 91       	ld	r24, X+
    3aa2:	01 90       	ld	r0, Z+
    3aa4:	80 19       	sub	r24, r0
    3aa6:	19 f4       	brne	.+6      	; 0x3aae <strncmp+0x18>
    3aa8:	00 20       	and	r0, r0
    3aaa:	b9 f7       	brne	.-18     	; 0x3a9a <strncmp+0x4>
    3aac:	88 1b       	sub	r24, r24
    3aae:	99 0b       	sbc	r25, r25
    3ab0:	08 95       	ret

00003ab2 <itoa>:
    3ab2:	fb 01       	movw	r30, r22
    3ab4:	9f 01       	movw	r18, r30
    3ab6:	e8 94       	clt
    3ab8:	42 30       	cpi	r20, 0x02	; 2
    3aba:	c4 f0       	brlt	.+48     	; 0x3aec <itoa+0x3a>
    3abc:	45 32       	cpi	r20, 0x25	; 37
    3abe:	b4 f4       	brge	.+44     	; 0x3aec <itoa+0x3a>
    3ac0:	4a 30       	cpi	r20, 0x0A	; 10
    3ac2:	29 f4       	brne	.+10     	; 0x3ace <itoa+0x1c>
    3ac4:	97 fb       	bst	r25, 7
    3ac6:	1e f4       	brtc	.+6      	; 0x3ace <itoa+0x1c>
    3ac8:	90 95       	com	r25
    3aca:	81 95       	neg	r24
    3acc:	9f 4f       	sbci	r25, 0xFF	; 255
    3ace:	64 2f       	mov	r22, r20
    3ad0:	77 27       	eor	r23, r23
    3ad2:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <__udivmodhi4>
    3ad6:	80 5d       	subi	r24, 0xD0	; 208
    3ad8:	8a 33       	cpi	r24, 0x3A	; 58
    3ada:	0c f0       	brlt	.+2      	; 0x3ade <itoa+0x2c>
    3adc:	89 5d       	subi	r24, 0xD9	; 217
    3ade:	81 93       	st	Z+, r24
    3ae0:	cb 01       	movw	r24, r22
    3ae2:	00 97       	sbiw	r24, 0x00	; 0
    3ae4:	a1 f7       	brne	.-24     	; 0x3ace <itoa+0x1c>
    3ae6:	16 f4       	brtc	.+4      	; 0x3aec <itoa+0x3a>
    3ae8:	5d e2       	ldi	r21, 0x2D	; 45
    3aea:	51 93       	st	Z+, r21
    3aec:	10 82       	st	Z, r1
    3aee:	c9 01       	movw	r24, r18
    3af0:	0c 94 b9 1d 	jmp	0x3b72	; 0x3b72 <strrev>

00003af4 <__mulhi_const_10>:
    3af4:	7a e0       	ldi	r23, 0x0A	; 10
    3af6:	97 9f       	mul	r25, r23
    3af8:	90 2d       	mov	r25, r0
    3afa:	87 9f       	mul	r24, r23
    3afc:	80 2d       	mov	r24, r0
    3afe:	91 0d       	add	r25, r1
    3b00:	11 24       	eor	r1, r1
    3b02:	08 95       	ret

00003b04 <utoa>:
    3b04:	fb 01       	movw	r30, r22
    3b06:	9f 01       	movw	r18, r30
    3b08:	42 30       	cpi	r20, 0x02	; 2
    3b0a:	74 f0       	brlt	.+28     	; 0x3b28 <utoa+0x24>
    3b0c:	45 32       	cpi	r20, 0x25	; 37
    3b0e:	64 f4       	brge	.+24     	; 0x3b28 <utoa+0x24>
    3b10:	64 2f       	mov	r22, r20
    3b12:	77 27       	eor	r23, r23
    3b14:	0e 94 f8 1c 	call	0x39f0	; 0x39f0 <__udivmodhi4>
    3b18:	80 5d       	subi	r24, 0xD0	; 208
    3b1a:	8a 33       	cpi	r24, 0x3A	; 58
    3b1c:	0c f0       	brlt	.+2      	; 0x3b20 <utoa+0x1c>
    3b1e:	89 5d       	subi	r24, 0xD9	; 217
    3b20:	81 93       	st	Z+, r24
    3b22:	cb 01       	movw	r24, r22
    3b24:	00 97       	sbiw	r24, 0x00	; 0
    3b26:	a1 f7       	brne	.-24     	; 0x3b10 <utoa+0xc>
    3b28:	10 82       	st	Z, r1
    3b2a:	c9 01       	movw	r24, r18
    3b2c:	0c 94 b9 1d 	jmp	0x3b72	; 0x3b72 <strrev>

00003b30 <__eerd_byte_m644pa>:
    3b30:	f9 99       	sbic	0x1f, 1	; 31
    3b32:	fe cf       	rjmp	.-4      	; 0x3b30 <__eerd_byte_m644pa>
    3b34:	92 bd       	out	0x22, r25	; 34
    3b36:	81 bd       	out	0x21, r24	; 33
    3b38:	f8 9a       	sbi	0x1f, 0	; 31
    3b3a:	99 27       	eor	r25, r25
    3b3c:	80 b5       	in	r24, 0x20	; 32
    3b3e:	08 95       	ret

00003b40 <__eerd_word_m644pa>:
    3b40:	a8 e1       	ldi	r26, 0x18	; 24
    3b42:	b0 e0       	ldi	r27, 0x00	; 0
    3b44:	42 e0       	ldi	r20, 0x02	; 2
    3b46:	50 e0       	ldi	r21, 0x00	; 0
    3b48:	0c 94 cb 1d 	jmp	0x3b96	; 0x3b96 <__eerd_blraw_m644pa>

00003b4c <__eewr_byte_m644pa>:
    3b4c:	26 2f       	mov	r18, r22

00003b4e <__eewr_r18_m644pa>:
    3b4e:	f9 99       	sbic	0x1f, 1	; 31
    3b50:	fe cf       	rjmp	.-4      	; 0x3b4e <__eewr_r18_m644pa>
    3b52:	1f ba       	out	0x1f, r1	; 31
    3b54:	92 bd       	out	0x22, r25	; 34
    3b56:	81 bd       	out	0x21, r24	; 33
    3b58:	20 bd       	out	0x20, r18	; 32
    3b5a:	0f b6       	in	r0, 0x3f	; 63
    3b5c:	f8 94       	cli
    3b5e:	fa 9a       	sbi	0x1f, 2	; 31
    3b60:	f9 9a       	sbi	0x1f, 1	; 31
    3b62:	0f be       	out	0x3f, r0	; 63
    3b64:	01 96       	adiw	r24, 0x01	; 1
    3b66:	08 95       	ret

00003b68 <__eewr_word_m644pa>:
    3b68:	0e 94 a6 1d 	call	0x3b4c	; 0x3b4c <__eewr_byte_m644pa>
    3b6c:	27 2f       	mov	r18, r23
    3b6e:	0c 94 a7 1d 	jmp	0x3b4e	; 0x3b4e <__eewr_r18_m644pa>

00003b72 <strrev>:
    3b72:	dc 01       	movw	r26, r24
    3b74:	fc 01       	movw	r30, r24
    3b76:	67 2f       	mov	r22, r23
    3b78:	71 91       	ld	r23, Z+
    3b7a:	77 23       	and	r23, r23
    3b7c:	e1 f7       	brne	.-8      	; 0x3b76 <strrev+0x4>
    3b7e:	32 97       	sbiw	r30, 0x02	; 2
    3b80:	04 c0       	rjmp	.+8      	; 0x3b8a <strrev+0x18>
    3b82:	7c 91       	ld	r23, X
    3b84:	6d 93       	st	X+, r22
    3b86:	70 83       	st	Z, r23
    3b88:	62 91       	ld	r22, -Z
    3b8a:	ae 17       	cp	r26, r30
    3b8c:	bf 07       	cpc	r27, r31
    3b8e:	c8 f3       	brcs	.-14     	; 0x3b82 <strrev+0x10>
    3b90:	08 95       	ret

00003b92 <__eerd_block_m644pa>:
    3b92:	dc 01       	movw	r26, r24
    3b94:	cb 01       	movw	r24, r22

00003b96 <__eerd_blraw_m644pa>:
    3b96:	fc 01       	movw	r30, r24
    3b98:	f9 99       	sbic	0x1f, 1	; 31
    3b9a:	fe cf       	rjmp	.-4      	; 0x3b98 <__eerd_blraw_m644pa+0x2>
    3b9c:	06 c0       	rjmp	.+12     	; 0x3baa <__eerd_blraw_m644pa+0x14>
    3b9e:	f2 bd       	out	0x22, r31	; 34
    3ba0:	e1 bd       	out	0x21, r30	; 33
    3ba2:	f8 9a       	sbi	0x1f, 0	; 31
    3ba4:	31 96       	adiw	r30, 0x01	; 1
    3ba6:	00 b4       	in	r0, 0x20	; 32
    3ba8:	0d 92       	st	X+, r0
    3baa:	41 50       	subi	r20, 0x01	; 1
    3bac:	50 40       	sbci	r21, 0x00	; 0
    3bae:	b8 f7       	brcc	.-18     	; 0x3b9e <__eerd_blraw_m644pa+0x8>
    3bb0:	08 95       	ret

00003bb2 <_exit>:
    3bb2:	f8 94       	cli

00003bb4 <__stop_program>:
    3bb4:	ff cf       	rjmp	.-2      	; 0x3bb4 <__stop_program>
